-- BP 7.1.6 content: Domain syschar: 3 persistence-version: 7.1.6

INSERT INTO S_DOM
	VALUES (1,
	'ooaofooa',
	'========================================================================

File:          $RCSfile: ooaofooa.xtuml,v $
Version:   $Revision: 1.127 $
Modified:  $Date: 2006/09/26 15:10:20 $

(c) Copyright 2004-2014 by Mentor Graphics Corp. All rights reserved.

========================================================================
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License.  You may obtain a copy
of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   See the
License for the specific language governing permissions and limitations under
the License.
========================================================================

This is the application domain for the Tiger project.

The processing in this model describes the activities
for model capture.



',
	1,
	2,
	3);
-- BP 7.1 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (4,
	'Wiring',
	'Persistent:false
',
	'W',
	0,
	1,
	0);
INSERT INTO S_SID
	VALUES (1,
	4);
INSERT INTO O_IOBJ
	VALUES (5,
	6,
	0,
	4,
	'Bridge',
	'S_BRG');
INSERT INTO O_IOBJ
	VALUES (7,
	8,
	0,
	4,
	'Function',
	'S_SYNC');
INSERT INTO R_SIMP
	VALUES (9);
INSERT INTO R_REL
	VALUES (9,
	3201,
	'',
	4);
INSERT INTO R_PART
	VALUES (8,
	9,
	10,
	0,
	1,
	'connects bridge execution to');
INSERT INTO O_RTIDA
	VALUES (11,
	8,
	0,
	9,
	10);
INSERT INTO R_RTO
	VALUES (8,
	9,
	10,
	0);
INSERT INTO R_OIR
	VALUES (8,
	9,
	10,
	7);
INSERT INTO R_FORM
	VALUES (12,
	9,
	13,
	1,
	1,
	'provides execution for');
INSERT INTO R_RGO
	VALUES (12,
	9,
	13);
INSERT INTO R_OIR
	VALUES (12,
	9,
	13,
	0);
INSERT INTO R_SIMP
	VALUES (14);
INSERT INTO R_REL
	VALUES (14,
	3200,
	'',
	4);
INSERT INTO R_PART
	VALUES (6,
	14,
	15,
	0,
	0,
	'for bridge execution');
INSERT INTO O_RTIDA
	VALUES (16,
	6,
	0,
	14,
	15);
INSERT INTO R_RTO
	VALUES (6,
	14,
	15,
	0);
INSERT INTO R_OIR
	VALUES (6,
	14,
	15,
	5);
INSERT INTO R_FORM
	VALUES (12,
	14,
	17,
	0,
	1,
	'is executed through');
INSERT INTO R_RGO
	VALUES (12,
	14,
	17);
INSERT INTO R_OIR
	VALUES (12,
	14,
	17,
	0);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (12,
	'Automatic Wiring',
	3200,
	'S_AW',
	'An instance of Automatic Wiring is created for each bridge within the Domain. 
Whenever a Bridge is found with no action language in it and has an External
Entity whose name matches another Domain in the verification and that exposes a 
Function whose name and arguments match that of the Bridge, the Automatic Wiring
is then associated with the matching Function.',
	4);
INSERT INTO O_TFR
	VALUES (18,
	12,
	'dispose',
	'',
	19,
	1,
	'// Automatic Wiring.dispose()

select one function related by self->S_SYNC[R3201];
if (not_empty function)
  unrelate function from self across R3201;
end if;

select one brg related by self->S_BRG[R3200];
if (not_empty brg)
  unrelate brg from self across R3200;
end if;

delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (12,
	6,
	0,
	16,
	14,
	17,
	15,
	20,
	21,
	0,
	0,
	'',
	'Bridge',
	'Brg_ID',
	'R3200');
INSERT INTO O_RATTR
	VALUES (20,
	12,
	16,
	6,
	1,
	'Brg_ID');
INSERT INTO O_ATTR
	VALUES (20,
	12,
	0,
	'Brg_ID',
	'',
	'',
	'Brg_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (12,
	8,
	0,
	11,
	9,
	13,
	10,
	23,
	24,
	0,
	0,
	'',
	'Function',
	'Sync_ID',
	'R3201');
INSERT INTO O_RATTR
	VALUES (23,
	12,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (23,
	12,
	20,
	'Sync_ID',
	'',
	'',
	'Sync_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	12);
INSERT INTO O_ID
	VALUES (1,
	12);
INSERT INTO O_ID
	VALUES (2,
	12);
-- BP 7.1 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (27,
	'Value',
	'This subsystem formalizes the concepts of values (r-values) and variables 
(l-values). It also captures the concept of an actual parameter.
Notify_Changes:false
Persistent:false
// This is used by schema_gen to ignore this subsystem (for publication)
TRANSLATE_FOR_EXTERNAL_USE:FALSE
',
	'V',
	800,
	1,
	28);
INSERT INTO S_SID
	VALUES (1,
	27);
INSERT INTO O_IOBJ
	VALUES (29,
	30,
	5,
	27,
	'Model Class',
	'O_OBJ');
INSERT INTO O_IOBJ
	VALUES (31,
	32,
	5,
	27,
	'Data Type',
	'S_DT');
INSERT INTO O_IOBJ
	VALUES (33,
	32,
	5,
	27,
	'Data Type',
	'S_DT');
INSERT INTO O_IOBJ
	VALUES (34,
	35,
	5,
	27,
	'Block',
	'ACT_BLK');
INSERT INTO O_IOBJ
	VALUES (36,
	37,
	5,
	27,
	'Attribute',
	'O_ATTR');
INSERT INTO O_IOBJ
	VALUES (38,
	39,
	5,
	27,
	'Enumerator',
	'S_ENUM');
INSERT INTO O_IOBJ
	VALUES (40,
	35,
	5,
	27,
	'Block',
	'ACT_BLK');
INSERT INTO O_IOBJ
	VALUES (41,
	8,
	5,
	27,
	'Function',
	'S_SYNC');
INSERT INTO O_IOBJ
	VALUES (42,
	43,
	5,
	27,
	'Operation',
	'O_TFR');
INSERT INTO O_IOBJ
	VALUES (44,
	6,
	5,
	27,
	'Bridge',
	'S_BRG');
INSERT INTO O_IOBJ
	VALUES (45,
	46,
	5,
	27,
	'Bridge Parameter',
	'S_BPARM');
INSERT INTO O_IOBJ
	VALUES (47,
	48,
	5,
	27,
	'Function Parameter',
	'S_SPARM');
INSERT INTO O_IOBJ
	VALUES (49,
	50,
	5,
	27,
	'Operation Parameter',
	'O_TPARM');
INSERT INTO O_IOBJ
	VALUES (51,
	52,
	5,
	27,
	'State Machine Event Data Item',
	'SM_EVTDI');
INSERT INTO O_IOBJ
	VALUES (53,
	37,
	0,
	27,
	'Attribute',
	'O_ATTR');
INSERT INTO O_IOBJ
	VALUES (54,
	55,
	0,
	27,
	'Structure Member',
	'S_MBR');
INSERT INTO O_IOBJ
	VALUES (56,
	57,
	0,
	27,
	'Property Parameter',
	'C_PP');
INSERT INTO O_IOBJ
	VALUES (58,
	59,
	0,
	27,
	'Dimensions',
	'S_DIM');
INSERT INTO O_IOBJ
	VALUES (60,
	61,
	0,
	27,
	'Provided Executable Property',
	'SPR_PEP');
INSERT INTO O_IOBJ
	VALUES (62,
	63,
	0,
	27,
	'Required Executable Property',
	'SPR_REP');
INSERT INTO O_IOBJ
	VALUES (64,
	57,
	0,
	27,
	'Property Parameter',
	'C_PP');
INSERT INTO O_IOBJ
	VALUES (65,
	66,
	0,
	27,
	'Symbolic Constant',
	'CNST_SYC');
INSERT INTO R_SIMP
	VALUES (67);
INSERT INTO R_REL
	VALUES (67,
	800,
	'',
	27);
INSERT INTO R_FORM
	VALUES (68,
	67,
	69,
	0,
	1,
	'is value of');
INSERT INTO R_RGO
	VALUES (68,
	67,
	69);
INSERT INTO R_OIR
	VALUES (68,
	67,
	69,
	0);
INSERT INTO R_PART
	VALUES (70,
	67,
	71,
	0,
	0,
	'has');
INSERT INTO O_RTIDA
	VALUES (72,
	70,
	0,
	67,
	71);
INSERT INTO R_RTO
	VALUES (70,
	67,
	71,
	0);
INSERT INTO R_OIR
	VALUES (70,
	67,
	71,
	0);
INSERT INTO R_SIMP
	VALUES (73);
INSERT INTO R_REL
	VALUES (73,
	804,
	'',
	27);
INSERT INTO R_PART
	VALUES (70,
	73,
	74,
	0,
	0,
	'has operand');
INSERT INTO O_RTIDA
	VALUES (72,
	70,
	0,
	73,
	74);
INSERT INTO R_RTO
	VALUES (70,
	73,
	74,
	0);
INSERT INTO R_OIR
	VALUES (70,
	73,
	74,
	0);
INSERT INTO R_FORM
	VALUES (75,
	73,
	76,
	0,
	1,
	'is operand to');
INSERT INTO R_RGO
	VALUES (75,
	73,
	76);
INSERT INTO R_OIR
	VALUES (75,
	73,
	76,
	0);
INSERT INTO R_SIMP
	VALUES (77);
INSERT INTO R_REL
	VALUES (77,
	803,
	'',
	27);
INSERT INTO R_PART
	VALUES (70,
	77,
	78,
	0,
	0,
	'has right');
INSERT INTO O_RTIDA
	VALUES (72,
	70,
	0,
	77,
	78);
INSERT INTO R_RTO
	VALUES (70,
	77,
	78,
	0);
INSERT INTO R_OIR
	VALUES (70,
	77,
	78,
	0);
INSERT INTO R_FORM
	VALUES (79,
	77,
	80,
	0,
	1,
	'is right operand to');
INSERT INTO R_RGO
	VALUES (79,
	77,
	80);
INSERT INTO R_OIR
	VALUES (79,
	77,
	80,
	0);
INSERT INTO R_SIMP
	VALUES (81);
INSERT INTO R_REL
	VALUES (81,
	802,
	'',
	27);
INSERT INTO R_PART
	VALUES (70,
	81,
	82,
	0,
	0,
	'has left');
INSERT INTO O_RTIDA
	VALUES (72,
	70,
	0,
	81,
	82);
INSERT INTO R_RTO
	VALUES (70,
	81,
	82,
	0);
INSERT INTO R_OIR
	VALUES (70,
	81,
	82,
	0);
INSERT INTO R_FORM
	VALUES (79,
	81,
	83,
	0,
	1,
	'is left operand to');
INSERT INTO R_RGO
	VALUES (79,
	81,
	83);
INSERT INTO R_OIR
	VALUES (79,
	81,
	83,
	0);
INSERT INTO R_SUBSUP
	VALUES (84);
INSERT INTO R_REL
	VALUES (84,
	801,
	'',
	27);
INSERT INTO R_SUPER
	VALUES (70,
	84,
	85);
INSERT INTO O_RTIDA
	VALUES (72,
	70,
	0,
	84,
	85);
INSERT INTO R_RTO
	VALUES (70,
	84,
	85,
	0);
INSERT INTO R_OIR
	VALUES (70,
	84,
	85,
	0);
INSERT INTO R_SUB
	VALUES (86,
	84,
	87);
INSERT INTO R_RGO
	VALUES (86,
	84,
	87);
INSERT INTO R_OIR
	VALUES (86,
	84,
	87,
	0);
INSERT INTO R_SUB
	VALUES (88,
	84,
	89);
INSERT INTO R_RGO
	VALUES (88,
	84,
	89);
INSERT INTO R_OIR
	VALUES (88,
	84,
	89,
	0);
INSERT INTO R_SUB
	VALUES (90,
	84,
	91);
INSERT INTO R_RGO
	VALUES (90,
	84,
	91);
INSERT INTO R_OIR
	VALUES (90,
	84,
	91,
	0);
INSERT INTO R_SUB
	VALUES (92,
	84,
	93);
INSERT INTO R_RGO
	VALUES (92,
	84,
	93);
INSERT INTO R_OIR
	VALUES (92,
	84,
	93,
	0);
INSERT INTO R_SUB
	VALUES (94,
	84,
	95);
INSERT INTO R_RGO
	VALUES (94,
	84,
	95);
INSERT INTO R_OIR
	VALUES (94,
	84,
	95,
	0);
INSERT INTO R_SUB
	VALUES (96,
	84,
	97);
INSERT INTO R_RGO
	VALUES (96,
	84,
	97);
INSERT INTO R_OIR
	VALUES (96,
	84,
	97,
	0);
INSERT INTO R_SUB
	VALUES (98,
	84,
	99);
INSERT INTO R_RGO
	VALUES (98,
	84,
	99);
INSERT INTO R_OIR
	VALUES (98,
	84,
	99,
	0);
INSERT INTO R_SUB
	VALUES (100,
	84,
	101);
INSERT INTO R_RGO
	VALUES (100,
	84,
	101);
INSERT INTO R_OIR
	VALUES (100,
	84,
	101,
	0);
INSERT INTO R_SUB
	VALUES (75,
	84,
	102);
INSERT INTO R_RGO
	VALUES (75,
	84,
	102);
INSERT INTO R_OIR
	VALUES (75,
	84,
	102,
	0);
INSERT INTO R_SUB
	VALUES (103,
	84,
	104);
INSERT INTO R_RGO
	VALUES (103,
	84,
	104);
INSERT INTO R_OIR
	VALUES (103,
	84,
	104,
	0);
INSERT INTO R_SUB
	VALUES (105,
	84,
	106);
INSERT INTO R_RGO
	VALUES (105,
	84,
	106);
INSERT INTO R_OIR
	VALUES (105,
	84,
	106,
	0);
INSERT INTO R_SUB
	VALUES (107,
	84,
	108);
INSERT INTO R_RGO
	VALUES (107,
	84,
	108);
INSERT INTO R_OIR
	VALUES (107,
	84,
	108,
	0);
INSERT INTO R_SUB
	VALUES (109,
	84,
	110);
INSERT INTO R_RGO
	VALUES (109,
	84,
	110);
INSERT INTO R_OIR
	VALUES (109,
	84,
	110,
	0);
INSERT INTO R_SUB
	VALUES (111,
	84,
	112);
INSERT INTO R_RGO
	VALUES (111,
	84,
	112);
INSERT INTO R_OIR
	VALUES (111,
	84,
	112,
	0);
INSERT INTO R_SUB
	VALUES (113,
	84,
	114);
INSERT INTO R_RGO
	VALUES (113,
	84,
	114);
INSERT INTO R_OIR
	VALUES (113,
	84,
	114,
	0);
INSERT INTO R_SUB
	VALUES (79,
	84,
	115);
INSERT INTO R_RGO
	VALUES (79,
	84,
	115);
INSERT INTO R_OIR
	VALUES (79,
	84,
	115,
	0);
INSERT INTO R_SUB
	VALUES (116,
	84,
	117);
INSERT INTO R_RGO
	VALUES (116,
	84,
	117);
INSERT INTO R_OIR
	VALUES (116,
	84,
	117,
	0);
INSERT INTO R_SUB
	VALUES (118,
	84,
	119);
INSERT INTO R_RGO
	VALUES (118,
	84,
	119);
INSERT INTO R_OIR
	VALUES (118,
	84,
	119,
	0);
INSERT INTO R_SUB
	VALUES (120,
	84,
	121);
INSERT INTO R_RGO
	VALUES (120,
	84,
	121);
INSERT INTO R_OIR
	VALUES (120,
	84,
	121,
	0);
INSERT INTO R_SUB
	VALUES (122,
	84,
	123);
INSERT INTO R_RGO
	VALUES (122,
	84,
	123);
INSERT INTO R_OIR
	VALUES (122,
	84,
	123,
	0);
INSERT INTO R_SUB
	VALUES (124,
	84,
	125);
INSERT INTO R_RGO
	VALUES (124,
	84,
	125);
INSERT INTO R_OIR
	VALUES (124,
	84,
	125,
	0);
INSERT INTO R_SUB
	VALUES (126,
	84,
	127);
INSERT INTO R_RGO
	VALUES (126,
	84,
	127);
INSERT INTO R_OIR
	VALUES (126,
	84,
	127,
	0);
INSERT INTO R_SUBSUP
	VALUES (128);
INSERT INTO R_REL
	VALUES (128,
	814,
	'',
	27);
INSERT INTO R_SUPER
	VALUES (129,
	128,
	130);
INSERT INTO O_RTIDA
	VALUES (131,
	129,
	0,
	128,
	130);
INSERT INTO R_RTO
	VALUES (129,
	128,
	130,
	0);
INSERT INTO R_OIR
	VALUES (129,
	128,
	130,
	0);
INSERT INTO R_SUB
	VALUES (132,
	128,
	133);
INSERT INTO R_RGO
	VALUES (132,
	128,
	133);
INSERT INTO R_OIR
	VALUES (132,
	128,
	133,
	0);
INSERT INTO R_SUB
	VALUES (134,
	128,
	135);
INSERT INTO R_RGO
	VALUES (134,
	128,
	135);
INSERT INTO R_OIR
	VALUES (134,
	128,
	135,
	0);
INSERT INTO R_SUB
	VALUES (136,
	128,
	137);
INSERT INTO R_RGO
	VALUES (136,
	128,
	137);
INSERT INTO R_OIR
	VALUES (136,
	128,
	137,
	0);
INSERT INTO R_SIMP
	VALUES (138);
INSERT INTO R_REL
	VALUES (138,
	805,
	'',
	27);
INSERT INTO R_PART
	VALUES (129,
	138,
	139,
	0,
	0,
	'references');
INSERT INTO O_RTIDA
	VALUES (131,
	129,
	0,
	138,
	139);
INSERT INTO R_RTO
	VALUES (129,
	138,
	139,
	0);
INSERT INTO R_OIR
	VALUES (129,
	138,
	139,
	0);
INSERT INTO R_FORM
	VALUES (109,
	138,
	140,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (109,
	138,
	140);
INSERT INTO R_OIR
	VALUES (109,
	138,
	140,
	0);
INSERT INTO R_SIMP
	VALUES (141);
INSERT INTO R_REL
	VALUES (141,
	808,
	'',
	27);
INSERT INTO R_PART
	VALUES (129,
	141,
	142,
	0,
	0,
	'refers to');
INSERT INTO O_RTIDA
	VALUES (131,
	129,
	0,
	141,
	142);
INSERT INTO R_RTO
	VALUES (129,
	141,
	142,
	0);
INSERT INTO R_OIR
	VALUES (129,
	141,
	142,
	0);
INSERT INTO R_FORM
	VALUES (94,
	141,
	143,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (94,
	141,
	143);
INSERT INTO R_OIR
	VALUES (94,
	141,
	143,
	0);
INSERT INTO R_SIMP
	VALUES (144);
INSERT INTO R_REL
	VALUES (144,
	809,
	'',
	27);
INSERT INTO R_PART
	VALUES (129,
	144,
	145,
	0,
	0,
	'refers to');
INSERT INTO O_RTIDA
	VALUES (131,
	129,
	0,
	144,
	145);
INSERT INTO R_RTO
	VALUES (129,
	144,
	145,
	0);
INSERT INTO R_OIR
	VALUES (129,
	144,
	145,
	0);
INSERT INTO R_FORM
	VALUES (105,
	144,
	146,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (105,
	144,
	146);
INSERT INTO R_OIR
	VALUES (105,
	144,
	146,
	0);
INSERT INTO R_SIMP
	VALUES (147);
INSERT INTO R_REL
	VALUES (147,
	818,
	'',
	27);
INSERT INTO R_FORM
	VALUES (132,
	147,
	148,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (132,
	147,
	148);
INSERT INTO R_OIR
	VALUES (132,
	147,
	148,
	0);
INSERT INTO R_PART
	VALUES (30,
	147,
	149,
	0,
	0,
	'refers to');
INSERT INTO O_RTIDA
	VALUES (150,
	30,
	0,
	147,
	149);
INSERT INTO R_RTO
	VALUES (30,
	147,
	149,
	0);
INSERT INTO R_OIR
	VALUES (30,
	147,
	149,
	29);
INSERT INTO R_SIMP
	VALUES (151);
INSERT INTO R_REL
	VALUES (151,
	819,
	'',
	27);
INSERT INTO R_FORM
	VALUES (134,
	151,
	152,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (134,
	151,
	152);
INSERT INTO R_OIR
	VALUES (134,
	151,
	152,
	0);
INSERT INTO R_PART
	VALUES (30,
	151,
	153,
	0,
	0,
	'refers to');
INSERT INTO O_RTIDA
	VALUES (150,
	30,
	0,
	151,
	153);
INSERT INTO R_RTO
	VALUES (30,
	151,
	153,
	0);
INSERT INTO R_OIR
	VALUES (30,
	151,
	153,
	29);
INSERT INTO R_SIMP
	VALUES (154);
INSERT INTO R_REL
	VALUES (154,
	820,
	'',
	27);
INSERT INTO R_PART
	VALUES (32,
	154,
	155,
	0,
	0,
	'has type');
INSERT INTO O_RTIDA
	VALUES (156,
	32,
	0,
	154,
	155);
INSERT INTO R_RTO
	VALUES (32,
	154,
	155,
	0);
INSERT INTO R_OIR
	VALUES (32,
	154,
	155,
	31);
INSERT INTO R_FORM
	VALUES (70,
	154,
	157,
	1,
	1,
	'is type of');
INSERT INTO R_RGO
	VALUES (70,
	154,
	157);
INSERT INTO R_OIR
	VALUES (70,
	154,
	157,
	0);
INSERT INTO R_SIMP
	VALUES (158);
INSERT INTO R_REL
	VALUES (158,
	821,
	'',
	27);
INSERT INTO R_PART
	VALUES (32,
	158,
	159,
	0,
	1,
	'has');
INSERT INTO O_RTIDA
	VALUES (156,
	32,
	0,
	158,
	159);
INSERT INTO R_RTO
	VALUES (32,
	158,
	159,
	0);
INSERT INTO R_OIR
	VALUES (32,
	158,
	159,
	33);
INSERT INTO R_FORM
	VALUES (136,
	158,
	160,
	1,
	1,
	'is type of');
INSERT INTO R_RGO
	VALUES (136,
	158,
	160);
INSERT INTO R_OIR
	VALUES (136,
	158,
	160,
	0);
INSERT INTO R_SIMP
	VALUES (161);
INSERT INTO R_REL
	VALUES (161,
	823,
	'',
	27);
INSERT INTO R_PART
	VALUES (35,
	161,
	162,
	0,
	0,
	'');
INSERT INTO O_RTIDA
	VALUES (163,
	35,
	0,
	161,
	162);
INSERT INTO R_RTO
	VALUES (35,
	161,
	162,
	0);
INSERT INTO R_OIR
	VALUES (35,
	161,
	162,
	34);
INSERT INTO R_FORM
	VALUES (129,
	161,
	164,
	1,
	1,
	'is scope for');
INSERT INTO R_RGO
	VALUES (129,
	161,
	164);
INSERT INTO R_OIR
	VALUES (129,
	161,
	164,
	0);
INSERT INTO R_SIMP
	VALUES (165);
INSERT INTO R_REL
	VALUES (165,
	806,
	'',
	27);
INSERT INTO R_FORM
	VALUES (96,
	165,
	166,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (96,
	165,
	166);
INSERT INTO R_OIR
	VALUES (96,
	165,
	166,
	0);
INSERT INTO R_PART
	VALUES (37,
	165,
	167,
	0,
	0,
	'is value of');
INSERT INTO O_RTIDA
	VALUES (168,
	37,
	0,
	165,
	167);
INSERT INTO O_RTIDA
	VALUES (169,
	37,
	0,
	165,
	167);
INSERT INTO R_RTO
	VALUES (37,
	165,
	167,
	0);
INSERT INTO R_OIR
	VALUES (37,
	165,
	167,
	36);
INSERT INTO R_SIMP
	VALUES (170);
INSERT INTO R_REL
	VALUES (170,
	824,
	'',
	27);
INSERT INTO R_PART
	VALUES (39,
	170,
	171,
	0,
	0,
	'has value');
INSERT INTO O_RTIDA
	VALUES (172,
	39,
	0,
	170,
	171);
INSERT INTO R_RTO
	VALUES (39,
	170,
	171,
	0);
INSERT INTO R_OIR
	VALUES (39,
	170,
	171,
	38);
INSERT INTO R_FORM
	VALUES (116,
	170,
	173,
	1,
	1,
	'is value of');
INSERT INTO R_RGO
	VALUES (116,
	170,
	173);
INSERT INTO R_OIR
	VALUES (116,
	170,
	173,
	0);
INSERT INTO R_SIMP
	VALUES (174);
INSERT INTO R_REL
	VALUES (174,
	825,
	'This association is conditional because the value
retrieved from the selected instance is either an attribute
or the result of an operation invocation.
',
	27);
INSERT INTO R_FORM
	VALUES (90,
	174,
	175,
	0,
	1,
	'');
INSERT INTO R_RGO
	VALUES (90,
	174,
	175);
INSERT INTO R_OIR
	VALUES (90,
	174,
	175,
	0);
INSERT INTO R_PART
	VALUES (103,
	174,
	176,
	0,
	1,
	'value');
INSERT INTO O_RTIDA
	VALUES (177,
	103,
	0,
	174,
	176);
INSERT INTO R_RTO
	VALUES (103,
	174,
	176,
	0);
INSERT INTO R_OIR
	VALUES (103,
	174,
	176,
	0);
INSERT INTO R_SIMP
	VALUES (178);
INSERT INTO R_REL
	VALUES (178,
	826,
	'',
	27);
INSERT INTO R_PART
	VALUES (35,
	178,
	179,
	0,
	0,
	'has scope');
INSERT INTO O_RTIDA
	VALUES (163,
	35,
	0,
	178,
	179);
INSERT INTO R_RTO
	VALUES (35,
	178,
	179,
	0);
INSERT INTO R_OIR
	VALUES (35,
	178,
	179,
	40);
INSERT INTO R_FORM
	VALUES (70,
	178,
	180,
	1,
	1,
	'defines scope of');
INSERT INTO R_RGO
	VALUES (70,
	178,
	180);
INSERT INTO R_OIR
	VALUES (70,
	178,
	180,
	0);
INSERT INTO R_SIMP
	VALUES (181);
INSERT INTO R_REL
	VALUES (181,
	817,
	'',
	27);
INSERT INTO R_PART
	VALUES (86,
	181,
	182,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (183,
	86,
	0,
	181,
	182);
INSERT INTO R_RTO
	VALUES (86,
	181,
	182,
	0);
INSERT INTO R_OIR
	VALUES (86,
	181,
	182,
	0);
INSERT INTO R_FORM
	VALUES (68,
	181,
	184,
	1,
	1,
	'has');
INSERT INTO R_RGO
	VALUES (68,
	181,
	184);
INSERT INTO R_OIR
	VALUES (68,
	181,
	184,
	0);
INSERT INTO R_SIMP
	VALUES (185);
INSERT INTO R_REL
	VALUES (185,
	810,
	'',
	27);
INSERT INTO R_PART
	VALUES (92,
	185,
	186,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (187,
	92,
	0,
	185,
	186);
INSERT INTO R_RTO
	VALUES (92,
	185,
	186,
	0);
INSERT INTO R_OIR
	VALUES (92,
	185,
	186,
	0);
INSERT INTO R_FORM
	VALUES (68,
	185,
	188,
	1,
	1,
	'has');
INSERT INTO R_RGO
	VALUES (68,
	185,
	188);
INSERT INTO R_OIR
	VALUES (68,
	185,
	188,
	0);
INSERT INTO R_SIMP
	VALUES (189);
INSERT INTO R_REL
	VALUES (189,
	811,
	'',
	27);
INSERT INTO R_PART
	VALUES (103,
	189,
	190,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (177,
	103,
	0,
	189,
	190);
INSERT INTO R_RTO
	VALUES (103,
	189,
	190,
	0);
INSERT INTO R_OIR
	VALUES (103,
	189,
	190,
	0);
INSERT INTO R_FORM
	VALUES (68,
	189,
	191,
	1,
	1,
	'has');
INSERT INTO R_RGO
	VALUES (68,
	189,
	191);
INSERT INTO R_OIR
	VALUES (68,
	189,
	191,
	0);
INSERT INTO R_SIMP
	VALUES (192);
INSERT INTO R_REL
	VALUES (192,
	827,
	'',
	27);
INSERT INTO R_FORM
	VALUES (86,
	192,
	193,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (86,
	192,
	193);
INSERT INTO R_OIR
	VALUES (86,
	192,
	193,
	0);
INSERT INTO R_PART
	VALUES (8,
	192,
	194,
	0,
	0,
	'');
INSERT INTO O_RTIDA
	VALUES (11,
	8,
	0,
	192,
	194);
INSERT INTO R_RTO
	VALUES (8,
	192,
	194,
	0);
INSERT INTO R_OIR
	VALUES (8,
	192,
	194,
	41);
INSERT INTO R_SIMP
	VALUES (195);
INSERT INTO R_REL
	VALUES (195,
	828,
	'',
	27);
INSERT INTO R_FORM
	VALUES (92,
	195,
	196,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (92,
	195,
	196);
INSERT INTO R_OIR
	VALUES (92,
	195,
	196,
	0);
INSERT INTO R_PART
	VALUES (6,
	195,
	197,
	0,
	0,
	'');
INSERT INTO O_RTIDA
	VALUES (16,
	6,
	0,
	195,
	197);
INSERT INTO R_RTO
	VALUES (6,
	195,
	197,
	0);
INSERT INTO R_OIR
	VALUES (6,
	195,
	197,
	44);
INSERT INTO R_SIMP
	VALUES (198);
INSERT INTO R_REL
	VALUES (198,
	829,
	'',
	27);
INSERT INTO R_FORM
	VALUES (103,
	198,
	199,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (103,
	198,
	199);
INSERT INTO R_OIR
	VALUES (103,
	198,
	199,
	0);
INSERT INTO R_PART
	VALUES (43,
	198,
	200,
	0,
	0,
	'');
INSERT INTO O_RTIDA
	VALUES (201,
	43,
	0,
	198,
	200);
INSERT INTO R_RTO
	VALUES (43,
	198,
	200,
	0);
INSERT INTO R_OIR
	VALUES (43,
	198,
	200,
	42);
INSERT INTO R_SIMP
	VALUES (202);
INSERT INTO R_REL
	VALUES (202,
	816,
	'',
	27);
INSERT INTO R_PART
	VALUES (68,
	202,
	203,
	0,
	1,
	'precedes');
INSERT INTO O_RTIDA
	VALUES (204,
	68,
	0,
	202,
	203);
INSERT INTO R_RTO
	VALUES (68,
	202,
	203,
	0);
INSERT INTO R_OIR
	VALUES (68,
	202,
	203,
	0);
INSERT INTO R_FORM
	VALUES (68,
	202,
	205,
	0,
	1,
	'succeeds');
INSERT INTO R_RGO
	VALUES (68,
	202,
	205);
INSERT INTO R_OIR
	VALUES (68,
	202,
	205,
	0);
INSERT INTO R_SIMP
	VALUES (206);
INSERT INTO R_REL
	VALUES (206,
	830,
	'',
	27);
INSERT INTO R_FORM
	VALUES (103,
	206,
	207,
	1,
	1,
	'variable');
INSERT INTO R_RGO
	VALUES (103,
	206,
	207);
INSERT INTO R_OIR
	VALUES (103,
	206,
	207,
	0);
INSERT INTO R_PART
	VALUES (129,
	206,
	208,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (131,
	129,
	0,
	206,
	208);
INSERT INTO R_RTO
	VALUES (129,
	206,
	208,
	0);
INSERT INTO R_OIR
	VALUES (129,
	206,
	208,
	0);
INSERT INTO R_SIMP
	VALUES (209);
INSERT INTO R_REL
	VALUES (209,
	831,
	'',
	27);
INSERT INTO R_PART
	VALUES (46,
	209,
	210,
	0,
	1,
	'is a value of');
INSERT INTO O_RTIDA
	VALUES (211,
	46,
	0,
	209,
	210);
INSERT INTO R_RTO
	VALUES (46,
	209,
	210,
	0);
INSERT INTO R_OIR
	VALUES (46,
	209,
	210,
	45);
INSERT INTO R_FORM
	VALUES (88,
	209,
	212,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (88,
	209,
	212);
INSERT INTO R_OIR
	VALUES (88,
	209,
	212,
	0);
INSERT INTO R_SIMP
	VALUES (213);
INSERT INTO R_REL
	VALUES (213,
	832,
	'',
	27);
INSERT INTO R_PART
	VALUES (48,
	213,
	214,
	0,
	1,
	'is a value of');
INSERT INTO O_RTIDA
	VALUES (215,
	48,
	0,
	213,
	214);
INSERT INTO R_RTO
	VALUES (48,
	213,
	214,
	0);
INSERT INTO R_OIR
	VALUES (48,
	213,
	214,
	47);
INSERT INTO R_FORM
	VALUES (88,
	213,
	216,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (88,
	213,
	216);
INSERT INTO R_OIR
	VALUES (88,
	213,
	216,
	0);
INSERT INTO R_SIMP
	VALUES (217);
INSERT INTO R_REL
	VALUES (217,
	833,
	'',
	27);
INSERT INTO R_PART
	VALUES (50,
	217,
	218,
	0,
	1,
	'is a value of');
INSERT INTO O_RTIDA
	VALUES (219,
	50,
	0,
	217,
	218);
INSERT INTO R_RTO
	VALUES (50,
	217,
	218,
	0);
INSERT INTO R_OIR
	VALUES (50,
	217,
	218,
	49);
INSERT INTO R_FORM
	VALUES (88,
	217,
	220,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (88,
	217,
	220);
INSERT INTO R_OIR
	VALUES (88,
	217,
	220,
	0);
INSERT INTO R_SIMP
	VALUES (221);
INSERT INTO R_REL
	VALUES (221,
	835,
	'',
	27);
INSERT INTO R_PART
	VALUES (129,
	221,
	222,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (131,
	129,
	0,
	221,
	222);
INSERT INTO R_RTO
	VALUES (129,
	221,
	222,
	0);
INSERT INTO R_OIR
	VALUES (129,
	221,
	222,
	0);
INSERT INTO R_FORM
	VALUES (223,
	221,
	224,
	1,
	0,
	'');
INSERT INTO R_RGO
	VALUES (223,
	221,
	224);
INSERT INTO R_OIR
	VALUES (223,
	221,
	224,
	0);
INSERT INTO R_SIMP
	VALUES (225);
INSERT INTO R_REL
	VALUES (225,
	812,
	'',
	27);
INSERT INTO R_FORM
	VALUES (90,
	225,
	226,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (90,
	225,
	226);
INSERT INTO R_OIR
	VALUES (90,
	225,
	226,
	0);
INSERT INTO R_PART
	VALUES (37,
	225,
	227,
	0,
	1,
	'member');
INSERT INTO O_RTIDA
	VALUES (168,
	37,
	0,
	225,
	227);
INSERT INTO O_RTIDA
	VALUES (169,
	37,
	0,
	225,
	227);
INSERT INTO R_RTO
	VALUES (37,
	225,
	227,
	0);
INSERT INTO R_OIR
	VALUES (37,
	225,
	227,
	53);
INSERT INTO R_SIMP
	VALUES (228);
INSERT INTO R_REL
	VALUES (228,
	836,
	'',
	27);
INSERT INTO R_FORM
	VALUES (118,
	228,
	229,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (118,
	228,
	229);
INSERT INTO R_OIR
	VALUES (118,
	228,
	229,
	0);
INSERT INTO R_PART
	VALUES (55,
	228,
	230,
	0,
	0,
	'is value of');
INSERT INTO O_RTIDA
	VALUES (231,
	55,
	0,
	228,
	230);
INSERT INTO O_RTIDA
	VALUES (232,
	55,
	0,
	228,
	230);
INSERT INTO R_RTO
	VALUES (55,
	228,
	230,
	0);
INSERT INTO R_OIR
	VALUES (55,
	228,
	230,
	54);
INSERT INTO R_SIMP
	VALUES (233);
INSERT INTO R_REL
	VALUES (233,
	837,
	'',
	27);
INSERT INTO R_FORM
	VALUES (118,
	233,
	234,
	0,
	1,
	'is root for');
INSERT INTO R_RGO
	VALUES (118,
	233,
	234);
INSERT INTO R_OIR
	VALUES (118,
	233,
	234,
	0);
INSERT INTO R_PART
	VALUES (70,
	233,
	235,
	0,
	0,
	'');
INSERT INTO O_RTIDA
	VALUES (72,
	70,
	0,
	233,
	235);
INSERT INTO R_RTO
	VALUES (70,
	233,
	235,
	0);
INSERT INTO R_OIR
	VALUES (70,
	233,
	235,
	0);
INSERT INTO R_SIMP
	VALUES (236);
INSERT INTO R_REL
	VALUES (236,
	807,
	'',
	27);
INSERT INTO R_FORM
	VALUES (96,
	236,
	237,
	0,
	1,
	'is root for');
INSERT INTO R_RGO
	VALUES (96,
	236,
	237);
INSERT INTO R_OIR
	VALUES (96,
	236,
	237,
	0);
INSERT INTO R_PART
	VALUES (70,
	236,
	238,
	0,
	0,
	'has root');
INSERT INTO O_RTIDA
	VALUES (72,
	70,
	0,
	236,
	238);
INSERT INTO R_RTO
	VALUES (70,
	236,
	238,
	0);
INSERT INTO R_OIR
	VALUES (70,
	236,
	238,
	0);
INSERT INTO R_SIMP
	VALUES (239);
INSERT INTO R_REL
	VALUES (239,
	838,
	'',
	27);
INSERT INTO R_PART
	VALUES (70,
	239,
	240,
	0,
	0,
	'has root');
INSERT INTO O_RTIDA
	VALUES (72,
	70,
	0,
	239,
	240);
INSERT INTO R_RTO
	VALUES (70,
	239,
	240,
	0);
INSERT INTO R_OIR
	VALUES (70,
	239,
	240,
	0);
INSERT INTO R_FORM
	VALUES (120,
	239,
	241,
	0,
	1,
	'is root for');
INSERT INTO R_RGO
	VALUES (120,
	239,
	241);
INSERT INTO R_OIR
	VALUES (120,
	239,
	241,
	0);
INSERT INTO R_SIMP
	VALUES (242);
INSERT INTO R_REL
	VALUES (242,
	839,
	'',
	27);
INSERT INTO R_FORM
	VALUES (120,
	242,
	243,
	0,
	1,
	'provides index of');
INSERT INTO R_RGO
	VALUES (120,
	242,
	243);
INSERT INTO R_OIR
	VALUES (120,
	242,
	243,
	0);
INSERT INTO R_PART
	VALUES (70,
	242,
	244,
	0,
	0,
	'has index');
INSERT INTO O_RTIDA
	VALUES (72,
	70,
	0,
	242,
	244);
INSERT INTO R_RTO
	VALUES (70,
	242,
	244,
	0);
INSERT INTO R_OIR
	VALUES (70,
	242,
	244,
	0);
INSERT INTO R_SIMP
	VALUES (245);
INSERT INTO R_REL
	VALUES (245,
	840,
	'',
	27);
INSERT INTO R_FORM
	VALUES (122,
	245,
	246,
	0,
	1,
	'has length returned by');
INSERT INTO R_RGO
	VALUES (122,
	245,
	246);
INSERT INTO R_OIR
	VALUES (122,
	245,
	246,
	0);
INSERT INTO R_PART
	VALUES (70,
	245,
	247,
	0,
	0,
	'returns length of');
INSERT INTO O_RTIDA
	VALUES (72,
	70,
	0,
	245,
	247);
INSERT INTO R_RTO
	VALUES (70,
	245,
	247,
	0);
INSERT INTO R_OIR
	VALUES (70,
	245,
	247,
	0);
INSERT INTO R_SIMP
	VALUES (248);
INSERT INTO R_REL
	VALUES (248,
	842,
	'',
	27);
INSERT INTO R_PART
	VALUES (124,
	248,
	249,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (250,
	124,
	0,
	248,
	249);
INSERT INTO R_RTO
	VALUES (124,
	248,
	249,
	0);
INSERT INTO R_OIR
	VALUES (124,
	248,
	249,
	0);
INSERT INTO R_FORM
	VALUES (68,
	248,
	251,
	1,
	1,
	'has');
INSERT INTO R_RGO
	VALUES (68,
	248,
	251);
INSERT INTO R_OIR
	VALUES (68,
	248,
	251,
	0);
INSERT INTO R_SIMP
	VALUES (252);
INSERT INTO R_REL
	VALUES (252,
	843,
	'',
	27);
INSERT INTO R_PART
	VALUES (57,
	252,
	253,
	0,
	1,
	'is a value of');
INSERT INTO O_RTIDA
	VALUES (254,
	57,
	0,
	252,
	253);
INSERT INTO R_RTO
	VALUES (57,
	252,
	253,
	0);
INSERT INTO R_OIR
	VALUES (57,
	252,
	253,
	56);
INSERT INTO R_FORM
	VALUES (88,
	252,
	255,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (88,
	252,
	255);
INSERT INTO R_OIR
	VALUES (88,
	252,
	255,
	0);
INSERT INTO R_SIMP
	VALUES (256);
INSERT INTO R_REL
	VALUES (256,
	844,
	'',
	27);
INSERT INTO R_PART
	VALUES (136,
	256,
	257,
	0,
	1,
	'specifies occurrences of');
INSERT INTO O_RTIDA
	VALUES (258,
	136,
	0,
	256,
	257);
INSERT INTO R_RTO
	VALUES (136,
	256,
	257,
	0);
INSERT INTO R_OIR
	VALUES (136,
	256,
	257,
	0);
INSERT INTO R_FORM
	VALUES (59,
	256,
	259,
	1,
	1,
	'may have');
INSERT INTO R_RGO
	VALUES (59,
	256,
	259);
INSERT INTO R_OIR
	VALUES (59,
	256,
	259,
	58);
INSERT INTO R_SIMP
	VALUES (260);
INSERT INTO R_REL
	VALUES (260,
	841,
	'',
	27);
INSERT INTO R_FORM
	VALUES (124,
	260,
	261,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (124,
	260,
	261);
INSERT INTO R_OIR
	VALUES (124,
	260,
	261,
	0);
INSERT INTO R_PART
	VALUES (61,
	260,
	262,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (263,
	61,
	0,
	260,
	262);
INSERT INTO R_RTO
	VALUES (61,
	260,
	262,
	0);
INSERT INTO R_OIR
	VALUES (61,
	260,
	262,
	60);
INSERT INTO R_SIMP
	VALUES (264);
INSERT INTO R_REL
	VALUES (264,
	845,
	'',
	27);
INSERT INTO R_FORM
	VALUES (124,
	264,
	265,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (124,
	264,
	265);
INSERT INTO R_OIR
	VALUES (124,
	264,
	265,
	0);
INSERT INTO R_PART
	VALUES (63,
	264,
	266,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (267,
	63,
	0,
	264,
	266);
INSERT INTO R_RTO
	VALUES (63,
	264,
	266,
	0);
INSERT INTO R_OIR
	VALUES (63,
	264,
	266,
	62);
INSERT INTO R_SIMP
	VALUES (268);
INSERT INTO R_REL
	VALUES (268,
	834,
	'',
	27);
INSERT INTO R_PART
	VALUES (107,
	268,
	269,
	0,
	0,
	'');
INSERT INTO O_RTIDA
	VALUES (270,
	107,
	0,
	268,
	269);
INSERT INTO R_RTO
	VALUES (107,
	268,
	269,
	0);
INSERT INTO R_OIR
	VALUES (107,
	268,
	269,
	0);
INSERT INTO R_FORM
	VALUES (271,
	268,
	272,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (271,
	268,
	272);
INSERT INTO R_OIR
	VALUES (271,
	268,
	272,
	0);
INSERT INTO R_SIMP
	VALUES (273);
INSERT INTO R_REL
	VALUES (273,
	846,
	'',
	27);
INSERT INTO R_FORM
	VALUES (271,
	273,
	274,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (271,
	273,
	274);
INSERT INTO R_OIR
	VALUES (271,
	273,
	274,
	0);
INSERT INTO R_PART
	VALUES (52,
	273,
	275,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (276,
	52,
	0,
	273,
	275);
INSERT INTO O_RTIDA
	VALUES (277,
	52,
	0,
	273,
	275);
INSERT INTO R_RTO
	VALUES (52,
	273,
	275,
	0);
INSERT INTO R_OIR
	VALUES (52,
	273,
	275,
	51);
INSERT INTO R_SIMP
	VALUES (278);
INSERT INTO R_REL
	VALUES (278,
	847,
	'',
	27);
INSERT INTO R_FORM
	VALUES (271,
	278,
	279,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (271,
	278,
	279);
INSERT INTO R_OIR
	VALUES (271,
	278,
	279,
	0);
INSERT INTO R_PART
	VALUES (57,
	278,
	280,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (254,
	57,
	0,
	278,
	280);
INSERT INTO R_RTO
	VALUES (57,
	278,
	280,
	0);
INSERT INTO R_OIR
	VALUES (57,
	278,
	280,
	64);
INSERT INTO R_SIMP
	VALUES (281);
INSERT INTO R_REL
	VALUES (281,
	848,
	'',
	27);
INSERT INTO R_PART
	VALUES (32,
	281,
	282,
	0,
	0,
	'has');
INSERT INTO O_RTIDA
	VALUES (156,
	32,
	0,
	281,
	282);
INSERT INTO R_RTO
	VALUES (32,
	281,
	282,
	0);
INSERT INTO R_OIR
	VALUES (32,
	281,
	282,
	33);
INSERT INTO R_FORM
	VALUES (129,
	281,
	283,
	1,
	1,
	'is type of');
INSERT INTO R_RGO
	VALUES (129,
	281,
	283);
INSERT INTO R_OIR
	VALUES (129,
	281,
	283,
	0);
INSERT INTO R_SIMP
	VALUES (284);
INSERT INTO R_REL
	VALUES (284,
	849,
	'',
	27);
INSERT INTO R_FORM
	VALUES (59,
	284,
	285,
	1,
	1,
	'may have');
INSERT INTO R_RGO
	VALUES (59,
	284,
	285);
INSERT INTO R_OIR
	VALUES (59,
	284,
	285,
	58);
INSERT INTO R_PART
	VALUES (129,
	284,
	286,
	0,
	1,
	'specifies occurrences of');
INSERT INTO O_RTIDA
	VALUES (131,
	129,
	0,
	284,
	286);
INSERT INTO R_RTO
	VALUES (129,
	284,
	286,
	0);
INSERT INTO R_OIR
	VALUES (129,
	284,
	286,
	0);
INSERT INTO R_SIMP
	VALUES (287);
INSERT INTO R_REL
	VALUES (287,
	850,
	'',
	27);
INSERT INTO R_FORM
	VALUES (126,
	287,
	288,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (126,
	287,
	288);
INSERT INTO R_OIR
	VALUES (126,
	287,
	288,
	0);
INSERT INTO R_PART
	VALUES (66,
	287,
	289,
	0,
	0,
	'');
INSERT INTO O_RTIDA
	VALUES (290,
	66,
	0,
	287,
	289);
INSERT INTO O_RTIDA
	VALUES (291,
	66,
	0,
	287,
	289);
INSERT INTO R_RTO
	VALUES (66,
	287,
	289,
	0);
INSERT INTO R_OIR
	VALUES (66,
	287,
	289,
	65);
INSERT INTO R_SIMP
	VALUES (292);
INSERT INTO R_REL
	VALUES (292,
	851,
	'',
	27);
INSERT INTO R_FORM
	VALUES (124,
	292,
	293,
	1,
	1,
	'is target of');
INSERT INTO R_RGO
	VALUES (124,
	292,
	293);
INSERT INTO R_OIR
	VALUES (124,
	292,
	293,
	0);
INSERT INTO R_PART
	VALUES (70,
	292,
	294,
	0,
	1,
	'has target');
INSERT INTO O_RTIDA
	VALUES (72,
	70,
	0,
	292,
	294);
INSERT INTO R_RTO
	VALUES (70,
	292,
	294,
	0);
INSERT INTO R_OIR
	VALUES (70,
	292,
	294,
	0);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (223,
	'Variable Location',
	824,
	'V_LOC',
	'A location in the activity where the variable appears.  VariableLocations
can be either l-values or r-values.  The variable which this location
applies to is either an instance of the Variable class (R835), or a by 
reference parameter acting as an l-value (R688).  Parameters acting as
r-values are captured by R835.',
	27);
INSERT INTO O_NBATTR
	VALUES (295,
	223);
INSERT INTO O_BATTR
	VALUES (295,
	223);
INSERT INTO O_ATTR
	VALUES (295,
	223,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	296,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (297,
	223);
INSERT INTO O_BATTR
	VALUES (297,
	223);
INSERT INTO O_ATTR
	VALUES (297,
	223,
	295,
	'LineNumber',
	'The line in the activity for this variable location.',
	'',
	'LineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (299,
	223);
INSERT INTO O_BATTR
	VALUES (299,
	223);
INSERT INTO O_ATTR
	VALUES (299,
	223,
	297,
	'StartPosition',
	'The column in the activity at which this variable location starts.',
	'',
	'StartPosition',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (300,
	223);
INSERT INTO O_BATTR
	VALUES (300,
	223);
INSERT INTO O_ATTR
	VALUES (300,
	223,
	299,
	'EndPosition',
	'The column in the activity at which this variable location ends.',
	'',
	'EndPosition',
	0,
	298,
	'',
	'');
INSERT INTO O_REF
	VALUES (223,
	129,
	0,
	131,
	221,
	224,
	222,
	301,
	302,
	0,
	0,
	'',
	'Variable',
	'Var_ID',
	'R835');
INSERT INTO O_RATTR
	VALUES (301,
	223,
	131,
	129,
	1,
	'Var_ID');
INSERT INTO O_ATTR
	VALUES (301,
	223,
	300,
	'Var_ID',
	'',
	'',
	'Var_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	223);
INSERT INTO O_OIDA
	VALUES (295,
	223,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	223);
INSERT INTO O_ID
	VALUES (2,
	223);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (129,
	'Variable',
	815,
	'V_VAR',
	'This class represents a temporary variable or an instance.',
	27);
INSERT INTO O_TFR
	VALUES (303,
	129,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	304);
INSERT INTO O_TFR
	VALUES (305,
	129,
	'migrate_to_int',
	'During parsing, all variables are initially created with a Transient Var (V_TRN) subtype.  If it is determined at a later point the Variable instance should have a subtype of Instance (V_INT), this function is called to migrate the V_TRN subtype instance to a V_INT instance.
--------------------------------------------------------------------------------
Bridge:ALS',
	19,
	1,
	'select one trn related by self->V_TRN[R814];
if ( not_empty trn )
  // need to migrate to V_INT
  unrelate self from trn across R814;
  delete object instance trn;
  create object instance inst_ref of V_INT;
  relate inst_ref to self across R814;
end if;
',
	1,
	'',
	306);
INSERT INTO O_TFR
	VALUES (306,
	129,
	'migrate_to_ins',
	'During parsing, all variables are initially created with a Transient Var (V_TRN) subtype.  If it is determined at a later point the Variable instance should have a subtype of Instance Set (V_INS), this function is called to migrate the V_TRN subtype instance to a V_INS instance.
--------------------------------------------------------------------------------
Bridge:ALS',
	19,
	1,
	'select one trn related by self->V_TRN[R814];
if ( not_empty trn )
  // need to migrate to V_INS
  unrelate self from trn across R814;
  delete object instance trn;
  create object instance inst_ref of V_INS;
  relate inst_ref to self across R814;
end if;
',
	1,
	'',
	307);
INSERT INTO O_TFR
	VALUES (308,
	129,
	'addLocation',
	'',
	19,
	1,
	'create object instance loc of V_LOC;
loc.LineNumber = param.line;
loc.StartPosition = param.col;
loc.EndPosition = loc.StartPosition + GD::strlen(s: self.Name) - 1;
relate loc to self across R835;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (309,
	308,
	'line',
	298,
	0,
	'',
	310,
	'');
INSERT INTO O_TPARM
	VALUES (310,
	308,
	'col',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (311,
	129,
	'getDimensionsCnt',
	'',
	298,
	1,
	'select many dims related by self->S_DIM[R849];
dimensions = cardinality dims;
return dimensions;',
	1,
	'',
	303);
INSERT INTO O_TFR
	VALUES (312,
	129,
	'resizeDimensions',
	'',
	19,
	1,
	'// If the number of dimensions has increased then add dimensions
while (param.numDimensions > self.getDimensionsCnt())
  create object instance dim of S_DIM;
  dim.dimensionCount = self.getDimensionsCnt();
  relate dim to self across R849;
end while;

// If the number of dimensions has decreased then remove dimensions
while (param.numDimensions < self.getDimensionsCnt())
  select any dim related by self->S_DIM[R849] where (selected.dimensionCount == (self.getDimensionsCnt()-1));
  unrelate dim from self across R849;
  delete object instance dim;
end while;

// Update the specific dimension that was passed-in if its elementCount has
// changed.
if (param.numDimensions > 0)
  select any dim related by self->S_DIM[R849] where (selected.dimensionCount == param.dimension);
  if (dim.elementCount != param.elementCount)
    dim.elementCount = param.elementCount;
  end if;
end if;',
	1,
	'',
	305);
INSERT INTO O_TPARM
	VALUES (313,
	312,
	'dimension',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (314,
	312,
	'elementCount',
	298,
	0,
	'',
	313,
	'');
INSERT INTO O_TPARM
	VALUES (315,
	312,
	'numDimensions',
	298,
	0,
	'',
	314,
	'');
INSERT INTO O_TFR
	VALUES (307,
	129,
	'isReferringToDefaultDataType',
	'',
	316,
	1,
	'select one dt related by self->S_DT[R848];
elementType = Util::getSimpleClassName(element:self.convertToInstance());
if(dt.Name == S_DT::getDefaultDataTypeName(elementType:elementType))
  return true;
end if;
return false;',
	1,
	'',
	311);
INSERT INTO O_TFR
	VALUES (304,
	129,
	'convertToInstance',
	'Translate:native',
	317,
	1,
	'return this;',
	0,
	'',
	318);
INSERT INTO O_TFR
	VALUES (318,
	129,
	'canReferToDataType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one body related by self->ACT_BLK[R823]->ACT_ACT[R601];
isInGenericPackage = body.associateWithContainer();
if isInGenericPackage
  select one dt related by self->S_DT[R848];
  if (not_empty dt)
    select one containingElem related by body->ACT_BIE[R640]->PE_PE[R640];
    return containingElem.canReferToDataType(dtID:dt.DT_ID, dtName:dt.Name);
  end if;
  return false;
else
  select one dt related by self->S_DT[R848];
  if(not_empty dt)
    select one dtPkg related by dt->S_DIP[R39]->S_DPK[R39];
    body.associateWithOwningComponent();
    select one component related by body->ACT_BIC[R694]->C_C[R694];
    if(not_empty component)
      select one reqSig related by body->ACT_RSB[R698];
      select one reqOp related by body->ACT_ROB[R698];
      select one proSig related by body->ACT_PSB[R698];
      select one proOp related by body->ACT_POB[R698];
      // if any of the following is not empty
      // then the dt must live at the system level
      if(not_empty reqSig)
        if(dtPkg.isDomainLevel())
          return false;
        else
          return true;
        end if;  
      elif(not_empty reqOp)
        select one dtPkg related by dt->S_DIP[R39]->S_DPK[R39];
        if(dtPkg.isDomainLevel())
          return false;
        else
          return true;
        end if;    
      elif(not_empty proSig)
        select one dtPkg related by dt->S_DIP[R39]->S_DPK[R39];
        if(dtPkg.isDomainLevel())
          return false;
        else
          return true;
        end if;  
      elif(not_empty proOp)
        select one dtPkg related by dt->S_DIP[R39]->S_DPK[R39];
        if(dtPkg.isDomainLevel())
          return false;
        else
          return true;
        end if;
      else
        select any domain from instances of S_DOM;
        if(not dtPkg.isDomainLevel())
          return true;
        else
          select one dtDomain related by dt->S_DOM[R14];
          if(dtDomain == domain)
            return true;
          end if;
        end if;
      end if;
    else
      select any domain from instances of S_DOM;
      if(dtPkg.isDomainLevel())
        select one dtDomain related by dt->S_DOM[R14];
        if(domain == dtDomain)
          return true;
        end if;
      else
        return true;
      end if;
    end if;
  end if;
  return false;
end if;',
	1,
	'',
	308);
INSERT INTO O_NBATTR
	VALUES (131,
	129);
INSERT INTO O_BATTR
	VALUES (131,
	129);
INSERT INTO O_ATTR
	VALUES (131,
	129,
	0,
	'Var_ID',
	'

',
	'',
	'Var_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_REF
	VALUES (129,
	35,
	0,
	163,
	161,
	164,
	162,
	319,
	320,
	0,
	0,
	'',
	'Block',
	'Block_ID',
	'R823');
INSERT INTO O_RATTR
	VALUES (319,
	129,
	163,
	35,
	1,
	'Block_ID');
INSERT INTO O_ATTR
	VALUES (319,
	129,
	131,
	'Block_ID',
	'

',
	'',
	'Block_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (321,
	129);
INSERT INTO O_BATTR
	VALUES (321,
	129);
INSERT INTO O_ATTR
	VALUES (321,
	129,
	319,
	'Name',
	'This string represents the name a variable.',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (323,
	129);
INSERT INTO O_BATTR
	VALUES (323,
	129);
INSERT INTO O_ATTR
	VALUES (323,
	129,
	321,
	'Declared',
	'This attribute is true if the variable has been fully declared. During parsing, there is a span of time between when the variable is first parsed and when we know what the data type of the variable is.  During this time Declared is false.  Once the type of the variable is assigned, Declared is set to true.
--------------------------------------------------------------------------------
Bridge:ALS',
	'',
	'Declared',
	0,
	316,
	'',
	'');
INSERT INTO O_REF
	VALUES (129,
	32,
	0,
	156,
	281,
	283,
	282,
	324,
	325,
	0,
	0,
	'',
	'Data Type',
	'DT_ID',
	'R848.''has''');
INSERT INTO O_RATTR
	VALUES (324,
	129,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (324,
	129,
	323,
	'DT_ID',
	'',
	'',
	'Element_ID',
	2,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	129);
INSERT INTO O_OIDA
	VALUES (131,
	129,
	0,
	'Var_ID');
INSERT INTO O_ID
	VALUES (1,
	129);
INSERT INTO O_ID
	VALUES (2,
	129);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (70,
	'Value',
	800,
	'V_VAL',
	'A value (r-value) may be assigned to a variable, attribute or parameter
(l-values). There are many different kinds of value in a model. This class
captures this observation in a supertype.',
	27);
INSERT INTO O_TFR
	VALUES (326,
	70,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.
',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	327);
INSERT INTO O_TFR
	VALUES (328,
	70,
	'setEndPosition',
	'',
	19,
	1,
	'select one body related by self->ACT_BLK[R826]->ACT_ACT[R601];
if ( self.StartPosition == -1 )
  self.EndPosition = -1;
else
  select one lin related by self->V_LIN[R801];
  if ( not_empty lin )
    self.EndPosition = self.StartPosition + GD::strlen(s: lin.Value) - 1;
    return;
  end if;

  select one lbo related by self->V_LBO[R801];
  if ( not_empty lbo )
    self.EndPosition = self.StartPosition + GD::strlen(s: lbo.Value) - 1;
    return;
  end if;

  select one lst related by self->V_LST[R801];
  if ( not_empty lst )
    self.EndPosition = self.StartPosition + GD::strlen(s: lst.Value); // + 1 - 1
    return;
  end if;

  select one lrl related by self->V_LRL[R801];
  if ( not_empty lrl )
    self.EndPosition = self.StartPosition + GD::strlen(s: lrl.Value) - 1;
    return;
  end if;

  select one bin related by self->V_BIN[R801];
  if ( not_empty bin )
    select one lop related by bin->V_VAL[R802];
    select one rop related by bin->V_VAL[R803];
    self.StartPosition = lop.StartPosition;
    self.EndPosition = rop.EndPosition;
    return;
  end if;

  select one unary related by self->V_UNY[R801];
  if ( not_empty unary )
    select one op related by unary->V_VAL[R804];
    self.EndPosition = op.EndPosition;
    return;
  end if;

  select one len related by self->V_LEN[R801];
  if ( not_empty len )
    select one enum related by len->S_ENUM[R824];
    self.EndPosition = self.StartPosition + GD::strlen(s: enum.Name) - 1;
    return;
  end if;

  select one scv related by self->V_SCV[R801];
  if ( not_empty scv )
    self.EndPosition = self.StartPosition + GD::strlen(s: self.Text) - 1;
    return;
  end if;
                             
  select one irf related by self->V_IRF[R801];
  if ( not_empty irf )
    select one var related by irf->V_VAR[R808];
    self.EndPosition = self.StartPosition + GD::strlen(s: var.Name) - 1;
    return;
  end if;

  select one isr related by self->V_ISR[R801];
  if ( not_empty isr )
    select one var related by isr->V_VAR[R809];
    self.EndPosition = self.StartPosition + GD::strlen(s: var.Name) - 1;
    return;
  end if;

  select one slr related by self->V_SLR[R801];
  if ( not_empty slr )
    // selected references are ignored
    return;
  end if;

  select one fnc related by self->V_FNV[R801];
  if ( not_empty fnc )
    // Function Values are not represented by any text in the OAL, therefore
    // they are ignored here.
    return;
  end if;

  select one brv related by self->V_BRV[R801];
  if ( not_empty brv )
    // Bridge Values are not represented by any text in the OAL, therefore
    // they are ignored here.
    return;
  end if;

  select one trv related by self->V_TRV[R801];
  if ( not_empty trv )
    // Operation Values are not represented by any text in the OAL, therefore
    // they are ignored here.
    return;
  end if;

  select one var related by self->V_TVL[R801]->V_VAR[R805];
  if ( not_empty var )
    self.EndPosition = self.StartPosition + GD::strlen(s: var.Name) - 1;
    return;
  end if;

  // Since all referenced parameters will have
  // the same name, just pick the first one.
  select any evtParmRef related by self->V_EDV[R801]->V_EPR[R834];
  if not_empty evtParmRef
    select one edi related by evtParmRef->SM_EVTDI[R846];
    if ( not_empty edi )
      self.EndPosition = self.StartPosition + GD::strlen(s: edi.Name) - 1;
      return;
    else
      select one propParm related by evtParmRef->C_PP[R847];
      if not_empty propParm
        self.EndPosition = self.StartPosition +
                                               GD::strlen(s: propParm.Name) - 1;
        return;
      end if;
    end if;
  end if;
  select one attr related by self->V_AVL[R801]->O_ATTR[R806];
  if ( not_empty attr )
    self.EndPosition = self.StartPosition + GD::strlen(s: attr.Name) - 1;
    return;
  end if;

  select one parm related by self->V_PVL[R801];
  if ( not_empty parm )
    select one bparm related by parm->S_BPARM[R831];
    if ( not_empty bparm )
      self.EndPosition = self.StartPosition + GD::strlen(s: bparm.Name) - 1;
      return;
    end if;
    select one sparm related by parm->S_SPARM[R832];
    if ( not_empty sparm )
      self.EndPosition = self.StartPosition + GD::strlen(s: sparm.Name) - 1;
      return;
    end if;
    select one tparm related by parm->O_TPARM[R833];
    if ( not_empty tparm )
      self.EndPosition = self.StartPosition + GD::strlen(s: tparm.Name) - 1;
      return;
    end if;
    select one pparm related by parm->C_PP[R843];
    if ( not_empty pparm )
      self.EndPosition = self.StartPosition + GD::strlen(s: pparm.Name) - 1;
      return;
    end if;
    // unknown parameter type
    self.StartPosition = -1;
    self.EndPosition = -1;
    pathMsg = "<No Path Available - Empty instance>";
    if (not_empty body)
      pathMsg = body.getPath();
    end if;
	USER::logError(msg: "Unknown parameter subtype",path:pathMsg);
    return;
  end if;
  select one memberVal related by self->V_MVL[R801];
  if (not_empty memberVal)
    select one member related by memberVal->S_MBR[R836];
    self.EndPosition = self.StartPosition + GD::strlen(s: member.Name) - 1;
    return;
  end if;
  select one aer related by self->V_AER[R801];
  if ( not_empty aer )
    // TODO
    return;
  end if;
  select one alv related by self->V_ALV[R801];
  if ( not_empty alv )
    self.EndPosition = self.StartPosition + 5; // strlen("length") - 1
    return;
  end if;
  select one msv related by self->V_MSV[R801];
  if not_empty msv
    select one message related by msv->SPR_PEP[R841]->C_EP[R4501];
    if(empty message)
      select one message related by msv->SPR_REP[R845]->C_EP[R4500];
    end if;
    if empty message
      pathMsg = "<No Path Available - Empty instance>";
    if (not_empty body)
      pathMsg = body.getPath();
    end if;
	USER::logError(msg: "setEndPosition: No message found",path:pathMsg);
    else
      select one sig related by message->C_AS[R4004];
      if not_empty sig
        self.EndPosition = self.StartPosition + GD::strlen(s: sig.Name);
        return;
      else
        select one op related by message->C_IO[R4004];
        if not_empty op
          self.EndPosition = self.StartPosition + GD::strlen(s: op.Name);
          return;
        else
          pathMsg = "<No Path Available - Empty instance>";
    if (not_empty body)
      pathMsg = body.getPath();
    end if;
	USER::logError(msg: "setEndPosition: Unknown message subtype",path:pathMsg);
        end if;
      end if;
    end if;
    self.StartPosition = -1;
    self.EndPosition = -1;
    return;
  end if;
  // unknown subtype of V_VAL
  self.StartPosition = -1;
  self.EndPosition = -1;
  pathMsg = "<No Path Available - Empty instance>";
    if (not_empty body)
      pathMsg = body.getPath();
    end if;
	USER::logError(msg: "Unknown value subtype",path:pathMsg);
end if;',
	1,
	'',
	329);
INSERT INTO O_TFR
	VALUES (330,
	70,
	'computeValue',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	331);
INSERT INTO O_TPARM
	VALUES (332,
	330,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (333,
	70,
	'setValue',
	'Note: Setting values is only supported for assigning values of invocation
parameters passed by reference.',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	334);
INSERT INTO O_TPARM
	VALUES (335,
	333,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (336,
	333,
	'value',
	317,
	0,
	'',
	335,
	'');
INSERT INTO O_TPARM
	VALUES (337,
	333,
	'member_id',
	296,
	0,
	'',
	336,
	'');
INSERT INTO O_TFR
	VALUES (338,
	70,
	'getValue',
	'',
	317,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return GD::NULL_INSTANCE();',
	1,
	'',
	339);
INSERT INTO O_TPARM
	VALUES (340,
	338,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (341,
	70,
	'hasSubtype',
	'',
	316,
	1,
	'select one lin related by self->V_LIN[R801];
if ( not_empty lin )
  return true;
end if;
select one lbo related by self->V_LBO[R801];
if ( not_empty lbo )
  return true;
end if;
select one lst related by self->V_LST[R801];
if ( not_empty lst )
  return true;
end if;
select one lrl related by self->V_LRL[R801];
if ( not_empty lrl )
  return true;
end if;
select one bin related by self->V_BIN[R801];
if ( not_empty bin )
  return true;
end if;
select one unary related by self->V_UNY[R801];
if ( not_empty unary )
  return true;
end if;
select one len related by self->V_LEN[R801];
if ( not_empty len )
  return true;
end if;
select one irf related by self->V_IRF[R801];
if ( not_empty irf )
  return true;
end if;
select one isr related by self->V_ISR[R801];
if ( not_empty isr )
  return true;
end if;
select one slr related by self->V_SLR[R801];
if ( not_empty slr )
  return true;
end if;
select one fnc related by self->V_FNV[R801];
if ( not_empty fnc )
  return true;
end if;
select one brv related by self->V_BRV[R801];
if ( not_empty brv )
  return true;
end if;
select one trv related by self->V_TRV[R801];
if ( not_empty trv )
  return true;
end if;
select one tvl related by self->V_TVL[R801];
if ( not_empty tvl )
  return true;
end if;
select one edv related by self->V_EDV[R801];
if ( not_empty edv )
  return true;
end if;
select one avl related by self->V_AVL[R801];
if ( not_empty avl )
  return true;
end if;
select one parm related by self->V_PVL[R801];
if ( not_empty parm )
  return true;
end if;
select one memberVal related by self->V_MVL[R801];
if (not_empty memberVal)
  return true;
end if;
return false;',
	1,
	'',
	338);
INSERT INTO O_TFR
	VALUES (339,
	70,
	'getRuntimeValue',
	'',
	296,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return GD::NULL_UNIQUE_ID();
',
	1,
	'',
	342);
INSERT INTO O_TPARM
	VALUES (343,
	339,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (344,
	70,
	'isLeaf',
	'',
	316,
	1,
	'// Value.isLeaf()
select one mvlRef related by self->V_MVL[R837];
select one arrayRef related by self->V_AER[R838];
return empty mvlRef and empty arrayRef;',
	1,
	'',
	341);
INSERT INTO O_TFR
	VALUES (334,
	70,
	'setRank',
	'',
	296,
	1,
	'// Value.setRank
select one tvl related by self->V_TVL[R801];
select one aer related by self->V_AER[R801];
varID = GD::NULL_UNIQUE_ID();
if not_empty tvl
  select one vvar related by tvl->V_VAR[R805];
  if not_empty vvar
    varID = vvar.Var_ID;

    select any rval from instances of V_VAL where param.rval_id == selected.Value_ID;
    rvalNumDimensions = rval.getDimensions();
    totalLvarDims = rvalNumDimensions + param.dimension;
    while ( rvalNumDimensions > 0 )
      // Resize each dimension
      elementCount = rval.getArrayLength(dimension:rvalNumDimensions-1);
      create object instance dim of S_DIM;
      // We may be deep into recursion.  As we unwind the aer dimensions will
      // be added.  Therefore, this dimension is "rvalNumDimensions + param.dimension".
      // If we are not in recursion then param.dimension will be 0;
      dim.dimensionCount = (rvalNumDimensions + param.dimension) - 1; // subtract 1 to make it 0 based
      dim.elementCount = elementCount;
      relate vvar to dim across R849;
      rvalNumDimensions = rvalNumDimensions - 1;
    end while;
  end if;
elif not_empty aer
  select one rootVal related by aer->V_VAL[R838];
  varID = rootVal.setRank(dimension:param.dimension+1, rval_id:param.rval_id);
  select any vvar from instances of V_VAR where selected.Var_ID == varID;
  if (not_empty vvar)
    //TODO: When we support values other then literals this will
    //      need to be parsed.  Until then, we use dynamic sizing (indicated
    //      with a value of 0) when a literal integer is not specified.
    elementCount = 0;

    select one lin related by aer->V_VAL[R839]->V_LIN[R801];
    if (not_empty lin)
      // Add 1 to the value because in this case, this was specified as an
      // array index.
      elementCount = lin.getInteger() + 1;
    end if;

    create object instance dim of S_DIM;
     select many numberOfDims related by vvar->S_DIM[R849]; 
    dim.dimensionCount = cardinality numberOfDims;
    dim.elementCount = elementCount;
    relate vvar to dim across R849;
  end if;
end if;
return varID;
',
	1,
	'',
	328);
INSERT INTO O_TPARM
	VALUES (345,
	334,
	'dimension',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (346,
	334,
	'rval_id',
	296,
	0,
	'',
	345,
	'');
INSERT INTO O_TFR
	VALUES (342,
	70,
	'getDimensions',
	'',
	298,
	1,
	'// Value.getDimensions()
select one memberRef related by self->V_MVL[R801];
select one attrValRef related by self->V_AVL[R801];
select one tranValRef related by self->V_TVL[R801];
select one arrayElemRef related by self->V_AER[R801];
select one funcReturnVal related by self->V_FNV[R801];
select one opReturnVal related by self->V_TRV[R801];
select one brReturnVal related by self->V_BRV[R801];
select one parmVal related by self->V_PVL[R801];
select one evtDatVal related by self->V_EDV[R801];
select one msgVal related by self->V_MSV[R801];
select one instRef related by self->V_IRF[R801];
if not_empty memberRef
  select one member related by memberRef->S_MBR[R836];
  return member.getDimensionsCnt();
elif not_empty instRef
	select one var related by instRef->V_VAR[R808];
	return var.getDimensionsCnt();
elif not_empty attrValRef
  select one attr related by attrValRef->O_ATTR[R806];
  return attr.getDimensionsCnt();
elif not_empty tranValRef
  select one tran related by tranValRef->V_VAR[R805];
  return tran.getDimensionsCnt();
elif not_empty arrayElemRef
  select one rootVal related by arrayElemRef->V_VAL[R838];
  cnt = rootVal.getDimensions() - 1;
  if cnt < 0
    // No action here, but note that this may indicate too many
    // array indices were specified.  We return the negative value
    // here for the caller to handle.  This rountine is most-often
    // called by the parser, and when this is a parse error we want
    // it reported as such.
    // Additionally, note that this behavior is critcal in
    // allowing the parser to determine our position in a multidimensional
    // array.  Through the recursion above, we find the root of the chain and
    // the stack unwinds back to the current position giving us the correct
    // position in a multidimensional array.
  end if;
  return cnt;
elif not_empty funcReturnVal
  select one func related by funcReturnVal->S_SYNC[R827];
  return func.getReturnDimensionsCnt();
elif not_empty opReturnVal
  select one op related by opReturnVal->O_TFR[R829];
  return op.getReturnDimensionsCnt();
elif not_empty brReturnVal
  select one br related by brReturnVal->S_BRG[R828];
  return br.getReturnDimensionsCnt();
elif not_empty parmVal
  select one fnParm related by parmVal->S_SPARM[R832];
  select one opParm related by parmVal->O_TPARM[R833];
  select one brParm related by parmVal->S_BPARM[R831];
  select one ppParm related by parmVal->C_PP[R843];
  if not_empty fnParm
    return fnParm.getDimensionsCnt();
  elif not_empty opParm
    return opParm.getDimensionsCnt();
  elif not_empty brParm
    return brParm.getDimensionsCnt();
  elif(not_empty ppParm)
    return ppParm.getDimensionsCnt();
  else
    // Cannot happen - required to satisfy parser
    return 0;
  end if;
elif not_empty evtDatVal
  // Since all referenced parameters will have
  // the same name, just pick the first one.
  select any evtParmRef related by evtDatVal->V_EPR[R834];
  select one evtdi related by evtParmRef->SM_EVTDI[R846];
  if not_empty evtdi
    return evtdi.getDimensionsCnt();
  else
    select one propParm related by evtParmRef->C_PP[R847];
    return propParm.getDimensionsCnt();
  end if;
elif not_empty msgVal
  select one io related by msgVal->SPR_REP[R845]->C_EP[R4500]->C_IO[R4004];
  if(empty io)
    select one io related by msgVal->SPR_PEP[R841]->C_EP[R4501]->C_IO[R4004];
  end if;
  if not_empty io
    return io.getReturnDimensionsCnt();
  else
    return 0;
  end if;
else
  return 0;
end if;',
	1,
	'',
	347);
INSERT INTO O_TFR
	VALUES (347,
	70,
	'getArrayLength',
	'Return the number of elements allowed in the specified dimension.  A value of
0 indicates that the array is dynamically sized.  A return value of -1 
indicates that the specfied dimension is invalid.   The specified dimension 
parameter is 0-based.',
	298,
	1,
	'// Value.getArrayLength()
select one memberRef related by self->V_MVL[R801];
select one attrValRef related by self->V_AVL[R801];
select one tranValRef related by self->V_TVL[R801];
select one arrayElemRef related by self->V_AER[R801];
select one funcReturnVal related by self->V_FNV[R801];
select one opReturnVal related by self->V_TRV[R801];
select one brReturnVal related by self->V_BRV[R801];
select one parmVal related by self->V_PVL[R801];
select one evtDatVal related by self->V_EDV[R801];
select one msgVal related by self->V_MSV[R801];
select one instRef related by self->V_IRF[R801];
select any dim from instances of S_DIM where selected.DIM_ID==GD::NULL_UNIQUE_ID();
dimensionSize = -1;

if not_empty memberRef
  select any dim related by memberRef->S_MBR[R836]->S_DIM[R53] where (selected.dimensionCount == param.dimension);
elif not_empty instRef
  select any dim related by instRef->V_VAR[R808]->S_DIM[R849] where (selected.dimensionCount == param.dimension);
elif not_empty attrValRef
  select any dim related by attrValRef->O_ATTR[R806]->S_DIM[R120] where (selected.dimensionCount == param.dimension);
elif not_empty tranValRef
  select any dim related by tranValRef->V_VAR[R805]->S_DIM[R849] where (selected.dimensionCount == param.dimension);
elif not_empty arrayElemRef
  select one rootVal related by arrayElemRef->V_VAL[R838];
  return rootVal.getArrayLength(dimension:param.dimension);
elif not_empty funcReturnVal
  select any dim related by funcReturnVal->S_SYNC[R827]->S_DIM[R51] where (selected.dimensionCount == param.dimension);
elif not_empty opReturnVal
  select any dim related by opReturnVal->O_TFR[R829]->S_DIM[R122] where (selected.dimensionCount == param.dimension);
elif not_empty brReturnVal
  select any dim related by brReturnVal->S_BRG[R828]->S_DIM[R50] where (selected.dimensionCount == param.dimension);
elif not_empty parmVal
  select one fnParm related by parmVal->S_SPARM[R832];
  select one opParm related by parmVal->O_TPARM[R833];
  select one brParm related by parmVal->S_BPARM[R831];
  select one prParm related by parmVal->C_PP[R843];
  if not_empty fnParm
    select any dim related by fnParm->S_DIM[R52] where (selected.dimensionCount == param.dimension);
  elif not_empty opParm
    select any dim related by opParm->S_DIM[R121] where (selected.dimensionCount == param.dimension);
  elif not_empty brParm
    select any dim related by brParm->S_DIM[R49] where (selected.dimensionCount == param.dimension);
  elif not_empty prParm
    select any dim related by prParm->S_DIM[R4017] where (selected.dimensionCount == param.dimension);
  else
    // Cannot happen - required to satisfy parser
  end if;
elif not_empty evtDatVal
  select any dim related by evtDatVal->V_EPR[R834]->SM_EVTDI[R846]->S_DIM[R531] where (selected.dimensionCount == param.dimension);
  if empty dim
    // it could be a signal event
    select any dim related by evtDatVal->V_EPR[R834]->C_PP[R847]->S_DIM[R4017]
                             where (selected.dimensionCount == param.dimension);
  end if;
elif not_empty msgVal
  select any dim related by msgVal->SPR_REP[R845]->C_EP[R4500]->C_IO[R4004]->S_DIM[R4018] where (selected.dimensionCount == param.dimension);
  if(empty dim)
    select any dim related by msgVal->SPR_PEP[R841]->C_EP[R4501]->C_IO[R4004]->S_DIM[R4018] where (selected.dimensionCount == param.dimension);
  end if;
end if;

if (not_empty dim)
  dimensionSize = dim.elementCount;
end if;
return dimensionSize;',
	1,
	'',
	326);
INSERT INTO O_TPARM
	VALUES (348,
	347,
	'dimension',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (349,
	70,
	'isElementCountValid',
	'This operation checks to see if the dimension value specified is withing bounds
of the actual declaration of the value.  For example:
foo[10] = "";  
foo[15] = "";
In the above example, the first line is a declaration statement (because it is
the first time this variable is used).  The element count of dimension 1 of 
this array is declared to be 11 elements (because it is an assignment and the
array is 0-based).  On the second line, an attempt is made to assign something 
to element 16 in the array.  This is an error (Array out of bounds), and it 
is the kind of problem this operation checks for.  This operation returns true
if the element count is valid and false if it is not.

             ',
	316,
	1,
	'isValid = true;

// Work up the array chain and find the root
select one aer related by self->V_AER[R801];
tempAER = aer;
while not_empty tempAER
  select one tempAER related by aer->V_VAL[R838]->V_AER[R801]; 
  if (not_empty tempAER)
    aer = tempAER;
  end if;
end while;

// We are now at the root of the array, so spin down through the chain and 
// check each dimension size.
dimension = 0;

while (isValid and not_empty aer)
  specifiedDimension = -1;
  // At some point BridgePoint will allow constants and even expressions as
  // an index, but right now we only allow integers.
  select one lin related by aer->V_VAL[R839]->V_LIN[R801];
  if (not_empty lin)
    specifiedDimension = lin.getInteger();
  end if;
  
  actualSize = self.getArrayLength(dimension:dimension);
  actualSizeIsDynamic = true;
  if (actualSize > 0)
    actualSizeIsDynamic = false;
  end if;
  if ( (not actualSizeIsDynamic) and (specifiedDimension >= actualSize) ) 
    isValid = false;
  end if;
  select one aer related by aer->V_VAL[R801]->V_AER[R838]; 
  dimension = dimension + 1;
end while;

return isValid;',
	1,
	'',
	333);
INSERT INTO O_TFR
	VALUES (329,
	70,
	'isReferringToDefaultDataType',
	'',
	316,
	1,
	'select one dt related by self->S_DT[R820];
elementType = Util::getSimpleClassName(element:self.convertToInstance());
if(dt.Name == S_DT::getDefaultDataTypeName(elementType:elementType))
  return true;
end if;
return false;',
	1,
	'',
	344);
INSERT INTO O_TFR
	VALUES (327,
	70,
	'convertToInstance',
	'Translate:native',
	317,
	1,
	'return this;',
	0,
	'',
	330);
INSERT INTO O_TFR
	VALUES (331,
	70,
	'canReferToDataType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one body related by self->ACT_BLK[R826]->ACT_ACT[R601];
isInGenericPackage = body.associateWithContainer();
if isInGenericPackage
  select one dt related by self->S_DT[R820];
  if(not_empty dt)
    select one containingElem related by body->ACT_BIE[R640]->PE_PE[R640];
    return containingElem.canReferToDataType(dtID:dt.DT_ID, dtName:dt.Name);
  end if;
  return false;
else
  select one dt related by self->S_DT[R820];
  if(not_empty dt)
    select one dtPkg related by dt->S_DIP[R39]->S_DPK[R39];
    body.associateWithOwningComponent();
    select one component related by body->ACT_BIC[R694]->C_C[R694];
    if(not_empty component)
      select one reqSig related by body->ACT_RSB[R698];
      select one reqOp related by body->ACT_ROB[R698];
      select one proSig related by body->ACT_PSB[R698];
      select one proOp related by body->ACT_POB[R698];
      // if any of the following is not empty
      // then the dt must live at the system level
      if(not_empty reqSig)
        if(dtPkg.isDomainLevel())
          return false;
        else
          return true;
        end if;  
      elif(not_empty reqOp)
        select one dtPkg related by dt->S_DIP[R39]->S_DPK[R39];
        if(dtPkg.isDomainLevel())
          return false;
        else
          return true;
        end if;    
      elif(not_empty proSig)
        select one dtPkg related by dt->S_DIP[R39]->S_DPK[R39];
        if(dtPkg.isDomainLevel())
          return false;
        else
          return true;
        end if;  
      elif(not_empty proOp)
        select one dtPkg related by dt->S_DIP[R39]->S_DPK[R39];
        if(dtPkg.isDomainLevel())
          return false;
        else
          return true;
        end if;
      else
        select any domain from instances of S_DOM;
        if(not dtPkg.isDomainLevel())
          return true;
        else
          select one dtDomain related by dt->S_DOM[R14];
          if(dtDomain == domain)
            return true;
          end if;
        end if;
      end if;
    else
      select any domain from instances of S_DOM;
      if(dtPkg.isDomainLevel())
        select one dtDomain related by dt->S_DOM[R14];
        if(domain == dtDomain)
          return true;
        end if;
      else
        return true;
      end if;
    end if;
  end if;
  return false;
end if;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (350,
	70,
	'isElementCountCompatible',
	'This operation checks to see if each dimension''s actual element count value 
is withing bounds of the element count of the variable being assigned.
For example:
foo[10] = "";  
foobar[15] = "";
foo = foobar;
In the above example, the assignment of foobar to foo should not be allowed
because the dimension element counts are not compatible.  Each dimension''s 
element count must match.
   ',
	316,
	1,
	'// Note that this value (self) is the lval and the paramater pased-in is the
// rval (see the operation description for more information)
//
 
isValid = true;
select any rval from instances of V_VAL where (selected.Value_ID == param.rVal);
if (empty rval)
  return false;
end if;

// Work up the array chain and find the root
select one l_aer related by self->V_AER[R801];
select one r_aer related by rval->V_AER[R801];
l_tempAER = l_aer;
r_tempAER = r_aer;
while ((not_empty l_tempAER and not_empty r_tempAER) and isValid)
  select one l_tempAER related by l_aer->V_VAL[R838]->V_AER[R801]; 
  select one r_tempAER related by r_aer->V_VAL[R838]->V_AER[R801]; 
  if (not_empty l_tempAER)
    l_aer = l_tempAER;
    if (not_empty r_tempAER)
	  l_aer = l_tempAER;
    else
      isValid = false;
    end if;
  else
    if (not_empty r_tempAER)
      isValid = false;
    end if;
  end if;
end while;

// We are now at the root of the array, so spin down through the chain and 
// check each dimension size.
dimension = 0;
while ((not_empty l_aer and not_empty r_aer) and isValid)
  l_actualSize = self.getArrayLength(dimension:dimension);
  r_actualSize = rval.getArrayLength(dimension:dimension);
  if ( l_actualSize != r_actualSize ) 
    isValid = false;
    break;
  end if;
  select one l_aer related by l_aer->V_VAL[R801]->V_AER[R838]; 
  select one r_aer related by r_aer->V_VAL[R801]->V_AER[R838]; 
  dimension = dimension + 1;
end while;

return isValid;',
	1,
	'',
	349);
INSERT INTO O_TPARM
	VALUES (351,
	350,
	'rVal',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_NBATTR
	VALUES (72,
	70);
INSERT INTO O_BATTR
	VALUES (72,
	70);
INSERT INTO O_ATTR
	VALUES (72,
	70,
	0,
	'Value_ID',
	'',
	'',
	'Value_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_REF
	VALUES (70,
	35,
	0,
	163,
	178,
	180,
	179,
	352,
	353,
	0,
	0,
	'',
	'Block',
	'Block_ID',
	'R826.''has scope''');
INSERT INTO O_RATTR
	VALUES (352,
	70,
	163,
	35,
	1,
	'Block_ID');
INSERT INTO O_ATTR
	VALUES (352,
	70,
	354,
	'Block_ID',
	'

',
	'',
	'Block_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (355,
	70);
INSERT INTO O_BATTR
	VALUES (355,
	70);
INSERT INTO O_ATTR
	VALUES (355,
	70,
	356,
	'LineNumber',
	'The line in the activity at which this value resides. It has a default 
value of -1, indicating that the location is not known.
                        
Not_participating_value: -1',
	'',
	'LineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (357,
	70);
INSERT INTO O_BATTR
	VALUES (357,
	70);
INSERT INTO O_ATTR
	VALUES (357,
	70,
	355,
	'StartPosition',
	'The column in the activity at which this value starts. It has a default 
value of -1, indicating that the location is not known.
                        
Not_participating_value: -1
',
	'',
	'StartPosition',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (358,
	70);
INSERT INTO O_BATTR
	VALUES (358,
	70);
INSERT INTO O_ATTR
	VALUES (358,
	70,
	357,
	'EndPosition',
	'The column in the activity at which this value ends. It has
a default value of -1, indicating that the location is not known.
                        
Not_participating_value: -1',
	'',
	'EndPosition',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (359,
	70);
INSERT INTO O_BATTR
	VALUES (359,
	70);
INSERT INTO O_ATTR
	VALUES (359,
	70,
	358,
	'firstParameterLabelLineNumber',
	'A scratchpad value employed while determining the textual position of any
parameter labels that are part of the composition of this value.
',
	'',
	'firstParameterLabelLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (360,
	70);
INSERT INTO O_BATTR
	VALUES (360,
	70);
INSERT INTO O_ATTR
	VALUES (360,
	70,
	359,
	'firstParameterLabelColumn',
	'See currentLabelLine.',
	'',
	'firstParameterLabelColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (361,
	70);
INSERT INTO O_BATTR
	VALUES (361,
	70);
INSERT INTO O_ATTR
	VALUES (361,
	70,
	360,
	'currentLaterParameterLabelLineNumber',
	'',
	'',
	'currentLaterParameterLabelLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (362,
	70);
INSERT INTO O_BATTR
	VALUES (362,
	70);
INSERT INTO O_ATTR
	VALUES (362,
	70,
	361,
	'currentLaterParameterLabelColumn',
	'',
	'',
	'currentLaterParameterLabelColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (363,
	70);
INSERT INTO O_BATTR
	VALUES (363,
	70);
INSERT INTO O_ATTR
	VALUES (363,
	70,
	72,
	'isLValue',
	'',
	'',
	'isLValue',
	0,
	316,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (356,
	70);
INSERT INTO O_BATTR
	VALUES (356,
	70);
INSERT INTO O_ATTR
	VALUES (356,
	70,
	363,
	'isImplicit',
	'',
	'',
	'isImplicit',
	0,
	316,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (364,
	70);
INSERT INTO O_BATTR
	VALUES (364,
	70);
INSERT INTO O_ATTR
	VALUES (364,
	70,
	352,
	'Text',
	'Persistent:false',
	'',
	'Text',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (70,
	32,
	0,
	156,
	154,
	157,
	155,
	354,
	365,
	0,
	0,
	'',
	'Data Type',
	'DT_ID',
	'R820.''has type''');
INSERT INTO O_RATTR
	VALUES (354,
	70,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (354,
	70,
	362,
	'DT_ID',
	'',
	'',
	'Element_ID',
	2,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	70);
INSERT INTO O_OIDA
	VALUES (72,
	70,
	0,
	'Value_ID');
INSERT INTO O_ID
	VALUES (1,
	70);
INSERT INTO O_ID
	VALUES (2,
	70);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (75,
	'Unary Operation',
	809,
	'V_UNY',
	'Like binary operators, unary operators modify the value in some way, but in this case only a single value is needed. One example is - (unary minus) which negates any numeric value. However other unary operators include the empty and not_empty set operators.',
	27);
INSERT INTO O_TFR
	VALUES (366,
	75,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'select one op related by self->V_VAL[R804];
if ( not_empty op )
  unrelate op from self across R804;
  op.dispose();
end if;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (367,
	75,
	'getValue',
	'Performs Unary Operation and returns the value.',
	317,
	1,
	'//Value: Unary Operation.getValue()
select one body related by self->V_VAL[R801]->ACT_BLK[R826]->ACT_ACT[R601];
select one dt related by self->V_VAL[R801]->S_DT[R820];
coreDataTypeName = dt.getCoreDataTypeName();
if (coreDataTypeName == "boolean")
  return GD::boolean_to_instance(value:self.getBoolean(stack_frame_id: param.stack_frame_id));
elif (coreDataTypeName == "integer")
  return GD::int_to_instance(value:self.getInteger(stack_frame_id: param.stack_frame_id));
elif (coreDataTypeName == "real")
  return GD::real_to_instance(value:self.getReal(stack_frame_id: param.stack_frame_id));         
else
  error_message = "Error: Did not find a supported data type " + coreDataTypeName + " in attempt to retrieve value in unary operation.";
  USER::logError(msg:error_message,path:body.getPath() );
end if;
  
return GD::string_to_instance(value:"Error");',
	1,
	'',
	368);
INSERT INTO O_TPARM
	VALUES (369,
	367,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (370,
	75,
	'getBoolean',
	'',
	316,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return false;',
	1,
	'',
	366);
INSERT INTO O_TPARM
	VALUES (371,
	370,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (372,
	75,
	'getInteger',
	'',
	298,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return 0;',
	1,
	'',
	370);
INSERT INTO O_TPARM
	VALUES (373,
	372,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (368,
	75,
	'getReal',
	'',
	374,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return 0.0;',
	1,
	'',
	372);
INSERT INTO O_TPARM
	VALUES (375,
	368,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (75,
	70,
	0,
	72,
	84,
	102,
	85,
	376,
	377,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R801');
INSERT INTO O_RATTR
	VALUES (376,
	75,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (376,
	75,
	0,
	'Value_ID',
	'',
	'',
	'Value_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (75,
	70,
	0,
	72,
	73,
	76,
	74,
	378,
	379,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R804.''has operand''');
INSERT INTO O_RATTR
	VALUES (378,
	75,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (378,
	75,
	376,
	'Operand_Value_ID',
	'',
	'Operand_',
	'Value_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (380,
	75);
INSERT INTO O_BATTR
	VALUES (380,
	75);
INSERT INTO O_ATTR
	VALUES (380,
	75,
	378,
	'Operator',
	'Full Name: Unary Mathematical Operator
The character or string representing the operation.',
	'',
	'Operator',
	0,
	322,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	75);
INSERT INTO O_OIDA
	VALUES (376,
	75,
	0,
	'Value_ID');
INSERT INTO O_ID
	VALUES (1,
	75);
INSERT INTO O_ID
	VALUES (2,
	75);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (136,
	'Transient Var',
	818,
	'V_TRN',
	'A variable that is created within a block of an action.
It has visibility equal to the scope of the block. Once
execution has passed out of the block in which the
transient is first assigned a value, the variable no longer
exists.',
	27);
INSERT INTO O_TFR
	VALUES (381,
	136,
	'getDimensionsCnt',
	'',
	298,
	1,
	'select many dims related by self->S_DIM[R844];
dimensions = cardinality dims;
return dimensions;
',
	1,
	'',
	382);
INSERT INTO O_TFR
	VALUES (383,
	136,
	'resizeDimensions',
	'',
	19,
	1,
	'// If the number of dimensions has increased then add dimensions
while (param.numDimensions > self.getDimensionsCnt())
  create object instance dim of S_DIM;
  dim.dimensionCount = self.getDimensionsCnt();
  relate dim to self across R844;
end while;

// If the number of dimensions has decreased then remove dimensions
while (param.numDimensions < self.getDimensionsCnt())
  select any dim related by self->S_DIM[R844] where (selected.dimensionCount == (self.getDimensionsCnt()-1));
  unrelate dim from self across R844;
  delete object instance dim;
end while;

// Update the specific dimension that was passed-in if its elementCount has 
// changed.
if (param.numDimensions > 0) 
  select any dim related by self->S_DIM[R844] where (selected.dimensionCount == param.dimension);
  if (dim.elementCount != param.elementCount)
    dim.elementCount = param.elementCount;
  end if;
end if;
',
	1,
	'',
	384);
INSERT INTO O_TPARM
	VALUES (385,
	383,
	'numDimensions',
	298,
	0,
	'',
	386,
	'');
INSERT INTO O_TPARM
	VALUES (387,
	383,
	'dimension',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (386,
	383,
	'elementCount',
	298,
	0,
	'',
	387,
	'');
INSERT INTO O_TFR
	VALUES (384,
	136,
	'isReferringToDefaultDataType',
	'',
	316,
	1,
	'select one dt related by self->S_DT[R821];
elementType = Util::getSimpleClassName(element:self.convertToInstance());
if(dt.Name == S_DT::getDefaultDataTypeName(elementType:elementType))
  return true;
end if;
return false;',
	1,
	'',
	381);
INSERT INTO O_TFR
	VALUES (382,
	136,
	'convertToInstance',
	'Translate:native',
	317,
	1,
	'return this;',
	0,
	'',
	388);
INSERT INTO O_TFR
	VALUES (388,
	136,
	'canReferToDataType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one body related by self->V_VAR[R814]->ACT_BLK[R823]->ACT_ACT[R601];
isInGenericPackage = body.associateWithContainer();
if isInGenericPackage
  select one dt related by self->S_DT[R821];
  if (not_empty dt)
    select one containingElem related by body->ACT_BIE[R640]->PE_PE[R640];
    return containingElem.canReferToDataType(dtID:dt.DT_ID, dtName:dt.Name);
  end if;
  return false;
else
  select one dt related by self->S_DT[R821];
  if(not_empty dt)
    select one dtPkg related by dt->S_DIP[R39]->S_DPK[R39];
    body.associateWithOwningComponent();
    select one component related by body->ACT_BIC[R694]->C_C[R694];
    if(not_empty component)
      select one reqSig related by body->ACT_RSB[R698];
      select one reqOp related by body->ACT_ROB[R698];
      select one proSig related by body->ACT_PSB[R698];
      select one proOp related by body->ACT_POB[R698];
      // if any of the following is not empty
      // then the dt must live at the system level
      if(not_empty reqSig)
        if(dtPkg.isDomainLevel())
          return false;
        else
          return true;
        end if;  
      elif(not_empty reqOp)
        select one dtPkg related by dt->S_DIP[R39]->S_DPK[R39];
        if(dtPkg.isDomainLevel())
          return false;
        else
          return true;
        end if;    
      elif(not_empty proSig)
        select one dtPkg related by dt->S_DIP[R39]->S_DPK[R39];
        if(dtPkg.isDomainLevel())
          return false;
        else
          return true;
        end if;  
      elif(not_empty proOp)
        select one dtPkg related by dt->S_DIP[R39]->S_DPK[R39];
        if(dtPkg.isDomainLevel())
          return false;
        else
          return true;
        end if;
      else
        select any domain from instances of S_DOM;
        if(not dtPkg.isDomainLevel())
          return true;
        else
          select one dtDomain related by dt->S_DOM[R14];
          if(dtDomain == domain)
            return true;
          end if;
        end if;
      end if;
    else
      select any domain from instances of S_DOM;
      if(dtPkg.isDomainLevel())
        select one dtDomain related by dt->S_DOM[R14];
        if(domain == dtDomain)
          return true;
        end if;
      else
        return true;
      end if;
    end if;
  end if;
  return false;
end if;',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (136,
	129,
	0,
	131,
	128,
	137,
	130,
	258,
	389,
	0,
	0,
	'',
	'Variable',
	'Var_ID',
	'R814');
INSERT INTO O_RATTR
	VALUES (258,
	136,
	131,
	129,
	1,
	'Var_ID');
INSERT INTO O_ATTR
	VALUES (258,
	136,
	0,
	'Var_ID',
	'

',
	'',
	'Var_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (390,
	136);
INSERT INTO O_BATTR
	VALUES (390,
	136);
INSERT INTO O_ATTR
	VALUES (390,
	136,
	391,
	'Dimensions',
	'This attribute is not used and will always be empty.
This attribute was deprecated when fixed-length
arrays were introduced.  It was left in-place simply for 
consistency/orthagonality with the other places in the meta-model that have 
dimensions.  All other places in the Meta-model do use this field.  It is 
used for user-entry of the the dimension string.  V_TRN.Dimensions is different 
because the user never enters a dimension string for a transient.  A transient 
gets its dimensions based on the rvalue that it is assigned from.',
	'',
	'Dimensions',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (136,
	32,
	0,
	156,
	158,
	160,
	159,
	391,
	392,
	0,
	0,
	'',
	'Data Type',
	'DT_ID',
	'R821');
INSERT INTO O_RATTR
	VALUES (391,
	136,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (391,
	136,
	258,
	'DT_ID',
	'',
	'',
	'Element_ID',
	2,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	136);
INSERT INTO O_OIDA
	VALUES (258,
	136,
	0,
	'Var_ID');
INSERT INTO O_ID
	VALUES (1,
	136);
INSERT INTO O_ID
	VALUES (2,
	136);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (109,
	'Transient Value Reference',
	805,
	'V_TVL',
	'This class represents a value held in a local variable being used on the right hand side of an assignment or an expression.',
	27);
INSERT INTO O_TFR
	VALUES (393,
	109,
	'getValue',
	'',
	317,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return GD::NULL_INSTANCE();',
	1,
	'',
	394);
INSERT INTO O_TPARM
	VALUES (395,
	393,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (396,
	109,
	'setValue',
	'Attempts to find the Local Value created for the transient reference and
assigns the passed in value to it.',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	393);
INSERT INTO O_TPARM
	VALUES (397,
	396,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (398,
	396,
	'value',
	317,
	0,
	'',
	397,
	'');
INSERT INTO O_TPARM
	VALUES (399,
	396,
	'member_id',
	296,
	0,
	'',
	398,
	'');
INSERT INTO O_TFR
	VALUES (394,
	109,
	'getRuntimeValue',
	'',
	296,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return GD::NULL_UNIQUE_ID();',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (400,
	394,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (109,
	70,
	0,
	72,
	84,
	110,
	85,
	401,
	402,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R801');
INSERT INTO O_RATTR
	VALUES (401,
	109,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (401,
	109,
	0,
	'Value_ID',
	'',
	'',
	'Value_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (109,
	129,
	0,
	131,
	138,
	140,
	139,
	403,
	404,
	0,
	0,
	'',
	'Variable',
	'Var_ID',
	'R805.''references''');
INSERT INTO O_RATTR
	VALUES (403,
	109,
	131,
	129,
	1,
	'Var_ID');
INSERT INTO O_ATTR
	VALUES (403,
	109,
	401,
	'Var_ID',
	'

',
	'',
	'Var_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	109);
INSERT INTO O_OIDA
	VALUES (401,
	109,
	0,
	'Value_ID');
INSERT INTO O_ID
	VALUES (1,
	109);
INSERT INTO O_ID
	VALUES (2,
	109);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (126,
	'Symbolic Constant Value',
	831,
	'V_SCV',
	'',
	27);
INSERT INTO O_TFR
	VALUES (405,
	126,
	'dispose',
	'',
	19,
	1,
	'select one syc related by self->CNST_SYC[R850];
if ( not_empty syc )
  unrelate self from syc across R850;
end if;

delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (126,
	70,
	0,
	72,
	84,
	127,
	85,
	406,
	407,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R801');
INSERT INTO O_RATTR
	VALUES (406,
	126,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (406,
	126,
	0,
	'Value_ID',
	'',
	'',
	'Value_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (126,
	66,
	0,
	290,
	287,
	288,
	289,
	408,
	409,
	0,
	0,
	'',
	'Symbolic Constant',
	'Const_ID',
	'R850');
INSERT INTO O_RATTR
	VALUES (408,
	126,
	290,
	66,
	1,
	'Const_ID');
INSERT INTO O_ATTR
	VALUES (408,
	126,
	406,
	'Const_ID',
	'',
	'',
	'Const_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (126,
	66,
	0,
	291,
	287,
	288,
	289,
	410,
	411,
	0,
	0,
	'',
	'Symbolic Constant',
	'DT_ID',
	'R850');
INSERT INTO O_RATTR
	VALUES (410,
	126,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (410,
	126,
	408,
	'DT_ID',
	'',
	'',
	'DT_ID',
	2,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	126);
INSERT INTO O_OIDA
	VALUES (406,
	126,
	0,
	'Value_ID');
INSERT INTO O_ID
	VALUES (1,
	126);
INSERT INTO O_ID
	VALUES (2,
	126);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (90,
	'Selected Reference',
	820,
	'V_SLR',
	'Similar to an attribute value but the instance in this case is the ''selected''
variable of a where clause.',
	27);
INSERT INTO O_TFR
	VALUES (412,
	90,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'select one attr related by self->O_ATTR[R812];
if ( not_empty attr )
  unrelate self from attr across R812;
end if;

select one trv related by self->V_TRV[R825];
if ( not_empty trv )
  unrelate self from trv across R825;
  select one val related by trv->V_VAL[R801];
  val.dispose();
end if;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (413,
	90,
	'getValue',
	'Returns a value of a Selected Reference',
	317,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return GD::NULL_INSTANCE();',
	1,
	'',
	412);
INSERT INTO O_TPARM
	VALUES (414,
	413,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (90,
	70,
	0,
	72,
	84,
	91,
	85,
	415,
	416,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R801');
INSERT INTO O_RATTR
	VALUES (415,
	90,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (415,
	90,
	0,
	'Value_ID',
	'',
	'',
	'Value_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (90,
	103,
	0,
	177,
	174,
	175,
	176,
	417,
	418,
	0,
	0,
	'',
	'Operation Value',
	'Value_ID',
	'R825.''value''');
INSERT INTO O_RATTR
	VALUES (417,
	90,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (417,
	90,
	419,
	'Op_Value_ID',
	'

',
	'Op_',
	'Value_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (90,
	37,
	0,
	168,
	225,
	226,
	227,
	419,
	420,
	0,
	0,
	'',
	'Attribute',
	'Attr_ID',
	'R812.''member''');
INSERT INTO O_RATTR
	VALUES (419,
	90,
	168,
	37,
	1,
	'Attr_ID');
INSERT INTO O_ATTR
	VALUES (419,
	90,
	421,
	'Attr_ID',
	'',
	'',
	'Attr_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (90,
	37,
	0,
	169,
	225,
	226,
	227,
	421,
	422,
	0,
	0,
	'',
	'Attribute',
	'Obj_ID',
	'R812.''member''');
INSERT INTO O_RATTR
	VALUES (421,
	90,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (421,
	90,
	415,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	90);
INSERT INTO O_OIDA
	VALUES (415,
	90,
	0,
	'Value_ID');
INSERT INTO O_ID
	VALUES (1,
	90);
INSERT INTO O_ID
	VALUES (2,
	90);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (88,
	'Parameter Value',
	821,
	'V_PVL',
	'This class represents the value of a parameter.',
	27);
INSERT INTO O_TFR
	VALUES (423,
	88,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'select one bparm related by self->S_BPARM[R831];
if not_empty bparm
  unrelate self from bparm across R831;
end if;
select one sparm related by self->S_SPARM[R832];
if not_empty sparm
  unrelate self from sparm across R832;
end if;
select one tparm related by self->O_TPARM[R833];
if not_empty tparm
  unrelate self from tparm across R833;
end if;
select one pparm related by self->C_PP[R843];
if not_empty pparm
  unrelate self from pparm across R843;
end if;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (424,
	88,
	'getValue',
	'Returns a value of a Parameter Value.',
	317,
	1,
	'// Value: Parameter Value.getValue()

select one function_parameter related by self->S_SPARM[R832];
select one operation_parameter related by self->O_TPARM[R833];
select one bridge_parameter related by self->S_BPARM[R831];
select one property_parameter related by self->C_PP[R843];

if (not_empty function_parameter)
  return function_parameter.getValue(stack_frame_id: param.stack_frame_id);     
elif (not_empty operation_parameter)
  return operation_parameter.getValue(stack_frame_id: param.stack_frame_id);
elif (not_empty bridge_parameter)
  return bridge_parameter.getValue(stack_frame_id: param.stack_frame_id);
elif(not_empty property_parameter)
  return property_parameter.getValue(stack_frame_id: param.stack_frame_id);
else
select one value related by self->V_VAL[R801];
select one block related by value->ACT_BLK[R826];
select one body related by block->ACT_ACT[R601];
  pathMsg = "<No Path Available - Empty instance>";
    if (not_empty body)
      pathMsg = body.getPath();
    end if;
	USER::logError(msg:"Error in Parameter Value.getValue: Did not find a local "+ "value.",path:pathMsg);
end if;
return GD::string_to_instance(value:"Error");',
	1,
	'',
	425);
INSERT INTO O_TPARM
	VALUES (426,
	424,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (427,
	88,
	'setValue',
	'Attempts to find the Local Value created for the parameter and assigns the
passed in value to it.',
	19,
	1,
	'// Value: Parameter Value.setValue()
select one body related by self->V_VAL[R801]->ACT_BLK[R826]->ACT_ACT[R601];
select one function_parameter related by self->S_SPARM[R832];
select one operation_parameter related by self->O_TPARM[R833];
select one bridge_parameter related by self->S_BPARM[R831];
select one property_parameter related by self->C_PP[R843];
if (not_empty function_parameter)
  function_parameter.setValue(stack_frame_id: param.stack_frame_id,
  value: param.value, member_id:param.member_id);     
elif (not_empty operation_parameter)
  operation_parameter.setValue(stack_frame_id: param.stack_frame_id,
  value: param.value, member_id:param.member_id);     
elif (not_empty bridge_parameter)
  bridge_parameter.setValue(stack_frame_id: param.stack_frame_id,
  value: param.value, member_id:param.member_id);     
elif(not_empty property_parameter)
  property_parameter.setValue(stack_frame_id: param.stack_frame_id,
  value: param.value, member_id:param.member_id);
else
  pathMsg = "<No Path Available - Empty instance>";
    if (not_empty body)
      pathMsg = body.getPath();
    end if;
	USER::logError(msg:"Error in Parameter Value.setValue:" +
                                                " Did not find a local value.",path:pathMsg);
end if;',
	1,
	'',
	424);
INSERT INTO O_TPARM
	VALUES (428,
	427,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (429,
	427,
	'value',
	317,
	0,
	'',
	428,
	'');
INSERT INTO O_TPARM
	VALUES (430,
	427,
	'member_id',
	296,
	0,
	'',
	429,
	'');
INSERT INTO O_TFR
	VALUES (425,
	88,
	'getRuntimeValue',
	'',
	296,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return GD::NULL_UNIQUE_ID();',
	1,
	'',
	423);
INSERT INTO O_TPARM
	VALUES (431,
	425,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (88,
	70,
	0,
	72,
	84,
	89,
	85,
	432,
	433,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R801');
INSERT INTO O_RATTR
	VALUES (432,
	88,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (432,
	88,
	0,
	'Value_ID',
	'',
	'',
	'Value_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (88,
	46,
	0,
	211,
	209,
	212,
	210,
	434,
	435,
	0,
	0,
	'',
	'Bridge Parameter',
	'BParm_ID',
	'R831.''is a value of''');
INSERT INTO O_RATTR
	VALUES (434,
	88,
	211,
	46,
	1,
	'BParm_ID');
INSERT INTO O_ATTR
	VALUES (434,
	88,
	432,
	'BParm_ID',
	'',
	'',
	'BParm_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (88,
	48,
	0,
	215,
	213,
	216,
	214,
	436,
	437,
	0,
	0,
	'',
	'Function Parameter',
	'SParm_ID',
	'R832.''is a value of''');
INSERT INTO O_RATTR
	VALUES (436,
	88,
	215,
	48,
	1,
	'SParm_ID');
INSERT INTO O_ATTR
	VALUES (436,
	88,
	434,
	'SParm_ID',
	'',
	'',
	'SParm_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (88,
	50,
	0,
	219,
	217,
	220,
	218,
	438,
	439,
	0,
	0,
	'',
	'Operation Parameter',
	'TParm_ID',
	'R833.''is a value of''');
INSERT INTO O_RATTR
	VALUES (438,
	88,
	219,
	50,
	1,
	'TParm_ID');
INSERT INTO O_ATTR
	VALUES (438,
	88,
	436,
	'TParm_ID',
	'',
	'',
	'TParm_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (88,
	57,
	0,
	254,
	252,
	255,
	253,
	440,
	441,
	0,
	0,
	'',
	'Property Parameter',
	'PP_Id',
	'R843.''is a value of''');
INSERT INTO O_RATTR
	VALUES (440,
	88,
	254,
	57,
	1,
	'PP_Id');
INSERT INTO O_ATTR
	VALUES (440,
	88,
	438,
	'PP_Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	88);
INSERT INTO O_OIDA
	VALUES (432,
	88,
	0,
	'Value_ID');
INSERT INTO O_ID
	VALUES (1,
	88);
INSERT INTO O_ID
	VALUES (2,
	88);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (103,
	'Operation Value',
	808,
	'V_TRV',
	'This class represents the value returned by an operation invocation.
--------------------------------------------------------------------------------
Bridge:ALS',
	27);
INSERT INTO O_TFR
	VALUES (442,
	103,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'select one tfr related by self->O_TFR[R829];
if ( not_empty tfr )
  unrelate self from tfr across R829;
end if;

select one var related by self->V_VAR[R830];
if ( not_empty var )
  unrelate self from var across R830;
end if;

select many parm_set related by self->V_PAR[R811];
for each parm in parm_set 
  unrelate self from parm across R811;
  parm.dispose();
end for;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (443,
	103,
	'getValue',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	442);
INSERT INTO O_TPARM
	VALUES (444,
	443,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (445,
	103,
	'setupParameterValues',
	'Create a new local value for each parameter within the stack frame of the operation we are going to execute.',
	316,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return false;',
	1,
	'',
	443);
INSERT INTO O_TPARM
	VALUES (446,
	445,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (103,
	70,
	0,
	72,
	84,
	104,
	85,
	177,
	447,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R801');
INSERT INTO O_RATTR
	VALUES (177,
	103,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (177,
	103,
	0,
	'Value_ID',
	'',
	'',
	'Value_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (103,
	43,
	0,
	201,
	198,
	199,
	200,
	448,
	449,
	0,
	0,
	'',
	'Operation',
	'Tfr_ID',
	'R829');
INSERT INTO O_RATTR
	VALUES (448,
	103,
	201,
	43,
	1,
	'Tfr_ID');
INSERT INTO O_ATTR
	VALUES (448,
	103,
	177,
	'Tfr_ID',
	'
',
	'',
	'Tfr_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (103,
	129,
	0,
	131,
	206,
	207,
	208,
	450,
	451,
	0,
	0,
	'',
	'Variable',
	'Var_ID',
	'R830');
INSERT INTO O_RATTR
	VALUES (450,
	103,
	131,
	129,
	1,
	'Var_ID');
INSERT INTO O_ATTR
	VALUES (450,
	103,
	448,
	'Var_ID',
	'

',
	'',
	'Var_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (452,
	103);
INSERT INTO O_BATTR
	VALUES (452,
	103);
INSERT INTO O_ATTR
	VALUES (452,
	103,
	450,
	'ParmListOK',
	'This attribute is true if there were no errors in parsing the operation invocation''s parameter list.
---------------------------------------------------------------------
Bridge:ALS',
	'',
	'ParmListOK',
	0,
	316,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (453,
	103);
INSERT INTO O_BATTR
	VALUES (453,
	103);
INSERT INTO O_ATTR
	VALUES (453,
	103,
	452,
	'modelClassKeyLettersLineNumber',
	'',
	'',
	'modelClassKeyLettersLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (454,
	103);
INSERT INTO O_BATTR
	VALUES (454,
	103);
INSERT INTO O_ATTR
	VALUES (454,
	103,
	453,
	'modelClassKeyLettersColumn',
	'',
	'',
	'modelClassKeyLettersColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	103);
INSERT INTO O_OIDA
	VALUES (177,
	103,
	0,
	'Value_ID');
INSERT INTO O_ID
	VALUES (1,
	103);
INSERT INTO O_ID
	VALUES (2,
	103);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (124,
	'Message Value',
	829,
	'V_MSV',
	'',
	27);
INSERT INTO O_TFR
	VALUES (455,
	124,
	'dispose',
	'',
	19,
	1,
	'// Message Value.dispose()
select one proExProp related by self->SPR_PEP[R841];
if not_empty proExProp
  unrelate self from proExProp across R841;
end if;
select one reqExProp related by self->SPR_REP[R845];
if(not_empty reqExProp)
  unrelate self from reqExProp across R845;
end if;
select many parm_set related by self->V_PAR[R842];
for each parm in parm_set 
  unrelate self from parm across R842;
  parm.dispose();
end for;
select one targetVal related by self->V_VAL[R851];
if not_empty targetVal
  unrelate self from targetVal across R851;
  targetVal.dispose();
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (456,
	124,
	'getValue',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	455);
INSERT INTO O_TPARM
	VALUES (457,
	456,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (458,
	124,
	'setupParameterValues',
	'',
	316,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return false;',
	1,
	'',
	456);
INSERT INTO O_TPARM
	VALUES (459,
	458,
	'stack_frame_id',
	296,
	0,
	'',
	460,
	'');
INSERT INTO O_TPARM
	VALUES (461,
	458,
	'executeRemotely',
	316,
	0,
	'',
	459,
	'');
INSERT INTO O_TPARM
	VALUES (462,
	458,
	'channel_id',
	296,
	0,
	'',
	461,
	'');
INSERT INTO O_TPARM
	VALUES (460,
	458,
	'ee_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (124,
	70,
	0,
	72,
	84,
	125,
	85,
	250,
	463,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R801');
INSERT INTO O_RATTR
	VALUES (250,
	124,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (250,
	124,
	0,
	'Value_ID',
	'',
	'',
	'Value_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (464,
	124);
INSERT INTO O_BATTR
	VALUES (464,
	124);
INSERT INTO O_ATTR
	VALUES (464,
	124,
	465,
	'ParmListOK',
	'',
	'',
	'ParmListOK',
	0,
	316,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (466,
	124);
INSERT INTO O_BATTR
	VALUES (466,
	124);
INSERT INTO O_ATTR
	VALUES (466,
	124,
	464,
	'ownerNameLineNumber',
	'',
	'',
	'ownerNameLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (467,
	124);
INSERT INTO O_BATTR
	VALUES (467,
	124);
INSERT INTO O_ATTR
	VALUES (467,
	124,
	466,
	'ownerNameColumn',
	'',
	'',
	'ownerNameColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_REF
	VALUES (124,
	63,
	0,
	267,
	264,
	265,
	266,
	465,
	468,
	0,
	0,
	'',
	'Required Executable Property',
	'Id',
	'R845');
INSERT INTO O_RATTR
	VALUES (465,
	124,
	267,
	63,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (465,
	124,
	469,
	'REP_Id',
	'',
	'REP_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (124,
	61,
	0,
	263,
	260,
	261,
	262,
	469,
	470,
	0,
	0,
	'',
	'Provided Executable Property',
	'Id',
	'R841');
INSERT INTO O_RATTR
	VALUES (469,
	124,
	263,
	61,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (469,
	124,
	250,
	'PEP_Id',
	'',
	'PEP_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (124,
	70,
	0,
	72,
	292,
	293,
	294,
	471,
	472,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R851.''has target''');
INSERT INTO O_RATTR
	VALUES (471,
	124,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (471,
	124,
	467,
	'Target_Value_ID',
	'',
	'Target_',
	'Value_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	124);
INSERT INTO O_OIDA
	VALUES (250,
	124,
	0,
	'Value_ID');
INSERT INTO O_ID
	VALUES (1,
	124);
INSERT INTO O_ID
	VALUES (2,
	124);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (118,
	'Member Value Reference',
	825,
	'V_MVL',
	'',
	27);
INSERT INTO O_TFR
	VALUES (473,
	118,
	'dispose',
	'',
	19,
	1,
	'select one member related by self->S_MBR[R836];
if (not_empty member)
  unrelate self from member across R836;
end if;

select one value related by self->V_VAL[R837];
if (not_empty value)
  unrelate self from value across R837;
end if;

delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (474,
	118,
	'getValue',
	'',
	317,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return GD::NULL_INSTANCE();',
	1,
	'',
	475);
INSERT INTO O_TPARM
	VALUES (476,
	474,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (477,
	118,
	'setValue',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	474);
INSERT INTO O_TPARM
	VALUES (478,
	477,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (479,
	477,
	'value',
	317,
	0,
	'',
	478,
	'');
INSERT INTO O_TPARM
	VALUES (480,
	477,
	'member_id',
	296,
	0,
	'',
	479,
	'');
INSERT INTO O_TFR
	VALUES (475,
	118,
	'getRuntimeValue',
	'',
	296,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return GD::NULL_UNIQUE_ID();',
	1,
	'',
	473);
INSERT INTO O_TPARM
	VALUES (481,
	475,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (118,
	70,
	0,
	72,
	84,
	119,
	85,
	482,
	483,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R801');
INSERT INTO O_RATTR
	VALUES (482,
	118,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (482,
	118,
	0,
	'Value_ID',
	'',
	'',
	'Value_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (118,
	70,
	0,
	72,
	233,
	234,
	235,
	484,
	485,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R837');
INSERT INTO O_RATTR
	VALUES (484,
	118,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (484,
	118,
	482,
	'Root_Value_ID',
	'',
	'Root_',
	'Value_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (118,
	55,
	0,
	231,
	228,
	229,
	230,
	486,
	487,
	0,
	0,
	'',
	'Structure Member',
	'Member_ID',
	'R836.''is value of''');
INSERT INTO O_RATTR
	VALUES (486,
	118,
	231,
	55,
	1,
	'Member_ID');
INSERT INTO O_ATTR
	VALUES (486,
	118,
	484,
	'Member_ID',
	'',
	'',
	'Member_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (118,
	55,
	0,
	232,
	228,
	229,
	230,
	488,
	489,
	0,
	0,
	'',
	'Structure Member',
	'Parent_DT_DT_ID',
	'R836.''is value of''');
INSERT INTO O_RATTR
	VALUES (488,
	118,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (488,
	118,
	486,
	'DT_DT_ID',
	'',
	'DT_',
	'Parent_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	118);
INSERT INTO O_OIDA
	VALUES (482,
	118,
	0,
	'Value_ID');
INSERT INTO O_ID
	VALUES (1,
	118);
INSERT INTO O_ID
	VALUES (2,
	118);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (100,
	'Literal String',
	810,
	'V_LST',
	'This class represents a literal string, may take any sequence of characters as a value.',
	27);
INSERT INTO O_TFR
	VALUES (490,
	100,
	'getString',
	'',
	322,
	1,
	'return self.Value;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (491,
	100,
	'removeQuotes',
	'Translate:native',
	322,
	1,
	'//  Value:Literal String.removeQuotes(s: string)

String out = p_S;

//  Remove the beginning and ending quotes
if (out.startsWith("\"")) {
	out = out.substring(1);
}
if (out.endsWith("\"")) {
	out = out.substring(0, out.length() - 1);
}

//  Now replace all double double quotes in the string with single double quotes
out = out.replaceAll("\"\"", "\"");

return out;

',
	0,
	'',
	490);
INSERT INTO O_TPARM
	VALUES (492,
	491,
	's',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (100,
	70,
	0,
	72,
	84,
	101,
	85,
	493,
	494,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R801');
INSERT INTO O_RATTR
	VALUES (493,
	100,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (493,
	100,
	0,
	'Value_ID',
	'',
	'',
	'Value_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (495,
	100);
INSERT INTO O_BATTR
	VALUES (495,
	100);
INSERT INTO O_ATTR
	VALUES (495,
	100,
	493,
	'Value',
	'Full Name: Literal String Value
The actual value of the literal.',
	'',
	'Value',
	0,
	322,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	100);
INSERT INTO O_OIDA
	VALUES (493,
	100,
	0,
	'Value_ID');
INSERT INTO O_ID
	VALUES (1,
	100);
INSERT INTO O_ID
	VALUES (2,
	100);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (111,
	'Literal Real',
	804,
	'V_LRL',
	'This class represents a literal real, may be a sequence of numeric characters with a decimal point appearing once somewhere in the sequence.',
	27);
INSERT INTO O_TFR
	VALUES (496,
	111,
	'getReal',
	'',
	374,
	1,
	'return GD::string_to_real(value:self.Value);',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (111,
	70,
	0,
	72,
	84,
	112,
	85,
	497,
	498,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R801');
INSERT INTO O_RATTR
	VALUES (497,
	111,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (497,
	111,
	0,
	'Value_ID',
	'',
	'',
	'Value_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (499,
	111);
INSERT INTO O_BATTR
	VALUES (499,
	111);
INSERT INTO O_ATTR
	VALUES (499,
	111,
	497,
	'Value',
	'Full Name: Literal Real Value
The actual value of the literal.',
	'',
	'Value',
	0,
	322,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	111);
INSERT INTO O_OIDA
	VALUES (497,
	111,
	0,
	'Value_ID');
INSERT INTO O_ID
	VALUES (1,
	111);
INSERT INTO O_ID
	VALUES (2,
	111);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (98,
	'Literal Integer',
	811,
	'V_LIN',
	'This class represents a literal integer, represented by a sequence of numeric characters.',
	27);
INSERT INTO O_TFR
	VALUES (500,
	98,
	'getInteger',
	'',
	298,
	1,
	'return GD::string_to_int(value:self.Value);',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (98,
	70,
	0,
	72,
	84,
	99,
	85,
	501,
	502,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R801');
INSERT INTO O_RATTR
	VALUES (501,
	98,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (501,
	98,
	0,
	'Value_ID',
	'',
	'',
	'Value_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (503,
	98);
INSERT INTO O_BATTR
	VALUES (503,
	98);
INSERT INTO O_ATTR
	VALUES (503,
	98,
	501,
	'Value',
	'Full Name: Literal Integer Value
The actual value of the literal.',
	'',
	'Value',
	0,
	322,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	98);
INSERT INTO O_OIDA
	VALUES (501,
	98,
	0,
	'Value_ID');
INSERT INTO O_ID
	VALUES (1,
	98);
INSERT INTO O_ID
	VALUES (2,
	98);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (116,
	'Literal Enumerator',
	823,
	'V_LEN',
	'This class represents a literal enumerated value.',
	27);
INSERT INTO O_TFR
	VALUES (504,
	116,
	'getValue',
	'',
	317,
	1,
	'//Literal Enumerator.getValue()
select one enum related by self->S_ENUM[R824];
select one edt related by enum->S_EDT[R27]->S_DT[R17];
return GD::string_to_instance(value:edt.Name + "::" + enum.Name);',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (116,
	70,
	0,
	72,
	84,
	117,
	85,
	505,
	506,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R801');
INSERT INTO O_RATTR
	VALUES (505,
	116,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (505,
	116,
	0,
	'Value_ID',
	'

',
	'',
	'Value_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (116,
	39,
	0,
	172,
	170,
	173,
	171,
	507,
	508,
	0,
	0,
	'',
	'Enumerator',
	'Enum_ID',
	'R824');
INSERT INTO O_RATTR
	VALUES (507,
	116,
	172,
	39,
	1,
	'Enum_ID');
INSERT INTO O_ATTR
	VALUES (507,
	116,
	505,
	'Enum_ID',
	'

',
	'',
	'Enum_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (509,
	116);
INSERT INTO O_BATTR
	VALUES (509,
	116);
INSERT INTO O_ATTR
	VALUES (509,
	116,
	507,
	'dataTypeNameLineNumber',
	'',
	'',
	'dataTypeNameLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (510,
	116);
INSERT INTO O_BATTR
	VALUES (510,
	116);
INSERT INTO O_ATTR
	VALUES (510,
	116,
	509,
	'dataTypeNameColumn',
	'',
	'',
	'dataTypeNameColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	116);
INSERT INTO O_OIDA
	VALUES (505,
	116,
	0,
	'Value_ID');
INSERT INTO O_ID
	VALUES (1,
	116);
INSERT INTO O_ID
	VALUES (2,
	116);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (113,
	'Literal Boolean',
	803,
	'V_LBO',
	'This class represents a literal boolean, may take the values true or false only.',
	27);
INSERT INTO O_TFR
	VALUES (511,
	113,
	'getBoolean',
	'',
	316,
	1,
	'if self.Value == "TRUE"
  return true;
else
  return false;
end if;',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (113,
	70,
	0,
	72,
	84,
	114,
	85,
	512,
	513,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R801');
INSERT INTO O_RATTR
	VALUES (512,
	113,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (512,
	113,
	0,
	'Value_ID',
	'',
	'',
	'Value_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (514,
	113);
INSERT INTO O_BATTR
	VALUES (514,
	113);
INSERT INTO O_ATTR
	VALUES (514,
	113,
	512,
	'Value',
	'Full Name: Literal Boolean Value
The actual value of the literal.',
	'',
	'Value',
	0,
	322,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	113);
INSERT INTO O_OIDA
	VALUES (512,
	113,
	0,
	'Value_ID');
INSERT INTO O_ID
	VALUES (1,
	113);
INSERT INTO O_ID
	VALUES (2,
	113);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (105,
	'Instance Set Reference',
	807,
	'V_ISR',
	'This class represents a set of instance references, the result of a select many statement.',
	27);
INSERT INTO O_TFR
	VALUES (515,
	105,
	'getRuntimeValue',
	'',
	296,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return GD::NULL_UNIQUE_ID(); ',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (516,
	515,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (105,
	70,
	0,
	72,
	84,
	106,
	85,
	517,
	518,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R801');
INSERT INTO O_RATTR
	VALUES (517,
	105,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (517,
	105,
	0,
	'Value_ID',
	'',
	'',
	'Value_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (105,
	129,
	0,
	131,
	144,
	146,
	145,
	519,
	520,
	0,
	0,
	'',
	'Variable',
	'Var_ID',
	'R809.''refers to''');
INSERT INTO O_RATTR
	VALUES (519,
	105,
	131,
	129,
	1,
	'Var_ID');
INSERT INTO O_ATTR
	VALUES (519,
	105,
	517,
	'Var_ID',
	'

',
	'',
	'Var_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	105);
INSERT INTO O_OIDA
	VALUES (517,
	105,
	0,
	'Value_ID');
INSERT INTO O_ID
	VALUES (1,
	105);
INSERT INTO O_ID
	VALUES (2,
	105);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (134,
	'Instance Set',
	817,
	'V_INS',
	'This class represents a set of instances.',
	27);
INSERT INTO O_TFR
	VALUES (521,
	134,
	'isEmpty',
	'',
	316,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return true; ',
	1,
	'',
	522);
INSERT INTO O_TPARM
	VALUES (523,
	521,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (522,
	134,
	'getCardinality',
	'',
	298,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return 0; ',
	1,
	'',
	524);
INSERT INTO O_TPARM
	VALUES (525,
	522,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (524,
	134,
	'dispose',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (134,
	129,
	0,
	131,
	128,
	135,
	130,
	526,
	527,
	0,
	0,
	'',
	'Variable',
	'Var_ID',
	'R814');
INSERT INTO O_RATTR
	VALUES (526,
	134,
	131,
	129,
	1,
	'Var_ID');
INSERT INTO O_ATTR
	VALUES (526,
	134,
	0,
	'Var_ID',
	'

',
	'',
	'Var_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (134,
	30,
	0,
	150,
	151,
	152,
	153,
	528,
	529,
	0,
	0,
	'',
	'Model Class',
	'Obj_ID',
	'R819.''refers to''');
INSERT INTO O_RATTR
	VALUES (528,
	134,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (528,
	134,
	526,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	134);
INSERT INTO O_OIDA
	VALUES (526,
	134,
	0,
	'Var_ID');
INSERT INTO O_ID
	VALUES (1,
	134);
INSERT INTO O_ID
	VALUES (2,
	134);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (94,
	'Instance Reference',
	813,
	'V_IRF',
	'This class represents an instance reference, the result of a select one or select any statement.',
	27);
INSERT INTO O_TFR
	VALUES (530,
	94,
	'getRuntimeValue',
	'',
	296,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return GD::NULL_UNIQUE_ID(); ',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (531,
	530,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (532,
	94,
	'setValue',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	530);
INSERT INTO O_TPARM
	VALUES (533,
	532,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (534,
	532,
	'value',
	317,
	0,
	'',
	533,
	'');
INSERT INTO O_TPARM
	VALUES (535,
	532,
	'member_id',
	296,
	0,
	'',
	534,
	'');
INSERT INTO O_REF
	VALUES (94,
	70,
	0,
	72,
	84,
	95,
	85,
	536,
	537,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R801');
INSERT INTO O_RATTR
	VALUES (536,
	94,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (536,
	94,
	0,
	'Value_ID',
	'',
	'',
	'Value_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (94,
	129,
	0,
	131,
	141,
	143,
	142,
	538,
	539,
	0,
	0,
	'',
	'Variable',
	'Var_ID',
	'R808.''refers to''');
INSERT INTO O_RATTR
	VALUES (538,
	94,
	131,
	129,
	1,
	'Var_ID');
INSERT INTO O_ATTR
	VALUES (538,
	94,
	536,
	'Var_ID',
	'

',
	'',
	'Var_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	94);
INSERT INTO O_OIDA
	VALUES (536,
	94,
	0,
	'Value_ID');
INSERT INTO O_ID
	VALUES (1,
	94);
INSERT INTO O_ID
	VALUES (2,
	94);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (132,
	'Instance Handle',
	816,
	'V_INT',
	'This class represents an instance.',
	27);
INSERT INTO O_TFR
	VALUES (540,
	132,
	'isEmpty',
	'',
	316,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return true; ',
	1,
	'',
	541);
INSERT INTO O_TPARM
	VALUES (542,
	540,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (543,
	132,
	'dispose',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (541,
	132,
	'getCardinality',
	'',
	298,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return 0; ',
	1,
	'',
	543);
INSERT INTO O_TPARM
	VALUES (544,
	541,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (132,
	129,
	0,
	131,
	128,
	133,
	130,
	545,
	546,
	0,
	0,
	'',
	'Variable',
	'Var_ID',
	'R814');
INSERT INTO O_RATTR
	VALUES (545,
	132,
	131,
	129,
	1,
	'Var_ID');
INSERT INTO O_ATTR
	VALUES (545,
	132,
	0,
	'Var_ID',
	'

',
	'',
	'Var_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (547,
	132);
INSERT INTO O_BATTR
	VALUES (547,
	132);
INSERT INTO O_ATTR
	VALUES (547,
	132,
	545,
	'IsImplicitInFor',
	'This attribute is true if the inst_ref variable was declared implicitly by a for each statement.
--------------------------------------------------------------------------------
Bridge:ALS',
	'',
	'IsImplicitInFor',
	0,
	316,
	'',
	'');
INSERT INTO O_REF
	VALUES (132,
	30,
	0,
	150,
	147,
	148,
	149,
	548,
	549,
	0,
	0,
	'',
	'Model Class',
	'Obj_ID',
	'R818.''refers to''');
INSERT INTO O_RATTR
	VALUES (548,
	132,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (548,
	132,
	547,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	132);
INSERT INTO O_OIDA
	VALUES (545,
	132,
	0,
	'Var_ID');
INSERT INTO O_ID
	VALUES (1,
	132);
INSERT INTO O_ID
	VALUES (2,
	132);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (86,
	'Function Value',
	822,
	'V_FNV',
	'This class represents the value returned by a function invocation.',
	27);
INSERT INTO O_TFR
	VALUES (550,
	86,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'select one sync related by self->S_SYNC[R827];
if ( not empty sync )
  unrelate self from sync across R827;
end if;

select many parm_set related by self->V_PAR[R817];
for each parm in parm_set 
  unrelate self from parm across R817;
  parm.dispose();
end for;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (551,
	86,
	'getValue',
	'Executes a function and returns a result.',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	550);
INSERT INTO O_TPARM
	VALUES (552,
	551,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (553,
	86,
	'setupParameterValues',
	'Initializes the parameters passing to a function.',
	316,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return false; ',
	1,
	'',
	551);
INSERT INTO O_TPARM
	VALUES (554,
	553,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (86,
	70,
	0,
	72,
	84,
	87,
	85,
	183,
	555,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R801');
INSERT INTO O_RATTR
	VALUES (183,
	86,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (183,
	86,
	0,
	'Value_ID',
	'',
	'',
	'Value_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (556,
	86);
INSERT INTO O_BATTR
	VALUES (556,
	86);
INSERT INTO O_ATTR
	VALUES (556,
	86,
	557,
	'ParmListOK',
	'This attribute is true if there were no errors in parsing the function invocation''s parameter list.
--------------------------------------------------------------------------------
Bridge:ALS',
	'',
	'ParmListOK',
	0,
	316,
	'',
	'');
INSERT INTO O_REF
	VALUES (86,
	8,
	0,
	11,
	192,
	193,
	194,
	557,
	558,
	0,
	0,
	'',
	'Function',
	'Sync_ID',
	'R827');
INSERT INTO O_RATTR
	VALUES (557,
	86,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (557,
	86,
	183,
	'Sync_ID',
	'

',
	'',
	'Sync_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	86);
INSERT INTO O_OIDA
	VALUES (183,
	86,
	0,
	'Value_ID');
INSERT INTO O_ID
	VALUES (1,
	86);
INSERT INTO O_ID
	VALUES (2,
	86);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (271,
	'Event Parameter Reference',
	830,
	'V_EPR',
	'',
	27);
INSERT INTO O_TFR
	VALUES (559,
	271,
	'dispose',
	'',
	19,
	1,
	'// Event Parameter Reference.dispose()
select one evtDataVal related by self->V_EDV[R834];
if not_empty evtDataVal
  unrelate self from evtDataVal across R834;
end if;
select one evtdi related by self->SM_EVTDI[R846];
if not_empty evtdi
  unrelate self from evtdi across R846;
end if;
select one propParm related by self->C_PP[R847];
if not_empty propParm
  unrelate self from propParm across R847;
end if;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (271,
	107,
	0,
	270,
	268,
	272,
	269,
	560,
	561,
	0,
	0,
	'',
	'Event Datum Value',
	'Value_ID',
	'R834');
INSERT INTO O_RATTR
	VALUES (560,
	271,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (560,
	271,
	0,
	'Value_ID',
	'',
	'',
	'Value_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (271,
	52,
	0,
	276,
	273,
	274,
	275,
	562,
	563,
	0,
	0,
	'',
	'State Machine Event Data Item',
	'SM_ID',
	'R846');
INSERT INTO O_RATTR
	VALUES (562,
	271,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (562,
	271,
	560,
	'SM_ID',
	'',
	'',
	'SM_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (271,
	52,
	0,
	277,
	273,
	274,
	275,
	566,
	567,
	0,
	0,
	'',
	'State Machine Event Data Item',
	'SMedi_ID',
	'R846');
INSERT INTO O_RATTR
	VALUES (566,
	271,
	277,
	52,
	1,
	'SMedi_ID');
INSERT INTO O_ATTR
	VALUES (566,
	271,
	562,
	'SMedi_ID',
	'',
	'',
	'SMedi_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (271,
	57,
	0,
	254,
	278,
	279,
	280,
	568,
	569,
	0,
	0,
	'',
	'Property Parameter',
	'PP_Id',
	'R847');
INSERT INTO O_RATTR
	VALUES (568,
	271,
	254,
	57,
	1,
	'PP_Id');
INSERT INTO O_ATTR
	VALUES (568,
	271,
	566,
	'PP_Id',
	'',
	'',
	'PP_Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	271);
INSERT INTO O_OIDA
	VALUES (560,
	271,
	0,
	'Value_ID');
INSERT INTO O_OIDA
	VALUES (562,
	271,
	0,
	'SM_ID');
INSERT INTO O_OIDA
	VALUES (566,
	271,
	0,
	'SMedi_ID');
INSERT INTO O_OIDA
	VALUES (568,
	271,
	0,
	'PP_Id');
INSERT INTO O_ID
	VALUES (1,
	271);
INSERT INTO O_ID
	VALUES (2,
	271);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (107,
	'Event Datum Value',
	806,
	'V_EDV',
	'This class represents the value of an event datum.',
	27);
INSERT INTO O_TFR
	VALUES (570,
	107,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'// Event Datum Value.dipose()
select many eprs related by self->V_EPR[R834];
for each epr in eprs
  epr.dispose();
end for;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (571,
	107,
	'getValue',
	'Return value for Event Datum Value',
	317,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return GD::NULL_INSTANCE(); ',
	1,
	'',
	572);
INSERT INTO O_TFR
	VALUES (572,
	107,
	'getRuntimeValue',
	'',
	296,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return GD::NULL_UNIQUE_ID(); ',
	1,
	'',
	570);
INSERT INTO O_TPARM
	VALUES (573,
	572,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (107,
	70,
	0,
	72,
	84,
	108,
	85,
	270,
	574,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R801');
INSERT INTO O_RATTR
	VALUES (270,
	107,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (270,
	107,
	0,
	'Value_ID',
	'',
	'',
	'Value_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	107);
INSERT INTO O_OIDA
	VALUES (270,
	107,
	0,
	'Value_ID');
INSERT INTO O_ID
	VALUES (1,
	107);
INSERT INTO O_ID
	VALUES (2,
	107);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (92,
	'Bridge Value',
	814,
	'V_BRV',
	'This class represents the value returned by a bridge invocation.',
	27);
INSERT INTO O_TFR
	VALUES (575,
	92,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'select one brg related by self->S_BRG[R828];
if ( not empty brg )
  unrelate self from brg across R828;
end if;

select many parm_set related by self->V_PAR[R810];
for each parm in parm_set 
  unrelate self from parm across R810;
  parm.dispose();
end for;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (576,
	92,
	'getValue',
	'Executes its bridge function and returns the result.',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	575);
INSERT INTO O_TPARM
	VALUES (577,
	576,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (578,
	92,
	'setupParameterValues',
	'',
	316,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return false; ',
	1,
	'',
	576);
INSERT INTO O_TPARM
	VALUES (579,
	578,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (580,
	578,
	'target_stack_frame_id',
	296,
	0,
	'',
	579,
	'');
INSERT INTO O_REF
	VALUES (92,
	70,
	0,
	72,
	84,
	93,
	85,
	187,
	581,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R801');
INSERT INTO O_RATTR
	VALUES (187,
	92,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (187,
	92,
	0,
	'Value_ID',
	'',
	'',
	'Value_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (582,
	92);
INSERT INTO O_BATTR
	VALUES (582,
	92);
INSERT INTO O_ATTR
	VALUES (582,
	92,
	583,
	'ParmListOK',
	'This attribute is true if there were no errors in parsing the bridge invocation''s parameter list.
--------------------------------------------------------------------------------
Bridge:ALS',
	'',
	'ParmListOK',
	0,
	316,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (584,
	92);
INSERT INTO O_BATTR
	VALUES (584,
	92);
INSERT INTO O_ATTR
	VALUES (584,
	92,
	582,
	'externalEntityKeyLettersLineNumber',
	'',
	'',
	'externalEntityKeyLettersLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (585,
	92);
INSERT INTO O_BATTR
	VALUES (585,
	92);
INSERT INTO O_ATTR
	VALUES (585,
	92,
	584,
	'externalEntityKeyLettersColumn',
	'',
	'',
	'externalEntityKeyLettersColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_REF
	VALUES (92,
	6,
	0,
	16,
	195,
	196,
	197,
	583,
	586,
	0,
	0,
	'',
	'Bridge',
	'Brg_ID',
	'R828');
INSERT INTO O_RATTR
	VALUES (583,
	92,
	16,
	6,
	1,
	'Brg_ID');
INSERT INTO O_ATTR
	VALUES (583,
	92,
	187,
	'Brg_ID',
	'
',
	'',
	'Brg_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	92);
INSERT INTO O_OIDA
	VALUES (187,
	92,
	0,
	'Value_ID');
INSERT INTO O_ID
	VALUES (1,
	92);
INSERT INTO O_ID
	VALUES (2,
	92);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (79,
	'Binary Operation',
	802,
	'V_BIN',
	'Values are yielded by simple or compound expressions. Compound expressions are made up of nested binary operations. This class represents such as binary operations. The operator attribute contains the string identifier of the operation to be carried out.',
	27);
INSERT INTO O_TFR
	VALUES (587,
	79,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'select one lop related by self->V_VAL[R802];
if ( not_empty lop )
  unrelate lop from self across R802;
  lop.dispose();
end if;
select one rop related by self->V_VAL[R803];
if ( not_empty rop )
  unrelate rop from self across R803;
  rop.dispose();
end if;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (588,
	79,
	'getValue',
	'Performs Binary Operation and returns the value.
',
	317,
	1,
	'//Value: Binary Operation.getValue()
select one body related by self->V_VAL[R801]->ACT_BLK[R826]->ACT_ACT[R601];
select one dt related by self->V_VAL[R801]->S_DT[R820];
coreDataTypeName = dt.getCoreDataTypeName();
if (coreDataTypeName == "boolean")
  return GD::boolean_to_instance(value:self.getBoolean(stack_frame_id: param.stack_frame_id));
elif (coreDataTypeName == "integer")
  return GD::int_to_instance(value:self.getInteger(stack_frame_id: param.stack_frame_id));
elif (coreDataTypeName == "real")
  return GD::real_to_instance(value:self.getReal(stack_frame_id: param.stack_frame_id));
elif (coreDataTypeName == "string")
  return GD::string_to_instance(value:self.getString(stack_frame_id: param.stack_frame_id));
else
  error_message = "Error: Did not find a supported data type " + coreDataTypeName + " in attempt to retrieve value in binary operation.";
  USER::logError(msg:error_message,path:body.getPath());
end if;

return GD::string_to_instance(value:"Error");',
	1,
	'',
	589);
INSERT INTO O_TPARM
	VALUES (590,
	588,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (591,
	79,
	'getBoolean',
	'Performs Binary Operation and returns the boolean value.',
	316,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return false;',
	1,
	'',
	587);
INSERT INTO O_TPARM
	VALUES (592,
	591,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (589,
	79,
	'getString',
	'',
	322,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return "";',
	1,
	'',
	593);
INSERT INTO O_TPARM
	VALUES (594,
	589,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (595,
	79,
	'getInteger',
	'',
	298,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return 0;',
	1,
	'',
	591);
INSERT INTO O_TPARM
	VALUES (596,
	595,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (593,
	79,
	'getReal',
	'',
	374,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return 0.0;',
	1,
	'',
	595);
INSERT INTO O_TPARM
	VALUES (597,
	593,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (598,
	79,
	'compareInstRefSets',
	'Translate:native',
	316,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return false;',
	0,
	'',
	588);
INSERT INTO O_TPARM
	VALUES (599,
	598,
	'rRtVal',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (600,
	598,
	'lRtVal',
	296,
	0,
	'',
	599,
	'');
INSERT INTO O_REF
	VALUES (79,
	70,
	0,
	72,
	84,
	115,
	85,
	601,
	602,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R801');
INSERT INTO O_RATTR
	VALUES (601,
	79,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (601,
	79,
	0,
	'Value_ID',
	'',
	'',
	'Value_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (79,
	70,
	0,
	72,
	77,
	80,
	78,
	603,
	604,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R803.''has right''');
INSERT INTO O_RATTR
	VALUES (603,
	79,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (603,
	79,
	601,
	'Right_Value_ID',
	'',
	'Right_',
	'Value_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (79,
	70,
	0,
	72,
	81,
	83,
	82,
	605,
	606,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R802.''has left''');
INSERT INTO O_RATTR
	VALUES (605,
	79,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (605,
	79,
	603,
	'Left_Value_ID',
	'',
	'Left_',
	'Value_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (607,
	79);
INSERT INTO O_BATTR
	VALUES (607,
	79);
INSERT INTO O_ATTR
	VALUES (607,
	79,
	605,
	'Operator',
	'Full Name: Mathematical Operator
Data Domain: The character or string representing the operation. These include but are not limited to +, -, / and *.',
	'',
	'Operator',
	0,
	322,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	79);
INSERT INTO O_OIDA
	VALUES (601,
	79,
	0,
	'Value_ID');
INSERT INTO O_ID
	VALUES (1,
	79);
INSERT INTO O_ID
	VALUES (2,
	79);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (96,
	'Attribute Value Reference',
	812,
	'V_AVL',
	'This class represents a value held in an attribute of an instance being used on the right hand side of an assignment or an expression.',
	27);
INSERT INTO O_TFR
	VALUES (608,
	96,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'select one attr related by self->O_ATTR[R806];
if ( not_empty attr )
  unrelate self from attr across R806;
end if;

select one instRef related by self->V_VAL[R807];
if ( not_empty instRef )
  unrelate self from instRef across R807;
end if;
                    
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (609,
	96,
	'getValue',
	'',
	317,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return GD::NULL_INSTANCE();',
	1,
	'',
	610);
INSERT INTO O_TPARM
	VALUES (611,
	609,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (612,
	96,
	'setValue',
	'Attempts to find the Local Value created for the attribute reference and
assigns the passed in value to it.',
	19,
	1,
	'// Attribute Value Reference.setValue
select one body related by self->V_VAL[R801]->ACT_BLK[R826]->ACT_ACT[R601];


select one val related by self->V_VAL[R807];
select one instReference related by val->V_IRF[R801];
select one paramValue related by val->V_PVL[R801];

// get the attribute instance which represnet the left hand side of assigment expr
select one target related by self->O_ATTR[R806];
if not_empty instReference
    instReference.setValue(stack_frame_id: param.stack_frame_id,
                                  value: param.value, member_id:target.Attr_ID);   
    return;
elif not_empty paramValue
    paramValue.setValue(stack_frame_id: param.stack_frame_id,
                                  value: param.value, member_id:target.Attr_ID);
    return;
end if; 


// Did not find a supported value data type.
pathMsg = "<No Path Available - Empty instance>";
    if (not_empty body)
      pathMsg = body.getPath();
    end if;
	USER::logError(msg:"Value:AttributeValueReference.setValue() error, data type not supported.",path:pathMsg);',
	1,
	'',
	609);
INSERT INTO O_TPARM
	VALUES (613,
	612,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (614,
	612,
	'value',
	317,
	0,
	'',
	613,
	'');
INSERT INTO O_TPARM
	VALUES (615,
	612,
	'member_id',
	296,
	0,
	'',
	614,
	'');
INSERT INTO O_TFR
	VALUES (616,
	96,
	'setupSelf',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	612);
INSERT INTO O_TPARM
	VALUES (617,
	616,
	'body_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (618,
	616,
	'stack_frame_id',
	296,
	0,
	'',
	617,
	'');
INSERT INTO O_TFR
	VALUES (610,
	96,
	'getRuntimeValue',
	'',
	296,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return GD::NULL_UNIQUE_ID();
',
	1,
	'',
	608);
INSERT INTO O_TPARM
	VALUES (619,
	610,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (96,
	70,
	0,
	72,
	84,
	97,
	85,
	620,
	621,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R801');
INSERT INTO O_RATTR
	VALUES (620,
	96,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (620,
	96,
	0,
	'Value_ID',
	'',
	'',
	'Value_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (96,
	37,
	0,
	168,
	165,
	166,
	167,
	622,
	623,
	0,
	0,
	'',
	'Attribute',
	'Attr_ID',
	'R806.''is value of''');
INSERT INTO O_RATTR
	VALUES (622,
	96,
	168,
	37,
	1,
	'Attr_ID');
INSERT INTO O_ATTR
	VALUES (622,
	96,
	624,
	'Attr_ID',
	'

',
	'',
	'Attr_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (96,
	70,
	0,
	72,
	236,
	237,
	238,
	625,
	626,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R807.''has root''');
INSERT INTO O_RATTR
	VALUES (625,
	96,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (625,
	96,
	620,
	'Root_Value_ID',
	'',
	'Root_',
	'Value_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (96,
	37,
	0,
	169,
	165,
	166,
	167,
	624,
	627,
	0,
	0,
	'',
	'Attribute',
	'Obj_ID',
	'R806.''is value of''');
INSERT INTO O_RATTR
	VALUES (624,
	96,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (624,
	96,
	625,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	96);
INSERT INTO O_OIDA
	VALUES (620,
	96,
	0,
	'Value_ID');
INSERT INTO O_ID
	VALUES (1,
	96);
INSERT INTO O_ID
	VALUES (2,
	96);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (122,
	'Array Length Value',
	828,
	'V_ALV',
	'',
	27);
INSERT INTO O_TFR
	VALUES (628,
	122,
	'dispose',
	'',
	19,
	1,
	'// Array Element Reference.dispose()
select one value related by self->V_VAL[R840];
if (not_empty value)
  unrelate self from value across R840;
end if;

delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (122,
	70,
	0,
	72,
	84,
	123,
	85,
	629,
	630,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R801');
INSERT INTO O_RATTR
	VALUES (629,
	122,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (629,
	122,
	0,
	'Value_ID',
	'',
	'',
	'Value_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (122,
	70,
	0,
	72,
	245,
	246,
	247,
	631,
	632,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R840');
INSERT INTO O_RATTR
	VALUES (631,
	122,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (631,
	122,
	629,
	'Array_Value_ID',
	'',
	'Array_',
	'Value_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	122);
INSERT INTO O_OIDA
	VALUES (629,
	122,
	0,
	'Value_ID');
INSERT INTO O_ID
	VALUES (1,
	122);
INSERT INTO O_ID
	VALUES (2,
	122);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (120,
	'Array Element Reference',
	826,
	'V_AER',
	'',
	27);
INSERT INTO O_TFR
	VALUES (633,
	120,
	'dispose',
	'',
	19,
	1,
	'// Array Element Reference.dispose()
select one value related by self->V_VAL[R838];
if (not_empty value)
  unrelate self from value across R838;
end if;

select one value related by self->V_VAL[R839];
if (not_empty value)
  unrelate self from value across R839;
end if;

delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (634,
	120,
	'getRuntimeValue',
	'',
	296,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return GD::NULL_UNIQUE_ID();
',
	1,
	'',
	633);
INSERT INTO O_TPARM
	VALUES (635,
	634,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (636,
	120,
	'setValue',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	634);
INSERT INTO O_TPARM
	VALUES (637,
	636,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (638,
	636,
	'value',
	317,
	0,
	'',
	637,
	'');
INSERT INTO O_TPARM
	VALUES (639,
	636,
	'member_id',
	296,
	0,
	'',
	638,
	'');
INSERT INTO O_REF
	VALUES (120,
	70,
	0,
	72,
	84,
	121,
	85,
	640,
	641,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R801');
INSERT INTO O_RATTR
	VALUES (640,
	120,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (640,
	120,
	0,
	'Value_ID',
	'',
	'',
	'Value_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (120,
	70,
	0,
	72,
	239,
	241,
	240,
	642,
	643,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R838.''has root''');
INSERT INTO O_RATTR
	VALUES (642,
	120,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (642,
	120,
	640,
	'Root_Value_ID',
	'',
	'Root_',
	'Value_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (120,
	70,
	0,
	72,
	242,
	243,
	244,
	644,
	645,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R839.''has index''');
INSERT INTO O_RATTR
	VALUES (644,
	120,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (644,
	120,
	642,
	'Index_Value_ID',
	'',
	'Index_',
	'Value_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	120);
INSERT INTO O_OIDA
	VALUES (640,
	120,
	0,
	'Value_ID');
INSERT INTO O_ID
	VALUES (1,
	120);
INSERT INTO O_ID
	VALUES (2,
	120);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (68,
	'Actual Parameter',
	801,
	'V_PAR',
	'This class represents the actual parameter value passed to a Function, Bridge or an Operation.',
	27);
INSERT INTO O_TFR
	VALUES (646,
	68,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'select one val related by self->V_VAL[R800];
if ( not_empty val )
  unrelate self from val across R800;
  val.dispose();
end if;
select one next_parm related by self->V_PAR[R816.''precedes''];
select one prior_parm related by self->V_PAR[R816.''succeeds''];
if ( not_empty next_parm and not_empty prior_parm )
  // in the middle of the chain
  unrelate self from next_parm across R816.''precedes'';
  unrelate prior_parm from self across R816.''precedes'';
  relate prior_parm to next_parm across R816.''precedes'';
else
  if ( not_empty prior_parm and empty next_parm )
    // we''re last in list
    unrelate prior_parm from self across R816.''precedes'';
  else
    // we''re first in list
    unrelate self from next_parm across R816.''precedes'';
  end if;
end if;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (68,
	70,
	0,
	72,
	67,
	69,
	71,
	204,
	647,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R800');
INSERT INTO O_RATTR
	VALUES (204,
	68,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (204,
	68,
	0,
	'Value_ID',
	'',
	'',
	'Value_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (68,
	648,
	0,
	649,
	650,
	651,
	652,
	653,
	654,
	0,
	0,
	'',
	'Operation Invocation',
	'Statement_ID',
	'R627');
INSERT INTO O_REF
	VALUES (68,
	655,
	0,
	656,
	657,
	658,
	659,
	653,
	660,
	654,
	0,
	'',
	'Bridge Invocation',
	'Statement_ID',
	'R628');
INSERT INTO O_REF
	VALUES (68,
	661,
	0,
	662,
	663,
	664,
	665,
	653,
	666,
	660,
	0,
	'',
	'Function Invocation',
	'Statement_ID',
	'R669');
INSERT INTO O_REF
	VALUES (68,
	667,
	0,
	668,
	669,
	670,
	671,
	653,
	672,
	666,
	0,
	'',
	'Event Specification Statement',
	'Statement_ID',
	'R700');
INSERT INTO O_REF
	VALUES (68,
	673,
	0,
	674,
	675,
	676,
	677,
	653,
	678,
	672,
	0,
	'',
	'Interface Operation Invocation',
	'Statement_ID',
	'R679');
INSERT INTO O_REF
	VALUES (68,
	679,
	0,
	680,
	681,
	682,
	683,
	653,
	684,
	678,
	0,
	'',
	'Signal Invocation',
	'Statement_ID',
	'R662');
INSERT INTO O_RATTR
	VALUES (653,
	68,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (653,
	68,
	204,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (687,
	68);
INSERT INTO O_BATTR
	VALUES (687,
	68);
INSERT INTO O_ATTR
	VALUES (687,
	68,
	688,
	'Name',
	'The name of the actual parameter value passed to a function. ',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (68,
	68,
	0,
	204,
	202,
	205,
	203,
	689,
	690,
	0,
	0,
	'',
	'Actual Parameter',
	'Value_ID',
	'R816');
INSERT INTO O_RATTR
	VALUES (689,
	68,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (689,
	68,
	687,
	'Next_Value_ID',
	'

',
	'Next_',
	'Value_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (691,
	68);
INSERT INTO O_BATTR
	VALUES (691,
	68);
INSERT INTO O_ATTR
	VALUES (691,
	68,
	689,
	'labelLineNumber',
	'Stores the line number within the activity text of the label associated with 
this actual parameter.',
	'',
	'labelLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (692,
	68);
INSERT INTO O_BATTR
	VALUES (692,
	68);
INSERT INTO O_ATTR
	VALUES (692,
	68,
	691,
	'labelColumn',
	'Stores the column within the activity text of the label associated with 
this actual parameter.
',
	'',
	'labelColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_REF
	VALUES (68,
	86,
	0,
	183,
	181,
	184,
	182,
	688,
	693,
	694,
	0,
	'',
	'Function Value',
	'Value_ID',
	'R817');
INSERT INTO O_REF
	VALUES (68,
	103,
	0,
	177,
	189,
	191,
	190,
	688,
	694,
	695,
	0,
	'',
	'Operation Value',
	'Value_ID',
	'R811');
INSERT INTO O_REF
	VALUES (68,
	92,
	0,
	187,
	185,
	188,
	186,
	688,
	695,
	0,
	0,
	'',
	'Bridge Value',
	'Value_ID',
	'R810');
INSERT INTO O_REF
	VALUES (68,
	124,
	0,
	250,
	248,
	251,
	249,
	688,
	696,
	693,
	0,
	'',
	'Message Value',
	'Value_ID',
	'R842');
INSERT INTO O_RATTR
	VALUES (688,
	68,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (688,
	68,
	653,
	'Invocation_Value_ID',
	'

',
	'Invocation_',
	'Value_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	68);
INSERT INTO O_OIDA
	VALUES (204,
	68,
	0,
	'Value_ID');
INSERT INTO O_ID
	VALUES (1,
	68);
INSERT INTO O_ID
	VALUES (2,
	68);
-- BP 7.1 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (697,
	'Use Case',
	'// This is used by schema_gen to ignore this subsystem (for publication)
TRANSLATE_FOR_EXTERNAL_USE:FALSE',
	'UC',
	1200,
	1,
	0);
INSERT INTO S_SID
	VALUES (1,
	697);
INSERT INTO O_IOBJ
	VALUES (698,
	699,
	0,
	697,
	'Domain',
	'S_DOM');
INSERT INTO O_IOBJ
	VALUES (700,
	701,
	0,
	697,
	'Subsystem',
	'S_SS');
INSERT INTO O_IOBJ
	VALUES (702,
	703,
	0,
	697,
	'Interaction Participant',
	'SQ_P');
INSERT INTO O_IOBJ
	VALUES (704,
	705,
	0,
	697,
	'System Model',
	'S_SYS');
INSERT INTO O_IOBJ
	VALUES (706,
	707,
	0,
	697,
	'Component Package',
	'CP_CP');
INSERT INTO O_IOBJ
	VALUES (708,
	709,
	0,
	697,
	'Component',
	'C_C');
INSERT INTO R_SIMP
	VALUES (710);
INSERT INTO R_REL
	VALUES (710,
	1201,
	'',
	697);
INSERT INTO R_PART
	VALUES (699,
	710,
	711,
	0,
	1,
	'can be displayed in');
INSERT INTO O_RTIDA
	VALUES (712,
	699,
	0,
	710,
	711);
INSERT INTO R_RTO
	VALUES (699,
	710,
	711,
	0);
INSERT INTO R_OIR
	VALUES (699,
	710,
	711,
	698);
INSERT INTO R_FORM
	VALUES (713,
	710,
	714,
	1,
	1,
	'can display');
INSERT INTO R_RGO
	VALUES (713,
	710,
	714);
INSERT INTO R_OIR
	VALUES (713,
	710,
	714,
	0);
INSERT INTO R_SIMP
	VALUES (715);
INSERT INTO R_REL
	VALUES (715,
	1202,
	'',
	697);
INSERT INTO R_PART
	VALUES (701,
	715,
	716,
	0,
	1,
	'can be displayed in');
INSERT INTO O_RTIDA
	VALUES (717,
	701,
	0,
	715,
	716);
INSERT INTO R_RTO
	VALUES (701,
	715,
	716,
	0);
INSERT INTO R_OIR
	VALUES (701,
	715,
	716,
	700);
INSERT INTO R_FORM
	VALUES (713,
	715,
	718,
	1,
	1,
	'can display');
INSERT INTO R_RGO
	VALUES (713,
	715,
	718);
INSERT INTO R_OIR
	VALUES (713,
	715,
	718,
	0);
INSERT INTO R_SIMP
	VALUES (719);
INSERT INTO R_REL
	VALUES (719,
	1208,
	'',
	697);
INSERT INTO R_PART
	VALUES (713,
	719,
	720,
	0,
	0,
	'is shown in');
INSERT INTO O_RTIDA
	VALUES (721,
	713,
	0,
	719,
	720);
INSERT INTO R_RTO
	VALUES (713,
	719,
	720,
	0);
INSERT INTO R_OIR
	VALUES (713,
	719,
	720,
	0);
INSERT INTO R_FORM
	VALUES (722,
	719,
	723,
	0,
	1,
	'can show');
INSERT INTO R_RGO
	VALUES (722,
	719,
	723);
INSERT INTO R_OIR
	VALUES (722,
	719,
	723,
	0);
INSERT INTO R_SIMP
	VALUES (724);
INSERT INTO R_REL
	VALUES (724,
	1209,
	'',
	697);
INSERT INTO R_PART
	VALUES (722,
	724,
	725,
	0,
	1,
	'is connection to parent');
INSERT INTO O_RTIDA
	VALUES (726,
	722,
	0,
	724,
	725);
INSERT INTO R_RTO
	VALUES (722,
	724,
	725,
	0);
INSERT INTO R_OIR
	VALUES (722,
	724,
	725,
	0);
INSERT INTO R_FORM
	VALUES (713,
	724,
	727,
	1,
	1,
	'has children');
INSERT INTO R_RGO
	VALUES (713,
	724,
	727);
INSERT INTO R_OIR
	VALUES (713,
	724,
	727,
	0);
INSERT INTO R_SUBSUP
	VALUES (728);
INSERT INTO R_REL
	VALUES (728,
	1210,
	'',
	697);
INSERT INTO R_SUPER
	VALUES (729,
	728,
	730);
INSERT INTO O_RTIDA
	VALUES (731,
	729,
	0,
	728,
	730);
INSERT INTO R_RTO
	VALUES (729,
	728,
	730,
	0);
INSERT INTO R_OIR
	VALUES (729,
	728,
	730,
	0);
INSERT INTO R_SUB
	VALUES (732,
	728,
	733);
INSERT INTO R_RGO
	VALUES (732,
	728,
	733);
INSERT INTO R_OIR
	VALUES (732,
	728,
	733,
	0);
INSERT INTO R_SUB
	VALUES (734,
	728,
	735);
INSERT INTO R_RGO
	VALUES (734,
	728,
	735);
INSERT INTO R_OIR
	VALUES (734,
	728,
	735,
	0);
INSERT INTO R_SUB
	VALUES (736,
	728,
	737);
INSERT INTO R_RGO
	VALUES (736,
	728,
	737);
INSERT INTO R_OIR
	VALUES (736,
	728,
	737,
	0);
INSERT INTO R_SUB
	VALUES (738,
	728,
	739);
INSERT INTO R_RGO
	VALUES (738,
	728,
	739);
INSERT INTO R_OIR
	VALUES (738,
	728,
	739,
	0);
INSERT INTO R_ASSOC
	VALUES (740);
INSERT INTO R_REL
	VALUES (740,
	1203,
	'',
	697);
INSERT INTO R_AONE
	VALUES (713,
	740,
	741,
	0,
	1,
	'is displayed in');
INSERT INTO O_RTIDA
	VALUES (721,
	713,
	0,
	740,
	741);
INSERT INTO R_RTO
	VALUES (713,
	740,
	741,
	0);
INSERT INTO R_OIR
	VALUES (713,
	740,
	741,
	0);
INSERT INTO R_AOTH
	VALUES (703,
	740,
	742,
	1,
	1,
	'can display');
INSERT INTO O_RTIDA
	VALUES (743,
	703,
	0,
	740,
	742);
INSERT INTO R_RTO
	VALUES (703,
	740,
	742,
	0);
INSERT INTO R_OIR
	VALUES (703,
	740,
	742,
	702);
INSERT INTO R_ASSR
	VALUES (744,
	740,
	745,
	0);
INSERT INTO R_RGO
	VALUES (744,
	740,
	745);
INSERT INTO R_OIR
	VALUES (744,
	740,
	745,
	0);
INSERT INTO R_SIMP
	VALUES (746);
INSERT INTO R_REL
	VALUES (746,
	1206,
	'',
	697);
INSERT INTO R_PART
	VALUES (703,
	746,
	747,
	0,
	0,
	'starts at');
INSERT INTO O_RTIDA
	VALUES (743,
	703,
	0,
	746,
	747);
INSERT INTO R_RTO
	VALUES (703,
	746,
	747,
	0);
INSERT INTO R_OIR
	VALUES (703,
	746,
	747,
	702);
INSERT INTO R_FORM
	VALUES (729,
	746,
	748,
	1,
	1,
	'is source');
INSERT INTO R_RGO
	VALUES (729,
	746,
	748);
INSERT INTO R_OIR
	VALUES (729,
	746,
	748,
	0);
INSERT INTO R_SIMP
	VALUES (749);
INSERT INTO R_REL
	VALUES (749,
	1207,
	'',
	697);
INSERT INTO R_FORM
	VALUES (729,
	749,
	750,
	1,
	1,
	'is destination');
INSERT INTO R_RGO
	VALUES (729,
	749,
	750);
INSERT INTO R_OIR
	VALUES (729,
	749,
	750,
	0);
INSERT INTO R_PART
	VALUES (703,
	749,
	751,
	0,
	0,
	'ends at');
INSERT INTO O_RTIDA
	VALUES (743,
	703,
	0,
	749,
	751);
INSERT INTO R_RTO
	VALUES (703,
	749,
	751,
	0);
INSERT INTO R_OIR
	VALUES (703,
	749,
	751,
	702);
INSERT INTO R_SIMP
	VALUES (752);
INSERT INTO R_REL
	VALUES (752,
	1211,
	'',
	697);
INSERT INTO R_PART
	VALUES (705,
	752,
	753,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (754,
	705,
	0,
	752,
	753);
INSERT INTO R_RTO
	VALUES (705,
	752,
	753,
	0);
INSERT INTO R_OIR
	VALUES (705,
	752,
	753,
	704);
INSERT INTO R_FORM
	VALUES (713,
	752,
	755,
	1,
	1,
	'can display');
INSERT INTO R_RGO
	VALUES (713,
	752,
	755);
INSERT INTO R_OIR
	VALUES (713,
	752,
	755,
	0);
INSERT INTO R_SIMP
	VALUES (756);
INSERT INTO R_REL
	VALUES (756,
	1212,
	'',
	697);
INSERT INTO R_PART
	VALUES (707,
	756,
	757,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (758,
	707,
	0,
	756,
	757);
INSERT INTO R_RTO
	VALUES (707,
	756,
	757,
	0);
INSERT INTO R_OIR
	VALUES (707,
	756,
	757,
	706);
INSERT INTO R_FORM
	VALUES (713,
	756,
	759,
	1,
	1,
	'can display');
INSERT INTO R_RGO
	VALUES (713,
	756,
	759);
INSERT INTO R_OIR
	VALUES (713,
	756,
	759,
	0);
INSERT INTO R_SIMP
	VALUES (760);
INSERT INTO R_REL
	VALUES (760,
	1213,
	'',
	697);
INSERT INTO R_PART
	VALUES (709,
	760,
	761,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (762,
	709,
	0,
	760,
	761);
INSERT INTO R_RTO
	VALUES (709,
	760,
	761,
	0);
INSERT INTO R_OIR
	VALUES (709,
	760,
	761,
	708);
INSERT INTO R_FORM
	VALUES (713,
	760,
	763,
	1,
	1,
	'can display');
INSERT INTO R_RGO
	VALUES (713,
	760,
	763);
INSERT INTO R_OIR
	VALUES (713,
	760,
	763,
	0);
INSERT INTO R_SIMP
	VALUES (764);
INSERT INTO R_REL
	VALUES (764,
	1214,
	'',
	697);
INSERT INTO R_PART
	VALUES (713,
	764,
	765,
	0,
	0,
	'contained in');
INSERT INTO O_RTIDA
	VALUES (721,
	713,
	0,
	764,
	765);
INSERT INTO R_RTO
	VALUES (713,
	764,
	765,
	0);
INSERT INTO R_OIR
	VALUES (713,
	764,
	765,
	0);
INSERT INTO R_FORM
	VALUES (766,
	764,
	767,
	1,
	1,
	'contains');
INSERT INTO R_RGO
	VALUES (766,
	764,
	767);
INSERT INTO R_OIR
	VALUES (766,
	764,
	767,
	0);
INSERT INTO R_SIMP
	VALUES (768);
INSERT INTO R_REL
	VALUES (768,
	1215,
	'',
	697);
INSERT INTO R_FORM
	VALUES (766,
	768,
	769,
	0,
	1,
	'contained through');
INSERT INTO R_RGO
	VALUES (766,
	768,
	769);
INSERT INTO R_OIR
	VALUES (766,
	768,
	769,
	0);
INSERT INTO R_PART
	VALUES (729,
	768,
	770,
	0,
	0,
	'provides containment');
INSERT INTO O_RTIDA
	VALUES (731,
	729,
	0,
	768,
	770);
INSERT INTO R_RTO
	VALUES (729,
	768,
	770,
	0);
INSERT INTO R_OIR
	VALUES (729,
	768,
	770,
	0);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (722,
	'Use Case in Use Case',
	1205,
	'UC_UIU',
	'',
	697);
INSERT INTO O_REF
	VALUES (722,
	713,
	0,
	721,
	719,
	723,
	720,
	726,
	771,
	0,
	0,
	'',
	'Use Case Diagram',
	'Package_ID',
	'R1208');
INSERT INTO O_RATTR
	VALUES (726,
	722,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (726,
	722,
	0,
	'Package_ID',
	'',
	'',
	'SpecificationPackage_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	722);
INSERT INTO O_OIDA
	VALUES (726,
	722,
	0,
	'Package_ID');
INSERT INTO O_ID
	VALUES (1,
	722);
INSERT INTO O_ID
	VALUES (2,
	722);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (713,
	'Use Case Diagram',
	1200,
	'UC_UCC',
	'',
	697);
INSERT INTO O_TFR
	VALUES (774,
	713,
	'get_compartment_text',
	'',
	322,
	1,
	'result = "";
if (param.at == Justification::Center_in_X)
  result = "use case";
elif (param.at == Justification::Center)
  result = self.Name;
end if;
return result;',
	1,
	'',
	775);
INSERT INTO O_TPARM
	VALUES (776,
	774,
	'comp_num',
	298,
	0,
	'',
	777,
	'');
INSERT INTO O_TPARM
	VALUES (778,
	774,
	'ent_num',
	298,
	0,
	'',
	776,
	'');
INSERT INTO O_TPARM
	VALUES (777,
	774,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (780,
	713,
	'get_compartments',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	774);
INSERT INTO O_TFR
	VALUES (781,
	713,
	'get_entries',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	780);
INSERT INTO O_TPARM
	VALUES (782,
	781,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (783,
	713,
	'get_text_style',
	'',
	784,
	1,
	'return Style::None;',
	1,
	'',
	785);
INSERT INTO O_TPARM
	VALUES (786,
	783,
	'comp_num',
	298,
	0,
	'',
	787,
	'');
INSERT INTO O_TPARM
	VALUES (788,
	783,
	'ent_num',
	298,
	0,
	'',
	786,
	'');
INSERT INTO O_TPARM
	VALUES (787,
	783,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (785,
	713,
	'get_style',
	'',
	784,
	1,
	'return Style::Folder;',
	1,
	'',
	789);
INSERT INTO O_TFR
	VALUES (789,
	713,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Package_ID;',
	1,
	'',
	781);
INSERT INTO O_TFR
	VALUES (790,
	713,
	'newUseCase',
	'',
	19,
	1,
	'create object instance uc of IA_UCP;
create object instance part of SQ_P;
create object instance piuc of UC_PIUC;
relate uc to part across R930;
relate part to self across R1203 using piuc;
uc.initialize();',
	1,
	'',
	791);
INSERT INTO O_TFR
	VALUES (792,
	713,
	'newUseCasePackage',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
create object instance ucc of UC_UCC;
create object instance sp of EP_SPKG;
relate ucc to sp across R1402;
select one ucinuc related by self->UC_UIU[R1208];
if(empty ucinuc)
  create object instance ucinuc of UC_UIU;
  relate self to ucinuc across R1208;
end if;
relate ucinuc to ucc across R1209;
ucc.initialize();',
	1,
	'',
	790);
INSERT INTO O_TFR
	VALUES (793,
	713,
	'initialize',
	'',
	19,
	1,
	'self.Name = ::getUniqueInitialName( 
    instance: self.convertToInstance(), 
    candidateName: "Unnamed Use Case Diagram");',
	1,
	'',
	783);
INSERT INTO O_TFR
	VALUES (794,
	713,
	'newActor',
	'',
	19,
	1,
	'create object instance actor of SQ_AP;
create object instance part of SQ_P;
create object instance piuc of UC_PIUC;
relate self to part across R1203 using piuc;
relate actor to part across R930;
actor.initialize();',
	1,
	'',
	793);
INSERT INTO O_TFR
	VALUES (795,
	713,
	'newGeneralization',
	'',
	316,
	1,
	'select any source related by self->UC_PIUC[R1203]->SQ_P[R1203] where (selected.Part_ID == param.from);
select any destination related by self->UC_PIUC[R1203]->SQ_P[R1203] where (selected.Part_ID == param.to);
createAssoc = false;
if((not_empty source) and (not_empty destination) and (source != destination))
  select one sourceUC related by source->IA_UCP[R930];
  select one destUC related by destination->IA_UCP[R930];
  if(not_empty sourceUC and not_empty destUC)
    createAssoc = true;
  else
    select one sourceActor related by source->SQ_AP[R930];
    select one destActor related by destination->SQ_AP[R930];
    if(not_empty sourceActor and not_empty destActor)
      createAssoc = true;
    end if;
  end if;
end if;
if(createAssoc)
  create object instance association of UC_UCA;
  create object instance gen of UC_G;
  create object instance aiuc of UC_AIUC;
  relate association to aiuc across R1215;
  relate self to aiuc across R1214;
  if (not_empty source)
    relate association to source across R1206;
  end if;
  if (not_empty destination)
    relate association to destination across R1207;
  end if;
  relate association to gen across R1210;
  return true;
end if;
return false;',
	1,
	'',
	796);
INSERT INTO O_TPARM
	VALUES (797,
	795,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (798,
	795,
	'to',
	296,
	0,
	'',
	799,
	'');
INSERT INTO O_TPARM
	VALUES (799,
	795,
	'fromIsImported',
	316,
	0,
	'',
	797,
	'');
INSERT INTO O_TPARM
	VALUES (800,
	795,
	'toIsImported',
	316,
	0,
	'',
	798,
	'');
INSERT INTO O_TFR
	VALUES (801,
	713,
	'newAssociation',
	'',
	316,
	1,
	'select any sourceActor related by self->UC_PIUC[R1203]->SQ_P[R1203]->SQ_AP[R930] where (selected.Part_ID == param.from);
select any destinationUC related by self->UC_PIUC[R1203]->SQ_P[R1203]->IA_UCP[R930] where (selected.Part_ID == param.to);
if(not_empty sourceActor and not_empty destinationUC)
  create object instance association of UC_UCA;
  create object instance ba of UC_BA;
  create object instance aiuc of UC_AIUC;
  relate association to aiuc across R1215;
  relate self to aiuc across R1214;
  select one sourcePart related by sourceActor->SQ_P[R930];
  select one destPart related by destinationUC->SQ_P[R930];
  relate association to sourcePart across R1206;
  relate association to destPart across R1207;
  relate association to ba across R1210;
  return true;
end if;
return false;',
	1,
	'',
	794);
INSERT INTO O_TPARM
	VALUES (802,
	801,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (803,
	801,
	'to',
	296,
	0,
	'',
	804,
	'');
INSERT INTO O_TPARM
	VALUES (804,
	801,
	'fromIsImported',
	316,
	0,
	'',
	802,
	'');
INSERT INTO O_TPARM
	VALUES (805,
	801,
	'toIsImported',
	316,
	0,
	'',
	803,
	'');
INSERT INTO O_TFR
	VALUES (791,
	713,
	'newInclude',
	'',
	316,
	1,
	'select any sourceUC related by self->UC_PIUC[R1203]->SQ_P[R1203]->IA_UCP[R930] where (selected.Part_ID == param.from);
select any destinationUC related by self->UC_PIUC[R1203]->SQ_P[R1203]->IA_UCP[R930] where (selected.Part_ID == param.to);
if(not_empty sourceUC and not_empty destinationUC) and (sourceUC != destinationUC)
  create object instance association of UC_UCA;
  create object instance inc of UC_I;
  create object instance aiuc of UC_AIUC;
  relate association to aiuc across R1215;
  relate self to aiuc across R1214;
  select one source related by sourceUC->SQ_P[R930];
  select one destination related by destinationUC->SQ_P[R930];
  relate association to source across R1206;
  relate association to destination across R1207;
  relate association to inc across R1210;
  return true;
end if;
return false;',
	1,
	'',
	795);
INSERT INTO O_TPARM
	VALUES (806,
	791,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (807,
	791,
	'to',
	296,
	0,
	'',
	808,
	'');
INSERT INTO O_TPARM
	VALUES (808,
	791,
	'fromIsImported',
	316,
	0,
	'',
	806,
	'');
INSERT INTO O_TPARM
	VALUES (809,
	791,
	'toIsImported',
	316,
	0,
	'',
	807,
	'');
INSERT INTO O_TFR
	VALUES (796,
	713,
	'newExtend',
	'',
	316,
	1,
	'select any sourceUC related by self->UC_PIUC[R1203]->SQ_P[R1203]->IA_UCP[R930] where (selected.Part_ID == param.from);
select any destinationUC related by self->UC_PIUC[R1203]->SQ_P[R1203]->IA_UCP[R930] where (selected.Part_ID == param.to);
if(not_empty sourceUC and not_empty destinationUC) and (sourceUC != destinationUC)
  create object instance association of UC_UCA;
  create object instance ext of UC_E;
  create object instance aiuc of UC_AIUC;
  relate association to aiuc across R1215;
  relate self to aiuc across R1214;
  select one source related by sourceUC->SQ_P[R930];
  select one destination related by destinationUC->SQ_P[R930];
  relate association to source across R1206;
  relate association to destination across R1207;
  relate association to ext across R1210;
  return true;
end if;
return false;',
	1,
	'',
	801);
INSERT INTO O_TPARM
	VALUES (810,
	796,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (811,
	796,
	'to',
	296,
	0,
	'',
	812,
	'');
INSERT INTO O_TPARM
	VALUES (812,
	796,
	'fromIsImported',
	316,
	0,
	'',
	810,
	'');
INSERT INTO O_TPARM
	VALUES (813,
	796,
	'toIsImported',
	316,
	0,
	'',
	811,
	'');
INSERT INTO O_TFR
	VALUES (775,
	713,
	'dispose',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// unrelate from parent
select one ucpInUcp related by self->UC_UIU[R1209];
if(not_empty ucpInUcp)
  unrelate self from ucpInUcp across R1209;
  // are there any other children?
  select any other_child related by ucpInUcp->UC_UCC[R1209];
  if empty other_child
    // no, dispose the use case in use case placeholder
    select one ucc related by ucpInUcp->UC_UCC[R1208];
    if(not_empty ucc)
      unrelate ucc from ucpInUcp across R1208;
    end if;
    delete object instance ucpInUcp;
  end if;
end if;

// delete child use case diagrams
select one ucinuc related by self->UC_UIU[R1208];
select many ucs related by ucinuc->UC_UCC[R1209];
for each uc in ucs
  uc.dispose();
end for;
// last child will delete the ucinuc instance
  
select one domain related by self->S_DOM[R1201];
if(not_empty domain)
  unrelate self from domain across R1201;
end if;
select one ss related by self->S_SS[R1202];
if(not_empty ss)
  unrelate self from ss across R1202;
end if;
select one system related by self->S_SYS[R1211];
if(not_empty system)
  unrelate self from system across R1211;
end if;
select one compPackage related by self->CP_CP[R1212];
if(not_empty compPackage)
  unrelate self from compPackage across R1212;
end if;
select one comp related by self->C_C[R1213];
if(not_empty comp)
  unrelate self from comp across R1213;
end if;
select many piucs related by self->UC_PIUC[R1203];
for each piuc in piucs
  select one participant related by piuc->SQ_P[R1203];
  if (not_empty participant)
    participant.dispose();
  end if;
end for;
// dispose association in use case instances
select many aiucs related by self->UC_AIUC[R1214];
for each aiuc in aiucs
  select one assoc related by aiuc->UC_UCA[R1215];
  unrelate aiuc from assoc across R1215;
  unrelate aiuc from self across R1214;
  assoc.dispose();
end for;
select one specPkg related by self->EP_SPKG[R1402];
if(not_empty specPkg)
  unrelate self from specPkg across R1402;
  specPkg.dispose();
end if;
delete object instance self;',
	1,
	'',
	814);
INSERT INTO O_TFR
	VALUES (815,
	713,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'// just return this instance as an Object
return this;',
	0,
	'',
	816);
INSERT INTO O_TFR
	VALUES (817,
	713,
	'associateWithPackage',
	'',
	19,
	1,
	'// unhook from current parent
self.deassociateFromParent();
// hook up with package
select any package from instances of EP_PKG
                                     where (selected.Package_ID == param.pkgID);
select one specPkg related by self->EP_SPKG[R1402];
relate specPkg to package across R1400;',
	1,
	'',
	818);
INSERT INTO O_TPARM
	VALUES (819,
	817,
	'pkgID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (820,
	713,
	'associateWithSystem',
	'',
	19,
	1,
	'// unhook from current parent
self.deassociateFromParent();
// hook up with system
select any system from instances of S_SYS
                                         where (selected.Sys_ID == param.sysID);
relate system to self across R1211;',
	1,
	'',
	821);
INSERT INTO O_TPARM
	VALUES (822,
	820,
	'sysID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (821,
	713,
	'associateWithSubsystem',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// unhook from current parent
self.deassociateFromParent();
// hook up with domain
select any ss from instances of S_SS where (selected.SS_ID == param.ssID);
relate ss to self across R1202;',
	1,
	'',
	817);
INSERT INTO O_TPARM
	VALUES (823,
	821,
	'ssID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (818,
	713,
	'associateWithDomain',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// unhook from current parent
self.deassociateFromParent();
// hook up with domain
select any domain from instances of S_DOM
                                         where (selected.Dom_ID == param.domID);
relate domain to self across R1201;',
	1,
	'',
	824);
INSERT INTO O_TPARM
	VALUES (825,
	818,
	'domID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (826,
	713,
	'associateWithComponent',
	'',
	19,
	1,
	'// unhook from current parent
self.deassociateFromParent();
// hook up with component
select any component from instances of C_C
                                    where (selected.Id == param.compID);
relate self to component across R1213;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (827,
	826,
	'compID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (824,
	713,
	'associateWithComponentPackage',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// unhook from current parent
self.deassociateFromParent();
// hook up with component package
select any cp from instances of CP_CP where (selected.Package_ID == param.cpID);
relate cp to self across R1212;',
	1,
	'',
	826);
INSERT INTO O_TPARM
	VALUES (828,
	824,
	'cpID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (816,
	713,
	'associateWithUseCaseDiagram',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// unhook from current parent
self.deassociateFromParent();
// hook up with communication
select any ucd from instances of UC_UCC
                                     where (selected.Package_ID == param.ucdID);
select one uiu related by ucd->UC_UIU[R1208];
if(empty uiu)
  create object instance uiu of UC_UIU;
  relate ucd to uiu across R1208;
end if;
relate self to uiu across R1209;',
	1,
	'',
	820);
INSERT INTO O_TPARM
	VALUES (829,
	816,
	'ucdID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (814,
	713,
	'deassociateFromParent',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one system related by self->S_SYS[R1211];
if(not_empty system)
  unrelate self from system across R1211;
end if;
select one domain related by self->S_DOM[R1201];
if(not_empty domain)
  unrelate self from domain across R1201;
end if;
select one subsystem related by self->S_SS[R1202];
if(not_empty subsystem)
  unrelate self from subsystem across R1202;
end if;
select one cp related by self->CP_CP[R1212];
if(not_empty cp)
  unrelate self from cp across R1212;
end if;
select one comp related by self->C_C[R1213];
if(not_empty comp)
  unrelate self from comp across R1213;
end if;
select one specPkg related by self->EP_SPKG[R1402];
select one package related by specPkg->EP_PKG[R1400];
if(not_empty package)
  unrelate specPkg from package across R1400;
end if;
select one ucinuc related by self->UC_UIU[R1209];
if(not_empty ucinuc)
  select one ucd related by ucinuc->UC_UCC[R1208];
  unrelate ucinuc from self across R1209;
  select many otherUCs related by ucinuc->UC_UCC[R1209];
  if(empty otherUCs)
    unrelate ucinuc from ucd across R1208;
    delete object instance ucinuc;
  end if;
end if;',
	1,
	'',
	815);
INSERT INTO O_TFR
	VALUES (830,
	713,
	'pasteUseCaseDiagram',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any ucd from instances of UC_UCC where (selected.Package_ID == param.id);
if(not_empty ucd)
  // guarantee a unique name for the pasted element
  ucd.Name = ::getUniqueInitialNameInParent (instance:ucd.convertToInstance(),
         					    name:ucd.Name, parent:self.convertToInstance());
  ucd.associateWithUseCaseDiagram(ucdID:self.Package_ID);
end if;',
	1,
	'',
	792);
INSERT INTO O_TPARM
	VALUES (831,
	830,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (832,
	713,
	'getUsecaseDiagramCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many useCases related by self->UC_UIU[R1208]->UC_UCC[R1209];
return cardinality useCases;',
	1,
	'',
	830);
INSERT INTO O_TFR
	VALUES (833,
	713,
	'getUsecaseDiagramId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many usecases related by self->UC_UIU[R1208]->UC_UCC[R1209];
// We''re preincrementing the index
count = -1;
for each usecase in usecases
  if (not_empty usecase)
      count = count+1;
  end if;
  if (count == param.index)
      return usecase.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	832);
INSERT INTO O_TPARM
	VALUES (834,
	833,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (835,
	713,
	'getUsecaseCount',
	'',
	298,
	1,
	'select many useCases related by self->SQ_P[R1203]->IA_UCP[R930];
return cardinality useCases;',
	1,
	'',
	833);
INSERT INTO O_TFR
	VALUES (836,
	713,
	'getUsecaseId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many usecases related by self->SQ_P[R1203]->IA_UCP[R930];
// We''re preincrementing the index
count = -1;
for each usecase in usecases
  if (not_empty usecase)
      count = count+1;
  end if;
  if (count == param.index)
      return usecase.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	835);
INSERT INTO O_TPARM
	VALUES (837,
	836,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (838,
	713,
	'getActorCount',
	'',
	298,
	1,
	'select many actors related by self->SQ_P[R1203]->SQ_AP[R930];
return cardinality actors;',
	1,
	'',
	836);
INSERT INTO O_TFR
	VALUES (839,
	713,
	'getActorId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many actors related by self->SQ_P[R1203]->SQ_AP[R930];
// We''re preincrementing the index
count = -1;
for each actor in actors
  if (not_empty actor)
      count = count+1;
  end if;
  if (count == param.index)
      return actor.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	838);
INSERT INTO O_TPARM
	VALUES (840,
	839,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (841,
	713,
	'pasteUseCaseParticipant',
	'',
	19,
	1,
	'select any usecase from instances of IA_UCP
                                           where (selected.Part_ID == param.id);
if(not_empty usecase)
  select one part related by usecase->SQ_P[R930];
  select one existingContainer related by part->UC_PIUC[R1203];
  if(not_empty existingContainer)
    select one ucd related by existingContainer->UC_UCC[R1203];
    if(not_empty ucd)
      unrelate ucd from part across R1203 using existingContainer;
    end if;
  end if;
  create object instance piuc of UC_PIUC;
  relate part to self across R1203 using piuc;
end if;',
	1,
	'',
	839);
INSERT INTO O_TPARM
	VALUES (842,
	841,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (843,
	713,
	'pasteActorParticipant',
	'',
	19,
	1,
	'select any actor from instances of SQ_AP
                                           where (selected.Part_ID == param.id);
if(not_empty actor)
  select one part related by actor->SQ_P[R930];
  select one existingContainer related by part->UC_PIUC[R1203];
  if(not_empty existingContainer)
    select one ucd related by existingContainer->UC_UCC[R1203];
    if(not_empty ucd)
      unrelate ucd from part across R1203 using existingContainer;
    end if;
  end if;
  create object instance piuc of UC_PIUC;
  relate part to self across R1203 using piuc;
end if;',
	1,
	'',
	841);
INSERT INTO O_TPARM
	VALUES (844,
	843,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (713,
	701,
	0,
	717,
	715,
	718,
	716,
	845,
	846,
	0,
	0,
	'',
	'Subsystem',
	'SS_ID',
	'R1202');
INSERT INTO O_RATTR
	VALUES (845,
	713,
	717,
	701,
	1,
	'SS_ID');
INSERT INTO O_ATTR
	VALUES (845,
	713,
	847,
	'SS_ID',
	'',
	'',
	'SS_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (713,
	699,
	0,
	712,
	710,
	714,
	711,
	847,
	848,
	0,
	0,
	'',
	'Domain',
	'Dom_ID',
	'R1201');
INSERT INTO O_RATTR
	VALUES (847,
	713,
	712,
	699,
	1,
	'Dom_ID');
INSERT INTO O_ATTR
	VALUES (847,
	713,
	721,
	'Dom_ID',
	'',
	'',
	'Dom_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (849,
	713);
INSERT INTO O_BATTR
	VALUES (849,
	713);
INSERT INTO O_ATTR
	VALUES (849,
	713,
	850,
	'Name',
	'Full Name: Use Case Diagram Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (851,
	713);
INSERT INTO O_BATTR
	VALUES (851,
	713);
INSERT INTO O_ATTR
	VALUES (851,
	713,
	849,
	'Descrip',
	'DiagFull Name: Use Case Diagram Description
Description: A textual description of this use case.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (713,
	705,
	0,
	754,
	752,
	755,
	753,
	852,
	853,
	0,
	0,
	'',
	'System Model',
	'Sys_ID',
	'R1211');
INSERT INTO O_RATTR
	VALUES (852,
	713,
	754,
	705,
	1,
	'Sys_ID');
INSERT INTO O_ATTR
	VALUES (852,
	713,
	851,
	'Sys_ID',
	'',
	'',
	'Sys_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (713,
	773,
	0,
	772,
	854,
	855,
	856,
	721,
	857,
	0,
	0,
	'',
	'Specification Package',
	'Package_ID',
	'R1402');
INSERT INTO O_RATTR
	VALUES (721,
	713,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (721,
	713,
	0,
	'Package_ID',
	'',
	'',
	'Package_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (713,
	707,
	0,
	758,
	756,
	759,
	757,
	858,
	859,
	0,
	0,
	'',
	'Component Package',
	'Package_ID',
	'R1212');
INSERT INTO O_RATTR
	VALUES (858,
	713,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (858,
	713,
	852,
	'Component_Package_ID',
	'',
	'Component_',
	'Package_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (713,
	722,
	0,
	726,
	724,
	727,
	725,
	850,
	860,
	0,
	0,
	'',
	'Use Case in Use Case',
	'Package_ID',
	'R1209');
INSERT INTO O_RATTR
	VALUES (850,
	713,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (850,
	713,
	845,
	'Parent_Package_ID',
	'',
	'Parent_',
	'Package_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (713,
	709,
	0,
	762,
	760,
	763,
	761,
	861,
	862,
	0,
	0,
	'',
	'Component',
	'Id',
	'R1213');
INSERT INTO O_RATTR
	VALUES (861,
	713,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (861,
	713,
	858,
	'Component_Id',
	'',
	'Component_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	713);
INSERT INTO O_OIDA
	VALUES (721,
	713,
	0,
	'Package_ID');
INSERT INTO O_ID
	VALUES (1,
	713);
INSERT INTO O_ID
	VALUES (2,
	713);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (729,
	'Use Case Association',
	1201,
	'UC_UCA',
	'',
	697);
INSERT INTO O_TFR
	VALUES (863,
	729,
	'dispose',
	'',
	19,
	1,
	'select one pe related by self->PE_PE[R8001];
if(not_empty pe)
  // PE_PE.dispose() will call back into this function at which time the
  // rest of the activity will execute.
  pe.dispose();
  return;
end if;
select one part related by self->SQ_P[R1206];
if(not_empty part)
  unrelate self from part across R1206;
end if;
select one part related by self->SQ_P[R1207];
if(not_empty part)
  unrelate self from part across R1207;
end if;
select one ba related by self->UC_BA[R1210];
select one gen related by self->UC_G[R1210];
select one inc related by self->UC_I[R1210];
select one ext related by self->UC_E[R1210];
if(not_empty ba)
  unrelate self from ba across R1210;
  ba.dispose();
elif(not_empty gen)
  unrelate self from gen across R1210;
  gen.dispose();
elif(not_empty inc)
  unrelate self from inc across R1210;
  inc.dispose();
elif(not_empty ext)
  unrelate self from ext across R1210;
  ext.dispose();
end if;
select one aiuc related by self->UC_AIUC[R1215];
if(not_empty aiuc)
  select one uc related by aiuc->UC_UCC[R1214];
  unrelate self from aiuc across R1215;
  unrelate aiuc from uc across R1214;
  delete object instance aiuc;
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (729,
	703,
	0,
	743,
	746,
	748,
	747,
	864,
	865,
	0,
	0,
	'',
	'Interaction Participant',
	'Part_ID',
	'R1206');
INSERT INTO O_RATTR
	VALUES (864,
	729,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (864,
	729,
	731,
	'Source_Part_ID',
	'',
	'Source_',
	'Part_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (729,
	703,
	0,
	743,
	749,
	750,
	751,
	866,
	867,
	0,
	0,
	'',
	'Interaction Participant',
	'Part_ID',
	'R1207');
INSERT INTO O_RATTR
	VALUES (866,
	729,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (866,
	729,
	864,
	'Destination_Part_ID',
	'',
	'Destination_',
	'Part_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (729,
	26,
	0,
	25,
	868,
	869,
	870,
	731,
	871,
	0,
	0,
	'',
	'Packageable Element',
	'Element_ID',
	'R8001');
INSERT INTO O_RATTR
	VALUES (731,
	729,
	25,
	26,
	0,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (731,
	729,
	0,
	'Assoc_ID',
	'',
	'',
	'Assoc_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	729);
INSERT INTO O_OIDA
	VALUES (731,
	729,
	0,
	'Assoc_ID');
INSERT INTO O_ID
	VALUES (1,
	729);
INSERT INTO O_ID
	VALUES (2,
	729);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (744,
	'Participant in Use Case',
	1203,
	'UC_PIUC',
	'',
	697);
INSERT INTO O_REF
	VALUES (744,
	713,
	0,
	721,
	740,
	745,
	741,
	872,
	873,
	0,
	0,
	'',
	'Use Case Diagram',
	'Package_ID',
	'R1203');
INSERT INTO O_RATTR
	VALUES (872,
	744,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (872,
	744,
	0,
	'Package_ID',
	'',
	'',
	'Package_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (744,
	703,
	0,
	743,
	740,
	745,
	742,
	874,
	875,
	0,
	0,
	'',
	'Interaction Participant',
	'Part_ID',
	'R1203');
INSERT INTO O_RATTR
	VALUES (874,
	744,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (874,
	744,
	872,
	'Part_ID',
	'',
	'',
	'Part_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	744);
INSERT INTO O_OIDA
	VALUES (872,
	744,
	0,
	'Package_ID');
INSERT INTO O_OIDA
	VALUES (874,
	744,
	0,
	'Part_ID');
INSERT INTO O_ID
	VALUES (1,
	744);
INSERT INTO O_ID
	VALUES (2,
	744);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (736,
	'Include',
	1208,
	'UC_I',
	'',
	697);
INSERT INTO O_TFR
	VALUES (876,
	736,
	'dispose',
	'',
	19,
	1,
	'select one uca related by self->UC_UCA[R1210];
if(not_empty uca)
  uca.dispose();
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (877,
	736,
	'get_style',
	'',
	784,
	1,
	'if(param.at == End::End)
  return Style::OpenArrow;
elif(param.at == End::Middle)
  return Style::Dash;
else
  return Style::None;
end if;',
	1,
	'',
	878);
INSERT INTO O_TPARM
	VALUES (879,
	877,
	'at',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (881,
	736,
	'get_connector_text',
	'',
	322,
	1,
	'if(param.at == End::Middle)
  return "include";
end if;
return "";',
	1,
	'',
	876);
INSERT INTO O_TPARM
	VALUES (882,
	881,
	'Obj_ID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (883,
	881,
	'Obj_TypeIsImported',
	316,
	0,
	'',
	882,
	'');
INSERT INTO O_TPARM
	VALUES (884,
	881,
	'at',
	880,
	0,
	'',
	883,
	'');
INSERT INTO O_TPARM
	VALUES (885,
	881,
	'parent_ID',
	296,
	0,
	'',
	884,
	'');
INSERT INTO O_TFR
	VALUES (878,
	736,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Assoc_ID;',
	1,
	'',
	886);
INSERT INTO O_TFR
	VALUES (886,
	736,
	'get_name',
	'',
	322,
	1,
	'return "";',
	1,
	'',
	881);
INSERT INTO O_NBATTR
	VALUES (887,
	736);
INSERT INTO O_BATTR
	VALUES (887,
	736);
INSERT INTO O_ATTR
	VALUES (887,
	736,
	888,
	'Descrip',
	'Full Name: Include Description
Description: A textual description of this include.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (736,
	729,
	0,
	731,
	728,
	737,
	730,
	888,
	889,
	0,
	0,
	'',
	'Use Case Association',
	'Assoc_ID',
	'R1210');
INSERT INTO O_RATTR
	VALUES (888,
	736,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (888,
	736,
	0,
	'Assoc_ID',
	'',
	'',
	'Element_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	736);
INSERT INTO O_OIDA
	VALUES (888,
	736,
	0,
	'Assoc_ID');
INSERT INTO O_ID
	VALUES (1,
	736);
INSERT INTO O_ID
	VALUES (2,
	736);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (734,
	'Generalization',
	1207,
	'UC_G',
	'',
	697);
INSERT INTO O_TFR
	VALUES (890,
	734,
	'dispose',
	'',
	19,
	1,
	'select one uca related by self->UC_UCA[R1210];
if(not_empty uca)
  uca.dispose();
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (891,
	734,
	'get_style',
	'',
	784,
	1,
	'if(param.at == End::End)
  return Style::Triangle;
elif(param.at == End::Middle)
  return Style::Solid;
else
  return Style::None;
end if;',
	1,
	'',
	892);
INSERT INTO O_TPARM
	VALUES (893,
	891,
	'at',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (894,
	734,
	'get_connector_text',
	'',
	322,
	1,
	'return "";',
	1,
	'',
	890);
INSERT INTO O_TPARM
	VALUES (895,
	894,
	'Obj_ID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (896,
	894,
	'Obj_TypeIsImported',
	316,
	0,
	'',
	895,
	'');
INSERT INTO O_TPARM
	VALUES (897,
	894,
	'at',
	880,
	0,
	'',
	896,
	'');
INSERT INTO O_TPARM
	VALUES (898,
	894,
	'parent_ID',
	296,
	0,
	'',
	897,
	'');
INSERT INTO O_TFR
	VALUES (892,
	734,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Assoc_ID;',
	1,
	'',
	899);
INSERT INTO O_TFR
	VALUES (899,
	734,
	'get_name',
	'',
	322,
	1,
	'return "";',
	1,
	'',
	894);
INSERT INTO O_NBATTR
	VALUES (900,
	734);
INSERT INTO O_BATTR
	VALUES (900,
	734);
INSERT INTO O_ATTR
	VALUES (900,
	734,
	901,
	'Descrip',
	'Full Name: Generalization Description
Description: A textual description of this generalization.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (734,
	729,
	0,
	731,
	728,
	735,
	730,
	901,
	902,
	0,
	0,
	'',
	'Use Case Association',
	'Assoc_ID',
	'R1210');
INSERT INTO O_RATTR
	VALUES (901,
	734,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (901,
	734,
	0,
	'Assoc_ID',
	'',
	'',
	'Element_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	734);
INSERT INTO O_OIDA
	VALUES (901,
	734,
	0,
	'Assoc_ID');
INSERT INTO O_ID
	VALUES (1,
	734);
INSERT INTO O_ID
	VALUES (2,
	734);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (732,
	'Extend',
	1209,
	'UC_E',
	'',
	697);
INSERT INTO O_TFR
	VALUES (903,
	732,
	'dispose',
	'',
	19,
	1,
	'select one uca related by self->UC_UCA[R1210];
if(not_empty uca)
  uca.dispose();
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (904,
	732,
	'get_style',
	'',
	784,
	1,
	'if(param.at == End::End)
  return Style::OpenArrow;
elif(param.at == End::Middle)
  return Style::Dash;
else
  return Style::None;
end if;',
	1,
	'',
	905);
INSERT INTO O_TPARM
	VALUES (906,
	904,
	'at',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (907,
	732,
	'get_connector_text',
	'',
	322,
	1,
	'if(param.at == End::Middle)
  return "extend";
end if;
return "";',
	1,
	'',
	903);
INSERT INTO O_TPARM
	VALUES (908,
	907,
	'Obj_ID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (909,
	907,
	'Obj_TypeIsImported',
	316,
	0,
	'',
	908,
	'');
INSERT INTO O_TPARM
	VALUES (910,
	907,
	'at',
	880,
	0,
	'',
	909,
	'');
INSERT INTO O_TPARM
	VALUES (911,
	907,
	'parent_ID',
	296,
	0,
	'',
	910,
	'');
INSERT INTO O_TFR
	VALUES (905,
	732,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Assoc_ID;',
	1,
	'',
	912);
INSERT INTO O_TFR
	VALUES (912,
	732,
	'get_name',
	'',
	322,
	1,
	'return "";',
	1,
	'',
	907);
INSERT INTO O_NBATTR
	VALUES (913,
	732);
INSERT INTO O_BATTR
	VALUES (913,
	732);
INSERT INTO O_ATTR
	VALUES (913,
	732,
	914,
	'Descrip',
	'Full Name: Extend Description
Description: A textual description of this extend.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (732,
	729,
	0,
	731,
	728,
	733,
	730,
	914,
	915,
	0,
	0,
	'',
	'Use Case Association',
	'Assoc_ID',
	'R1210');
INSERT INTO O_RATTR
	VALUES (914,
	732,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (914,
	732,
	0,
	'Assoc_ID',
	'',
	'',
	'Element_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	732);
INSERT INTO O_OIDA
	VALUES (914,
	732,
	0,
	'Assoc_ID');
INSERT INTO O_ID
	VALUES (1,
	732);
INSERT INTO O_ID
	VALUES (2,
	732);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (738,
	'Binary Association',
	1206,
	'UC_BA',
	'',
	697);
INSERT INTO O_TFR
	VALUES (916,
	738,
	'get_style',
	'',
	784,
	1,
	'if(param.at == End::Middle)
  return Style::Solid;
else
  return Style::None;
end if;',
	1,
	'',
	917);
INSERT INTO O_TPARM
	VALUES (918,
	916,
	'at',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (917,
	738,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Assoc_ID;',
	1,
	'',
	919);
INSERT INTO O_TFR
	VALUES (920,
	738,
	'get_connector_text',
	'',
	322,
	1,
	'return "";',
	1,
	'',
	921);
INSERT INTO O_TPARM
	VALUES (922,
	920,
	'Obj_ID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (923,
	920,
	'Obj_TypeIsImported',
	316,
	0,
	'',
	922,
	'');
INSERT INTO O_TPARM
	VALUES (924,
	920,
	'at',
	880,
	0,
	'',
	923,
	'');
INSERT INTO O_TPARM
	VALUES (925,
	920,
	'parent_ID',
	296,
	0,
	'',
	924,
	'');
INSERT INTO O_TFR
	VALUES (921,
	738,
	'dispose',
	'',
	19,
	1,
	'select one uca related by self->UC_UCA[R1210];
if(not_empty uca)
  uca.dispose();
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (919,
	738,
	'get_name',
	'',
	322,
	1,
	'return "";',
	1,
	'',
	920);
INSERT INTO O_NBATTR
	VALUES (926,
	738);
INSERT INTO O_BATTR
	VALUES (926,
	738);
INSERT INTO O_ATTR
	VALUES (926,
	738,
	927,
	'Descrip',
	'Full Name: Association Description
Description: A textual description of this association.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (738,
	729,
	0,
	731,
	728,
	739,
	730,
	927,
	928,
	0,
	0,
	'',
	'Use Case Association',
	'Assoc_ID',
	'R1210');
INSERT INTO O_RATTR
	VALUES (927,
	738,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (927,
	738,
	0,
	'Assoc_ID',
	'',
	'',
	'Element_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	738);
INSERT INTO O_OIDA
	VALUES (927,
	738,
	0,
	'Assoc_ID');
INSERT INTO O_ID
	VALUES (1,
	738);
INSERT INTO O_ID
	VALUES (2,
	738);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (766,
	'Association In Use Case',
	1210,
	'UC_AIUC',
	'',
	697);
INSERT INTO O_REF
	VALUES (766,
	729,
	0,
	731,
	768,
	769,
	770,
	929,
	930,
	0,
	0,
	'',
	'Use Case Association',
	'Assoc_ID',
	'R1215');
INSERT INTO O_RATTR
	VALUES (929,
	766,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (929,
	766,
	0,
	'Assoc_ID',
	'',
	'',
	'Assoc_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (766,
	713,
	0,
	721,
	764,
	767,
	765,
	931,
	932,
	0,
	0,
	'',
	'Use Case Diagram',
	'Package_ID',
	'R1214');
INSERT INTO O_RATTR
	VALUES (931,
	766,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (931,
	766,
	929,
	'Package_ID',
	'',
	'',
	'Package_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	766);
INSERT INTO O_ID
	VALUES (1,
	766);
INSERT INTO O_ID
	VALUES (2,
	766);
-- BP 7.1 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (933,
	'System Level Datatypes',
	'// This is used by schema_gen to ignore this subsystem (for publication)
TRANSLATE_FOR_EXTERNAL_USE:FALSE

The System Level Datatypes subsystem exists mainly to setup linking between a
datatype package and a system, as well as datatypes and a system.',
	'SLD',
	4400,
	1,
	0);
INSERT INTO S_SID
	VALUES (1,
	933);
INSERT INTO O_IOBJ
	VALUES (934,
	705,
	0,
	933,
	'System Model',
	'S_SYS');
INSERT INTO O_IOBJ
	VALUES (935,
	936,
	0,
	933,
	'Data Type Package',
	'S_DPK');
INSERT INTO O_IOBJ
	VALUES (937,
	32,
	0,
	933,
	'Data Type',
	'S_DT');
INSERT INTO O_IOBJ
	VALUES (938,
	939,
	0,
	933,
	'Constant Specification',
	'CNST_CSP');
INSERT INTO R_ASSOC
	VALUES (940);
INSERT INTO R_REL
	VALUES (940,
	4400,
	'',
	933);
INSERT INTO R_AONE
	VALUES (705,
	940,
	941,
	0,
	1,
	'is contained in');
INSERT INTO O_RTIDA
	VALUES (754,
	705,
	0,
	940,
	941);
INSERT INTO R_RTO
	VALUES (705,
	940,
	941,
	0);
INSERT INTO R_OIR
	VALUES (705,
	940,
	941,
	934);
INSERT INTO R_AOTH
	VALUES (936,
	940,
	942,
	1,
	1,
	'contains');
INSERT INTO O_RTIDA
	VALUES (943,
	936,
	0,
	940,
	942);
INSERT INTO R_RTO
	VALUES (936,
	940,
	942,
	0);
INSERT INTO R_OIR
	VALUES (936,
	940,
	942,
	935);
INSERT INTO R_ASSR
	VALUES (944,
	940,
	945,
	0);
INSERT INTO R_RGO
	VALUES (944,
	940,
	945);
INSERT INTO R_OIR
	VALUES (944,
	940,
	945,
	0);
INSERT INTO R_ASSOC
	VALUES (946);
INSERT INTO R_REL
	VALUES (946,
	4401,
	'',
	933);
INSERT INTO R_AONE
	VALUES (936,
	946,
	947,
	1,
	1,
	'can show in lower package');
INSERT INTO O_RTIDA
	VALUES (943,
	936,
	0,
	946,
	947);
INSERT INTO R_RTO
	VALUES (936,
	946,
	947,
	0);
INSERT INTO R_OIR
	VALUES (936,
	946,
	947,
	935);
INSERT INTO R_AOTH
	VALUES (32,
	946,
	948,
	1,
	1,
	'may show');
INSERT INTO O_RTIDA
	VALUES (156,
	32,
	0,
	946,
	948);
INSERT INTO R_RTO
	VALUES (32,
	946,
	948,
	0);
INSERT INTO R_OIR
	VALUES (32,
	946,
	948,
	937);
INSERT INTO R_ASSR
	VALUES (949,
	946,
	950,
	0);
INSERT INTO R_RGO
	VALUES (949,
	946,
	950);
INSERT INTO R_OIR
	VALUES (949,
	946,
	950,
	0);
INSERT INTO R_SIMP
	VALUES (951);
INSERT INTO R_REL
	VALUES (951,
	4402,
	'CrossComponent:true',
	933);
INSERT INTO R_FORM
	VALUES (949,
	951,
	952,
	1,
	1,
	'is system of');
INSERT INTO R_RGO
	VALUES (949,
	951,
	952);
INSERT INTO R_OIR
	VALUES (949,
	951,
	952,
	0);
INSERT INTO R_PART
	VALUES (705,
	951,
	953,
	0,
	0,
	'is datatype in');
INSERT INTO O_RTIDA
	VALUES (754,
	705,
	0,
	951,
	953);
INSERT INTO R_RTO
	VALUES (705,
	951,
	953,
	0);
INSERT INTO R_OIR
	VALUES (705,
	951,
	953,
	934);
INSERT INTO R_SIMP
	VALUES (954);
INSERT INTO R_REL
	VALUES (954,
	4404,
	'CrossComponent:true',
	933);
INSERT INTO R_PART
	VALUES (705,
	954,
	955,
	0,
	0,
	'is constant in');
INSERT INTO O_RTIDA
	VALUES (754,
	705,
	0,
	954,
	955);
INSERT INTO R_RTO
	VALUES (705,
	954,
	955,
	0);
INSERT INTO R_OIR
	VALUES (705,
	954,
	955,
	934);
INSERT INTO R_FORM
	VALUES (956,
	954,
	957,
	1,
	1,
	'is system of');
INSERT INTO R_RGO
	VALUES (956,
	954,
	957);
INSERT INTO R_OIR
	VALUES (956,
	954,
	957,
	0);
INSERT INTO R_ASSOC
	VALUES (958);
INSERT INTO R_REL
	VALUES (958,
	4403,
	'',
	933);
INSERT INTO R_AONE
	VALUES (936,
	958,
	959,
	1,
	1,
	'can show in lower package');
INSERT INTO O_RTIDA
	VALUES (943,
	936,
	0,
	958,
	959);
INSERT INTO R_RTO
	VALUES (936,
	958,
	959,
	0);
INSERT INTO R_OIR
	VALUES (936,
	958,
	959,
	935);
INSERT INTO R_AOTH
	VALUES (939,
	958,
	960,
	1,
	1,
	'may show');
INSERT INTO O_RTIDA
	VALUES (961,
	939,
	0,
	958,
	960);
INSERT INTO R_RTO
	VALUES (939,
	958,
	960,
	0);
INSERT INTO R_OIR
	VALUES (939,
	958,
	960,
	938);
INSERT INTO R_ASSR
	VALUES (956,
	958,
	962,
	0);
INSERT INTO R_RGO
	VALUES (956,
	958,
	962);
INSERT INTO R_OIR
	VALUES (956,
	958,
	962,
	0);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (944,
	'System Datatype Package',
	4400,
	'SLD_SDP',
	'',
	933);
INSERT INTO O_REF
	VALUES (944,
	705,
	0,
	754,
	940,
	945,
	941,
	963,
	964,
	0,
	0,
	'',
	'System Model',
	'Sys_ID',
	'R4400');
INSERT INTO O_RATTR
	VALUES (963,
	944,
	754,
	705,
	1,
	'Sys_ID');
INSERT INTO O_ATTR
	VALUES (963,
	944,
	0,
	'Sys_ID',
	'',
	'',
	'Sys_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (944,
	936,
	0,
	943,
	940,
	945,
	942,
	965,
	966,
	0,
	0,
	'',
	'Data Type Package',
	'Package_ID',
	'R4400');
INSERT INTO O_RATTR
	VALUES (965,
	944,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (965,
	944,
	963,
	'Package_ID',
	'',
	'',
	'Package_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	944);
INSERT INTO O_OIDA
	VALUES (963,
	944,
	0,
	'Sys_ID');
INSERT INTO O_OIDA
	VALUES (965,
	944,
	0,
	'Package_ID');
INSERT INTO O_ID
	VALUES (1,
	944);
INSERT INTO O_ID
	VALUES (2,
	944);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (949,
	'System Datatype in Package',
	4401,
	'SLD_SDINP',
	'',
	933);
INSERT INTO O_REF
	VALUES (949,
	705,
	0,
	754,
	951,
	952,
	953,
	967,
	968,
	0,
	0,
	'',
	'System Model',
	'Sys_ID',
	'R4402');
INSERT INTO O_RATTR
	VALUES (967,
	949,
	754,
	705,
	1,
	'Sys_ID');
INSERT INTO O_ATTR
	VALUES (967,
	949,
	969,
	'Sys_ID',
	'',
	'',
	'Sys_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (949,
	936,
	0,
	943,
	946,
	950,
	947,
	970,
	971,
	0,
	0,
	'',
	'Data Type Package',
	'Package_ID',
	'R4401');
INSERT INTO O_RATTR
	VALUES (970,
	949,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (970,
	949,
	0,
	'Package_ID',
	'',
	'',
	'Package_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (949,
	32,
	0,
	156,
	946,
	950,
	948,
	969,
	972,
	0,
	0,
	'',
	'Data Type',
	'DT_ID',
	'R4401');
INSERT INTO O_RATTR
	VALUES (969,
	949,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (969,
	949,
	970,
	'DT_ID',
	'',
	'',
	'Element_ID',
	2,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	949);
INSERT INTO O_OIDA
	VALUES (970,
	949,
	0,
	'Package_ID');
INSERT INTO O_OIDA
	VALUES (969,
	949,
	0,
	'DT_ID');
INSERT INTO O_ID
	VALUES (1,
	949);
INSERT INTO O_ID
	VALUES (2,
	949);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (956,
	'System Constant in Package',
	4402,
	'SLD_SCINP',
	'',
	933);
INSERT INTO O_REF
	VALUES (956,
	705,
	0,
	754,
	954,
	957,
	955,
	973,
	974,
	0,
	0,
	'',
	'System Model',
	'Sys_ID',
	'R4404');
INSERT INTO O_RATTR
	VALUES (973,
	956,
	754,
	705,
	1,
	'Sys_ID');
INSERT INTO O_ATTR
	VALUES (973,
	956,
	0,
	'Sys_ID',
	'',
	'',
	'Sys_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (956,
	936,
	0,
	943,
	958,
	962,
	959,
	975,
	976,
	0,
	0,
	'',
	'Data Type Package',
	'Package_ID',
	'R4403');
INSERT INTO O_RATTR
	VALUES (975,
	956,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (975,
	956,
	973,
	'Package_ID',
	'',
	'',
	'Package_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (956,
	939,
	0,
	961,
	958,
	962,
	960,
	977,
	978,
	0,
	0,
	'',
	'Constant Specification',
	'Constant_Spec_ID',
	'R4403');
INSERT INTO O_RATTR
	VALUES (977,
	956,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (977,
	956,
	975,
	'Constant_Spec_ID',
	'',
	'',
	'Constant_Spec_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	956);
INSERT INTO O_OIDA
	VALUES (975,
	956,
	0,
	'Package_ID');
INSERT INTO O_OIDA
	VALUES (977,
	956,
	0,
	'Constant_Spec_ID');
INSERT INTO O_ID
	VALUES (1,
	956);
INSERT INTO O_ID
	VALUES (2,
	956);
-- BP 7.1 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (979,
	'Subsystem',
	'A class (O_OBJ)  is an abstraction of a real world thing that has specific attributes (O_ATTR) and, if active, has a lifecycle model as a state machine (SM_SM).  All instances of the class must have the same characteristics and follow the same state behavior.  Classes fall into many categories, some of which are: tangible things, roles, interactions and specifications. ',
	'O',
	101,
	1,
	980);
INSERT INTO S_SID
	VALUES (1,
	979);
INSERT INTO O_IOBJ
	VALUES (981,
	32,
	5,
	979,
	'Data Type',
	'S_DT');
INSERT INTO O_IOBJ
	VALUES (982,
	983,
	5,
	979,
	'Referred To Class in Assoc',
	'R_RTO');
INSERT INTO O_IOBJ
	VALUES (984,
	985,
	5,
	979,
	'Referring Class In Assoc',
	'R_RGO');
INSERT INTO O_IOBJ
	VALUES (986,
	59,
	0,
	979,
	'Dimensions',
	'S_DIM');
INSERT INTO O_IOBJ
	VALUES (987,
	988,
	0,
	979,
	'Instance Reference Data Type',
	'S_IRDT');
INSERT INTO R_SIMP
	VALUES (989);
INSERT INTO R_REL
	VALUES (989,
	117,
	'',
	979);
INSERT INTO R_PART
	VALUES (43,
	989,
	990,
	0,
	0,
	'is part of ');
INSERT INTO O_RTIDA
	VALUES (201,
	43,
	0,
	989,
	990);
INSERT INTO R_RTO
	VALUES (43,
	989,
	990,
	0);
INSERT INTO R_OIR
	VALUES (43,
	989,
	990,
	0);
INSERT INTO R_FORM
	VALUES (50,
	989,
	991,
	1,
	1,
	'contains');
INSERT INTO R_RGO
	VALUES (50,
	989,
	991);
INSERT INTO R_OIR
	VALUES (50,
	989,
	991,
	0);
INSERT INTO R_SIMP
	VALUES (992);
INSERT INTO R_REL
	VALUES (992,
	118,
	'CrossComponent:true',
	979);
INSERT INTO R_PART
	VALUES (32,
	992,
	993,
	0,
	0,
	'is defined by');
INSERT INTO O_RTIDA
	VALUES (156,
	32,
	0,
	992,
	993);
INSERT INTO R_RTO
	VALUES (32,
	992,
	993,
	0);
INSERT INTO R_OIR
	VALUES (32,
	992,
	993,
	981);
INSERT INTO R_FORM
	VALUES (50,
	992,
	994,
	1,
	1,
	'defines the type of ');
INSERT INTO R_RGO
	VALUES (50,
	992,
	994);
INSERT INTO R_OIR
	VALUES (50,
	992,
	994,
	0);
INSERT INTO R_SIMP
	VALUES (995);
INSERT INTO R_REL
	VALUES (995,
	116,
	'CrossComponent:true',
	979);
INSERT INTO R_PART
	VALUES (32,
	995,
	996,
	0,
	0,
	'return code is defined by');
INSERT INTO O_RTIDA
	VALUES (156,
	32,
	0,
	995,
	996);
INSERT INTO R_RTO
	VALUES (32,
	995,
	996,
	0);
INSERT INTO R_OIR
	VALUES (32,
	995,
	996,
	981);
INSERT INTO R_FORM
	VALUES (43,
	995,
	997,
	1,
	1,
	'defines the type of return code');
INSERT INTO R_RGO
	VALUES (43,
	995,
	997);
INSERT INTO R_OIR
	VALUES (43,
	995,
	997,
	0);
INSERT INTO R_SIMP
	VALUES (998);
INSERT INTO R_REL
	VALUES (998,
	115,
	'',
	979);
INSERT INTO R_FORM
	VALUES (43,
	998,
	999,
	1,
	1,
	'may contain');
INSERT INTO R_RGO
	VALUES (43,
	998,
	999);
INSERT INTO R_OIR
	VALUES (43,
	998,
	999,
	0);
INSERT INTO R_PART
	VALUES (30,
	998,
	1000,
	0,
	0,
	'is associated with');
INSERT INTO O_RTIDA
	VALUES (150,
	30,
	0,
	998,
	1000);
INSERT INTO R_RTO
	VALUES (30,
	998,
	1000,
	0);
INSERT INTO R_OIR
	VALUES (30,
	998,
	1000,
	0);
INSERT INTO R_SIMP
	VALUES (1001);
INSERT INTO R_REL
	VALUES (1001,
	102,
	'',
	979);
INSERT INTO R_FORM
	VALUES (37,
	1001,
	1002,
	1,
	1,
	'has characteristics abstracted by');
INSERT INTO R_RGO
	VALUES (37,
	1001,
	1002);
INSERT INTO R_OIR
	VALUES (37,
	1001,
	1002,
	0);
INSERT INTO R_PART
	VALUES (30,
	1001,
	1003,
	0,
	0,
	'abstracts characteristics of');
INSERT INTO O_RTIDA
	VALUES (150,
	30,
	0,
	1001,
	1003);
INSERT INTO R_RTO
	VALUES (30,
	1001,
	1003,
	0);
INSERT INTO R_OIR
	VALUES (30,
	1001,
	1003,
	0);
INSERT INTO R_SIMP
	VALUES (1004);
INSERT INTO R_REL
	VALUES (1004,
	103,
	'This association specifies the order in which a classes attributes appear on the OIM. The instance for which no instance ''preceeds'' is the first (top) class attribute on the OIM. The instance for which no instance ''succeeds'' is the last (bottom) class attribute on the OIM.',
	979);
INSERT INTO R_PART
	VALUES (37,
	1004,
	1005,
	0,
	1,
	'succeeds');
INSERT INTO O_RTIDA
	VALUES (168,
	37,
	0,
	1004,
	1005);
INSERT INTO O_RTIDA
	VALUES (169,
	37,
	0,
	1004,
	1005);
INSERT INTO R_RTO
	VALUES (37,
	1004,
	1005,
	0);
INSERT INTO R_OIR
	VALUES (37,
	1004,
	1005,
	0);
INSERT INTO R_FORM
	VALUES (37,
	1004,
	1006,
	0,
	1,
	'precedes');
INSERT INTO R_RGO
	VALUES (37,
	1004,
	1006);
INSERT INTO R_OIR
	VALUES (37,
	1004,
	1006,
	0);
INSERT INTO R_SIMP
	VALUES (1007);
INSERT INTO R_REL
	VALUES (1007,
	114,
	'CrossComponent:true',
	979);
INSERT INTO R_PART
	VALUES (32,
	1007,
	1008,
	0,
	0,
	'defines type of');
INSERT INTO O_RTIDA
	VALUES (156,
	32,
	0,
	1007,
	1008);
INSERT INTO R_RTO
	VALUES (32,
	1007,
	1008,
	0);
INSERT INTO R_OIR
	VALUES (32,
	1007,
	1008,
	981);
INSERT INTO R_FORM
	VALUES (37,
	1007,
	1009,
	1,
	1,
	'is defined by');
INSERT INTO R_RGO
	VALUES (37,
	1007,
	1009);
INSERT INTO R_OIR
	VALUES (37,
	1007,
	1009,
	0);
INSERT INTO R_SUBSUP
	VALUES (1010);
INSERT INTO R_REL
	VALUES (1010,
	106,
	'',
	979);
INSERT INTO R_SUPER
	VALUES (37,
	1010,
	1011);
INSERT INTO O_RTIDA
	VALUES (168,
	37,
	0,
	1010,
	1011);
INSERT INTO O_RTIDA
	VALUES (169,
	37,
	0,
	1010,
	1011);
INSERT INTO R_RTO
	VALUES (37,
	1010,
	1011,
	0);
INSERT INTO R_OIR
	VALUES (37,
	1010,
	1011,
	0);
INSERT INTO R_SUB
	VALUES (1012,
	1010,
	1013);
INSERT INTO R_RGO
	VALUES (1012,
	1010,
	1013);
INSERT INTO R_OIR
	VALUES (1012,
	1010,
	1013,
	0);
INSERT INTO R_SUB
	VALUES (1014,
	1010,
	1015);
INSERT INTO R_RGO
	VALUES (1014,
	1010,
	1015);
INSERT INTO R_OIR
	VALUES (1014,
	1010,
	1015,
	0);
INSERT INTO R_SIMP
	VALUES (1016);
INSERT INTO R_REL
	VALUES (1016,
	113,
	'CrossComponent:true',
	979);
INSERT INTO R_PART
	VALUES (1012,
	1016,
	1017,
	0,
	0,
	'navigates back to');
INSERT INTO O_RTIDA
	VALUES (1018,
	1012,
	0,
	1016,
	1017);
INSERT INTO O_RTIDA
	VALUES (1019,
	1012,
	0,
	1016,
	1017);
INSERT INTO R_RTO
	VALUES (1012,
	1016,
	1017,
	0);
INSERT INTO R_OIR
	VALUES (1012,
	1016,
	1017,
	0);
INSERT INTO R_FORM
	VALUES (1014,
	1016,
	1020,
	1,
	1,
	'can be the base of');
INSERT INTO R_RGO
	VALUES (1014,
	1016,
	1020);
INSERT INTO R_OIR
	VALUES (1014,
	1016,
	1020,
	0);
INSERT INTO R_SUBSUP
	VALUES (1021);
INSERT INTO R_REL
	VALUES (1021,
	107,
	'',
	979);
INSERT INTO R_SUPER
	VALUES (1012,
	1021,
	1022);
INSERT INTO O_RTIDA
	VALUES (1018,
	1012,
	0,
	1021,
	1022);
INSERT INTO O_RTIDA
	VALUES (1019,
	1012,
	0,
	1021,
	1022);
INSERT INTO R_RTO
	VALUES (1012,
	1021,
	1022,
	0);
INSERT INTO R_OIR
	VALUES (1012,
	1021,
	1022,
	0);
INSERT INTO R_SUB
	VALUES (1023,
	1021,
	1024);
INSERT INTO R_RGO
	VALUES (1023,
	1021,
	1024);
INSERT INTO R_OIR
	VALUES (1023,
	1021,
	1024,
	0);
INSERT INTO R_SUB
	VALUES (1025,
	1021,
	1026);
INSERT INTO R_RGO
	VALUES (1025,
	1021,
	1026);
INSERT INTO R_OIR
	VALUES (1025,
	1021,
	1026,
	0);
INSERT INTO R_SIMP
	VALUES (1027);
INSERT INTO R_REL
	VALUES (1027,
	108,
	'',
	979);
INSERT INTO R_FORM
	VALUES (1028,
	1027,
	1029,
	1,
	0,
	'resolves ');
INSERT INTO R_RGO
	VALUES (1028,
	1027,
	1029);
INSERT INTO R_OIR
	VALUES (1028,
	1027,
	1029,
	0);
INSERT INTO R_PART
	VALUES (1014,
	1027,
	1030,
	0,
	0,
	'is resolved by');
INSERT INTO O_RTIDA
	VALUES (1031,
	1014,
	0,
	1027,
	1030);
INSERT INTO O_RTIDA
	VALUES (1032,
	1014,
	0,
	1027,
	1030);
INSERT INTO R_RTO
	VALUES (1014,
	1027,
	1030,
	0);
INSERT INTO R_OIR
	VALUES (1014,
	1027,
	1030,
	0);
INSERT INTO R_SIMP
	VALUES (1033);
INSERT INTO R_REL
	VALUES (1033,
	112,
	'',
	979);
INSERT INTO R_PART
	VALUES (1028,
	1033,
	1034,
	0,
	1,
	'succeeds');
INSERT INTO O_RTIDA
	VALUES (1035,
	1028,
	1,
	1033,
	1034);
INSERT INTO R_RTO
	VALUES (1028,
	1033,
	1034,
	1);
INSERT INTO R_OIR
	VALUES (1028,
	1033,
	1034,
	0);
INSERT INTO R_FORM
	VALUES (1028,
	1033,
	1036,
	0,
	1,
	'precedes');
INSERT INTO R_RGO
	VALUES (1028,
	1033,
	1036);
INSERT INTO R_OIR
	VALUES (1028,
	1033,
	1036,
	0);
INSERT INTO R_ASSOC
	VALUES (1037);
INSERT INTO R_REL
	VALUES (1037,
	105,
	'',
	979);
INSERT INTO R_AOTH
	VALUES (37,
	1037,
	1038,
	1,
	1,
	'is made up of ');
INSERT INTO O_RTIDA
	VALUES (168,
	37,
	0,
	1037,
	1038);
INSERT INTO O_RTIDA
	VALUES (169,
	37,
	0,
	1037,
	1038);
INSERT INTO R_RTO
	VALUES (37,
	1037,
	1038,
	0);
INSERT INTO R_OIR
	VALUES (37,
	1037,
	1038,
	0);
INSERT INTO R_AONE
	VALUES (1039,
	1037,
	1040,
	1,
	1,
	'is part of ');
INSERT INTO O_RTIDA
	VALUES (1041,
	1039,
	0,
	1037,
	1040);
INSERT INTO O_RTIDA
	VALUES (1042,
	1039,
	0,
	1037,
	1040);
INSERT INTO R_RTO
	VALUES (1039,
	1037,
	1040,
	0);
INSERT INTO R_OIR
	VALUES (1039,
	1037,
	1040,
	0);
INSERT INTO R_ASSR
	VALUES (1043,
	1037,
	1044,
	0);
INSERT INTO R_RGO
	VALUES (1043,
	1037,
	1044);
INSERT INTO R_OIR
	VALUES (1043,
	1037,
	1044,
	0);
INSERT INTO R_SIMP
	VALUES (1045);
INSERT INTO R_REL
	VALUES (1045,
	104,
	'',
	979);
INSERT INTO R_FORM
	VALUES (1039,
	1045,
	1046,
	1,
	1,
	'is identified by');
INSERT INTO R_RGO
	VALUES (1039,
	1045,
	1046);
INSERT INTO R_OIR
	VALUES (1039,
	1045,
	1046,
	0);
INSERT INTO R_PART
	VALUES (30,
	1045,
	1047,
	0,
	0,
	'identifies');
INSERT INTO O_RTIDA
	VALUES (150,
	30,
	0,
	1045,
	1047);
INSERT INTO R_RTO
	VALUES (30,
	1045,
	1047,
	0);
INSERT INTO R_OIR
	VALUES (30,
	1045,
	1047,
	0);
INSERT INTO R_SIMP
	VALUES (1048);
INSERT INTO R_REL
	VALUES (1048,
	101,
	'CrossComponent:true',
	979);
INSERT INTO R_PART
	VALUES (30,
	1048,
	1049,
	0,
	1,
	'represents');
INSERT INTO O_RTIDA
	VALUES (150,
	30,
	0,
	1048,
	1049);
INSERT INTO R_RTO
	VALUES (30,
	1048,
	1049,
	0);
INSERT INTO R_OIR
	VALUES (30,
	1048,
	1049,
	0);
INSERT INTO R_FORM
	VALUES (1050,
	1048,
	1051,
	1,
	1,
	'has presence in other subsystems');
INSERT INTO R_RGO
	VALUES (1050,
	1048,
	1051);
INSERT INTO R_OIR
	VALUES (1050,
	1048,
	1051,
	0);
INSERT INTO R_ASSOC
	VALUES (1052);
INSERT INTO R_REL
	VALUES (1052,
	110,
	'CrossComponent:true',
	979);
INSERT INTO R_AONE
	VALUES (983,
	1052,
	1053,
	1,
	1,
	'identifies for this association');
INSERT INTO O_RTIDA
	VALUES (1054,
	983,
	1,
	1052,
	1053);
INSERT INTO O_RTIDA
	VALUES (1055,
	983,
	1,
	1052,
	1053);
INSERT INTO O_RTIDA
	VALUES (1056,
	983,
	1,
	1052,
	1053);
INSERT INTO O_RTIDA
	VALUES (1057,
	983,
	1,
	1052,
	1053);
INSERT INTO R_RTO
	VALUES (983,
	1052,
	1053,
	1);
INSERT INTO R_OIR
	VALUES (983,
	1052,
	1053,
	982);
INSERT INTO R_AOTH
	VALUES (1043,
	1052,
	1058,
	1,
	0,
	'is identified in this association by');
INSERT INTO O_RTIDA
	VALUES (1059,
	1043,
	0,
	1052,
	1058);
INSERT INTO O_RTIDA
	VALUES (1060,
	1043,
	0,
	1052,
	1058);
INSERT INTO O_RTIDA
	VALUES (1061,
	1043,
	0,
	1052,
	1058);
INSERT INTO R_RTO
	VALUES (1043,
	1052,
	1058,
	0);
INSERT INTO R_OIR
	VALUES (1043,
	1052,
	1058,
	0);
INSERT INTO R_ASSR
	VALUES (1062,
	1052,
	1063,
	0);
INSERT INTO R_RGO
	VALUES (1062,
	1052,
	1063);
INSERT INTO R_OIR
	VALUES (1062,
	1052,
	1063,
	0);
INSERT INTO R_SIMP
	VALUES (1064);
INSERT INTO R_REL
	VALUES (1064,
	109,
	'CrossComponent:true',
	979);
INSERT INTO R_FORM
	VALUES (983,
	1064,
	1065,
	1,
	1,
	'identifies for this association ');
INSERT INTO R_RGO
	VALUES (983,
	1064,
	1065);
INSERT INTO R_OIR
	VALUES (983,
	1064,
	1065,
	982);
INSERT INTO R_PART
	VALUES (1039,
	1064,
	1066,
	0,
	1,
	'is identified in this association by');
INSERT INTO O_RTIDA
	VALUES (1041,
	1039,
	0,
	1064,
	1066);
INSERT INTO O_RTIDA
	VALUES (1042,
	1039,
	0,
	1064,
	1066);
INSERT INTO R_RTO
	VALUES (1039,
	1064,
	1066,
	0);
INSERT INTO R_OIR
	VALUES (1039,
	1064,
	1066,
	0);
INSERT INTO R_ASSOC
	VALUES (1067);
INSERT INTO R_REL
	VALUES (1067,
	111,
	'CrossComponent:true',
	979);
INSERT INTO R_AONE
	VALUES (985,
	1067,
	1068,
	1,
	1,
	'is used to refer class by');
INSERT INTO O_RTIDA
	VALUES (1069,
	985,
	0,
	1067,
	1068);
INSERT INTO O_RTIDA
	VALUES (1070,
	985,
	0,
	1067,
	1068);
INSERT INTO O_RTIDA
	VALUES (1071,
	985,
	0,
	1067,
	1068);
INSERT INTO R_RTO
	VALUES (985,
	1067,
	1068,
	0);
INSERT INTO R_OIR
	VALUES (985,
	1067,
	1068,
	984);
INSERT INTO R_AOTH
	VALUES (1062,
	1067,
	1072,
	1,
	1,
	'refers across association via');
INSERT INTO O_RTIDA
	VALUES (1073,
	1062,
	0,
	1067,
	1072);
INSERT INTO O_RTIDA
	VALUES (1074,
	1062,
	0,
	1067,
	1072);
INSERT INTO O_RTIDA
	VALUES (1075,
	1062,
	0,
	1067,
	1072);
INSERT INTO O_RTIDA
	VALUES (1076,
	1062,
	0,
	1067,
	1072);
INSERT INTO O_RTIDA
	VALUES (1077,
	1062,
	0,
	1067,
	1072);
INSERT INTO R_RTO
	VALUES (1062,
	1067,
	1072,
	0);
INSERT INTO R_OIR
	VALUES (1062,
	1067,
	1072,
	0);
INSERT INTO R_ASSR
	VALUES (1028,
	1067,
	1078,
	0);
INSERT INTO R_RGO
	VALUES (1028,
	1067,
	1078);
INSERT INTO R_OIR
	VALUES (1028,
	1067,
	1078,
	0);
INSERT INTO R_SIMP
	VALUES (1079);
INSERT INTO R_REL
	VALUES (1079,
	119,
	'Notify_Changes:false',
	979);
INSERT INTO R_PART
	VALUES (1080,
	1079,
	1081,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (1082,
	1080,
	0,
	1079,
	1081);
INSERT INTO R_RTO
	VALUES (1080,
	1079,
	1081,
	0);
INSERT INTO R_OIR
	VALUES (1080,
	1079,
	1081,
	0);
INSERT INTO R_FORM
	VALUES (1014,
	1079,
	1083,
	1,
	1,
	'visited');
INSERT INTO R_RGO
	VALUES (1014,
	1079,
	1083);
INSERT INTO R_OIR
	VALUES (1014,
	1079,
	1083,
	0);
INSERT INTO R_SIMP
	VALUES (1084);
INSERT INTO R_REL
	VALUES (1084,
	120,
	'',
	979);
INSERT INTO R_PART
	VALUES (37,
	1084,
	1085,
	0,
	1,
	'specifies occurrences of');
INSERT INTO O_RTIDA
	VALUES (168,
	37,
	0,
	1084,
	1085);
INSERT INTO O_RTIDA
	VALUES (169,
	37,
	0,
	1084,
	1085);
INSERT INTO R_RTO
	VALUES (37,
	1084,
	1085,
	0);
INSERT INTO R_OIR
	VALUES (37,
	1084,
	1085,
	0);
INSERT INTO R_FORM
	VALUES (59,
	1084,
	1086,
	1,
	1,
	'may have');
INSERT INTO R_RGO
	VALUES (59,
	1084,
	1086);
INSERT INTO R_OIR
	VALUES (59,
	1084,
	1086,
	986);
INSERT INTO R_SIMP
	VALUES (1087);
INSERT INTO R_REL
	VALUES (1087,
	121,
	'',
	979);
INSERT INTO R_PART
	VALUES (50,
	1087,
	1088,
	0,
	1,
	'specifies occurrences of');
INSERT INTO O_RTIDA
	VALUES (219,
	50,
	0,
	1087,
	1088);
INSERT INTO R_RTO
	VALUES (50,
	1087,
	1088,
	0);
INSERT INTO R_OIR
	VALUES (50,
	1087,
	1088,
	0);
INSERT INTO R_FORM
	VALUES (59,
	1087,
	1089,
	1,
	1,
	'may have');
INSERT INTO R_RGO
	VALUES (59,
	1087,
	1089);
INSERT INTO R_OIR
	VALUES (59,
	1087,
	1089,
	986);
INSERT INTO R_SIMP
	VALUES (1090);
INSERT INTO R_REL
	VALUES (1090,
	122,
	'',
	979);
INSERT INTO R_PART
	VALUES (43,
	1090,
	1091,
	0,
	1,
	'defines return value dimensions for');
INSERT INTO O_RTIDA
	VALUES (201,
	43,
	0,
	1090,
	1091);
INSERT INTO R_RTO
	VALUES (43,
	1090,
	1091,
	0);
INSERT INTO R_OIR
	VALUES (43,
	1090,
	1091,
	0);
INSERT INTO R_FORM
	VALUES (59,
	1090,
	1092,
	1,
	1,
	'return value may have');
INSERT INTO R_RGO
	VALUES (59,
	1090,
	1092);
INSERT INTO R_OIR
	VALUES (59,
	1090,
	1092,
	986);
INSERT INTO R_SIMP
	VALUES (1093);
INSERT INTO R_REL
	VALUES (1093,
	123,
	'CrossComponent:true',
	979);
INSERT INTO R_PART
	VALUES (30,
	1093,
	1094,
	0,
	0,
	'provides reference datatype for');
INSERT INTO O_RTIDA
	VALUES (150,
	30,
	0,
	1093,
	1094);
INSERT INTO R_RTO
	VALUES (30,
	1093,
	1094,
	0);
INSERT INTO R_OIR
	VALUES (30,
	1093,
	1094,
	0);
INSERT INTO R_FORM
	VALUES (988,
	1093,
	1095,
	1,
	1,
	'is available as a reference by');
INSERT INTO R_RGO
	VALUES (988,
	1093,
	1095);
INSERT INTO R_OIR
	VALUES (988,
	1093,
	1095,
	987);
INSERT INTO R_SIMP
	VALUES (1096);
INSERT INTO R_REL
	VALUES (1096,
	124,
	'',
	979);
INSERT INTO R_PART
	VALUES (50,
	1096,
	1097,
	0,
	1,
	'succeeds');
INSERT INTO O_RTIDA
	VALUES (219,
	50,
	0,
	1096,
	1097);
INSERT INTO R_RTO
	VALUES (50,
	1096,
	1097,
	0);
INSERT INTO R_OIR
	VALUES (50,
	1096,
	1097,
	0);
INSERT INTO R_FORM
	VALUES (50,
	1096,
	1098,
	0,
	1,
	'precedes');
INSERT INTO R_RGO
	VALUES (50,
	1096,
	1098);
INSERT INTO R_OIR
	VALUES (50,
	1096,
	1098,
	0);
INSERT INTO R_SIMP
	VALUES (1099);
INSERT INTO R_REL
	VALUES (1099,
	125,
	'',
	979);
INSERT INTO R_PART
	VALUES (43,
	1099,
	1100,
	0,
	1,
	'succeeds');
INSERT INTO O_RTIDA
	VALUES (201,
	43,
	0,
	1099,
	1100);
INSERT INTO R_RTO
	VALUES (43,
	1099,
	1100,
	0);
INSERT INTO R_OIR
	VALUES (43,
	1099,
	1100,
	0);
INSERT INTO R_FORM
	VALUES (43,
	1099,
	1101,
	0,
	1,
	'precedes');
INSERT INTO R_RGO
	VALUES (43,
	1099,
	1101);
INSERT INTO R_OIR
	VALUES (43,
	1099,
	1101,
	0);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (1062,
	'Referred To Identifier Attribute',
	111,
	'O_RTIDA',
	'This class serves a linkage between R# (Attribute Reference in Class ) and the referred to class identifier attribute.',
	979);
INSERT INTO O_TFR
	VALUES (1102,
	1062,
	'dispose',
	'Dispose this O_RTIDA.
',
	19,
	1,
	'select many refs related by self->O_REF[R111];
for each ref in refs
  ref.migrateRefAttrOrDispose();
end for;
select one oida related by self->O_OIDA[R110];
select one rto related by self->R_RTO[R110];
unrelate oida from rto across R110 using self;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (1103,
	1062,
	'get_name',
	'',
	322,
	1,
	'select one cia related by self->O_OIDA[R110];
select one assoc related by self->R_RTO[R110]->R_OIR[R203]->R_REL[R201];
result = cia.localAttributeName + " {R"; 
result = result + GD::int_to_string(value: assoc.Numb);
result = result + "}";
return result;',
	1,
	'',
	1102);
INSERT INTO O_REF
	VALUES (1062,
	1043,
	0,
	1059,
	1052,
	1063,
	1058,
	1073,
	1104,
	0,
	0,
	'',
	'Class Identifier Attribute',
	'Attr_ID',
	'R110');
INSERT INTO O_RATTR
	VALUES (1073,
	1062,
	168,
	37,
	1,
	'Attr_ID');
INSERT INTO O_ATTR
	VALUES (1073,
	1062,
	0,
	'Attr_ID',
	'',
	'',
	'Attr_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1062,
	983,
	1,
	1054,
	1052,
	1063,
	1053,
	1075,
	1105,
	0,
	0,
	'',
	'Referred To Class in Assoc',
	'Oid_ID',
	'R110');
INSERT INTO O_REF
	VALUES (1062,
	1043,
	0,
	1060,
	1052,
	1063,
	1058,
	1075,
	1106,
	1105,
	0,
	'',
	'Class Identifier Attribute',
	'Oid_ID',
	'R110');
INSERT INTO O_RATTR
	VALUES (1075,
	1062,
	1041,
	1039,
	1,
	'Oid_ID');
INSERT INTO O_ATTR
	VALUES (1075,
	1062,
	1076,
	'Oid_ID',
	'',
	'',
	'Oid_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1062,
	983,
	1,
	1055,
	1052,
	1063,
	1053,
	1074,
	1107,
	0,
	0,
	'',
	'Referred To Class in Assoc',
	'OIR_ID',
	'R110');
INSERT INTO O_RATTR
	VALUES (1074,
	1062,
	1108,
	1109,
	1,
	'OIR_ID');
INSERT INTO O_ATTR
	VALUES (1074,
	1062,
	1077,
	'OIR_ID',
	'',
	'',
	'OIR_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1062,
	1043,
	0,
	1061,
	1052,
	1063,
	1058,
	1076,
	1110,
	0,
	0,
	'',
	'Class Identifier Attribute',
	'Obj_ID',
	'R110');
INSERT INTO O_REF
	VALUES (1062,
	983,
	1,
	1056,
	1052,
	1063,
	1053,
	1076,
	1111,
	1110,
	0,
	'',
	'Referred To Class in Assoc',
	'Obj_ID',
	'R110');
INSERT INTO O_RATTR
	VALUES (1076,
	1062,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (1076,
	1062,
	1073,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1062,
	983,
	1,
	1057,
	1052,
	1063,
	1053,
	1077,
	1112,
	0,
	0,
	'',
	'Referred To Class in Assoc',
	'Rel_ID',
	'R110');
INSERT INTO O_RATTR
	VALUES (1077,
	1062,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (1077,
	1062,
	1075,
	'Rel_ID',
	'',
	'',
	'Rel_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	1062);
INSERT INTO O_OIDA
	VALUES (1073,
	1062,
	0,
	'Attr_ID');
INSERT INTO O_OIDA
	VALUES (1074,
	1062,
	0,
	'OIR_ID');
INSERT INTO O_OIDA
	VALUES (1075,
	1062,
	0,
	'Oid_ID');
INSERT INTO O_OIDA
	VALUES (1076,
	1062,
	0,
	'Obj_ID');
INSERT INTO O_OIDA
	VALUES (1077,
	1062,
	0,
	'Rel_ID');
INSERT INTO O_ID
	VALUES (1,
	1062);
INSERT INTO O_ID
	VALUES (2,
	1062);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (1080,
	'Referential Attribute Visited Recorder',
	114,
	'O_RAVR',
	'A non-persistent instance of this class is created per domain.  The sole 
purpose of this instance is to allow instances of Referential Attribute to 
be related to it across R119 as a way to mark that they have been visited
during a traversal from a referential attribute to its base attribute. 
This marking is performed in order to avoid an infinite loop during the 
traversal caused by any circular referencing that may be present.  

Persistent:false
User_Visible:false
TRANSLATE_FOR_EXTERNAL_USE:FALSE',
	979);
INSERT INTO O_TFR
	VALUES (1113,
	1080,
	'setAllToNotVisited',
	'',
	19,
	1,
	'// for each visited attribute
select many attributes related by self->O_RATTR[R119];
for each attribute in attributes
   	// make this attribute no longer visited
   	unrelate attribute from self across R119;
end for;',
	2,
	'',
	1114);
INSERT INTO O_TFR
	VALUES (1114,
	1080,
	'areAnyVisited',
	'',
	316,
	1,
	'select any attribute related by self->O_RATTR[R119];
return not_empty attribute;',
	1,
	'',
	0);
INSERT INTO O_NBATTR
	VALUES (1082,
	1080);
INSERT INTO O_BATTR
	VALUES (1082,
	1080);
INSERT INTO O_ATTR
	VALUES (1082,
	1080,
	0,
	'recorderId',
	'Persistent:false
User_Visible:false
TRANSLATE_FOR_EXTERNAL_USE:FALSE',
	'',
	'recorderId',
	0,
	296,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	1080);
INSERT INTO O_OIDA
	VALUES (1082,
	1080,
	0,
	'recorderId');
INSERT INTO O_ID
	VALUES (1,
	1080);
INSERT INTO O_ID
	VALUES (2,
	1080);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (1014,
	'Referential Attribute',
	109,
	'O_RATTR',
	'A referential attribute captures the formalization of an association.  A referential attribute refers to an identifying attribute in the class at the other end of the association which it formalizes.',
	979);
INSERT INTO O_TFR
	VALUES (1115,
	1014,
	'dispose',
	'Dispose of this Referential Attribute.
',
	19,
	1,
	'select one battr related by self->O_BATTR[R113];
if (not_empty battr)
  unrelate self from battr across R113;
end if;
select many refs related by self->O_REF[R108];
for each ref in refs
  unrelate self from ref across R108;
  ref.dispose();
end for;
select one attr related by self->O_ATTR[R106];
if ( not_empty attr )
  unrelate self from attr across R106;
end if;
delete object instance self;',
	1,
	'',
	1116);
INSERT INTO O_TFR
	VALUES (1117,
	1014,
	'migrateToBase',
	'Migrate this Referntial Attribute to a Base Attribute.  This may be neccessary when it no longer refers to anything but is still part of the class identifier.
',
	19,
	1,
	'select one attr related by self->O_ATTR[R106];
unrelate self from attr across R106;
// Make the new base attribute have the same
// data type as the original
select one battr related by self->O_BATTR[R113];
if (not_empty battr)
  unrelate self from battr across R113;
  // Migrate the data type of self to the type of the old referred to attribute
  select one battrType related by battr->O_ATTR[R106]->S_DT[R114];
  select one attrType related by attr->S_DT[R114];
  unrelate attr from attrType across R114;
  relate attr to battrType across R114;
end if;
create object instance battr of O_BATTR;
relate attr to battr across R106;
create object instance nbattr of O_NBATTR;
relate nbattr to battr across R107;
// Now change the base attribute of all referring
// referentials to this new base.
select many rtoRefs related by attr->O_OIDA[R105]->
                             O_RTIDA[R110]->O_REF[R111]->O_RATTR[R108];
for each ref in rtoRefs
  select one oldBattr related by ref->O_BATTR[R113];
  unrelate ref from oldBattr across R113;
  relate ref to battr across R113;
end for;
self.dispose();
',
	1,
	'',
	1118);
INSERT INTO O_TFR
	VALUES (1119,
	1014,
	'get_name',
	'',
	322,
	1,
	'select one attr related by self->O_ATTR[R106];
   result = attr.Name;
   select many ref_set related by self->O_REF[R108];
   for each ref in ref_set
     result = result + " (" + ref.get_text(includeTextPhrase:true) + ")";
   end for;
   return result;',
	1,
	'',
	1115);
INSERT INTO O_TFR
	VALUES (1118,
	1014,
	'isOrphaned',
	'',
	316,
	1,
	'select any rattr_root related by self->O_REF[R108]->O_RTIDA[R111]->O_OIDA[R110]->O_ATTR[R105];
return empty rattr_root;
',
	1,
	'',
	1120);
INSERT INTO O_TFR
	VALUES (1116,
	1014,
	'combine_refs',
	'',
	19,
	1,
	'select any other_attr related by self->O_ATTR[R106]->O_OBJ[R102]->O_ATTR[R102]
       where selected.Attr_ID == param.other_id;
select one other_rattr related by other_attr->O_RATTR[R106];
select many other_ref_set related by other_rattr->O_REF[R108];
   
   // find last O_REF in self''s ref list R112
   select any ref related by self->O_REF[R108];
   select one next_ref related by ref->O_REF[R112.''precedes''];
   while (not_empty next_ref)
     select one next_ref related by ref->O_REF[R112.''precedes''];
     if (not_empty next_ref)
       ref = next_ref;
     end if;
   end while;
   
   for each other_ref in other_ref_set
     unrelate other_ref from other_rattr across R108;
     relate other_ref to self across R108;  
     // add other_ref to self''s ref list R112
     relate other_ref to ref across R112.''succeeds'';
     ref = other_ref;    
   end for;
   select any oida related by other_attr->O_OIDA[R105];
   if ( not_empty oida )  // attribute is identifying
     other_rattr.migrateToBase();
   else
     other_attr.dispose();
   end if;',
	1,
	'',
	1121);
INSERT INTO O_TPARM
	VALUES (1122,
	1116,
	'other_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1123,
	1014,
	'split_refs',
	'',
	19,
	1,
	'select any other_ref related by self->O_REF[R108]
       where selected.ARef_ID == param.other_id;
       
   // remove other_ref from self''s R112 list
   select one next_ref related by other_ref->O_REF[R112.''precedes''];
   select one prev_ref related by other_ref->O_REF[R112.''succeeds''];
   if (empty next_ref)
     unrelate prev_ref from other_ref across R112.''precedes'';  
   elif (empty prev_ref)
     unrelate other_ref from next_ref across R112.''precedes''; 
   else
     unrelate other_ref from next_ref across R112.''precedes''; 
     unrelate prev_ref from other_ref across R112.''precedes''; 
     relate next_ref to prev_ref across R112.''succeeds'';  
   end if; 
    
   unrelate other_ref from self across R108;
   // create referential attribute
   select one mc related by self->O_ATTR[R106]->O_OBJ[R102];
   newAttr_id = mc.newReferentialAttribute(ref_obj_id: other_ref.RObj_ID, 
       ref_oid_id: other_ref.ROid_ID, ref_attr_id: other_ref.RAttr_ID, id: -1 );
   
   select any newRattr related by mc->O_ATTR[R102]->O_RATTR[R106] 
        where selected.Attr_ID == newAttr_id;
   relate other_ref to newRattr across R108;',
	1,
	'',
	1124);
INSERT INTO O_TPARM
	VALUES (1125,
	1123,
	'other_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1121,
	1014,
	'alreadyCombinedWith',
	'',
	316,
	1,
	'select any ref related by self->O_REF[R108]
  where ( selected.Attr_ID == param.id );
return not_empty ref;',
	1,
	'',
	1126);
INSERT INTO O_TPARM
	VALUES (1127,
	1121,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1120,
	1014,
	'get_root_name_internal',
	'',
	322,
	1,
	'if ( self.Ref_Mode == 0 )  // use local root
  select one attr related by self->O_ATTR[R106];
  return attr.Root_Nam;
else
  select many oref_set related by self->O_REF[R108];
  for each oref in oref_set
    select one attr related by oref->O_RTIDA[R111]->O_OIDA[R110]->O_ATTR[R105];
    if ( not_empty attr )
      root_name = attr.get_root();
      if ( root_name != O_RATTR::ROOT_LOOP_STRING() )
        return root_name;
      end if;
    else
      return self.BaseAttrName;
    end if;
  end for;
end if;

// We didn''t find anything
return self.BaseAttrName;
',
	1,
	'',
	1128);
INSERT INTO O_TFR
	VALUES (1129,
	1014,
	'get_prefix_string_internal',
	'',
	322,
	1,
	'select one attr related by self->O_ATTR[R106];
if ( attr.Pfx_Mode == 1 )  // use local prefix
  return attr.Prefix;
elif ( attr.Pfx_Mode == 2 )  // use referred to prefix
  select many oref_set related by self->O_REF[R108];
  for each oref in oref_set
    select one root_attr related by oref->O_RTIDA[R111]->O_OIDA[R110]->O_ATTR[R105];
    if ( not_empty root_attr )
      prefix = root_attr.get_prefix();
      if ( prefix != O_RATTR::PREFIX_LOOP_STRING() )
        return prefix;
      end if;
    else
      return self.BaseAttrName;
    end if;
  end for;
  // We didn''t find anything
  return self.BaseAttrName;
else  // no prefix
  return "";
end if;
',
	1,
	'',
	1130);
INSERT INTO O_TFR
	VALUES (1124,
	1014,
	'setDatatype',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// assure that the datatype is the correct one for
// referential attributes
select one attr related by self->O_ATTR[R106];
select one dt related by attr->S_DT[R114];
if ( not_empty dt )
  if ( dt.Name == "same_as<Base_Attribute>" )
    return;
  else
    unrelate attr from dt across R114;
  end if;
end if;


isInGenericPkg = false;
select one pkg related by attr->O_OBJ[R102]->PE_PE[R8001]->EP_PKG[R8000];
if (not_empty pkg)
  isInGenericPkg = true;
end if;

if (isInGenericPkg)
  select one system related by pkg->S_SYS[R1405];
  dt_id = GD::NULL_UNIQUE_ID();
  if not_empty system
    dt_id = system.getCoreTypeId(name:"same_as<Base_Attribute>");
  end if;
  select any pe from instances of PE_PE where selected.Element_ID == dt_id;
  select one ref_attr_dt related by pe->S_DT[R8001]; 
  if (empty ref_attr_dt)
    USER::logError(msg:
                  "Unable to locate expected data type: same_as<Base_Attribute>",path:"PathNotProvided");
  else
    relate attr to ref_attr_dt across R114;
  end if;
else
  select any dom from instances of S_DOM;
  select any ref_attr_dt related by dom->S_DT[R14] where
                                     selected.Name == "same_as<Base_Attribute>";
  if(empty ref_attr_dt)
    // if the ref attr dt was not found check the system level
    // dts, but only if the domain found is the formal content
    // of a component
    if(dom.participatesInSystem())
      select one system related by dom->CN_DC[R4204]->C_C[R4204]->CP_CP[R4608]
                                                                 ->S_SYS[R4606];
      dt_id = GD::NULL_UNIQUE_ID();
      if not_empty system
        dt_id = system.getCoreTypeId(name:"same_as<Base_Attribute>");
      end if;
      select any pe from instances of PE_PE where selected.Element_ID == dt_id;
      select one ref_attr_dt related by pe->S_DT[R8001]; 
    else
      // this is an error, if the domain is not
      // participating at the system level and
      // we cannot find the type at the domain
      // level we have a problem
      USER::logError(msg:
                  "Unable to locate expected data type: same_as<Base_Attribute>",path:"PathNotProvided");
    end if;
  end if;
  relate attr to ref_attr_dt across R114;
end if;   

',
	1,
	'',
	1117);
INSERT INTO O_TFR
	VALUES (1131,
	1014,
	'get_root',
	'',
	322,
	1,
	'tmp_root = "";

select one recorder related by self->O_RAVR[R119];
if (not_empty recorder)
	tmp_root = O_RATTR::ROOT_LOOP_STRING();
elif ( self.Ref_Mode == 0 )   // Local Attribute
    select one attr related by self->O_ATTR[R106];
	tmp_root = attr.Root_Nam;
elif ( self.Ref_Mode == 1 )  // Referred To Attribute
   	select any recorder from instances of O_RAVR;
   	if(empty recorder)
      create object instance recorder of O_RAVR;
    end if;
   	relate self to recorder across R119;
	tmp_root = self.get_root_name_internal();
   	unrelate self from recorder across R119;
// when calls are all finished, all visited attributes should be false
end if;

return tmp_root ;
',
	1,
	'',
	1129);
INSERT INTO O_TFR
	VALUES (1126,
	1014,
	'ROOT_LOOP_STRING',
	'',
	322,
	0,
	'return "< Name Loop >";',
	1,
	'',
	1132);
INSERT INTO O_TFR
	VALUES (1132,
	1014,
	'PREFIX_LOOP_STRING',
	'',
	322,
	0,
	'return "< Prefix Loop >";
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (1133,
	1014,
	'get_prefix',
	'',
	322,
	1,
	'tmp_prefix = "";
select one recorder related by self->O_RAVR[R119];
if (not_empty recorder)
	tmp_prefix = O_RATTR::PREFIX_LOOP_STRING();
else
  select one attr related by self->O_ATTR[R106];
  if ( attr.Pfx_Mode == 1 )   // Local Prefix
	tmp_prefix = attr.Prefix;
  elif ( attr.Pfx_Mode == 2 )  // Referred To Prefix
   	select any recorder from instances of O_RAVR;
   	if(empty recorder)
      create object instance recorder of O_RAVR;
    end if;
   	
   	relate self to recorder across R119;
	tmp_prefix = self.get_prefix_string_internal();
   	unrelate self from recorder across R119;
    // when calls are all finished, all visited attributes should be false
  end if;
end if;

// no prefix is handled by default
return tmp_prefix ;
',
	1,
	'',
	1119);
INSERT INTO O_TFR
	VALUES (1128,
	1014,
	'get_root_name',
	'',
	322,
	1,
	'select any recorder from instances of O_RAVR;
if(empty recorder)
  create object instance recorder of O_RAVR;
end if;

recorder.setAllToNotVisited();

result = self.get_root_name_internal();
   
// assert that there are no visited referential attributes
if (recorder.areAnyVisited())
   USER::logError(msg:"Assertion failed: get_root_name(): referential attribute is still marked as visited",path:"");
end if;
   
return result;',
	1,
	'',
	1131);
INSERT INTO O_TFR
	VALUES (1130,
	1014,
	'get_prefix_string',
	'',
	322,
	1,
	'select any recorder from instances of O_RAVR;
if(empty recorder)
  create object instance recorder of O_RAVR;
end if;

recorder.setAllToNotVisited();
   
result = self.get_prefix_string_internal();
  
// assert that there are no visited referential attributes
if (recorder.areAnyVisited())
   USER::logError(msg:"Assertion failed: get_prefix_string(): referential attribute is still marked as visited",path:"");
end if;
   
return result;',
	1,
	'',
	1133);
INSERT INTO O_REF
	VALUES (1014,
	37,
	0,
	168,
	1010,
	1015,
	1011,
	1031,
	1134,
	0,
	0,
	'',
	'Attribute',
	'Attr_ID',
	'R106');
INSERT INTO O_RATTR
	VALUES (1031,
	1014,
	168,
	37,
	1,
	'Attr_ID');
INSERT INTO O_ATTR
	VALUES (1031,
	1014,
	0,
	'Attr_ID',
	'',
	'',
	'Attr_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1014,
	1012,
	0,
	1018,
	1016,
	1020,
	1017,
	1135,
	1136,
	0,
	1,
	'',
	'Base Attribute',
	'Attr_ID',
	'R113');
INSERT INTO O_RATTR
	VALUES (1135,
	1014,
	168,
	37,
	1,
	'Attr_ID');
INSERT INTO O_ATTR
	VALUES (1135,
	1014,
	1032,
	'BAttr_ID',
	'Reference IS CONSTRAINED such that Base Attribute related across R113 is same Base Attribute which is found by navigating back through the referred to attributes until Base Attribute is found.',
	'B',
	'Attr_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1137,
	1014);
INSERT INTO O_BATTR
	VALUES (1137,
	1014);
INSERT INTO O_ATTR
	VALUES (1137,
	1014,
	1138,
	'Ref_Mode',
	'Full Name: Referential Attribute Referred to Mode
Description: Indicates how to build the name of the referential attribute.
Data Domain: 0 = use local root, 1 = use referred to root

enum0: Local Attribute
enum1: Referred To Attribute',
	'',
	'Ref_Mode',
	0,
	298,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (1139,
	1014,
	'Attribute_c base_attr = Attribute_c.getOneO_ATTROnR106(BaseAttribute_c.getOneO_BATTROnR113(this));
if (base_attr != null){
	m_baseattrname = base_attr.getName();
	return m_baseattrname;
}
else{
	return m_baseattrname;
}',
	0);
INSERT INTO O_BATTR
	VALUES (1139,
	1014);
INSERT INTO O_ATTR
	VALUES (1139,
	1014,
	1137,
	'BaseAttrName',
	'Full Name: Base Attribute Name
Calculate the value of Base Attribute name.
if it is calculated then set it otherwise use the existing cached value.
Translate: native
In Properties: false',
	'',
	'BaseAttrName',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (1014,
	1080,
	0,
	1082,
	1079,
	1083,
	1081,
	1140,
	1141,
	0,
	0,
	'',
	'Referential Attribute Visited Recorder',
	'recorderId',
	'R119');
INSERT INTO O_RATTR
	VALUES (1140,
	1014,
	1082,
	1080,
	1,
	'recorderId');
INSERT INTO O_ATTR
	VALUES (1140,
	1014,
	1139,
	'recorderId',
	'Persistent:false
User_Visible:false
TRANSLATE_FOR_EXTERNAL_USE:FALSE
',
	'',
	'recorderId',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1014,
	1012,
	0,
	1019,
	1016,
	1020,
	1017,
	1138,
	1142,
	0,
	1,
	'',
	'Base Attribute',
	'Obj_ID',
	'R113');
INSERT INTO O_RATTR
	VALUES (1138,
	1014,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (1138,
	1014,
	1135,
	'BObj_ID',
	'',
	'B',
	'Obj_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1014,
	37,
	0,
	169,
	1010,
	1015,
	1011,
	1032,
	1143,
	0,
	0,
	'',
	'Attribute',
	'Obj_ID',
	'R106');
INSERT INTO O_RATTR
	VALUES (1032,
	1014,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (1032,
	1014,
	1031,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	1014);
INSERT INTO O_OIDA
	VALUES (1031,
	1014,
	0,
	'Attr_ID');
INSERT INTO O_OIDA
	VALUES (1032,
	1014,
	0,
	'Obj_ID');
INSERT INTO O_ID
	VALUES (1,
	1014);
INSERT INTO O_ID
	VALUES (2,
	1014);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (50,
	'Operation Parameter',
	113,
	'O_TPARM',
	'Each operation (O_TFR) can have one or more parameters (O_TPARM).  A parameter to an operation is called an operation parameter.  Operation parameters are either passed in by value, or by reference.  Operation parameters can be accessed by using the param keyword from within an operation action specification.',
	979);
INSERT INTO O_TFR
	VALUES (1144,
	50,
	'dispose',
	'Dispose this Operation Parameter.
',
	19,
	1,
	'// Operation Parameter.dispose()
//
// Value Subsystem
select many pvs related by self->V_PVL[R833];
for each pv in pvs
  unrelate self from pv across R833;
end for;
//
// Subsystem Subsystem
select one operation related by self->O_TFR[R117];
unrelate self from operation across R117;
select one dt related by self->S_DT[R118];
unrelate self from dt across R118;
//
select one successor related by self->O_TPARM[R124.''precedes''];
select one predecessor related by self->O_TPARM[R124.''succeeds''];
if (not empty successor)
  unrelate self from successor across R124.''precedes'';
end if;
if (not empty predecessor)
  unrelate self from predecessor across R124.''succeeds'';
end if;
if (not_empty successor and not_empty predecessor)
  relate successor to predecessor across R124.''succeeds'';
end if;
// dispose each message argument
// associated with this parm
select many args related by self->MSG_OA[R1015];
for each arg in args
  arg.dispose();
end for;
//
select many dims related by self->S_DIM[R121];
for each dim in dims
  unrelate self from dim across R121;
  delete object instance dim;
end for;
//
// Finally delete self
delete object instance self;',
	1,
	'',
	1145);
INSERT INTO O_TFR
	VALUES (1146,
	50,
	'initialize',
	'Initialize this Operation Parameter.  Set the Name and data type to default values.
',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one system related by self->O_TFR[R117]->O_OBJ[R115]->PE_PE[R8001]->
                                       EP_PKG[R8000]->S_SYS[R1405];
isInGenericPackage = false;                                       
if (not_empty system)
  isInGenericPackage = true;
else
  select one component related by self->O_TFR[R117]->O_OBJ[R115]->PE_PE[R8001]->
                                   C_C[R8003];
  if (not_empty component)
    rootCompIdInPkg = component.getRootComponentId();
    select any rootComponent from instances of C_C where (selected.Id == rootCompIdInPkg);
    select one system related by rootComponent->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405];
  end if;
  if (not_empty system)
    isInGenericPackage = true;
  end if;
end if;                                       
select one operation related by self->O_TFR[R117];
operation.addParameterToOrdering(id:self.TParm_ID);
select any dom from instances of S_DOM;
select any def_dt related by dom->S_DT[R14] where selected.Name == "integer";
if(empty def_dt)
  if (isInGenericPackage)
    // if the integer dt was not found check the system level dts.
    dt_id = GD::NULL_UNIQUE_ID();
    if not_empty system
      dt_id = system.getCoreTypeId(name:"integer");
    end if;
    select any pe from instances of PE_PE where selected.Element_ID == dt_id;
    select one def_dt related by pe->S_DT[R8001]; 
    if empty def_dt
      USER::logError(msg:"Unable to locate expected data type: integer",path:"");
    end if;
  else
    // if the integer dt was not found check the system level
    // dts, but only if the domain found is the formal content
    // of a component
    if(dom.participatesInSystem())
      select one system related by dom->CN_DC[R4204]->C_C[R4204]->CP_CP[R4608]
                                    ->S_SYS[R4606];
      dt_id = GD::NULL_UNIQUE_ID();
      if not_empty system
        dt_id = system.getCoreTypeId(name:"integer");
      end if;
      select any pe from instances of PE_PE where selected.Element_ID == dt_id;
      select one def_dt related by pe->S_DT[R8001]; 
    else
      // this is an error, if the domain is not
      // participating at the system level and
      // we cannot find the type at the domain
      // level we have a problem
      USER::logError(msg:"Unable to locate expected data type: integer",path:"");
    end if;
  end if;
end if;
relate self to def_dt across R118;
name = ::getUniqueInitialName( 
    instance: self.convertToInstance(), 
    candidateName: "Unnamed Parameter");
success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:true);    
if ( success!="") 
 self.Name=success;
else 
 self.dispose();   
end if; ',
	1,
	'',
	1147);
INSERT INTO O_TFR
	VALUES (1148,
	50,
	'isAllowedType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// if this element is at the system level check the
// system level data types, otherwise check the 
// domain
// Operation Parameter.isAllowedType()
select one packageableElem related by self->O_TFR[R117]->
                                                      O_OBJ[R115]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;
if isInGenericPackage
  return packageableElem.isAllowedType(isReturnType:false,
                                                       typeName:param.typeName);
else
  select one domain related by self->O_TFR[R117]->O_OBJ[R115]->S_SS[R2]->S_DOM[R1];
  if(not_empty domain)
    select one system related by domain->S_SYS[R28];
    if(not_empty system)
      return S_DT::isAllowedParameterType( typeName: param.typeName,
                                   			dom_id: domain.get_ooa_id() );
    else
      // first check the domain level
      result = S_DT::isAllowedParameterType( typeName: param.typeName,
                                   			dom_id: domain.get_ooa_id() );
      if(not result)
        // if nothing valid check the system level
        select one system related by domain->CN_DC[R4204]->C_C[R4204]
      											   ->CP_CP[R4608]->S_SYS[R4606];
        return Util::isAllowedParameterType(system:system.convertToInstance(),
                                                       typeName:param.typeName);
      else
        return result;
      end if;
    end if;
  end if;
  return false;
end if;',
	1,
	'',
	1146);
INSERT INTO O_TPARM
	VALUES (1149,
	1148,
	'typeName',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1145,
	50,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'// just return this instance as an Object
return this;',
	0,
	'',
	1150);
INSERT INTO O_TFR
	VALUES (1147,
	50,
	'getValue',
	'',
	317,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return GD::NULL_INSTANCE(); ',
	1,
	'',
	1151);
INSERT INTO O_TPARM
	VALUES (1152,
	1147,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1153,
	50,
	'setValue',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	1154);
INSERT INTO O_TPARM
	VALUES (1155,
	1153,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (1156,
	1153,
	'value',
	317,
	0,
	'',
	1155,
	'');
INSERT INTO O_TPARM
	VALUES (1157,
	1153,
	'member_id',
	296,
	0,
	'',
	1156,
	'');
INSERT INTO O_TFR
	VALUES (1154,
	50,
	'resolveDatatype',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one dtProxy related by self->S_DT[R118];
if(not_empty dtProxy and not Util::isProxy(element:self.convertToInstance()))
  name = dtProxy.Name;
  unrelate dtProxy from self across R118;
  
  select one packageableElem related by self->O_TFR[R117]->
                                                      O_OBJ[R115]->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = not_empty package or not_empty component;
  if isInGenericPackage
    id = packageableElem.resolveDataTypeRelativeToSelf(default_name:"integer",
                                                            expected_name:name);                                                          
    select any resolvedDt related by package->PE_VIS[R8002]->
                         PE_PE[R8002]->S_DT[R8001] where selected.DT_ID == id;
    if (empty resolvedDt)
      select any resolvedDt related by component->PE_CVS[R8004]->
                       PE_PE[R8004]->S_DT[R8001] where selected.DT_ID == id;
    end if;	
    if not_empty resolvedDt
      relate resolvedDt to self across R118;
    end if;
  else
    select one domain related by self->O_TFR[R117]->O_OBJ[R115]->S_SS[R2]
                                                                    ->S_DOM[R1];
    id = domain.resolveDataTypeRelativeToSelf(default_name:"integer",
                                                            expected_name:name);
    // until we have instance reference passing, we search for
    // the data type related to the domain first then to the
    // system
    select any resolvedDT related by domain->S_DT[R14]
                                                   where (selected.DT_ID == id);
    if(empty resolvedDT)
      select one system related by domain->CN_DC[R4204]->C_C[R4204]
                                                   ->CP_CP[R4608]->S_SYS[R4606];
      select any resolvedDT related by system->SLD_SDINP[R4402]->S_DT[R4401]
                                                   where (selected.DT_ID == id);
      if empty resolvedDT and not_empty system and system.useGlobals
        select any resolvedDT related by system->G_EIS[R9100]->PE_PE[R9100]->
                                       S_DT[R8001] where (selected.DT_ID == id);
      end if;
    end if;
    if(not_empty resolvedDT)
      relate resolvedDT to self across R118;
    end if;
  end if;
end if;',
	1,
	'',
	1158);
INSERT INTO O_TFR
	VALUES (1151,
	50,
	'getDimensionsCnt',
	'',
	298,
	1,
	'select many dims related by self->S_DIM[R121];
dimensions = cardinality dims;
return dimensions;
',
	1,
	'',
	1144);
INSERT INTO O_TFR
	VALUES (1158,
	50,
	'resizeDimensions',
	'',
	19,
	1,
	'// If the number of dimensions has increased then add dimensions
while (param.numDimensions > self.getDimensionsCnt())
  create object instance dim of S_DIM;
  dim.dimensionCount = self.getDimensionsCnt();
  relate dim to self across R121;
end while;

// If the number of dimensions has decreased then remove dimensions
while (param.numDimensions < self.getDimensionsCnt())
  select any dim related by self->S_DIM[R121] where (selected.dimensionCount == (self.getDimensionsCnt()-1));
  unrelate dim from self across R121;
  delete object instance dim;
end while;

// Update the specific dimension that was passed-in if its elementCount has 
// changed.
if (param.numDimensions > 0) 
  select any dim related by self->S_DIM[R121] where (selected.dimensionCount == param.dimension);
  if (dim.elementCount != param.elementCount)
    dim.elementCount = param.elementCount;
  end if;
end if;
',
	1,
	'',
	1159);
INSERT INTO O_TPARM
	VALUES (1160,
	1158,
	'elementCount',
	298,
	0,
	'',
	1161,
	'');
INSERT INTO O_TPARM
	VALUES (1161,
	1158,
	'dimension',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (1162,
	1158,
	'numDimensions',
	298,
	0,
	'',
	1160,
	'');
INSERT INTO O_TFR
	VALUES (1159,
	50,
	'moveUp',
	'',
	19,
	1,
	'::changeNotificationEnablement(enabled:false);
select one prev_attr related by self->O_TPARM[R124.''succeeds''];
select one prev_prev_attr related by prev_attr->O_TPARM[R124.''succeeds''];
select one next_attr related by self->O_TPARM[R124.''precedes''];

if ( not_empty prev_prev_attr )
  unrelate prev_attr from prev_prev_attr across R124.''succeeds'';
end if;
if ( not_empty next_attr )
  unrelate next_attr from self across R124.''succeeds'';
end if;
unrelate self from prev_attr across R124.''succeeds'';

if ( not_empty prev_prev_attr )
  relate self to prev_prev_attr across R124.''succeeds'';
end if;
// want to enable listeners at the last possible moment
if ( empty next_attr )
  ::changeNotificationEnablement(enabled:true);
end if;
relate prev_attr to self across R124.''succeeds'';
if ( not_empty next_attr )
  ::changeNotificationEnablement(enabled:true);
  relate next_attr to prev_attr across R124.''succeeds'';
end if;
',
	1,
	'',
	1163);
INSERT INTO O_TFR
	VALUES (1163,
	50,
	'moveDown',
	'',
	19,
	1,
	'::changeNotificationEnablement(enabled:false);
select one next_attr related by self->O_TPARM[R124.''precedes''];
select one prev_attr related by self->O_TPARM[R124.''succeeds''];
select one next_next_attr related by next_attr->O_TPARM[R124.''precedes''];

if ( not_empty next_next_attr )
  unrelate next_next_attr from next_attr across R124.''succeeds'';
end if;
if ( not_empty prev_attr )
  unrelate self from prev_attr across R124.''succeeds'';
end if;
unrelate next_attr from self across R124.''succeeds'';

if ( not_empty prev_attr )
  relate next_attr to prev_attr across R124.''succeeds'';
end if;
   
// want to enable listeners at the last possible moment
if ( empty next_next_attr )
  ::changeNotificationEnablement(enabled:true);
end if;
relate self to next_attr across R124.''succeeds'';
if ( not_empty next_next_attr )
  ::changeNotificationEnablement(enabled:true);
  relate next_next_attr to self across R124.''succeeds'';
end if;
',
	1,
	'',
	1164);
INSERT INTO O_TFR
	VALUES (1165,
	50,
	'actionFilter',
	'',
	316,
	1,
	'if (param.name == "can" )
  if ( param.value == "move up" )
    select one prev_attr related by self->O_TPARM[R124.''succeeds''];
    return not_empty prev_attr;
  elif ( param.value == "move down" )
    select one next_attr related by self->O_TPARM[R124.''precedes''];
    return not_empty next_attr;
  end if;
end if;
return false;
',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (1166,
	1165,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (1167,
	1165,
	'value',
	322,
	0,
	'',
	1166,
	'');
INSERT INTO O_TFR
	VALUES (1168,
	50,
	'canReferToDataType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// select the dt
select one dt related by self->S_DT[R118];
if(not_empty dt)
  select one packageableElem related by self->O_TFR[R117]->
                                              O_OBJ[R115]->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = not_empty package or not_empty component;

  if (isInGenericPackage)
    return packageableElem.canReferToDataType(dtID:dt.DT_ID, dtName: dt.Name);
  else
    // if the data type package is at the system
    // level we can use the data type as long as
    // this element belongs to a formal component
    select one domain related by self->O_TFR[R117]->O_OBJ[R115]->S_SS[R2]
            ->S_DOM[R1];
    select one dtPkg related by dt->S_DIP[R39]->S_DPK[R39];
    if(not dtPkg.isDomainLevel())
      if( (not_empty domain) and domain.participatesInSystem())
        return true;
      else
        return false;
      end if;
    else
      // otherwise the DT must be in the same domain
      select one dtDomain related by dt->S_DOM[R14];
      if(dtDomain == domain)
        return true;
      end if;
    end if;
  end if;
end if;
return false;
',
	1,
	'',
	1165);
INSERT INTO O_TFR
	VALUES (1164,
	50,
	'isReferringToDefaultDataType',
	'',
	316,
	1,
	'select one dt related by self->S_DT[R118];
elementType = Util::getSimpleClassName(element:self.convertToInstance());
if(dt.Name == S_DT::getDefaultDataTypeName(elementType:elementType))
  return true;
end if;
return false;
',
	1,
	'',
	1148);
INSERT INTO O_TFR
	VALUES (1150,
	50,
	'canUseDataType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Operation Parameter.canUseDataType()
select one packageableElem related by self->O_TFR[R117]->
                                                      O_OBJ[R115]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;
if isInGenericPackage
  // Find the previously created visibility list
  select any resultSet related by package->PE_SRS[R8005] where
        selected.Name == "" and selected.Type == ElementTypeConstants::DATATYPE;
  select any dt related by resultSet->PE_VIS[R8006]->
                     PE_PE[R8002]->S_DT[R8001] where selected.DT_ID == param.id;
  if not_empty component
    // Find the previously created visibility list
    select any compResultSet related by component->PE_CRS[R8007] where
        selected.Name == "" and selected.Type == ElementTypeConstants::DATATYPE;
    select any dt related by compResultSet->PE_CVS[R8008]->
                     PE_PE[R8004]->S_DT[R8001] where selected.DT_ID == param.id;
  end if;
  if(not_empty dt)
    if(self.isAllowedType(typeName:dt.Name))
      return true;
    end if;
  end if;
  return false;
else
  select one domain related by self->O_TFR[R117]->O_OBJ[R115]->S_SS[R2]
                                                                    ->S_DOM[R1];
  if(domain.participatesInSystem())
    // system level check both the system
    // and the domain for the dt
    select one system related by domain->CN_DC[R4204]->C_C[R4204]->CP_CP[R4608]
                                                                 ->S_SYS[R4606];
    select any dt related by system->SLD_SDINP[R4402]->S_DT[R4401]
                                             where (selected.DT_ID == param.id);
    if empty dt and not_empty system and system.useGlobals
      select any dt related by system->G_EIS[R9100]->PE_PE[R9100]->S_DT[R8001]
                                             where (selected.DT_ID == param.id);
    end if;
    if(empty dt)
      select any dt related by domain->S_DT[R14]
                                             where (selected.DT_ID == param.id);
    end if;
    if(not_empty dt)
      if(self.isAllowedType(typeName:dt.Name))
        return true;
      end if;
    end if;
  else
    // only check the domain for the dt
    select any dt related by domain->S_DT[R14] where (selected.DT_ID == param.id);
    if(not_empty dt)
      if(self.isAllowedType(typeName:dt.Name))
        return true;
      end if;
    end if;
  end if;
  return false;
end if;',
	1,
	'',
	1168);
INSERT INTO O_TPARM
	VALUES (1169,
	1150,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1170,
	50,
	'checkIntegrity',
	'',
	19,
	1,
	'// check for any operation parameters that have a matching name
// under the parent operation
select one package related by self->O_TFR[R117]
                                     ->O_OBJ[R115]->PE_PE[R8001]->EP_PKG[R8000];
select one system related by package->S_SYS[R1405];
select one operation related by self->O_TFR[R117];
sys_id = GD::NULL_UNIQUE_ID();
if(not_empty system)
 sys_id = system.Sys_ID;
end if;
select many parameters related by operation->O_TPARM[R117];
for each parameter in parameters
  if(parameter != self and parameter.Name == self.Name)
    select one class related by operation->O_OBJ[R115];
	MI_IM::createIssue(sys_id:sys_id, description:
	               "Found another parameter under the same operation " +
	     "with a matching name.", severity:Severity::Error, name:self.Name,
	   path:class.getPath(path:"", includeSelf:true) + "::" + operation.Name +
	      "::" + self.Name, id:self.TParm_ID, element:self.convertToInstance());
  end if;
end for;',
	1,
	'',
	1153);
INSERT INTO O_NBATTR
	VALUES (219,
	50);
INSERT INTO O_BATTR
	VALUES (219,
	50);
INSERT INTO O_ATTR
	VALUES (219,
	50,
	0,
	'TParm_ID',
	'Full Name: Operation Parameter Identifier
Description: Uniquely identifies an operation parameter',
	'',
	'TParm_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_REF
	VALUES (50,
	43,
	0,
	201,
	989,
	991,
	990,
	1171,
	1172,
	0,
	0,
	'',
	'Operation',
	'Tfr_ID',
	'R117.''is part of ''');
INSERT INTO O_RATTR
	VALUES (1171,
	50,
	201,
	43,
	1,
	'Tfr_ID');
INSERT INTO O_ATTR
	VALUES (1171,
	50,
	219,
	'Tfr_ID',
	'',
	'',
	'Tfr_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1173,
	50);
INSERT INTO O_BATTR
	VALUES (1173,
	50);
INSERT INTO O_ATTR
	VALUES (1173,
	50,
	1171,
	'Name',
	'Full Name: Operation Parameter Name
Description: This is the name of the parameter.',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1174,
	50);
INSERT INTO O_BATTR
	VALUES (1174,
	50);
INSERT INTO O_ATTR
	VALUES (1174,
	50,
	1175,
	'By_Ref',
	'Full Name: By Reference Indicator
Description: Indicates whether or not this parameter is passed by reference
Data Domain: 0 = passed by value, 1 = passed by reference
enum0: By Value
enum1: By Reference',
	'',
	'By_Ref',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1176,
	50);
INSERT INTO O_BATTR
	VALUES (1176,
	50);
INSERT INTO O_ATTR
	VALUES (1176,
	50,
	1174,
	'Dimensions',
	'Full Name: Array Dimensions',
	'',
	'Dimensions',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (50,
	50,
	0,
	219,
	1096,
	1098,
	1097,
	1177,
	1178,
	0,
	0,
	'',
	'Operation Parameter',
	'TParm_ID',
	'R124.''succeeds''');
INSERT INTO O_RATTR
	VALUES (1177,
	50,
	219,
	50,
	1,
	'TParm_ID');
INSERT INTO O_ATTR
	VALUES (1177,
	50,
	1176,
	'Previous_TParm_ID',
	'',
	'Previous_',
	'TParm_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1179,
	50);
INSERT INTO O_BATTR
	VALUES (1179,
	50);
INSERT INTO O_ATTR
	VALUES (1179,
	50,
	1177,
	'Descrip',
	'Full Name: Description
Description:  A textual description of the operation parameter.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (50,
	32,
	0,
	156,
	992,
	994,
	993,
	1175,
	1180,
	0,
	0,
	'',
	'Data Type',
	'DT_ID',
	'R118.''is defined by''');
INSERT INTO O_RATTR
	VALUES (1175,
	50,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (1175,
	50,
	1173,
	'DT_ID',
	'',
	'',
	'Element_ID',
	2,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	50);
INSERT INTO O_OIDA
	VALUES (219,
	50,
	0,
	'TParm_ID');
INSERT INTO O_ID
	VALUES (1,
	50);
INSERT INTO O_ID
	VALUES (2,
	50);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (43,
	'Operation',
	112,
	'O_TFR',
	'A Operation is a method associated with a class.  Operations can be synchronously called from Action Specifications.  Two types of operations exist.  Class-based operations affect the class as a whole.  Instance-based operations affect only an instance.',
	979);
INSERT INTO O_TFR
	VALUES (1181,
	43,
	'dispose',
	'Dispose this Operation.
',
	19,
	1,
	'// Subsytem Subsystem
select one myClass related by self->O_OBJ[R115];
unrelate self from myClass across R115;
//
select one successor related by self->O_TFR[R125.''precedes''];
select one predecessor related by self->O_TFR[R125.''succeeds''];
if (not empty successor)
  unrelate self from successor across R125.''precedes'';
end if;
if (not empty predecessor)
  unrelate self from predecessor across R125.''succeeds'';
end if;
if (not_empty successor and not_empty predecessor)
  relate successor to predecessor across R125.''succeeds'';
end if;
//
select one dt related by self->S_DT[R116];
unrelate self from dt across R116;
select many oparms related by self->O_TPARM[R117];
for each oparm in oparms
  oparm.dispose();
end for;
//
// Body Subsystem
select one body related by self->ACT_OPB[R696]->ACT_ACT[R698];
if (not_empty body)
  body.dispose();
end if;
//
// Invocation Subsystem
select many invs related by self->ACT_TFM[R673];
for each inv in invs
  unrelate self from inv across R673;
end for;
//
// Value Subsystem
select many oprVals related by self->V_TRV[R829];
for each oprVal in oprVals
  unrelate self from oprVal across R829;
end for;
// for each message that this operation
// is associated with
select many oms related by self->MSG_O[R1011];
for each om in oms
  select one message related by om->MSG_SM[R1020];
  message.unformalize();
end for;
select many dims related by self->S_DIM[R122];
for each dim in dims
  unrelate self from dim across R122;
  delete object instance dim;
end for;
//
// Finally, delete self
delete object instance self;',
	1,
	'',
	1182);
INSERT INTO O_TFR
	VALUES (1183,
	43,
	'initialize',
	'Initialize this Operation.  Set Name and return type to default values.
',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one clazz related by self->O_OBJ[R115];
clazz.addOperationToOrdering(id:self.Tfr_ID);
select any dom from instances of S_DOM;
select any def_dt related by dom->S_DT[R14] where selected.Name == "void";
if not_empty dom
  if(empty def_dt)
    // if the void dt was not found check the system level
    // dts, but only if the domain found is the formal content
    // of a component
    if(dom.participatesInSystem())
      select one system related by dom->CN_DC[R4204]->C_C[R4204]->CP_CP[R4608]
                                                                 ->S_SYS[R4606];
      dt_id = GD::NULL_UNIQUE_ID();
      if not_empty system
        dt_id = system.getCoreTypeId(name:"void");
      end if;
      select any pe from instances of PE_PE where selected.Element_ID == dt_id;
      select one def_dt related by pe->S_DT[R8001];
    else
      // this is an error, if the domain is not
      // participating at the system level and
      // we cannot find the type at the domain
      // level we have a problem
      USER::logError(msg:"Unable to locate expected data type: void",path:"");
    end if;
  end if;
else
  // Owning Class is in a package . . . 
  select one system related by self->O_OBJ[R115]->PE_PE[R8001]->
                                                    EP_PKG[R8000]->S_SYS[R1405];
  if not_empty system
    dt_id = system.getCoreTypeId(name:"void");
    select any pe from instances of PE_PE where selected.Element_ID == dt_id;
    select one def_dt related by pe->S_DT[R8001];
  else
    // this is an error, if the system is not
    // found we cannot find the core type
    USER::logError(msg:"Unable to locate system root for data type: void",path:"");
  end if;
end if;
relate self to def_dt across R116;
name = ::getUniqueInitialName( 
    instance: self.convertToInstance(), 
    candidateName: "Unnamed Operation");
success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:true);    
if ( success!="") 
 self.Name=success;
else 
 self.dispose();   
end if;   
self.Instance_Based = Scope::Instance;
self.Suc_Pars = ParseStatus::parseInitial;
',
	1,
	'',
	1184);
INSERT INTO O_TFR
	VALUES (1185,
	43,
	'newParameter',
	'Create a new parameter for this operation.',
	19,
	1,
	'create object instance parm of O_TPARM;
relate self to parm across R117;
parm.initialize();
self.createParameterInInteractions(id:parm.TParm_ID);',
	1,
	'',
	1186);
INSERT INTO O_TFR
	VALUES (1187,
	43,
	'isAllowedReturnType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one packageableElem related by self->O_OBJ[R115]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;
if isInGenericPackage
  if self.getReturnDimensionsCnt() != 0 and param.typeName == "void"
    return false;
  else
    // TODO Need to implement datatype namespacing here or in the Util call
    return packageableElem.isAllowedType(isReturnType:true,
                                                       typeName:param.typeName);
  end if;
else
  if self.getReturnDimensionsCnt() != 0 and param.typeName == "void"
    return false;
  else
    // if this element is at the system level check the
    // system level data types, otherwise check the 
    // domain
    select one domain related by self->O_OBJ[R115]->S_SS[R2]->S_DOM[R1];
    if(not_empty domain)
      select one system related by domain->S_SYS[R28];
      if(not_empty system)
        return S_DT::isAllowedReturnType( typeName: param.typeName,
                                   		dom_id: domain.get_ooa_id() );
      else
        // first check the domain level
        result = S_DT::isAllowedReturnType( typeName: param.typeName,
                                   			dom_id: domain.get_ooa_id() );
        if(not result)
          // if nothing valid check the system level
          select one system related by domain->CN_DC[R4204]->C_C[R4204]
      											   ->CP_CP[R4608]->S_SYS[R4606];
          return Util::isAllowedReturnType(system:system.convertToInstance(),
                                                       typeName:param.typeName);
        else
          return result;
        end if;
      end if;
    else
      // Owning class is in a package . . .
      // TODO Need to implement datatype namespacing here or in the Util call
      select one system related by self->O_OBJ[R115]->PE_PE[R8001]->
                                                    EP_PKG[R8000]->S_SYS[R1405];
      if not_empty system
        return Util::isAllowedReturnType(system:system.convertToInstance(),
                                                       typeName:param.typeName);
      else
        // this is an error, if the system is not
        // found we cannot sheck the core types
        USER::logError(msg:"Unable to locate system root for data type check.",path:"");
        return false;
      end if;
    end if;
  end if;
end if;',
	1,
	'',
	1188);
INSERT INTO O_TPARM
	VALUES (1189,
	1187,
	'typeName',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1182,
	43,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'// just return this instance as an Object
return this;',
	0,
	'',
	1190);
INSERT INTO O_TFR
	VALUES (1184,
	43,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Tfr_ID;',
	1,
	'',
	1191);
INSERT INTO O_TFR
	VALUES (1192,
	43,
	'resolveDatatype',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one dtProxy related by self->S_DT[R116];
if(not_empty dtProxy and not Util::isProxy(element:self.convertToInstance()))
  name = dtProxy.Name;
  unrelate dtProxy from self across R116;
  
  select one packageableElem related by self->O_OBJ[R115]->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPkg = not_empty package or not_empty component;
  if (isInGenericPkg)
    id = packageableElem.resolveDataTypeRelativeToSelf(default_name:"void",
                                                            expected_name:name);                                                          
    select any resolvedDT related by package->PE_VIS[R8002]->
                         PE_PE[R8002]->S_DT[R8001] where selected.DT_ID == id;
    if (empty resolvedDT)
      select any resolvedDt related by component->PE_CVS[R8004]->
                       PE_PE[R8004]->S_DT[R8001] where selected.DT_ID == id;
    end if;	
    if(not_empty resolvedDT)
      relate resolvedDT to self across R116;
    end if;
  else
    select one domain related by self->O_OBJ[R115]->S_SS[R2]->S_DOM[R1];
    id = domain.resolveDataTypeRelativeToSelf(default_name:"void",
  													        expected_name:name);
    // until we have instance reference passing, we search for
    // the data type related to the domain first then to the
    // system
    select any resolvedDT related by domain->S_DT[R14]
  												   where (selected.DT_ID == id);
    if(empty resolvedDT)
      select one system related by domain->CN_DC[R4204]->C_C[R4204]
    				                               ->CP_CP[R4608]->S_SYS[R4606];
      select any resolvedDT related by system->SLD_SDINP[R4402]->S_DT[R4401]
    				 						       where (selected.DT_ID == id);
      if empty resolvedDT and not_empty system and system.useGlobals
        select any resolvedDT related by system->G_EIS[R9100]->PE_PE[R9100]->
                                       S_DT[R8001] where (selected.DT_ID == id);
    end if;
    end if;
    if(not_empty resolvedDT)
      relate resolvedDT to self across R116;
    end if;
  end if;     
end if;',
	1,
	'',
	1193);
INSERT INTO O_TFR
	VALUES (1194,
	43,
	'isVoid',
	'',
	316,
	1,
	'select one dt related by self->S_DT[R116];
return dt.Name == "void";',
	1,
	'',
	1195);
INSERT INTO O_TFR
	VALUES (1191,
	43,
	'getReturnDimensionsCnt',
	'',
	298,
	1,
	'select many dims related by self->S_DIM[R122];
dimensions = cardinality dims;
return dimensions;',
	1,
	'',
	1181);
INSERT INTO O_TFR
	VALUES (1193,
	43,
	'resizeReturn_Dimensions',
	'',
	19,
	1,
	'// If the number of dimensions has increased then add dimensions
while (param.numDimensions > self.getReturnDimensionsCnt())
  create object instance dim of S_DIM;
  dim.dimensionCount = self.getReturnDimensionsCnt();
  relate dim to self across R122;
end while;

// If the number of dimensions has decreased then remove dimensions
while (param.numDimensions < self.getReturnDimensionsCnt())
  select any dim related by self->S_DIM[R122] where (selected.dimensionCount == (self.getReturnDimensionsCnt()-1));
  unrelate dim from self across R122;
  delete object instance dim;
end while;

// Update the specific dimension that was passed-in if its elementCount has 
// changed.
if (param.numDimensions > 0) 
  select any dim related by self->S_DIM[R122] where (selected.dimensionCount == param.dimension);
  if (dim.elementCount != param.elementCount)
    dim.elementCount = param.elementCount;
  end if;
end if;
',
	1,
	'',
	1185);
INSERT INTO O_TPARM
	VALUES (1196,
	1193,
	'elementCount',
	298,
	0,
	'',
	1197,
	'');
INSERT INTO O_TPARM
	VALUES (1198,
	1193,
	'numDimensions',
	298,
	0,
	'',
	1196,
	'');
INSERT INTO O_TPARM
	VALUES (1197,
	1193,
	'dimension',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1186,
	43,
	'moveUp',
	'',
	19,
	1,
	'::changeNotificationEnablement(enabled:false);
select one prev_attr related by self->O_TFR[R125.''succeeds''];
select one prev_prev_attr related by prev_attr->O_TFR[R125.''succeeds''];
select one next_attr related by self->O_TFR[R125.''precedes''];

if ( not_empty prev_prev_attr )
  unrelate prev_attr from prev_prev_attr across R125.''succeeds'';
end if;
if ( not_empty next_attr )
  unrelate next_attr from self across R125.''succeeds'';
end if;
unrelate self from prev_attr across R125.''succeeds'';

if ( not_empty prev_prev_attr )
  relate self to prev_prev_attr across R125.''succeeds'';
end if;
// want to enable listeners at the last possible moment
if ( empty next_attr )
  ::changeNotificationEnablement(enabled:true);
end if;
relate prev_attr to self across R125.''succeeds'';
if ( not_empty next_attr )
  ::changeNotificationEnablement(enabled:true);
  relate next_attr to prev_attr across R125.''succeeds'';
end if;
',
	1,
	'',
	1199);
INSERT INTO O_TFR
	VALUES (1199,
	43,
	'moveDown',
	'',
	19,
	1,
	'::changeNotificationEnablement(enabled:false);
select one next_attr related by self->O_TFR[R125.''precedes''];
select one prev_attr related by self->O_TFR[R125.''succeeds''];
select one next_next_attr related by next_attr->O_TFR[R125.''precedes''];

if ( not_empty next_next_attr )
  unrelate next_next_attr from next_attr across R125.''succeeds'';
end if;
if ( not_empty prev_attr )
  unrelate self from prev_attr across R125.''succeeds'';
end if;
unrelate next_attr from self across R125.''succeeds'';

if ( not_empty prev_attr )
  relate next_attr to prev_attr across R125.''succeeds'';
end if;
   
// want to enable listeners at the last possible moment
if ( empty next_next_attr )
  ::changeNotificationEnablement(enabled:true);
end if;
relate self to next_attr across R125.''succeeds'';
if ( not_empty next_next_attr )
  ::changeNotificationEnablement(enabled:true);
  relate next_next_attr to self across R125.''succeeds'';
end if;
',
	1,
	'',
	1194);
INSERT INTO O_TFR
	VALUES (1200,
	43,
	'actionFilter',
	'',
	316,
	1,
	'if (param.name == "can" )
  if ( param.value == "move up" )
    select one prev_attr related by self->O_TFR[R125.''succeeds''];
    return not_empty prev_attr;
  elif ( param.value == "move down" )
    select one next_attr related by self->O_TFR[R125.''precedes''];
    return not_empty next_attr;
  end if;
end if;
return false;
',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (1201,
	1200,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (1202,
	1200,
	'value',
	322,
	0,
	'',
	1201,
	'');
INSERT INTO O_TFR
	VALUES (1188,
	43,
	'initializeOrder',
	'',
	19,
	1,
	'// Alpha-sort the O_TPARM elements if they have not yet been ordered
select many peers related by self->O_TPARM[R117];
if (cardinality peers > 1)
    initialOrderingCheckPerformed = false;
	select any head related by self->O_TPARM[R117] where (selected.Tfr_ID == GD::NULL_UNIQUE_ID());
	endOfList = head;
	loopCnt = 0;
	for each peer in peers
	  if ( not initialOrderingCheckPerformed)
	    select one predecessor related by peer->O_TPARM[R124.''precedes''];
	    select one successor related by peer->O_TPARM[R124.''succeeds''];
	    initialOrderingCheckPerformed = true;
	    if (not_empty  predecessor or not_empty  successor)
	      // Already ordered
	      break;
	    end if;
	    head = peer;
	    endOfList = peer;
	  end if;
	  
      if (loopCnt == 1)
        if (peer.Name < head.Name)
          relate peer to head across R124.''precedes'';
          endOfList = peer;
        else
          relate head to peer across R124.''precedes'';
          head = peer;
        end if;
      elif (loopCnt > 1)
        insertPoint = head;
        select one next related by head->O_TPARM[R124.''succeeds''];
        while (not_empty next)
          if (next.Name < peer.Name)
            break;
          else
            insertPoint = next;          
            select one next related by next->O_TPARM[R124.''succeeds''];
          end if;
        end while;
        
        if (empty next)
          // New end of list
          relate peer to endOfList across R124.''precedes'';   
          endOfList = peer;       
        else
          if ((insertPoint == head) and (peer.Name > head.Name))
            // New head
            relate head to peer across R124.''precedes'';
            head = peer;
          else
            unrelate next from insertPoint across R124.''precedes'';
            relate peer to insertPoint across R124.''precedes'';
            relate next to peer across R124.''precedes'';
          end if;          
        end if;
      end if;
      
      loopCnt = loopCnt + 1;
	end for;
end if;',
	1,
	'',
	1183);
INSERT INTO O_TFR
	VALUES (1190,
	43,
	'canReferToDataType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// select the dt
select one dt related by self->S_DT[R116];
if(not_empty dt)
  select one packageableElem related by self->O_OBJ[R115]->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = not_empty package or not_empty component;

  if (isInGenericPackage)
    return packageableElem.canReferToDataType(dtID:dt.DT_ID, dtName: dt.Name);
  else
    // if the data type package is at the system
    // level we can use the data type as long as
    // this element belongs to a formal component
    select one domain related by self->O_OBJ[R115]->S_SS[R2]->S_DOM[R1];
    select one dtPkg related by dt->S_DIP[R39]->S_DPK[R39];
    if(not dtPkg.isDomainLevel())
      if(domain.participatesInSystem())
        return true;
      else
        return false;
      end if;
    else
      // otherwise the DT must be in the same domain
      select one dtDomain related by dt->S_DOM[R14];
      if(dtDomain == domain)
        return true;
      end if;
    end if;
  end if;
end if;
return false;
',
	1,
	'',
	1200);
INSERT INTO O_TFR
	VALUES (1195,
	43,
	'isReferringToDefaultDataType',
	'',
	316,
	1,
	'select one dt related by self->S_DT[R116];
elementType = Util::getSimpleClassName(element:self.convertToInstance());
if(dt.Name == S_DT::getDefaultDataTypeName(elementType:elementType))
  return true;
end if;
return false;
',
	1,
	'',
	1187);
INSERT INTO O_TFR
	VALUES (1203,
	43,
	'getContainingComponentId',
	'',
	296,
	1,
	'select one clazz related by self->O_OBJ[R115];
return clazz.getContainingComponentId();
',
	1,
	'',
	1192);
INSERT INTO O_TFR
	VALUES (1204,
	43,
	'canUseDataType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Operation::canUseDataType()
select one packageableElem related by self->O_OBJ[R115]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;
if isInGenericPackage
  // Find the previously created visibility list
  select any resultSet related by package->PE_SRS[R8005] where
        selected.Name == "" and selected.Type == ElementTypeConstants::DATATYPE;
  select any dt related by resultSet->PE_VIS[R8006]->
                     PE_PE[R8002]->S_DT[R8001] where selected.DT_ID == param.id;
  if not_empty component
    // Find the previously created visibility list
    select any compResultSet related by component->PE_CRS[R8007] where
        selected.Name == "" and selected.Type == ElementTypeConstants::DATATYPE;
    select any dt related by compResultSet->PE_CVS[R8008]->
                     PE_PE[R8004]->S_DT[R8001] where selected.DT_ID == param.id;
  end if;
  if(not_empty dt)
    if(self.isAllowedReturnType(typeName:dt.Name))
      return true;
    end if;
  end if;
  return false;
else
  select one domain related by self->O_OBJ[R115]->S_SS[R2]->S_DOM[R1];
  if not_empty domain
    if(domain.participatesInSystem())
      // system level check both the system
      // and the domain for the dt
      select one system related by domain->CN_DC[R4204]->C_C[R4204]->
                                                     CP_CP[R4608]->S_SYS[R4606];
      select any dt related by system->SLD_SDINP[R4402]->S_DT[R4401]
                                             where (selected.DT_ID == param.id);
      if empty dt and not_empty system and system.useGlobals
        select any dt related by system->G_EIS[R9100]->PE_PE[R9100]->S_DT[R8001]
                                             where (selected.DT_ID == param.id);
      end if;
      if(empty dt)
        select any dt related by domain->S_DT[R14]
                                             where (selected.DT_ID == param.id);
      end if;
      if(not_empty dt)
        if(self.isAllowedReturnType(typeName:dt.Name))
          return true;
        end if;
      end if;
    else
      // only check the domain for the dt
      select any dt related by domain->S_DT[R14] where
                                                   (selected.DT_ID == param.id);
      if(not_empty dt)
        if(self.isAllowedReturnType(typeName:dt.Name))
          return true;
        end if;
      end if;
    end if;
  else
    select one system related by self->O_OBJ[R115]->PE_PE[R8001]->
                                                    EP_PKG[R8000]->S_SYS[R1405];
      select any dt related by system->SLD_SDINP[R4402]->S_DT[R4401]
                                             where (selected.DT_ID == param.id);
      if empty dt and not_empty system and system.useGlobals
        select any dt related by system->G_EIS[R9100]->PE_PE[R9100]->S_DT[R8001]
                                             where (selected.DT_ID == param.id);
      end if;
      if not_empty dt
        if self.isAllowedReturnType(typeName:dt.Name)
          return true;
        end if;
      end if; 
  end if;
  return false;
end if;',
	1,
	'',
	1203);
INSERT INTO O_TPARM
	VALUES (1205,
	1204,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1206,
	43,
	'getContainerId',
	'',
	296,
	1,
	'// Operation.getContainerId
select one clazz related by self->O_OBJ[R115];
return clazz.getContainerId();',
	1,
	'',
	1204);
INSERT INTO O_TFR
	VALUES (1207,
	43,
	'pasteOperationParameter',
	'',
	19,
	1,
	'select any opParm from instances of O_TPARM
                                          where (selected.TParm_ID == param.id);
if(not_empty opParm)
  select one existingOperation related by opParm->O_TFR[R117];
  if(not_empty existingOperation)
    unrelate existingOperation from opParm across R117;
  end if;
  relate opParm to self across R117;
  self.addParameterToOrdering(id:opParm.TParm_ID);
  opParm.Name = ::getUniqueInitialNameInParent(instance:opParm.convertToInstance(),
  						name:opParm.Name, parent:self.convertToInstance());
  self.createParameterInInteractions(id:opParm.TParm_ID);
end if;',
	1,
	'',
	1206);
INSERT INTO O_TPARM
	VALUES (1208,
	1207,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1209,
	43,
	'createParameterInInteractions',
	'',
	19,
	1,
	'// for each message associated with this bridge
// create a message argument
select any parm from instances of O_TPARM where (selected.TParm_ID == param.id);
select many messages related by self->MSG_O[R1011]->MSG_SM[R1020]->MSG_M[R1018];
for each message in messages
  create object instance arg of MSG_A;
  create object instance oa of MSG_OA;
  relate oa to parm across R1015;
  relate oa to arg across R1013;
  relate message to arg across R1001;
end for;
',
	1,
	'',
	1207);
INSERT INTO O_TPARM
	VALUES (1210,
	1209,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1211,
	43,
	'addParameterToOrdering',
	'',
	19,
	1,
	'select any parameter from instances of O_TPARM
                                          where (selected.TParm_ID == param.id);
if(not_empty parameter)
  ::changeNotificationEnablement(enabled:false);
  select many peers related by self->O_TPARM[R117];
  for each peer in peers
    if (peer != parameter)
      select one predecessor related by peer->O_TPARM[R124.''precedes''];
      if (empty predecessor)
        relate parameter to peer across R124.''succeeds'';
      end if;
    end if;
  end for;
  ::changeNotificationEnablement(enabled:true);
end if;',
	1,
	'',
	1209);
INSERT INTO O_TPARM
	VALUES (1212,
	1211,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1213,
	43,
	'checkIntegrity',
	'',
	19,
	1,
	'// check for any operations that have a matching signature
select one package related by self->O_OBJ[R115]->PE_PE[R8001]->EP_PKG[R8000];
select many operations related by self->O_OBJ[R115]->O_TFR[R115];
for each operation in operations
  if(operation != self and operation.getSignature() == self.getSignature())
    select one system related by package->S_SYS[R1405];
    sys_id = GD::NULL_UNIQUE_ID();
    if(not_empty system)
      sys_id = system.Sys_ID;
    end if;
    select one class related by self->O_OBJ[R115];
	MI_IM::createIssue(sys_id:sys_id, description:
	               "Found another operation under the same class " +
	     "with a matching signature." + GD::newline() + GD::newline()
	            + "Signature: " + self.getSignature(), severity:Severity::Error,
	                                                             name:self.Name,
	   path:class.getPath(path:self.Name, includeSelf:true), id:self.Tfr_ID,
	                                          element:self.convertToInstance());
  end if;
end for;',
	1,
	'',
	1211);
INSERT INTO O_TFR
	VALUES (1214,
	43,
	'getSignature',
	'',
	322,
	1,
	'/**
 *  Return a string representation of this functions signature
 */
signature = self.Name;
count = 0;
select many parameters related by self->O_TPARM[R117];
paramLength = cardinality parameters;
if(paramLength > 0)
  signature = signature + "(";
end if;
for each parameter in parameters
  select one type related by parameter->S_DT[R118];
  if(count > 0 and count != paramLength - 1)
    signature = signature + ", ";
  end if;
  signature = signature + type.Name;
  count = count + 1;
end for;
if(paramLength > 0)
  signature = signature + ")";
end if;
return signature;',
	1,
	'',
	1213);
INSERT INTO O_NBATTR
	VALUES (201,
	43);
INSERT INTO O_BATTR
	VALUES (201,
	43);
INSERT INTO O_ATTR
	VALUES (201,
	43,
	0,
	'Tfr_ID',
	'Full Name: Operation Identifier',
	'',
	'Tfr_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1215,
	43);
INSERT INTO O_BATTR
	VALUES (1215,
	43);
INSERT INTO O_ATTR
	VALUES (1215,
	43,
	1216,
	'Name',
	'Full Name: Operation Name
Description: The name of this operation.',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1217,
	43);
INSERT INTO O_BATTR
	VALUES (1217,
	43);
INSERT INTO O_ATTR
	VALUES (1217,
	43,
	1215,
	'Descrip',
	'Full Name: Operation Description
Description: A textual description of this operation.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1218,
	43);
INSERT INTO O_BATTR
	VALUES (1218,
	43);
INSERT INTO O_ATTR
	VALUES (1218,
	43,
	1219,
	'Instance_Based',
	'Full Name: Instance Based Indicator
Description: Indicates whether the operation is instance-based or class-based.
Data Domain: 0 = class-based, 1 = instance-based
',
	'',
	'Instance_Based',
	0,
	1220,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (1221,
	43,
	'self.Action_Semantics = ::convertRelocatableTags(in:self.Action_Semantics_internal);
',
	1);
INSERT INTO O_BATTR
	VALUES (1221,
	43);
INSERT INTO O_ATTR
	VALUES (1221,
	43,
	1218,
	'Action_Semantics',
	'Full Name: Action Semantics Field
Description: Defines the action semantics for the operation
Persistent:false
',
	'',
	'Action_Semantics',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1222,
	43);
INSERT INTO O_BATTR
	VALUES (1222,
	43);
INSERT INTO O_ATTR
	VALUES (1222,
	43,
	1223,
	'Suc_Pars',
	'Full Name: Successful Parse Indicator
Description: Indicates the status of the parse for the operation action described in the attribute Action_Semantics
Data Domain: 0=not parsed, 1 = parse successful, 2 = parse unsuccessful, 3 = parse on apply set but never been parsed
',
	'',
	'Suc_Pars',
	0,
	1224,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1223,
	43);
INSERT INTO O_BATTR
	VALUES (1223,
	43);
INSERT INTO O_ATTR
	VALUES (1223,
	43,
	1221,
	'Action_Semantics_internal',
	'User_Visible:false',
	'',
	'Action_Semantics_internal',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1225,
	43);
INSERT INTO O_BATTR
	VALUES (1225,
	43);
INSERT INTO O_ATTR
	VALUES (1225,
	43,
	1222,
	'Return_Dimensions',
	'Full Name: Return Array Dimensions
DynamicReadOnly:isVoid',
	'',
	'Return_Dimensions',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (43,
	43,
	0,
	201,
	1099,
	1101,
	1100,
	1226,
	1227,
	0,
	0,
	'',
	'Operation',
	'Tfr_ID',
	'R125');
INSERT INTO O_RATTR
	VALUES (1226,
	43,
	201,
	43,
	1,
	'Tfr_ID');
INSERT INTO O_ATTR
	VALUES (1226,
	43,
	1225,
	'Previous_Tfr_ID',
	'',
	'Previous_',
	'Tfr_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (43,
	32,
	0,
	156,
	995,
	997,
	996,
	1219,
	1228,
	0,
	0,
	'',
	'Data Type',
	'DT_ID',
	'R116');
INSERT INTO O_RATTR
	VALUES (1219,
	43,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (1219,
	43,
	1217,
	'DT_ID',
	'',
	'',
	'Element_ID',
	2,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (43,
	30,
	0,
	150,
	998,
	999,
	1000,
	1216,
	1229,
	0,
	0,
	'',
	'Model Class',
	'Obj_ID',
	'R115');
INSERT INTO O_RATTR
	VALUES (1216,
	43,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (1216,
	43,
	201,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	43);
INSERT INTO O_OIDA
	VALUES (201,
	43,
	0,
	'Tfr_ID');
INSERT INTO O_ID
	VALUES (1,
	43);
INSERT INTO O_ID
	VALUES (2,
	43);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (1025,
	'New Base Attribute',
	108,
	'O_NBATTR',
	'A New Base Attribute is a non-derived base attribute.',
	979);
INSERT INTO O_TFR
	VALUES (1230,
	1025,
	'dispose',
	'Dispose this New Base Attribute.
',
	19,
	1,
	'select one battr related by self->O_BATTR[R107];
unrelate self from battr across R107;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (1231,
	1025,
	'get_name',
	'',
	322,
	1,
	'return "as New Base Attribute";',
	1,
	'',
	1230);
INSERT INTO O_REF
	VALUES (1025,
	1012,
	0,
	1018,
	1021,
	1026,
	1022,
	1232,
	1233,
	0,
	0,
	'',
	'Base Attribute',
	'Attr_ID',
	'R107');
INSERT INTO O_RATTR
	VALUES (1232,
	1025,
	168,
	37,
	1,
	'Attr_ID');
INSERT INTO O_ATTR
	VALUES (1232,
	1025,
	0,
	'Attr_ID',
	'',
	'',
	'Attr_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1025,
	1012,
	0,
	1019,
	1021,
	1026,
	1022,
	1234,
	1235,
	0,
	0,
	'',
	'Base Attribute',
	'Obj_ID',
	'R107');
INSERT INTO O_RATTR
	VALUES (1234,
	1025,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (1234,
	1025,
	1232,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	1025);
INSERT INTO O_OIDA
	VALUES (1232,
	1025,
	0,
	'Attr_ID');
INSERT INTO O_OIDA
	VALUES (1234,
	1025,
	0,
	'Obj_ID');
INSERT INTO O_ID
	VALUES (1,
	1025);
INSERT INTO O_ID
	VALUES (2,
	1025);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (30,
	'Model Class',
	101,
	'O_OBJ',
	'A model class represents an abstraction of a real world thing.  All instances of a class have the same characteristics and conform to the same set of rules.  The characteristics of a class are captured as attributes.  Each class within a domain are assigned a unique name, number, and keyletter.',
	979);
INSERT INTO O_TFR
	VALUES (1236,
	30,
	'get_compartments',
	'A Class has three compartments for the name, attributes and
operations.
-----------------------------------------------------------------------------------
Bridge:GD',
	298,
	1,
	'return 3;',
	1,
	'',
	1237);
INSERT INTO O_TFR
	VALUES (1238,
	30,
	'get_entries',
	'This operation returns the number of entries in each compartment.
-----------------------------------------------------------------------------------
Bridge:GD',
	298,
	1,
	'if (param.comp_num == 1)
 return 2;
end if;
if (param.comp_num == 2)
  select many attrs related by self->O_ATTR[R102];
  return cardinality attrs;
end if;
if (param.comp_num == 3)
  select many tfrs related by self->O_TFR[R115];
  return cardinality tfrs;
end if;
return 0;',
	1,
	'',
	1236);
INSERT INTO O_TPARM
	VALUES (1239,
	1238,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1240,
	30,
	'get_style',
	'A Class is shown as a box.
-----------------------------------------------------------------------------------
Bridge:GD',
	784,
	1,
	'return Style::Box;',
	1,
	'',
	1241);
INSERT INTO O_TFR
	VALUES (1237,
	30,
	'get_compartment_text',
	'This class returns text from a given compartment and location.
-----------------------------------------------------------------------------------
Bridge:GD',
	322,
	1,
	'result = "";
//
// Compartment 1
//
if (param.comp_num == 1)
  if (param.ent_num == 1)
    if (param.at == Justification::Center_in_X)
      result = self.Name;
      select one pe related by self->PE_PE[R8001];
      if not_empty pe
        result = pe.getVisibilityAdornment() + result;
      end if;
    end if;
  elif (param.ent_num == 2)
    if (param.at == Justification::Right)
      result = "{" + GD::int_to_string(value:self.Numb) + "," + self.Key_Lett + "}";
    end if;
  end if;
//
// Compartment 2
//
elif (param.comp_num == 2)
  select any attr related by self->O_ATTR[R102] where (selected.PAttr_ID == GD::NULL_UNIQUE_ID());
  if (param.at != Justification::Center)
    cursor = param.ent_num;
    while (not_empty attr AND cursor > 1)
      select one attr related by attr->O_ATTR[R103.''precedes''];
      cursor = cursor - 1;
    end while;
    if (empty attr) 
      return "";
    end if;
  end if;
  if (param.at == Justification::Left)
    select one dt related by attr->S_DT[R114];
    select one rattr related by attr->O_RATTR[R106];
    if (not_empty rattr)
      select one dt related by rattr->O_BATTR[R113]->O_ATTR[R106]->S_DT[R114];
    end if;
    result = attr.Name;
    result = result + attr.Dimensions;
    result = result + ":";
    if ( not_empty dt )
      result = result + dt.Name;
    else
      result = result + ::getOrphanedElementName();
    end if;
  elif (param.at == Justification::Right)
    tag_sep = "";
    // make sure the identifier tags are output in increasing order
    id_num_loop = 0;
    select many ids related by attr->O_ID[R105];    
    while ( id_num_loop < 3 )
      for each id in ids
        if ( id.Oid_ID == id_num_loop )
          result = result + tag_sep + "I";
          if (id.Oid_ID > 0)
            idnum = id.Oid_ID + 1;
            result = result + GD::int_to_string(value:idnum);
          end if;
          tag_sep = ",";
        end if;
      end for;
      id_num_loop = id_num_loop + 1;
    end while;
    select many refs related by attr->O_RATTR[R106]->O_REF[R108];
    if (not_empty refs)
      //
      // Find the first in the list of references
      //
      select any ref related by attr->O_RATTR[R106]->O_REF[R108] where (selected.PARef_ID == GD::NULL_UNIQUE_ID());
      //
      // Traverse reference list and add reference to text
      //
      while (not_empty ref)
        result =  result + tag_sep + ref.get_text(includeTextPhrase:false);
        tag_sep = ",";
        select one ref related by ref->O_REF[R112.''precedes''];
      end while;
    end if;
    //
    // Add Mathematically derived marker
    //
    select one derived_attr related by attr->O_BATTR[R106]->O_DBATTR[R107];
    if (not_empty derived_attr)
      result = result + tag_sep + "M";
      tag_sep = ",";
    end if;
    if (result != "")
      result = "{" + result + "}";
    end if;
  end if;
//
// Compartment 3
//
elif (param.comp_num == 3)
  if (param.at == Justification::Left)
    cursor = 1;
    select any op related by self->O_TFR[R115] where (selected.Previous_Tfr_ID == GD::NULL_UNIQUE_ID());
    line_separator = "";
    while (not_empty op)
      if (cursor == param.ent_num)
        result = result + line_separator;
        result = result + op.Name + "(";
        select any parm related by op->O_TPARM[R117]  where (selected.Previous_TParm_ID == GD::NULL_UNIQUE_ID());
        parm_separator = "";
        while (not_empty parm)
          result = result + parm_separator;
          result = result + parm.Name;
          result = result + parm.Dimensions;
          result = result + ":";
          select one dt related by parm->S_DT[R118];
          if ( not_empty dt )
            result = result + dt.Name;
          else
            result = result + ::getOrphanedElementName();
          end if;
          parm_separator = ", ";
          select one parm related by parm->O_TPARM[R124.''precedes''];
        end while;
        result = result + ")";
        result = result + op.Return_Dimensions;
        result = result + ":";
        select one dt related by op->S_DT[R116];
        if ( not_empty dt )
          result = result + dt.Name;
        else
          result = result + ::getOrphanedElementName();
        end if;
      end if;
      cursor = cursor + 1;
      select one op related by op->O_TFR[R125.''precedes''];
    end while;
  end if;
end if;
return result;
',
	1,
	'',
	1242);
INSERT INTO O_TPARM
	VALUES (1243,
	1237,
	'comp_num',
	298,
	0,
	'',
	1244,
	'');
INSERT INTO O_TPARM
	VALUES (1245,
	1237,
	'ent_num',
	298,
	0,
	'',
	1243,
	'');
INSERT INTO O_TPARM
	VALUES (1244,
	1237,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1246,
	30,
	'get_text_style',
	'Most entries have no special formatting, but in the case of a class
based operation, the name should be underlined.
-----------------------------------------------------------------------------------
Bridge:GD',
	784,
	1,
	'//
// Compartment 3
//
if (param.comp_num == 3)
  if (param.at == Justification::Left)
    cursor = 1;
    select many ops related by self->O_TFR[R115];
    for each op in ops
      if (cursor == param.ent_num)
        if (op.Instance_Based == Scope::Instance)
          return Style::None;
        else
          return Style::Underlined;
        end if;
      end if;
      cursor = cursor + 1;
    end for;
  end if;
end if;
return Style::None;',
	1,
	'',
	1240);
INSERT INTO O_TPARM
	VALUES (1247,
	1246,
	'comp_num',
	298,
	0,
	'',
	1248,
	'');
INSERT INTO O_TPARM
	VALUES (1249,
	1246,
	'ent_num',
	298,
	0,
	'',
	1247,
	'');
INSERT INTO O_TPARM
	VALUES (1248,
	1246,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1241,
	30,
	'get_ooa_id',
	'The ooa_id of a Class is it''s Obj_ID
-----------------------------------------------------------------------------------
Bridge:GD',
	296,
	1,
	'return self.Obj_ID;',
	1,
	'',
	1238);
INSERT INTO O_TFR
	VALUES (1250,
	30,
	'initialize',
	'Initialize a new Class instance.',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
name = ::getUniqueInitialName(
    instance: self.convertToInstance(),
    candidateName: "Unnamed Class");
success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:true);    
if ( success!="") 
 self.Name=success;
else 
 self.dispose();
end if;    


select one packageableElem related by self->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;

// Note that this is here just to get the variable classes into context.
select many classes related by package->PE_PE[R8000]->O_OBJ[R8001];

if (isInGenericPackage)
  if (not_empty package)
    // we''re in a package, get the classes in the package and set the class number
    select many classes related by package->PE_PE[R8000]->O_OBJ[R8001];
    if ( package.Num_Rng == 0 )
      self.Numb = 1;
    else
      self.Numb = package.Num_Rng;
    end if;
  else
    rootCompIdInPkg = component.getRootComponentId();
    select any rootComponent from instances of C_C where (selected.Id == rootCompIdInPkg);
    select one package related by rootComponent->PE_PE[R8001]->EP_PKG[R8000];
    
    if ( package.Num_Rng == 0 )
      self.Numb = 1;
    else
      self.Numb = package.Num_Rng;
    end if;
  end if;
else
  // this model-class''s default number is either one or
  // the starting value in the number range of its owning subsystem
  // if the range is not zero
  select one ss related by self->S_SS[R2];
  select many classes related by ss->O_OBJ[R2];
  if not_empty ss
    if ( ss.Num_Rng == 0 )
      self.Numb = 1;
    else
      self.Numb = ss.Num_Rng;
    end if;
    if (ss.Prefix != "")
      self.Key_Lett = ss.Prefix + "_";
    end if;
  end if;  
end if;

// for each model-class associated with this model-class''s
// owning subsystem or package
for each clazz in classes
  // if this class equals self, skip it
  if (clazz.Obj_ID == self.Obj_ID) continue; end if;

  // if this other class''s number is greater than this model-class''s number
  if (clazz.Numb >= self.Numb)
    // have this model-class''s number be just greater
    // than this other class''s number
    self.Numb = clazz.Numb + 1;
  end if;
end for;

self.Key_Lett = OS::remove_spaces(s:name);
self.addIdentifiers();

// create an instance state machine id and a class state machine
// id
self.Ism_ID = Util::getUniqueStateMachineId(classId:self.Obj_ID, type:"i");
self.Csm_ID = Util::getUniqueStateMachineId(classId:self.Obj_ID, type:"c");',
	1,
	'',
	1246);
INSERT INTO O_TFR
	VALUES (1251,
	30,
	'dispose',
	'The Model Class dispose function.',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Association Subsystem
select many assocs related by self->R_REL[R201];
for each assoc in assocs
   if ( self.isEssentialToAssoc( id: assoc.Rel_ID ) )
     assoc.dispose();
   end if;
end for;
select many oirs related by self->R_OIR[R201];
for each oir in oirs
  oir.dispose();
end for;
//
// Subsystem Subsystem
select many iobjs related by self->O_IOBJ[R101];
for each iobj in iobjs
  iobj.dispose();
end for;
select many oids related by self->O_ID[R104];
for each oid in oids
  oid.dispose();
end for;
select many attrs related by self->O_ATTR[R102];
for each attr in attrs
  attr.dispose();
end for;
select many tfrs related by self->O_TFR[R115];
for each tfr in tfrs
  tfr.dispose();
end for;
//
// Domain Subsystem
select one ss related by self->S_SS[R2];
if (not_empty ss)
  unrelate self from ss across R2;
end if;
//   In the Domain SS, datatype disposals are initiated through S_DT.dispose().
//   So, for the inst_ref and inst_ref_set, call the supertype S_DT.dispose()
//   and it will clean up all the associations and the S_IRDT subtypes.
select many irdts related by self->S_IRDT[R123];
for each irdt in irdts
  unrelate self from irdt across R123;
  select one dt related by irdt->S_DT[R17];
  dt.dispose();
end for;
//
// State Machine Subsystem
select one ism related by self->SM_ISM[R518];
if (not_empty ism)
  select one sm related by ism->SM_SM[R517];
  sm.dispose();
  unrelate self from ism across R518;
end if;
select one asm related by self->SM_ASM[R519];
if (not_empty asm)
  select one sm related by asm->SM_SM[R517];
  sm.dispose();
  unrelate self from asm across R519;
end if;
//
// Communication and Access Subsystem
select many accpaths related by self->CA_SMOA[R417]->CA_ACC[R415];
for each accpath in accpaths
  accpath.dispose();
end for;
//
// Body Subsystem
select many forstmts related by self->ACT_FOR[R670];
for each forstmt in forstmts
  unrelate self from forstmt across R670;
end for;
//
// Instance Access Subsystem
select many crs related by self->ACT_CR[R671];
for each cr in crs
  unrelate self from cr across R671;
end for;
select many cnvs related by self->ACT_CNV[R672];
for each cnv in cnvs
  unrelate self from cnv across R672;
end for;
//
// Selection Subsystem
select many selws related by self->ACT_FIW[R676];
for each selw in selws
  unrelate self from selw across R676;
end for;
select many sfms related by self->ACT_FIO[R677];
for each sfm in sfms
  unrelate self from sfm across R677;
end for;
select many links related by self->ACT_LNK[R678];
for each link in links
  unrelate self from link across R678;
end for;
//
// Value Subsystem
select many vinsts related by self->V_INT[R818];
for each vinst in vinsts
  unrelate self from vinst across R818;
end for;
select many vinsets related by self->V_INS[R819];
for each vinset in vinsets
  unrelate self from vinset across R819;
end for;
//
// Instance Subsystem
//
// For each sequence participant this class is associated with
select many cps related by self->SQ_CP[R939];
for each cp in cps
  // unformalize the participant
  cp.unformalize();
end for;
select many cips related by self->SQ_CIP[R934];
for each cip in cips
  // unformalize the participant
  cip.unformalize();
end for;
select one pe related by self->PE_PE[R8001];
if (not_empty pe)
  unrelate self from pe across R8001;
  pe.dispose();
end if;
//
// Finally, delete self
delete object instance self;
',
	1,
	'',
	1252);
INSERT INTO O_TFR
	VALUES (1252,
	30,
	'create_sm',
	'Create a related ISM or ASM depending on the value of the sm_type parameter.
Check if a sm of that type already exists.  If so, return false.
If not, create the ism or asm and return true.',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
if (param.sm_type == "ISM")
  select one ism related by self->SM_ISM[R518];
  if (not_empty ism)
    return FALSE;
  else
    // in order to use the already created ism id
    // we must use a bridge function which allows
    // setting the SM_ID, the SM_ISM and SM_SM
    // instances must be created natively
    Util::createInstanceStateMachine(class:self.convertToInstance());
    select one ism related by self->SM_ISM[R518];
    select one sm related by ism->SM_SM[R517];
    create object instance moore of SM_MOORE;
    relate sm to moore across R510;
    // add current state attribute
    newAttr_id = self.newAttribute();
    //
    // Find the attribute we just created
    //
    select any attr related by self->O_ATTR[R102] where selected.Attr_ID == 
                                                                     newAttr_id;
    attr.Root_Nam = "current_state";
    select any dom from instances of S_DOM;
    select any dt related by dom->S_DT[R14] where
                                          selected.Name == "state<State_Model>";
    if(empty dt)
      // if the state model dt was not found check the system level
      // dts, traversing through a package or through the domain if it is the
      // formal content of a component.
      select one system related by self->PE_PE[R8001]->
                                                    EP_PKG[R8000]->S_SYS[R1405];
      if(not_empty dom and dom.participatesInSystem())
        select one system related by dom->CN_DC[R4204]->C_C[R4204]->CP_CP[R4608]
                                                                 ->S_SYS[R4606];
      end if;
      dt_id = GD::NULL_UNIQUE_ID();
      if not_empty system
        dt_id = system.getCoreTypeId(name:"state<State_Model>");
      end if;
      select any pe from instances of PE_PE where selected.Element_ID == dt_id;
      select one dt related by pe->S_DT[R8001];
    end if;
    if (not_empty dt)
      select one oldDT related by attr->S_DT[R114];
      unrelate attr from oldDT across R114;
      relate attr to dt across R114;
    else
      USER::logError(msg:
                     "Unable to locate expected data type: state<State_Model>",path:self.getPath(path:self.Name,includeSelf:true));
    end if;
  end if;
elif (param.sm_type == "ASM")
  select one asm related by self->SM_ASM[R519];
  if(not_empty asm)
    return FALSE;
  else
    Util::createClassStateMachine(class:self.convertToInstance());
    select one csm related by self->SM_ASM[R519];
    select one sm related by csm->SM_SM[R517];
    create object instance moore of SM_MOORE;
    relate sm to moore across R510;
  end if;
else
  return FALSE;
end if;
return TRUE;',
	1,
	'',
	1253);
INSERT INTO O_TPARM
	VALUES (1254,
	1252,
	'sm_type',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1255,
	30,
	'newAttribute',
	'',
	296,
	1,
	'//
// Find the last attribute currently in the list
//
create object instance newAttr of O_ATTR;
self.addAttributeToOrdering(id:newAttr.Attr_ID);
select many cips related by self->SQ_CIP[R934];
// For each sequence instance this class is associated with
for each cip in cips
  // add an attribute value to the instance for the new attribute
  create object instance attrValue of SQ_AV;
  create object instance fav of SQ_FAV;
  relate attrValue to cip across R937;
  relate attrValue to newAttr across R938;
  relate fav to attrValue across R948;
end for;
relate self to newAttr across R102;
newAttr.initialize();
return newAttr.Attr_ID;
',
	1,
	'',
	1256);
INSERT INTO O_TFR
	VALUES (1257,
	30,
	'newOperation',
	'Create a new operation for this class.
',
	19,
	1,
	'create object instance operation of O_TFR;
relate self to operation across R115;
operation.initialize();
',
	1,
	'',
	1258);
INSERT INTO O_TFR
	VALUES (1259,
	30,
	'isEssentialToAssoc',
	'Finding and clearing associative associations first is essential to cleanly disposing of a Model
Class. ',
	316,
	1,
	'retval = true;
select many oir_set related by self->R_OIR[R201] where ( selected.Rel_ID == param.id ); 
for each oir in oir_set
   select one rgo related by oir->R_RGO[R203];
   select one sub related by rgo->R_SUB[R205];
   if ( not_empty sub )
     retval = false;
     break;
   end if;
   select one link related by rgo->R_ASSR[R205];
   if ( not_empty link )
     retval = false;
     break;
   end if;
end for;
return retval;
',
	1,
	'',
	1260);
INSERT INTO O_TPARM
	VALUES (1261,
	1259,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1262,
	30,
	'addIdentifiers',
	'This operation ensures that there are three identifiers defined for the class.
',
	19,
	1,
	'select any oid1 related by self->O_ID[R104] where ( selected.Oid_ID == 0 );
if ( empty oid1 )
  create object instance oid1 of O_ID;
  oid1.Oid_ID = 0;
  relate oid1 to self across R104;
end if;
select any oid2 related by self->O_ID[R104] where ( selected.Oid_ID == 1 );
if ( empty oid2 )
  create object instance oid2 of O_ID;
  oid2.Oid_ID = 1;
  relate oid2 to self across R104;
end if;
select any oid3 related by self->O_ID[R104] where ( selected.Oid_ID == 2 );
if ( empty oid3 )
  create object instance oid3 of O_ID;
  oid3.Oid_ID = 2;
  relate oid3 to self across R104;
end if;

',
	1,
	'',
	1263);
INSERT INTO O_TFR
	VALUES (1264,
	30,
	'findUnusedIdentifier',
	'Find an identifier for the class that is not in use.  I.e., there are no attributes related
to it.   Return either the Oid_ID if one is found, or -1 if all are in use.
',
	298,
	1,
	'select many oid_set related by self->O_ID[R104];
for each oid in oid_set
  select any oida related by oid->O_OIDA[R105];
  if ( empty oida );
    return oid.Oid_ID;
  end if;
end for;
return -1;
',
	1,
	'',
	1265);
INSERT INTO O_TFR
	VALUES (1266,
	30,
	'newReferentialAttribute',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.

select any ref_obj related by self->S_SS[R2]->S_DOM[R1]->S_SS[R1]->O_OBJ[R2]
      where selected.Obj_ID == param.ref_obj_id;

// check for isInGenericPackage
if (empty ref_obj)
  select any ref_obj related by self->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405]->EP_PKG[R1405]->PE_PE[R8000]->O_OBJ[R8001]
      where selected.Obj_ID == param.ref_obj_id;
end if;
    
select any ref_oid related by ref_obj->O_ID[R104] 
    where selected.Oid_ID == param.ref_oid_id;
select any ref_oida related by ref_oid->O_OIDA[R105] 
    where selected.Attr_ID == param.ref_attr_id;

select one id_attr related by ref_oida->O_ATTR[R105];

select one base_attr related by id_attr->O_BATTR[R106];
if ( empty base_attr )
  select one base_attr related by id_attr->O_RATTR[R106]->O_BATTR[R113];
end if;

newAttr_id = self.newAttribute();
select any attr related by self->O_ATTR[R102] where selected.Attr_ID == newAttr_id;
attr.migrateBaseToReferential();
attr.Root_Nam = id_attr.Name;

select one ref_attr related by attr->O_RATTR[R106];
relate ref_attr to base_attr across R113;

if ( param.id != -1 )
  select any assr_id related by self->O_ID[R104] where selected.Oid_ID == param.id;
  create object instance assr_oida of O_OIDA;
   relate attr to assr_id across R105 using assr_oida;
end if;
return newAttr_id;
',
	1,
	'',
	1257);
INSERT INTO O_TPARM
	VALUES (1267,
	1266,
	'ref_obj_id',
	296,
	0,
	'',
	1268,
	'');
INSERT INTO O_TPARM
	VALUES (1269,
	1266,
	'ref_oid_id',
	298,
	0,
	'',
	1267,
	'');
INSERT INTO O_TPARM
	VALUES (1268,
	1266,
	'ref_attr_id',
	296,
	0,
	'',
	1270,
	'');
INSERT INTO O_TPARM
	VALUES (1270,
	1266,
	'id',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1263,
	30,
	'actionFilter',
	'Bridge: UI',
	316,
	1,
	'if (param.name == "can")
  if (param.value == "instanceStateChart")
    select one ism related by self->SM_ISM[R518];
    return empty ism;
  elif (param.value == "classStateChart")
    select one asm related by self->SM_ASM[R519];
    return empty asm;
  elif (param.value == "publishRefs")
    prefEnableInstanceReferences = "bridgepoint_prefs_enable_instance_references";
    if (PREF::getBoolean( name:prefEnableInstanceReferences) == true)
      select any ir related by self->S_IRDT[R123] where selected.isSet == false;
      select any irs related by self->S_IRDT[R123] where selected.isSet == true;
      if ((empty ir) or (empty irs))
        return true;
      end if;
    end if;
  elif param.value == "make public"
    select one pe related by self->PE_PE[R8001];
    select one pkg related by pe->EP_PKG[R8000];
    if not_empty pkg
      if not_empty pe 
        return pe.Visibility != Visibility::Public;
      end if;
    end if;
  elif param.value == "make protected"
    select one pe related by self->PE_PE[R8001];
    select one pkg related by pe->EP_PKG[R8000];
    if not_empty pkg
      if not_empty pe 
        return pe.Visibility != Visibility::Protected;
      end if;
    end if;
  elif param.value == "make private"
    select one pe related by self->PE_PE[R8001];
    select one pkg related by pe->EP_PKG[R8000];
    if not_empty pkg
      if not_empty pe 
        return pe.Visibility != Visibility::Private;
      end if;
    end if;
  end if;
end if;
return false;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (1271,
	1263,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (1272,
	1263,
	'value',
	322,
	0,
	'',
	1271,
	'');
INSERT INTO O_TFR
	VALUES (1256,
	30,
	'isSupertypeOf',
	'',
	316,
	1,
	'/*
Returns whether this class is a supertype of the one whose ID is given.
*/

// for each supertype of the given class
select any givenClass from instances of O_OBJ
	where selected.Obj_ID == param.classId;
select many supertypes related by givenClass->R_OIR[R201]->R_RGO[R203]
	->R_SUB[R205]->R_SUBSUP[R213]->R_SUPER[R212]
	->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201];
for each supertype in supertypes
	// if this supertype is self, or a recursive call to this operation says 
	// that some supertype of this supertype is self
	if (supertype == self or self.isSupertypeOf(classId:supertype.Obj_ID)) 
		// this class is a supertype of the one given
		return true;
	end if;
end for;

return false;',
	1,
	'',
	1259);
INSERT INTO O_TPARM
	VALUES (1273,
	1256,
	'classId',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1242,
	30,
	'getPath',
	'',
	322,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
path = "";
if(param.includeSelf)
  path = self.Name;
end if;
if(param.path != "")
  path = path + "::" + param.path;
end if;

isInGenericPkg = false;
select one pkg related by self->PE_PE[R8001]->EP_PKG[R8000];
if (not_empty pkg)
  isInGenericPkg = true;
end if;

if (isInGenericPkg)
  return pkg.getPath(path:path);
else
  select one ss related by self->S_SS[R2];
  if(not_empty ss)
    return ss.getPath(path:path);
  else
    return "";
  end if;
end if;   
',
	1,
	'',
	1274);
INSERT INTO O_TPARM
	VALUES (1275,
	1242,
	'path',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (1276,
	1242,
	'includeSelf',
	316,
	0,
	'',
	1275,
	'');
INSERT INTO O_TFR
	VALUES (1277,
	30,
	'eventIsClassBased',
	'',
	316,
	1,
	'/*
This operation only exists because of a bug in MC-Java where an operation may 
not be called on the selected item in the where clause of a select statement.
*/

select any event from instances of SM_EVT 
	where selected.SMevt_ID == param.eventId 
	and (selected.SM_ID == param.instanceStateMachineId
	or selected.SM_ID == param.classStateMachineId);
return event.isClassBased();',
	1,
	'',
	1278);
INSERT INTO O_TPARM
	VALUES (1279,
	1277,
	'eventId',
	296,
	0,
	'',
	1280,
	'');
INSERT INTO O_TPARM
	VALUES (1281,
	1277,
	'instanceStateMachineId',
	296,
	0,
	'',
	1279,
	'');
INSERT INTO O_TPARM
	VALUES (1280,
	1277,
	'classStateMachineId',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1274,
	30,
	'getNumCompartmentIconSlots',
	'',
	298,
	1,
	'/*
Returns how many icon slots there are within the given compartment of a 
model-class''s representative shape.
*/
                                      
// there are the two state machine icons in the first compartment
if (param.compartmentNum == 1) 
  return 2;
end if;
                                   
return 0;',
	1,
	'',
	1264);
INSERT INTO O_TPARM
	VALUES (1282,
	1274,
	'compartmentNum',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1283,
	30,
	'shouldCompartmentIconBeDrawn',
	'',
	316,
	1,
	'/*
Returns whether the icon of the given slot within the given compartment of
this model-class''s representative shape should be drawn. 
*/
                                   
// if the first compartment is being considered
if (param.compartmentNum == 1)
  // the first slot corresponds to this class''s instance state machine
  if (param.slotNum == 0) 
    select one machine related by self->SM_ISM[R518];
    return not_empty machine;
  end if;
                                   
  // the second slot corresponds to this class''s class state machine
  if (param.slotNum == 1) 
    select one machine related by self->SM_ASM[R519];
    return not_empty machine;
  end if;
end if;
                                   
return false;',
	1,
	'',
	1284);
INSERT INTO O_TPARM
	VALUES (1285,
	1283,
	'compartmentNum',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (1286,
	1283,
	'slotNum',
	298,
	0,
	'',
	1285,
	'');
INSERT INTO O_TFR
	VALUES (1253,
	30,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'// just return this instance as an Object
return this;',
	0,
	'',
	1262);
INSERT INTO O_TFR
	VALUES (1287,
	30,
	'pasteAttribute',
	'',
	19,
	1,
	'select any attribute from instances of O_ATTR
                                           where (selected.Attr_ID == param.id);
if(not_empty attribute)
  // remove any incomplete referentials
  result = self.removeIncompleteReferential(id:attribute.Attr_ID);
  if(not result)
    // otherwise hook this attribute up with the class
    select one existingClass related by attribute->O_OBJ[R102];
    if(not_empty existingClass)
      unrelate existingClass from attribute across R102;
    end if;
    // set up ordering
    self.addAttributeToOrdering(id:attribute.Attr_ID);
    relate self to attribute across R102;
    // configure the name
    attribute.Root_Nam = ::getUniqueInitialNameInParent(instance:
                                                  attribute.convertToInstance(),
  						  name:attribute.Root_Nam, parent:self.convertToInstance());
  end if;
end if;',
	1,
	'',
	1266);
INSERT INTO O_TPARM
	VALUES (1288,
	1287,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1289,
	30,
	'removeIncompleteNonLocalEvents',
	'',
	19,
	1,
	'// for each state machine remove all non-local events
// if the inherited event was not copied as well, or if
// the association between the supertype/subtype association
// was not copied
select one asm related by self->SM_ASM[R519]->SM_SM[R517];
if(not_empty asm)
  asm.removeIncompleteNonLocalEvents();
end if;
select one ism related by self->SM_ISM[R518]->SM_SM[R517];
if(not_empty ism)
  ism.removeIncompleteNonLocalEvents();
end if;',
	1,
	'',
	1287);
INSERT INTO O_TFR
	VALUES (1265,
	30,
	'findImportedSupertypeClass',
	'',
	296,
	1,
	'/*
Find the imported class that actually provides the supertype association
to the supertype class for the given class.
*/
// for each supertype of the given class
select any expectedSuper from instances of O_OBJ
	where selected.Obj_ID == param.supertypeClassId;
	   if(empty expectedSuper)
	     select any expectedImportedSuper from instances of O_IOBJ
	 	    where selected.Obj_ID == param.supertypeClassId;
	 	      if(not_empty expectedImportedSuper)
	 	         select one expectedSuper related by expectedImportedSuper->O_OBJ[R101];
	 	      end if;
	   end if;
select many oirs related by self->R_OIR[R201]->R_RGO[R203]
	->R_SUB[R205]->R_SUBSUP[R213]->R_SUPER[R212]
	->R_RTO[R204]->R_OIR[R203];
for each oir in oirs
  select one supertype related by oir->O_OBJ[R201];
  if (supertype == expectedSuper)
    select one iobj related by oir->O_IOBJ[R202];
    if(not_empty iobj)
      return iobj.IObj_ID;
    end if;
  else
    // the supertype may exist further up the hierarchy
    // make a recursive call
    id = supertype.findImportedSupertypeClass(supertypeClassId:param.supertypeClassId);
    if(id != GD::NULL_UNIQUE_ID())
      return id;
    end if;
  end if;
end for;
return GD::NULL_UNIQUE_ID();',
	1,
	'',
	1277);
INSERT INTO O_TPARM
	VALUES (1290,
	1265,
	'supertypeClassId',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1278,
	30,
	'disposeLowerNonLocalEvents',
	'',
	19,
	1,
	'select any originalClass from instances of O_OBJ where (selected.Obj_ID == param.originalId);
if(not_empty originalClass)
  select any supertypeClass from instances of O_OBJ where (selected.Obj_ID == param.originalSupertypeId);
  // if the event''s class is a supertype of the original class
  // remove the non-local events
  if(self != originalClass or param.disposeSelfEvents)
    select one machine related by self->SM_ISM[R518]->SM_SM[R517];
    if(not_empty machine)
      select many nlevts related by machine->SM_EVT[R502]->SM_SEVT[R525]
    	  ->SM_NLEVT[R526];
      for each nlevt in nlevts
        select one poly related by nlevt->SM_PEVT[R527];
        if empty poly
          select one evt related by nlevt->SM_SEVT[R526]->SM_EVT[R525];
          if not empty evt
            evt.dispose(); 
            Util::logError(message: "An orphaned polymorphic event was found"+ 
            "and removed while deleting the owning class.");
          end if;
          continue;
        end if;
        select one polyClass related by poly->SM_EVT[R525]->SM_SM[R502]
        		->SM_ISM[R517]->O_OBJ[R518];
        disposeEvent = not polyClass.isSupertypeOf(classId:self.Obj_ID);
        if(param.polyId != GD::NULL_UNIQUE_ID())
          if(polyClass.isSupertypeOf(classId:originalClass.Obj_ID))
            select any polyEvt from instances of SM_EVT where (selected.SMevt_ID == param.polyId);
            if(not_empty polyEvt)
              select one pe related by polyEvt->SM_PEVT[R525];
              disposeEvent = poly == pe;
            end if;
          end if;
        end if;
        if(disposeEvent)
          select one evt related by nlevt->SM_SEVT[R526]->SM_EVT[R525];
          evt.dispose();
          poly.migrateToLocalEvent();
        end if;
      end for;
    end if;
  end if;
  // select all subtypes of the supertype class
  select many subtypes related by self->R_OIR[R201]->R_RTO[R203]
  		->R_SUPER[R204]->R_SUBSUP[R212]->R_SUB[R213]->R_RGO[R205]->R_OIR[R203]
  		->O_OBJ[R201];
  for each subtype in subtypes
    subtype.disposeLowerNonLocalEvents(originalId:param.originalId, disposeSelfEvents:param.disposeSelfEvents, polyId:param.polyId, originalSupertypeId:param.originalSupertypeId);
  end for;
end if;',
	1,
	'',
	1251);
INSERT INTO O_TPARM
	VALUES (1291,
	1278,
	'originalId',
	296,
	0,
	'',
	1292,
	'');
INSERT INTO O_TPARM
	VALUES (1293,
	1278,
	'polyId',
	296,
	0,
	'',
	1294,
	'');
INSERT INTO O_TPARM
	VALUES (1292,
	1278,
	'disposeSelfEvents',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (1294,
	1278,
	'originalSupertypeId',
	296,
	0,
	'',
	1291,
	'');
INSERT INTO O_TFR
	VALUES (1295,
	30,
	'removeInconsistentSubtypeIgnores',
	'',
	19,
	1,
	'/*
Traverse down the supertype/subtype hierarchy until we find
one event ignored.  At which point we dispose all lower non-local
events.
*/
select many subtypes related by self->R_OIR[R201]->R_RTO[R203]->R_SUPER[R204]
  ->R_SUBSUP[R212]->R_SUB[R213]->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201];
for each subtype in subtypes
  select many nlevts related by subtype->SM_ISM[R518]->SM_SM[R517]
    ->SM_EVT[R502]->SM_SEVT[R525]->SM_NLEVT[R526];
  for each nlevt in nlevts
    select any ignore related by nlevt->SM_SEVT[R526]->SM_SEME[R503]
      ->SM_EIGN[R504];
    select any transition related by nlevt->SM_SEVT[R526]->SM_SEME[R503]
      ->SM_NSTXN[R504];
    if(not_empty ignore) and (empty transition)
      // if there is an ignore and no transition, remove all non-local events
      // used below this subtype
      select one poly related by nlevt->SM_PEVT[R527]->SM_EVT[R525];
      subtype.disposeLowerNonLocalEvents(disposeSelfEvents:false, originalId:subtype.Obj_ID, polyId:poly.SMevt_ID, originalSupertypeId:self.Obj_ID);
    else
      // recurse to the any subtypes of this subtype
      subtype.removeInconsistentSubtypeIgnores();
    end if;
  end for;
end for;',
	1,
	'',
	1289);
INSERT INTO O_TFR
	VALUES (1284,
	30,
	'rename',
	'Rename the class and the instance reference and instance reference set datatypes
associated with this class.',
	19,
	1,
	'if(OS::remove_spaces(s:self.Name) == self.Key_Lett)
  self.Key_Lett = OS::remove_spaces(s:param.new_name);
end if;
self.Name = param.new_name;

select any ir related by self->S_IRDT[R123] where selected.isSet == false;
if (not_empty ir)
  ir.rename(new_name: "inst_ref<" + param.new_name + ">");
end if;

select any irs related by self->S_IRDT[R123] where selected.isSet == true;
if (not_empty irs)
  irs.rename(new_name: "inst_ref_set<" + param.new_name + ">");
end if;',
	1,
	'',
	1295);
INSERT INTO O_TPARM
	VALUES (1296,
	1284,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1258,
	30,
	'newInstanceReferenceDataType',
	'This function creates two new S_IRDT datatypes.  These are instance reference
datatypes that are associated with a model class.  One is inst_ref<classname>,
the other is inst_ref_set<classname>.',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Model Class::newInstanceReferenceDataType()
select one packageableElem related by self->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;
if (isInGenericPackage)
  // Make sure the IRDTs don''t already exist before creating new ones.  Check
  // the single and set version and create whatever does not exist.
  select any existing_irdt related by self->S_IRDT[R123] where selected.isSet == false;
  if (empty existing_irdt)
    create object instance pe of PE_PE;
    relate pe to package across R8000;
    pe.initialize();
    pe.type = ElementTypeConstants::DATATYPE;
    create object instance dt of S_DT;
    relate pe to dt across R8001;
    create object instance irdt of S_IRDT;
    irdt.isSet = false;
    relate dt to irdt across R17;

    dt.initialize(newname:"inst_ref<" + self.Name + ">");
    relate self to irdt across R123;
  end if;

  select any existing_irdt_set related by self->S_IRDT[R123] where selected.isSet == true;
  if (empty existing_irdt_set)
    create object instance pe of PE_PE;
    relate pe to package across R8000;
    pe.initialize();
    pe.type = ElementTypeConstants::DATATYPE;
    create object instance dt2 of S_DT;
    relate pe to dt2 across R8001;
    create object instance irsdt of S_IRDT;
    irsdt.isSet = true;
    relate irsdt to dt2 across R17;
  
    dt2.initialize(newname:"inst_ref_set<" + self.Name + ">");
    relate self to irsdt across R123;
  end if;  
  return;
end if;

// Below this point is for the case where this O_OBJ is not in a generic package

select one dom related by self->S_SS[R2]->S_DOM[R1];
select any dtp related by dom->S_DPK[R40] where selected.Name == "Datatypes";

if (empty dtp)
  // Note: this code would ideally call Domain.newDatatypePackage(), but that
  // does not return the UUID of the newly created package (or an inst_ref to
  // the new package).  If possible, change the function and call it from here.
  create object instance dtp of S_DPK;
  dtp.Name = "Datatypes";
  relate dtp to dom across R40;
end if;

// Make sure the IRDTs don''t already exist before creating new ones.  Check
// the single and set version and create whatever does not exist.
select any existing_irdt related by self->S_IRDT[R123] where selected.isSet == false;
if (empty existing_irdt)
  create object instance dt of S_DT;
  create object instance irdt of S_IRDT;
  irdt.isSet = false;
  relate dt to irdt across R17;

  create object instance dip of S_DIP;
  relate dt to dtp across R39 using dip;

  dt.initialize(newname:"inst_ref<" + self.Name + ">");
  dtp.associateNewDTWithDomainOrSystem(dt_id:dt.DT_ID);
  relate self to irdt across R123;
end if;

select any existing_irdt_set related by self->S_IRDT[R123] where selected.isSet == true;
if (empty existing_irdt_set)
  create object instance dt2 of S_DT;
  create object instance irsdt of S_IRDT;
  irsdt.isSet = true;
  relate irsdt to dt2 across R17;

  create object instance dip of S_DIP;
  relate dt2 to dtp across R39 using dip;

  dt2.initialize(newname:"inst_ref_set<" + self.Name + ">");
  dtp.associateNewDTWithDomainOrSystem(dt_id:dt2.DT_ID);
  relate self to irsdt across R123;
end if;',
	1,
	'',
	1255);
INSERT INTO O_TFR
	VALUES (1260,
	30,
	'initializeOrder',
	'',
	19,
	1,
	'// Alpha-sort the O_TFR elements if they have not yet been ordered
select many peers related by self->O_TFR[R115];
if (cardinality peers > 1)
    initialOrderingCheckPerformed = false;
	select any head related by self->O_TFR[R115] where (selected.Obj_ID == GD::NULL_UNIQUE_ID());
	endOfList = head;
	loopCnt = 0;
	for each peer in peers
	  if ( not initialOrderingCheckPerformed)
	    select one predecessor related by peer->O_TFR[R125.''precedes''];
	    select one successor related by peer->O_TFR[R125.''succeeds''];
	    initialOrderingCheckPerformed = true;
	    if (not_empty  predecessor or not_empty  successor)
	      // Already ordered
	      break;
	    end if;
	    head = peer;
	    endOfList = peer;
	  end if;
	  
      if (loopCnt == 1)
        if (peer.Name < head.Name)
          relate peer to head across R125.''precedes'';
          endOfList = peer;
        else
          relate head to peer across R125.''precedes'';
          head = peer;
        end if;
      elif (loopCnt > 1)
        insertPoint = head;
        select one next related by head->O_TFR[R125.''succeeds''];
        while (not_empty next)
          if (next.Name < peer.Name)
            break;
          else
            insertPoint = next;          
            select one next related by next->O_TFR[R125.''succeeds''];
          end if;
        end while;
        
        if (empty next)
          // New end of list
          relate peer to endOfList across R125.''precedes'';   
          endOfList = peer;       
        else
          if ((insertPoint == head) and (peer.Name > head.Name))
            // New head
            relate head to peer across R125.''precedes'';
            head = peer;
          else
            unrelate next from insertPoint across R125.''precedes'';
            relate peer to insertPoint across R125.''precedes'';
            relate next to peer across R125.''precedes'';
          end if;          
        end if;
      end if;
      
      loopCnt = loopCnt + 1;
	end for;
end if;
',
	1,
	'',
	1250);
INSERT INTO O_TFR
	VALUES (1297,
	30,
	'getContainingComponentId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Model Class.getContainingComponentId()
isInGenericPkg = false;
select one pkg related by self->PE_PE[R8001]->EP_PKG[R8000];
if (not_empty pkg)
  isInGenericPkg = true;
end if;
if (isInGenericPkg)
  select one component related by self->PE_PE[R8001]->C_C[R8003];
  if(not_empty component)
    return component.Id;
  end if;
  if not_empty pkg
    return pkg.getContainingComponentId();
  end if;
  USER::logError(msg:
               "Class has no parent in Model Class.getContainingComponentId()",path:self.getPath(path:self.Name,includeSelf:true));
else
  select one subsystem related by self->S_SS[R2];
  if not_empty subsystem
    return subsystem.getContainingComponentId();
  end if;
end if;   
return GD::NULL_UNIQUE_ID();

',
	1,
	'',
	1283);
INSERT INTO O_TFR
	VALUES (1298,
	30,
	'getContainerId',
	'',
	296,
	1,
	'// Model Class.getContainerId()
select one component related by self->PE_PE[R8001]->C_C[R8003];
if not_empty component
  return component.Id;
else
  select one package related by self->PE_PE[R8001]->EP_PKG[R8000];
  if not_empty package
    return package.Package_ID;
  end if;
end if;
return GD::NULL_UNIQUE_ID();',
	1,
	'',
	1297);
INSERT INTO O_TFR
	VALUES (1299,
	30,
	'pasteOperation',
	'',
	19,
	1,
	'select any operation from instances of O_TFR
                                            where (selected.Tfr_ID == param.id);
if(not_empty operation)
  select one existingObj related by operation->O_OBJ[R115];
  if(not_empty existingObj)
    unrelate operation from existingObj across R115;
  end if;
  relate operation to self across R115;  
  operation.Name = ::getUniqueInitialNameInParent(instance:operation.convertToInstance(),
  						name:operation.Name, parent:self.convertToInstance());
  self.addOperationToOrdering(id:operation.Tfr_ID);
end if;',
	1,
	'',
	1298);
INSERT INTO O_TPARM
	VALUES (1300,
	1299,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1301,
	30,
	'addAttributeToOrdering',
	'',
	19,
	1,
	'select any newAttr from instances of O_ATTR
                                           where (selected.Attr_ID == param.id);
select many attrs related by self->O_ATTR[R102];
for each attr in attrs
 select one nextAttr related by attr->O_ATTR[R103.''precedes''];
  if (empty nextAttr)
    break;
  end if;
end for;
if (not_empty attr)
  //
  // If there was a previous last attribute link this one to the end . . .
  // We need to disable the listeners because the ordering change
  // causes a NPE when the display updates before R102 is formalized
  ::changeNotificationEnablement(enabled:false);
  relate attr to newAttr across R103.''precedes'';
  ::changeNotificationEnablement(enabled:true);
end if;
',
	1,
	'',
	1299);
INSERT INTO O_TPARM
	VALUES (1302,
	1301,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1303,
	30,
	'removeIncompleteReferential',
	'',
	316,
	1,
	'select any attribute from instances of O_ATTR
                                           where (selected.Attr_ID == param.id);
if(not_empty attribute)
  select one refAttr related by attribute->O_RATTR[R106];
  if(not_empty refAttr)
    select any referredToAttr related by refAttr->O_REF[R108]->O_RTIDA[R111];
    select one identAttr related by referredToAttr->O_OIDA[R110];
    select one rto related by referredToAttr->R_RTO[R110];
    if(empty identAttr or empty rto)
      attribute.dispose();
      return true;
    end if;
  end if;
end if;
return false;',
	1,
	'',
	1301);
INSERT INTO O_TPARM
	VALUES (1304,
	1303,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1305,
	30,
	'addOperationToOrdering',
	'',
	19,
	1,
	'select any operation from instances of O_TFR
                                            where (selected.Tfr_ID == param.id);
if(not_empty operation)
  ::changeNotificationEnablement(enabled:false);
  select many peers related by self->O_TFR[R115];
  for each peer in peers
    if (peer != operation)
      select one predecessor related by peer->O_TFR[R125.''precedes''];
      if (empty predecessor)
        relate operation to peer across R125.''succeeds'';
      end if;
    end if;
  end for;
  ::changeNotificationEnablement(enabled:true);
end if;',
	1,
	'',
	1303);
INSERT INTO O_TPARM
	VALUES (1306,
	1305,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1307,
	30,
	'canCopyAttribute',
	'',
	316,
	1,
	'select any attribute related by self->O_ATTR[R102]
                                           where (selected.Attr_ID == param.id);
if(not_empty attribute)
  select one refAttr related by attribute->O_RATTR[R106];
  if(not_empty refAttr)
    return false;
  end if;
else
  return false;
end if;
return true;',
	1,
	'',
	1305);
INSERT INTO O_TPARM
	VALUES (1308,
	1307,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1309,
	30,
	'removeIncompleteSignalEvents',
	'',
	19,
	1,
	'// for each state machine remove all non-local events
// if the inherited event was not copied as well, or if
// the association between the supertype/subtype association
// was not copied
select one asm related by self->SM_ASM[R519]->SM_SM[R517];
if(not_empty asm)
  asm.removeIncompleteSignalEvents();
end if;
select one ism related by self->SM_ISM[R518]->SM_SM[R517];
if(not_empty ism)
  ism.removeIncompleteSignalEvents();
end if;',
	1,
	'',
	1307);
INSERT INTO O_TFR
	VALUES (1310,
	30,
	'checkIntegrity',
	'',
	19,
	1,
	'// check for any classes with the same key letters that are
// also in scope
select one package related by self->PE_PE[R8001]->EP_PKG[R8000];
select many objs related by package->PE_PE[R8000]->O_OBJ[R8001];
for each obj in objs
  if(obj.Key_Lett == self.Key_Lett and obj != self)
    select one system related by package->S_SYS[R1405];
    sys_id = GD::NULL_UNIQUE_ID();
    if(not_empty system)
      sys_id = system.Sys_ID;
    end if;
	MI_IM::createIssue(sys_id:sys_id, description:
	              "Another class within the same package has been found " +
	     "with the same key letters.", severity:Severity::Error, name:self.Name,
	   path:self.getPath(path:self.Name, includeSelf:true), id:self.Obj_ID,
	                                          element:self.convertToInstance());
  end if;
  // also check for duplicate numbers
  if(obj.Numb == self.Numb and obj != self)
    select one system related by package->S_SYS[R1405];
    sys_id = GD::NULL_UNIQUE_ID();
    if(not_empty system)
      sys_id = system.Sys_ID;
    end if;
	MI_IM::createIssue(sys_id:sys_id, description:
	              "Another class within the same package has been found " +
	   "with the same number.", severity:Severity::Warning, name:self.Name,
	   path:self.getPath(path:self.Name, includeSelf:true), id:self.Obj_ID,
	                                          element:self.convertToInstance());
  end if;
end for;',
	1,
	'',
	1309);
INSERT INTO O_NBATTR
	VALUES (1311,
	30);
INSERT INTO O_BATTR
	VALUES (1311,
	30);
INSERT INTO O_ATTR
	VALUES (1311,
	30,
	150,
	'Name',
	'Full Name: Class Name
Description: Name of the class as entered in the model.',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1312,
	30);
INSERT INTO O_BATTR
	VALUES (1312,
	30);
INSERT INTO O_ATTR
	VALUES (1312,
	30,
	1311,
	'Numb',
	'Full Name: Class Number
Description: Number of the class as it appears in the model.
min_value: 0
max_value: 9999
',
	'',
	'Numb',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1313,
	30);
INSERT INTO O_BATTR
	VALUES (1313,
	30);
INSERT INTO O_ATTR
	VALUES (1313,
	30,
	1312,
	'Key_Lett',
	'Full Name: Class Key Letters
Description: Key letters of the class as they appear in the model.',
	'',
	'Key_Lett',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1314,
	30);
INSERT INTO O_BATTR
	VALUES (1314,
	30);
INSERT INTO O_ATTR
	VALUES (1314,
	30,
	1313,
	'Descrip',
	'Full Name: Class Description
Description: This is a description of the class as entered by the user.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (30,
	701,
	0,
	717,
	1315,
	1316,
	1317,
	1318,
	1319,
	0,
	0,
	'',
	'Subsystem',
	'SS_ID',
	'R2.''is contained in''');
INSERT INTO O_RATTR
	VALUES (1318,
	30,
	717,
	701,
	1,
	'SS_ID');
INSERT INTO O_ATTR
	VALUES (1318,
	30,
	1314,
	'SS_ID',
	'',
	'',
	'SS_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (30,
	26,
	0,
	25,
	868,
	1320,
	870,
	150,
	1321,
	0,
	0,
	'',
	'Packageable Element',
	'Element_ID',
	'R8001');
INSERT INTO O_RATTR
	VALUES (150,
	30,
	25,
	26,
	0,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (150,
	30,
	0,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1322,
	30);
INSERT INTO O_BATTR
	VALUES (1322,
	30);
INSERT INTO O_ATTR
	VALUES (1322,
	30,
	1318,
	'Ism_ID',
	'',
	'',
	'Ism_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1323,
	30);
INSERT INTO O_BATTR
	VALUES (1323,
	30);
INSERT INTO O_ATTR
	VALUES (1323,
	30,
	1322,
	'Csm_ID',
	'',
	'',
	'Csm_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	30);
INSERT INTO O_OIDA
	VALUES (150,
	30,
	0,
	'Obj_ID');
INSERT INTO O_ID
	VALUES (1,
	30);
INSERT INTO O_ID
	VALUES (2,
	30);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (1050,
	'Imported Class',
	102,
	'O_IOBJ',
	'Classes can have interactions with classes in other subsystems.  In order to capture these spanning interactions, Classes can be imported into another subsystem.  Spanning interactions can be associations, event communications, or data accesses and are captured in class diagram, communication diagram, and synchronous communication diagram, respectively.  Spanning interactions provide the data for derivation of the subsystem association model, subsystem communication model, and subsystem access model.',
	979);
INSERT INTO O_TFR
	VALUES (1324,
	1050,
	'get_style',
	'An Imported Class looks the same as regular Class, except it''s back-
ground color is different. The background is set as a user preference
and is not controlled here.
-----------------------------------------------------------------------------------
Bridge:GD',
	784,
	1,
	'select one cl related by self->O_OBJ[R101];
if (not_empty cl)
  return cl.get_style();
else
  // Something went wrong
  return Style::None;
end if;',
	1,
	'',
	1325);
INSERT INTO O_TFR
	VALUES (1326,
	1050,
	'get_compartments',
	'An Imported Class has the same number of compartments as the Class
it represents.
-----------------------------------------------------------------------------------
Bridge:GD',
	298,
	1,
	'select one cl related by self->O_OBJ[R101];
if (not_empty cl)
  return cl.get_compartments();
else
  // Imported Class is Unassigned
  return 1;
end if;',
	1,
	'',
	1327);
INSERT INTO O_TFR
	VALUES (1327,
	1050,
	'get_compartment_text',
	'An Imported Class has the same text as the Class it represents, except
that it adds the stereotype "<<Imported>>" to the name compartment.
-----------------------------------------------------------------------------------
Bridge:GD',
	322,
	1,
	'select one cl related by self->O_OBJ[R101];
if (not_empty cl)
  if (param.comp_num == 1)
    if (param.ent_num == 1)
      if (param.at == Justification::Center_in_X)
        return cl.getPath(path:"", includeSelf:true);
      end if;
    end if;
  end if;
  return cl.get_compartment_text(comp_num:param.comp_num,
                                                    ent_num:param.ent_num,
                                                    at:param.at);
else
  // Imported Object is Unassigned
  if (param.comp_num == 1)
    if (param.ent_num == 1)
      if (param.at == Justification::Center_in_X)
        return "Unassigned Imported Class";
      end if;
    end if;
  end if;
  return "";
end if;',
	1,
	'',
	1328);
INSERT INTO O_TPARM
	VALUES (1329,
	1327,
	'comp_num',
	298,
	0,
	'',
	1330,
	'');
INSERT INTO O_TPARM
	VALUES (1331,
	1327,
	'ent_num',
	298,
	0,
	'',
	1329,
	'');
INSERT INTO O_TPARM
	VALUES (1330,
	1327,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1332,
	1050,
	'get_entries',
	'An Imported Class has the same number of entries as the Class it
represents, except for the first compartment in which it adds the
stereotype, "<<Imported>>".
-----------------------------------------------------------------------------------
Bridge:GD',
	298,
	1,
	'select one cl related by self->O_OBJ[R101];
if (not_empty cl)
  entries = cl.get_entries(comp_num:param.comp_num);
  if (param.comp_num == 1)
    entries = entries + 1;
  end if;
  return entries;
else
  // Imported Class is Unassigned
  return 1;
end if;
',
	1,
	'',
	1326);
INSERT INTO O_TPARM
	VALUES (1333,
	1332,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1334,
	1050,
	'get_text_style',
	'An Imported Class has the same text style as the class it represents.
-----------------------------------------------------------------------------------
Bridge:GD',
	784,
	1,
	'select one cl related by self->O_OBJ[R101];
if (not_empty cl)
  return cl.get_text_style(comp_num:param.comp_num, ent_num:param.ent_num, at:param.at);
else
  // Imported Class is Unassigned
  return Style::None;
end if;',
	1,
	'',
	1324);
INSERT INTO O_TPARM
	VALUES (1335,
	1334,
	'comp_num',
	298,
	0,
	'',
	1336,
	'');
INSERT INTO O_TPARM
	VALUES (1337,
	1334,
	'ent_num',
	298,
	0,
	'',
	1335,
	'');
INSERT INTO O_TPARM
	VALUES (1336,
	1334,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1325,
	1050,
	'get_ooa_id',
	'The ooa_id of an Imported Class is it''s IObj_ID
-----------------------------------------------------------------------------------
Bridge:GD',
	296,
	1,
	'return self.IObj_ID;',
	1,
	'',
	1338);
INSERT INTO O_TFR
	VALUES (1339,
	1050,
	'dispose',
	'The dispose operation for an Imported Class.',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Subsystem Subsystem
select one realObj related by self->O_OBJ[R101];
if (not_empty realObj)
  unrelate self from realObj across R101;
end if;  
// Association Subsystem
select many oirs related by self->R_OIR[R202];
for each oir in oirs
  select one assoc related by oir->R_REL[R201];
  if not_empty assoc
    if realObj.isEssentialToAssoc(id: assoc.Rel_ID)
      assoc.dispose();
    else
      oir.dispose();
    end if;
  else
    oir.dispose();
  end if;
end for;
//
// Domain Subsystem
select one ss related by self->S_SS[R3];
if (not_empty ss)
  unrelate self from ss across R3;
end if;
//
// Communication and Access Subsystem
select many oaps related by self->CA_ACC[R425];
for each oap in oaps
  oap.dispose();
end for;
select many daps related by self->CA_SMOA[R420]->CA_ACC[R415];
for each dap in daps
  dap.dispose();
end for;
select many dcps related by self->CA_SMSMC[R414]->CA_COMM[R401];
for each dcp in dcps
  dcp.dispose();
end for;
select many ocps related by self->CA_SMSMC[R424]->CA_COMM[R401];
for each ocp in ocps
  ocp.dispose();
end for;
select one pe related by self->PE_PE[R8001];
if (not_empty pe)
  unrelate self from pe across R8001;
  pe.dispose();
end if;
//
// Finally, delete self
delete object instance self;',
	1,
	'',
	1340);
INSERT INTO O_TFR
	VALUES (1338,
	1050,
	'get_name',
	'',
	322,
	1,
	'select one obj related by self->O_OBJ[R101];
if (not_empty obj)
return obj.Name;
else 
return "Unassigned Imported Class";
end if;
',
	1,
	'',
	1332);
INSERT INTO O_TFR
	VALUES (1341,
	1050,
	'actionFilter',
	'Bridge: UI
',
	316,
	1,
	'if (param.name == "unassigned" )
  // See if it is already assigned and if it is return false
  select one obj related by self->O_OBJ[R101];
  if (not_empty obj) 
    return false;
  end if;
  
  select one packageableElem related by self->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = not_empty package or not_empty component;
  
  if (param.value =="generic pkg" )
    if(not isInGenericPackage)
      return false;
    end if;
    // collect visible classes, and return true if any
    // are available
    if(not_empty package)
      // should never be empty until we support
      // classes directly on the component diagram
      package.clearScope();
      package.collectVisibleElementsForName(name:"",
                         type:ElementTypeConstants::CLASS, descending:false,
                                      originatingContainerID:package.Package_ID,
                                          delegatingPkgID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:false);
      select many srs related by package->PE_SRS[R8005]
                           where (selected.Type == ElementTypeConstants::CLASS);
      select many pes related by srs->PE_VIS[R8006]->PE_PE[R8002];
      return cardinality pes != 0;
    end if;
  elif (param.value =="spec pkg")
    return (not isInGenericPackage);
  end if;
end if;
return false;
',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (1342,
	1341,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (1343,
	1341,
	'value',
	322,
	0,
	'',
	1342,
	'');
INSERT INTO O_TFR
	VALUES (1328,
	1050,
	'getElideCompartmentTextAtEnd',
	'',
	316,
	1,
	'// elide at the front if the given compartment/entry corresponds to
// the class''s path (and name), and a class has been assigned to this instance 
select one clazz related by self->O_OBJ[R101];
elideAtFront = false;	// necessary due to bug with boolean expressions
elideAtFront = param.compartmentNum == 1 and param.entryNum == 1 
	and not_empty clazz;
return not elideAtFront;',
	1,
	'',
	1339);
INSERT INTO O_TPARM
	VALUES (1344,
	1328,
	'compartmentNum',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (1345,
	1328,
	'entryNum',
	298,
	0,
	'',
	1344,
	'');
INSERT INTO O_TFR
	VALUES (1346,
	1050,
	'resolveModelClass',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one proxyClass related by self->O_OBJ[R101];
if(not_empty proxyClass and not Util::isProxy(element:self.convertToInstance()))
  select one packageableElem related by self->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = not_empty package or not_empty component;

  if (isInGenericPackage)
    clazz = proxyClass;
    if (empty package)
      rootCompIdInPkg = component.getRootComponentId();
      select any rootComponent from instances of C_C where (selected.Id == rootCompIdInPkg);      
      select one package related by rootComponent->PE_PE[R8001]->EP_PKG[R8000]; 
    end if;
    // first try to resolve to referred to class by key letters and name
    select any clazz related by package->S_SYS[R1405]->EP_PKG[R1405]->PE_PE[R8000]->O_OBJ[R8001]
         where (selected.Key_Lett == proxyClass.Key_Lett and selected.Name == proxyClass.Name);
    if(empty clazz)
      // if no class was found try to resolve it by key_letters alone
      select any clazz related by package->S_SYS[R1405]->EP_PKG[R1405]->PE_PE[R8000]->O_OBJ[R8001]
           where (selected.Key_Lett == proxyClass.Key_Lett);
      if(empty clazz)
        // if still no class was found try to resolve on the name alone
        select any clazz related by package->S_SYS[R1405]->EP_PKG[R1405]->PE_PE[R8000]->O_OBJ[R8001]
             where (selected.Name == proxyClass.Name);
      end if;
    end if;
    classResolved = not_empty clazz;
    if(classResolved)
      relate self to clazz across R101;
      // update any class in associations
      select many cias related by self->R_OIR[R202];
      for each cia in cias
        select one existingClass related by cia->O_OBJ[R201];
        select one assoc related by cia->R_REL[R201];
        if(existingClass != clazz)
          unrelate existingClass from assoc across R201 using cia;
          relate clazz to assoc across R201 using cia;
        end if;
      end for;
      // unformalize any associations connected to this imported class
      select many assocs related by self->R_OIR[R202]->R_REL[R201];
      for each assoc in assocs
        // only unformalize if this association has not already been
        // unformalized
        if(assoc.isFormalized())
          assoc.unformalize();
        end if;
      end for;      
    else
      // dispose any associations connected to this imported class
      select many assocs related by self->R_OIR[R202]->R_REL[R201];
      for each assoc in assocs
        assoc.dispose();
      end for;
    end if;
    return;
  end if;  // end isInGenericPackage
  
  //////////////////////////////////////////////////////////////////////
  // Note: Everything below this point is for the case when we are using 
  //       specialized packages.
  //////////////////////////////////////////////////////////////////////
  
  // if a subsystem is resolved by the proxy class
  // then this imported class has already been
  // resolved or does not need to be as the referred to
  // class is contained in the copy
  select one ss related by proxyClass->S_SS[R2];
  if(empty ss or Util::isProxy(element:ss.convertToInstance()))
    name = proxyClass.Name;
    key_letters = proxyClass.Key_Lett;
    unrelate self from proxyClass across R101;
    select one otherSS related by self->S_SS[R3];
    // this is safe as there will only ever be one
    // domain
    select any domain from instances of S_DOM;
    // first try to resolve to referred to class by key letters and name
    select any clazz related by domain->S_SS[R1]->O_OBJ[R2]
         where (selected.Key_Lett == key_letters and selected.Name == name and selected.SS_ID != otherSS.SS_ID);
    if(empty clazz)
      // if no class was found try to resolve it by key_letters alone
      select any clazz related by domain->S_SS[R1]->O_OBJ[R2]
           where (selected.Key_Lett == key_letters and selected.SS_ID != otherSS.SS_ID);
      if(empty clazz)
        // if still no class was found try to resolve on the name alone
        select any clazz related by domain->S_SS[R1]->O_OBJ[R2]
             where (selected.Name == name and selected.SS_ID != otherSS.SS_ID);
      end if;
    end if;
    classResolved = not_empty clazz;
    select one ss related by clazz->S_SS[R2];
    if(ss == otherSS)
      // do not allow import resolution to a class
      // that is in the same subsystem as the imported
      // class
      classResolved = false;
    end if;
    if(classResolved)
      relate self to clazz across R101;
      // update any class in associations
      select many cias related by self->R_OIR[R202];
      for each cia in cias
        select one existingClass related by cia->O_OBJ[R201];
        select one assoc related by cia->R_REL[R201];
        if(existingClass != clazz)
          unrelate existingClass from assoc across R201 using cia;
          relate clazz to assoc across R201 using cia;
        end if;
      end for;
      // unformalize any associations connected to this imported class
      select many assocs related by self->R_OIR[R202]->R_REL[R201];
      for each assoc in assocs
        // only unformalize if this association has not already been
        // unformalized
        if(assoc.isFormalized())
          assoc.unformalize();
        end if;
      end for;      
    else
      // no class could be resolved
      message = ::getMissingClassMessage();
      // add message to a list that will display in a warning dialog at
      // the end of the paste operation
      Util::addPastedElementToProblemList(elementName:self.Obj_Name + "::" + self.Obj_KL, message:message);
      // dispose any associations connected to this imported class
      select many assocs related by self->R_OIR[R202]->R_REL[R201];
      for each assoc in assocs
        assoc.dispose();
      end for;
    end if;
  end if;
end if;
',
	1,
	'',
	1334);
INSERT INTO O_TFR
	VALUES (1340,
	1050,
	'convertToInstance',
	'Translate:native',
	317,
	1,
	'return this;',
	0,
	'',
	1341);
INSERT INTO O_TFR
	VALUES (1347,
	1050,
	'canAssignToClass',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one packageableElem related by self->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
if (empty package)
  select one rootComponent related by packageableElem->C_C[R8003];
  if (not_empty rootComponent)
    rootCompIdInPkg = rootComponent.getRootComponentId();
    select any rootComponent from instances of C_C where (selected.Id == rootCompIdInPkg);
    select one package related by rootComponent->PE_PE[R8001]->EP_PKG[R8000];
  end if;
end if;
isInGenericPackage = not_empty package;

if (isInGenericPackage)
  select any candidatePe from instances of PE_PE where
                                                selected.Element_ID == param.Id;
  if not_empty candidatePe
    select one candidatePkg related by candidatePe->EP_PKG[R8000];
    if (empty candidatePkg)
      select one candidateComp related by candidatePe->C_C[R8003];
      if (not_empty candidateComp)
        rootCompIdInPkg = candidateComp.getRootComponentId();
        select any rootCandidateComponent from instances of C_C where (selected.Id == rootCompIdInPkg);
        select one candidatePkg related by rootCandidateComponent->PE_PE[R8001]->EP_PKG[R8000];
      end if;
    end if;
    if not_empty package and not_empty candidatePkg
      return package != candidatePkg;
    end if;
    return true;
  end if;
else
  // Below this is for when we are NOT under a generic package
  select any candidateClass from instances of O_OBJ where
                                                    selected.Obj_ID == param.Id;
  select one subsystem related by self->S_SS[R3];
  select one candidateContainerSS related by candidateClass->S_SS[R2];
  if not_empty subsystem and not_empty candidateContainerSS
    return subsystem != candidateContainerSS;
  end if;
end if;
return false;
',
	1,
	'',
	1346);
INSERT INTO O_TPARM
	VALUES (1348,
	1347,
	'Id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1349,
	1050,
	'getConfigurationInheritanceElementId',
	'',
	317,
	1,
	'select one importedClass related by self->O_OBJ[R101];
if(not_empty importedClass)
  return importedClass.convertToInstance();
end if;
return self.convertToInstance();',
	1,
	'',
	1347);
INSERT INTO O_NBATTR
	VALUES (1350,
	1050);
INSERT INTO O_BATTR
	VALUES (1350,
	1050);
INSERT INTO O_ATTR
	VALUES (1350,
	1050,
	1351,
	'Modl_Typ',
	'Full Name: Model Type
Description: Indicates what type of model the Imported Class is in.
Data Domain: 5 indicates Class Diagram, 6 indicates Communication Diagram, 7 indicates Synchronous Communication Diagram
enum5: Class Diagram
enum6: Communication Diagram
enum7: Synchronous Communication Diagram
impl_detail: true
readonly: true
User_Visible: false',
	'',
	'Modl_Typ',
	0,
	298,
	'',
	'');
INSERT INTO O_REF
	VALUES (1050,
	701,
	0,
	717,
	1352,
	1353,
	1354,
	1355,
	1356,
	0,
	0,
	'',
	'Subsystem',
	'SS_ID',
	'R3');
INSERT INTO O_RATTR
	VALUES (1355,
	1050,
	717,
	701,
	1,
	'SS_ID');
INSERT INTO O_ATTR
	VALUES (1355,
	1050,
	1350,
	'SS_ID',
	'',
	'',
	'SS_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (1357,
	1050,
	'select one model_class related by self->O_OBJ[R101];
if ( empty model_class )
   self.Obj_Name = "Unassigned Imported Class";
else
   self.Obj_Name = model_class.Name;
end if;

',
	1);
INSERT INTO O_BATTR
	VALUES (1357,
	1050);
INSERT INTO O_ATTR
	VALUES (1357,
	1050,
	1355,
	'Obj_Name',
	'Full Name: Class Name
Description:  This attribute provides identifying information for the Class related to this Imported Class.  This is used to associate the Imported Class to its related Class when importing a subsystem containing the Imported Class into a new/different domain.

',
	'',
	'Obj_Name',
	0,
	322,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (1358,
	1050,
	'select one model_class related by self->O_OBJ[R101];
if ( empty model_class )
   self.Obj_KL = ::getOrphanedElementKL();
else
   self.Obj_KL = model_class.Key_Lett;
end if;

',
	1);
INSERT INTO O_BATTR
	VALUES (1358,
	1050);
INSERT INTO O_ATTR
	VALUES (1358,
	1050,
	1357,
	'Obj_KL',
	'Full Name: Class Key Letter
Description:  This attribute provides identifying information for the Class related to this Imported class.  This is used to associate the Imported Class to its related class when importing a  subsystem containing the Imported Class into a new/different domain.

',
	'',
	'Obj_KL',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (1050,
	30,
	0,
	150,
	1048,
	1051,
	1049,
	1351,
	1359,
	0,
	0,
	'',
	'Model Class',
	'Obj_ID',
	'R101');
INSERT INTO O_RATTR
	VALUES (1351,
	1050,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (1351,
	1050,
	1360,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1050,
	26,
	0,
	25,
	868,
	1361,
	870,
	1360,
	1362,
	0,
	0,
	'',
	'Packageable Element',
	'Element_ID',
	'R8001');
INSERT INTO O_RATTR
	VALUES (1360,
	1050,
	25,
	26,
	0,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (1360,
	1050,
	0,
	'IObj_ID',
	'Full Name: Imported Class Identifier
Description: Uniquely identifies an instance of imported class',
	'',
	'IObj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	1050);
INSERT INTO O_OIDA
	VALUES (1360,
	1050,
	0,
	'IObj_ID');
INSERT INTO O_ID
	VALUES (1,
	1050);
INSERT INTO O_ID
	VALUES (2,
	1050);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (1023,
	'Derived Base Attribute',
	107,
	'O_DBATTR',
	'A Derived Attribute is the result of an algorithm used to derive the value. A derived based attribute is said to be mathematically-dependent since is value is derived from other data in the model.  The action for the derived base attribute is used to set the value of the attribute by using the self keyword.',
	979);
INSERT INTO O_TFR
	VALUES (1363,
	1023,
	'dispose',
	'Dispose this Derived Base Attribute.
',
	19,
	1,
	'select one battr related by self->O_BATTR[R107];
unrelate self from battr across R107;
//Body Subsystem
select one body related by self->ACT_DAB[R693]->ACT_ACT[R698];
if (not_empty body)
  body.dispose();
end if;
//
// Finally delete self
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (1364,
	1023,
	'get_name',
	'',
	322,
	1,
	'select one attr related by self->O_BATTR[R107]->O_ATTR[R106];
if (empty attr)
  return ::getOrphanedElementName();
else
  return attr.Name;
end if;',
	1,
	'',
	1363);
INSERT INTO O_TFR
	VALUES (1365,
	1023,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native
',
	317,
	1,
	'// just return this instance as an Object
return this;
',
	0,
	'',
	1364);
INSERT INTO O_REF
	VALUES (1023,
	1012,
	0,
	1018,
	1021,
	1024,
	1022,
	1366,
	1367,
	0,
	0,
	'',
	'Base Attribute',
	'Attr_ID',
	'R107');
INSERT INTO O_RATTR
	VALUES (1366,
	1023,
	168,
	37,
	1,
	'Attr_ID');
INSERT INTO O_ATTR
	VALUES (1366,
	1023,
	0,
	'Attr_ID',
	'',
	'',
	'Attr_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (1368,
	1023,
	'self.Action_Semantics = ::convertRelocatableTags(in:self.Action_Semantics_internal);
',
	1);
INSERT INTO O_BATTR
	VALUES (1368,
	1023);
INSERT INTO O_ATTR
	VALUES (1368,
	1023,
	1369,
	'Action_Semantics',
	'Full Name: Action Semantics Field
Description: This attribute contains the action semantics for the mathematically-dependent attribute.
Persistent:false',
	'',
	'Action_Semantics',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1370,
	1023);
INSERT INTO O_BATTR
	VALUES (1370,
	1023);
INSERT INTO O_ATTR
	VALUES (1370,
	1023,
	1371,
	'Suc_Pars',
	'Full Name: Successful Parse Indicator
Description: Indicates the status of the parse for the derived base attribute action specification in the attribute Action_Semantics
Data Domain: 0=not parsed, 1 = parse successful, 2 = parse unsuccessful, 3 = parse on apply set but never been parsed
',
	'',
	'Suc_Pars',
	0,
	1224,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1371,
	1023);
INSERT INTO O_BATTR
	VALUES (1371,
	1023);
INSERT INTO O_ATTR
	VALUES (1371,
	1023,
	1368,
	'Action_Semantics_internal',
	'User_Visible:false',
	'',
	'Action_Semantics_internal',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (1023,
	1012,
	0,
	1019,
	1021,
	1024,
	1022,
	1369,
	1372,
	0,
	0,
	'',
	'Base Attribute',
	'Obj_ID',
	'R107');
INSERT INTO O_RATTR
	VALUES (1369,
	1023,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (1369,
	1023,
	1366,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	1023);
INSERT INTO O_OIDA
	VALUES (1366,
	1023,
	0,
	'Attr_ID');
INSERT INTO O_OIDA
	VALUES (1369,
	1023,
	0,
	'Obj_ID');
INSERT INTO O_ID
	VALUES (1,
	1023);
INSERT INTO O_ID
	VALUES (2,
	1023);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (1043,
	'Class Identifier Attribute',
	105,
	'O_OIDA',
	'An attribute that is part of a class identifier is a class identifier attribute.',
	979);
INSERT INTO O_TFR
	VALUES (1373,
	1043,
	'dispose',
	'Dispose this Class Identifier Attribute.
',
	19,
	1,
	'select one attr related by self->O_ATTR[R105];
select one id related by self->O_ID[R105];
unrelate attr from id across R105 using self;
select many rtidas related by self->O_RTIDA[R110];
for each rtida in rtidas
  rtida.dispose();
end for;
delete object instance self;',
	1,
	'',
	1374);
INSERT INTO O_TFR
	VALUES (1374,
	1043,
	'addReference',
	'',
	296,
	1,
	'select any rel from instances of R_REL where selected.Rel_ID == param.rel_id;
select any rgo related by rel->R_OIR[R201]->R_RGO[R203] 
    where selected.Obj_ID == param.rgo_obj_id and selected.OIR_ID == param.rgo_oir_id;
select one rgo_obj related by rgo->R_OIR[R203]->O_OBJ[R201];

newAttr_id = rgo_obj.newReferentialAttribute(ref_obj_id: self.Obj_ID, 
    ref_oid_id: self.Oid_ID, ref_attr_id: self.Attr_ID, id: param.id );

select any ref_attr related by rgo_obj->O_ATTR[R102]->O_RATTR[R106]
    where selected.Attr_ID == newAttr_id;

select any rto related by rel->R_OIR[R201]->R_RTO[R203] 
    where selected.Obj_ID == param.rto_obj_id and selected.OIR_ID == param.rto_oir_id;

// An rtida instance may already exist if we''re adding 
// the second (or subsequent) subtype to an inheritance 
// association
select any rtida related by self->O_RTIDA[R110] 
    where selected.Rel_ID == param.rel_id and selected.OIR_ID == param.rto_oir_id;
if ( empty rtida )
  create object instance rtida of O_RTIDA;
  relate self to rto across R110 using rtida;
end if;

create object instance ref of O_REF;
relate ref to ref_attr across R108;
relate rtida to rgo across R111 using ref;

return newAttr_id;
',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (1375,
	1374,
	'rel_id',
	296,
	0,
	'',
	1376,
	'');
INSERT INTO O_TPARM
	VALUES (1377,
	1374,
	'rto_obj_id',
	296,
	0,
	'',
	1378,
	'');
INSERT INTO O_TPARM
	VALUES (1379,
	1374,
	'rto_oir_id',
	296,
	0,
	'',
	1377,
	'');
INSERT INTO O_TPARM
	VALUES (1380,
	1374,
	'rgo_obj_id',
	296,
	0,
	'',
	1375,
	'');
INSERT INTO O_TPARM
	VALUES (1378,
	1374,
	'rgo_oir_id',
	296,
	0,
	'',
	1380,
	'');
INSERT INTO O_TPARM
	VALUES (1376,
	1374,
	'id',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1381,
	1043,
	'get_name',
	'',
	322,
	1,
	'return "*" + GD::int_to_string(value:self.Oid_ID+1);
',
	1,
	'',
	1373);
INSERT INTO O_TFR
	VALUES (1382,
	1043,
	'getCachedLocalAttributeName',
	'Translate:native',
	322,
	1,
	'	return m_localattributename;',
	0,
	'',
	1381);
INSERT INTO O_TFR
	VALUES (1383,
	1043,
	'setCachedLocalAttributeName',
	'Translate:native',
	19,
	1,
	'	m_localattributename = p_Value;',
	0,
	'',
	1382);
INSERT INTO O_TPARM
	VALUES (1384,
	1383,
	'value',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (1043,
	37,
	0,
	168,
	1037,
	1044,
	1038,
	1059,
	1385,
	0,
	0,
	'',
	'Attribute',
	'Attr_ID',
	'R105');
INSERT INTO O_RATTR
	VALUES (1059,
	1043,
	168,
	37,
	1,
	'Attr_ID');
INSERT INTO O_ATTR
	VALUES (1059,
	1043,
	0,
	'Attr_ID',
	'',
	'',
	'Attr_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1043,
	1039,
	0,
	1041,
	1037,
	1044,
	1040,
	1060,
	1386,
	0,
	0,
	'',
	'Class Identifier',
	'Oid_ID',
	'R105');
INSERT INTO O_RATTR
	VALUES (1060,
	1043,
	1041,
	1039,
	1,
	'Oid_ID');
INSERT INTO O_ATTR
	VALUES (1060,
	1043,
	1061,
	'Oid_ID',
	'Not_participating_value: -1',
	'',
	'Oid_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1043,
	1039,
	0,
	1042,
	1037,
	1044,
	1040,
	1061,
	1387,
	0,
	0,
	'',
	'Class Identifier',
	'Obj_ID',
	'R105');
INSERT INTO O_REF
	VALUES (1043,
	37,
	0,
	169,
	1037,
	1044,
	1038,
	1061,
	1388,
	1387,
	0,
	'',
	'Attribute',
	'Obj_ID',
	'R105');
INSERT INTO O_RATTR
	VALUES (1061,
	1043,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (1061,
	1043,
	1059,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (1389,
	1043,
	'select one attribute related by self->O_ATTR[R105];
if(not_empty attribute)
  self.setCachedLocalAttributeName(value: attribute.Name);
  self.localAttributeName = attribute.Name;
else
  self.localAttributeName = self.getCachedLocalAttributeName();
end if;',
	1);
INSERT INTO O_BATTR
	VALUES (1389,
	1043);
INSERT INTO O_ATTR
	VALUES (1389,
	1043,
	1060,
	'localAttributeName',
	'User_Visible:false',
	'',
	'localAttributeName',
	0,
	322,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	1043);
INSERT INTO O_OIDA
	VALUES (1059,
	1043,
	0,
	'Attr_ID');
INSERT INTO O_OIDA
	VALUES (1060,
	1043,
	0,
	'Oid_ID');
INSERT INTO O_OIDA
	VALUES (1061,
	1043,
	0,
	'Obj_ID');
INSERT INTO O_ID
	VALUES (1,
	1043);
INSERT INTO O_ID
	VALUES (2,
	1043);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (1039,
	'Class Identifier',
	104,
	'O_ID',
	'A set of one or more Attributes which uniquely distinguishes each instance of a class is a class identifier.  A class may have several identifiers.',
	979);
INSERT INTO O_TFR
	VALUES (1390,
	1039,
	'dispose',
	'Dispose this Class Identifier.
',
	19,
	1,
	'select one obj related by self->O_OBJ[R104];
  unrelate self from obj across R104;
select many rtos related by self->R_RTO[R109];
for each rto in rtos
  rto.dispose();
end for;
select many oidas related by self->O_OIDA[R105];
for each oida in oidas
  oida.dispose();
end for;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (1391,
	1039,
	'get_name',
	'',
	322,
	1,
	'return "*" + GD::int_to_string(value:self.Oid_ID+1);
',
	1,
	'',
	1390);
INSERT INTO O_TFR
	VALUES (1392,
	1039,
	'hasAttributes',
	'This is a class based operation because instance based operations are
not allowed on the selected variable in a where clause. which is where we
need to use this operation.  Adding this operation as an MDA was avoided to
prevent a schema change.

',
	316,
	0,
	'select any oid from instances of O_ID where selected.Obj_ID == param.obj_id
  and selected.Oid_ID == param.oid_id;

select any oida related by oid->O_OIDA[R105];
return not_empty oida;
',
	1,
	'',
	1391);
INSERT INTO O_TPARM
	VALUES (1393,
	1392,
	'obj_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (1394,
	1392,
	'oid_id',
	298,
	0,
	'',
	1393,
	'');
INSERT INTO O_NBATTR
	VALUES (1041,
	1039);
INSERT INTO O_BATTR
	VALUES (1041,
	1039);
INSERT INTO O_ATTR
	VALUES (1041,
	1039,
	0,
	'Oid_ID',
	'Full Name: Class Identifier Identifier
Description: The identifying attribute set number.
Data Domain: 0 = Primary Identifer Set (e.g., *), 1 = Secondary Identifier Set (e.g., *2), 2 = Third Identifier Set (e.g., *3)
enum0: *1
enum1: *2
enum2: *3
impl_detail: true
readonly: true
',
	'',
	'Oid_ID',
	0,
	298,
	'',
	'');
INSERT INTO O_REF
	VALUES (1039,
	30,
	0,
	150,
	1045,
	1046,
	1047,
	1042,
	1395,
	0,
	0,
	'',
	'Model Class',
	'Obj_ID',
	'R104');
INSERT INTO O_RATTR
	VALUES (1042,
	1039,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (1042,
	1039,
	1041,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	1039);
INSERT INTO O_OIDA
	VALUES (1041,
	1039,
	0,
	'Oid_ID');
INSERT INTO O_OIDA
	VALUES (1042,
	1039,
	0,
	'Obj_ID');
INSERT INTO O_ID
	VALUES (1,
	1039);
INSERT INTO O_ID
	VALUES (2,
	1039);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (1012,
	'Base Attribute',
	106,
	'O_BATTR',
	'A Base attribute is a non-referential attribute.  Base attributes are either derived base attributes (O_DBATTR) or non-derived base attributes (O_NBATTR).',
	979);
INSERT INTO O_TFR
	VALUES (1396,
	1012,
	'dispose',
	'Dispose this Base Attribute.
',
	19,
	1,
	'select one dbattr related by self->O_DBATTR[R107];
if (not_empty dbattr)
  dbattr.dispose();
else
  select one nbattr related by self->O_NBATTR[R107];
  if (not_empty nbattr)
    nbattr.dispose();
  end if;
end if;
select many rattrs related by self->O_RATTR[R113];
for each rattr in rattrs
  unrelate self from rattr across R113;
end for;
select one attr related by self->O_ATTR[R106];
if (not_empty attr)
  unrelate self from attr across R106;
end if;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (1012,
	37,
	0,
	168,
	1010,
	1013,
	1011,
	1018,
	1397,
	0,
	0,
	'',
	'Attribute',
	'Attr_ID',
	'R106');
INSERT INTO O_RATTR
	VALUES (1018,
	1012,
	168,
	37,
	1,
	'Attr_ID');
INSERT INTO O_ATTR
	VALUES (1018,
	1012,
	0,
	'Attr_ID',
	'',
	'',
	'Attr_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1012,
	37,
	0,
	169,
	1010,
	1013,
	1011,
	1019,
	1398,
	0,
	0,
	'',
	'Attribute',
	'Obj_ID',
	'R106');
INSERT INTO O_RATTR
	VALUES (1019,
	1012,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (1019,
	1012,
	1018,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	1012);
INSERT INTO O_OIDA
	VALUES (1018,
	1012,
	0,
	'Attr_ID');
INSERT INTO O_OIDA
	VALUES (1019,
	1012,
	0,
	'Obj_ID');
INSERT INTO O_ID
	VALUES (1,
	1012);
INSERT INTO O_ID
	VALUES (2,
	1012);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (1028,
	'Attribute Reference in Class',
	110,
	'O_REF',
	'The class represents an association number (R#) which follows a referential attribute.',
	979);
INSERT INTO O_TFR
	VALUES (1399,
	1028,
	'get_name',
	'Creates a string containing a descriptive name for the instance.',
	322,
	1,
	'select one rel related by self->R_RGO[R111]->R_OIR[R203]->R_REL[R201];
if empty rel 
  return self.RObj_Name + "." + self.RAttr_Name + "(" + self.Rel_Name + ")";
else
  select one attr related by self->O_RTIDA[R111]->O_OIDA[R110]->O_ATTR[R105];
	if(not_empty attr)
	  select one obj related by attr->O_OBJ[R102];
      txt_phrase = self.get_referential_phrase();
	  if not_empty attr and not_empty obj
	    if(txt_phrase == "") 
		  return obj.Name + "." + attr.Name + "(" + rel.get_name() + ")";
		else
		  return obj.Name + "." + attr.Name + "(" + rel.get_name() + "." + Util::getTic() 
		                                               + txt_phrase + Util::getTic() + ")";
		end if;
	  else
	// during import may not be related yet
	    return self.RObj_Name + "." + self.RAttr_Name + "(" + self.Rel_Name + ")";
	  end if;
    else 
	  return self.RObj_Name + "." + self.RAttr_Name + "(" + self.Rel_Name + ")";
    end if;
end if;',
	1,
	'',
	1400);
INSERT INTO O_TFR
	VALUES (1400,
	1028,
	'dispose',
	'Dispose this O_REF.
',
	19,
	1,
	'select one next_ref related by self->O_REF[R112.''precedes''];
select one prior_ref related by self->O_REF[R112.''succeeds''];
if ( not_empty next_ref and not_empty prior_ref )
  // in the middle of the chain
  unrelate self from next_ref across R112.''precedes'';
  unrelate prior_ref from self across R112.''precedes'';
  relate prior_ref to next_ref across R112.''precedes'';
else
  if ( not_empty prior_ref and empty next_ref )
    // we''re last in list
    unrelate prior_ref from self across R112.''precedes'';
  else
    // we''re first in list
    unrelate self from next_ref across R112.''precedes'';
  end if;
end if;
select one owningReferential related by self->O_RATTR[R108];
if not_empty owningReferential
 unrelate self from owningReferential across R108;
end if;
select one rtida related by self->O_RTIDA[R111];
select one rgo related by self->R_RGO[R111];
select one rto related by rtida->R_RTO[R110];
unrelate rtida from rgo across R111 using self;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (1401,
	1028,
	'get_text',
	'',
	322,
	1,
	'result = "R???";
select one rel related by self->R_RGO[R111]->R_OIR[R203]->R_REL[R201];
if ( not_empty rel )
  txt_phrase = self.get_referential_phrase();
  if(txt_phrase == "" or not param.includeTextPhrase)
    result = rel.get_name();
  else
    result = rel.get_name() + "." + Util::getTic() + txt_phrase
                                                               + Util::getTic();
  end if;
else
  result = self.Rel_Name;	   
end if;
//
// Append constrained marker if required
//
if (self.Is_Cstrd)
  result = result + "c";
end if;
return result;',
	1,
	'',
	1399);
INSERT INTO O_TPARM
	VALUES (1402,
	1401,
	'includeTextPhrase',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1403,
	1028,
	'migrateRefAttrOrDispose',
	'',
	19,
	1,
	'select many siblings related by self->O_RATTR[R108]->O_REF[R108];
if (cardinality siblings == 1)
  // This referential is not going to refer to anything after this . . . 
  select one rattr related by self->O_RATTR[R108];
  select any idattr related by rattr->O_ATTR[R106]->O_OIDA[R105];
  if (empty idattr)
    // this referential has no references left and it''s not part of an identifier
    // it should be removed
    select one attr related by rattr->O_ATTR[R106];
    attr.dispose();
  else
    select any rattr_ref related by idattr->O_RTIDA[R110];
    if ( not_empty rattr_ref )
      // rattr''s identifier is used to formalize another relationship
      // we need to keep it as a base attribute
      rattr.migrateToBase();
    else
      select one attr related by rattr->O_ATTR[R106];
      attr.dispose();
    end if;
  end if;
else
  self.dispose();
end if;
',
	1,
	'',
	1401);
INSERT INTO O_TFR
	VALUES (1404,
	1028,
	'get_referential_phrase',
	'',
	322,
	1,
	'select one rto related by self->O_RTIDA[R111]->R_RTO[R110];
select one cone related by rto->R_AONE[R204];
select one coth related by rto->R_AOTH[R204];
select one casp related by rto->R_PART[R204];
txt_phrase = "";
if(not_empty cone)
  txt_phrase = cone.Txt_Phrs;
end if;
if(not_empty coth)
  txt_phrase = coth.Txt_Phrs;
end if;
if(not_empty casp)
  txt_phrase = casp.Txt_Phrs;
end if;
return txt_phrase;',
	1,
	'',
	1403);
INSERT INTO O_REF
	VALUES (1028,
	1062,
	0,
	1075,
	1067,
	1078,
	1072,
	1405,
	1406,
	0,
	0,
	'',
	'Referred To Identifier Attribute',
	'Oid_ID',
	'R111');
INSERT INTO O_RATTR
	VALUES (1405,
	1028,
	1041,
	1039,
	1,
	'Oid_ID');
INSERT INTO O_ATTR
	VALUES (1405,
	1028,
	1407,
	'ROid_ID',
	'',
	'R',
	'Oid_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1028,
	1062,
	0,
	1073,
	1067,
	1078,
	1072,
	1408,
	1409,
	0,
	0,
	'',
	'Referred To Identifier Attribute',
	'Attr_ID',
	'R111');
INSERT INTO O_RATTR
	VALUES (1408,
	1028,
	168,
	37,
	1,
	'Attr_ID');
INSERT INTO O_ATTR
	VALUES (1408,
	1028,
	1405,
	'RAttr_ID',
	'',
	'R',
	'Attr_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1028,
	985,
	0,
	1069,
	1067,
	1078,
	1068,
	1410,
	1411,
	0,
	0,
	'',
	'Referring Class In Assoc',
	'OIR_ID',
	'R111');
INSERT INTO O_RATTR
	VALUES (1410,
	1028,
	1108,
	1109,
	1,
	'OIR_ID');
INSERT INTO O_ATTR
	VALUES (1410,
	1028,
	1412,
	'OIR_ID',
	'',
	'',
	'OIR_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1028,
	1062,
	0,
	1074,
	1067,
	1078,
	1072,
	1413,
	1414,
	0,
	0,
	'',
	'Referred To Identifier Attribute',
	'OIR_ID',
	'R111');
INSERT INTO O_RATTR
	VALUES (1413,
	1028,
	1108,
	1109,
	1,
	'OIR_ID');
INSERT INTO O_ATTR
	VALUES (1413,
	1028,
	1410,
	'ROIR_ID',
	'',
	'R',
	'OIR_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1028,
	1014,
	0,
	1031,
	1027,
	1029,
	1030,
	1415,
	1416,
	0,
	0,
	'',
	'Referential Attribute',
	'Attr_ID',
	'R108');
INSERT INTO O_RATTR
	VALUES (1415,
	1028,
	168,
	37,
	1,
	'Attr_ID');
INSERT INTO O_ATTR
	VALUES (1415,
	1028,
	1413,
	'Attr_ID',
	'',
	'',
	'Attr_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1035,
	1028);
INSERT INTO O_BATTR
	VALUES (1035,
	1028);
INSERT INTO O_ATTR
	VALUES (1035,
	1028,
	1415,
	'ARef_ID',
	'Full Name: Attribute Reference In Class Identifier
Description: Secondary Identifier
',
	'',
	'ARef_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_REF
	VALUES (1028,
	1028,
	1,
	1035,
	1033,
	1036,
	1034,
	1417,
	1418,
	0,
	0,
	'',
	'Attribute Reference in Class',
	'ARef_ID',
	'R112');
INSERT INTO O_RATTR
	VALUES (1417,
	1028,
	1035,
	1028,
	1,
	'ARef_ID');
INSERT INTO O_ATTR
	VALUES (1417,
	1028,
	1035,
	'PARef_ID',
	'',
	'P',
	'ARef_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1419,
	1028);
INSERT INTO O_BATTR
	VALUES (1419,
	1028);
INSERT INTO O_ATTR
	VALUES (1419,
	1028,
	1417,
	'Is_Cstrd',
	'Full Name: Is Constrained
Description: Signifies a constrained referential
Data Domain: 0 = not  constrained, 1 = constrained',
	'',
	'Is_Cstrd',
	0,
	316,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1420,
	1028);
INSERT INTO O_BATTR
	VALUES (1420,
	1028);
INSERT INTO O_ATTR
	VALUES (1420,
	1028,
	1419,
	'Descrip',
	'Full Name: Attribute Reference in Class Description
Description: Description of the attribute reference.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (1421,
	1028,
	'ModelClass_c base_class = ModelClass_c
			.getOneO_OBJOnR201(ClassInAssociation_c
				.getOneR_OIROnR203(ReferredToClassInAssoc_c
					.getOneR_RTOOnR110(ReferredToIdentifierAttribute_c
						.getOneO_RTIDAOnR111(this))));

if (base_class != null){
	m_robj_name = base_class.getName();
	return m_robj_name;
}
else{
	return m_robj_name;
}',
	0);
INSERT INTO O_BATTR
	VALUES (1421,
	1028);
INSERT INTO O_ATTR
	VALUES (1421,
	1028,
	1420,
	'RObj_Name',
	'Full Name: Referred To Class
Description: Class Name of referencial Attribute.
Calculate the value of Reffered to Class Name.
if it is calculated then set it otherwise use the existing cached value.
Translate: native
In Properties: false',
	'',
	'RObj_Name',
	0,
	322,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (1422,
	1028,
	'Attribute_c base_attribute = Attribute_c
			.getOneO_ATTROnR105(ClassIdentifierAttribute_c
				.getOneO_OIDAOnR110(ReferredToIdentifierAttribute_c
					.getOneO_RTIDAOnR111(this)));
if (base_attribute != null){
	m_rattr_name = base_attribute.getName();
	return m_rattr_name;
}
else{
	return m_rattr_name;
}',
	0);
INSERT INTO O_BATTR
	VALUES (1422,
	1028);
INSERT INTO O_ATTR
	VALUES (1422,
	1028,
	1421,
	'RAttr_Name',
	'Full Name: Referred To Attribute
Description: Attribute Name of referencial Attribute in Referred to class.
Calculate the value of Reffered to Attribute Name.
if it is calculated then set it otherwise use the existing cached value.
Translate: native
In Properties: false',
	'',
	'RAttr_Name',
	0,
	322,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (1423,
	1028,
	'Association_c base_association = Association_c
			.getOneR_RELOnR201(ClassInAssociation_c
				.getOneR_OIROnR203(ReferredToClassInAssoc_c
					.getOneR_RTOOnR110(ReferredToIdentifierAttribute_c
						.getOneO_RTIDAOnR111(this))));
if (base_association != null){
		String txt_phrase = Get_referential_phrase();
		if (txt_phrase.equals("")) {
			m_rel_name = base_association.Get_name();
		} else {
			m_rel_name = base_association.Get_name() + ".''" + txt_phrase
					+ "''";
		}
		return m_rel_name;
}
else{
	return m_rel_name;
}',
	0);
INSERT INTO O_BATTR
	VALUES (1423,
	1028);
INSERT INTO O_ATTR
	VALUES (1423,
	1028,
	1422,
	'Rel_Name',
	'Full Name: Referenced Over
Description: Name of relation from which referencial attribute comes.
Calculate the value of Refference Over.
if it is calculated then set it otherwise use the existing cached value.
Translate: native
In Properties: false',
	'',
	'Rel_Name',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (1028,
	1062,
	0,
	1076,
	1067,
	1078,
	1072,
	1407,
	1424,
	0,
	0,
	'',
	'Referred To Identifier Attribute',
	'Obj_ID',
	'R111');
INSERT INTO O_RATTR
	VALUES (1407,
	1028,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (1407,
	1028,
	1425,
	'RObj_ID',
	'',
	'R',
	'Obj_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1028,
	1014,
	0,
	1032,
	1027,
	1029,
	1030,
	1425,
	1426,
	0,
	0,
	'',
	'Referential Attribute',
	'Obj_ID',
	'R108');
INSERT INTO O_REF
	VALUES (1028,
	985,
	0,
	1070,
	1067,
	1078,
	1068,
	1425,
	1427,
	1426,
	0,
	'',
	'Referring Class In Assoc',
	'Obj_ID',
	'R111');
INSERT INTO O_RATTR
	VALUES (1425,
	1028,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (1425,
	1028,
	0,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1028,
	985,
	0,
	1071,
	1067,
	1078,
	1068,
	1412,
	1428,
	0,
	0,
	'',
	'Referring Class In Assoc',
	'Rel_ID',
	'R111');
INSERT INTO O_REF
	VALUES (1028,
	1062,
	0,
	1077,
	1067,
	1078,
	1072,
	1412,
	1429,
	1428,
	0,
	'',
	'Referred To Identifier Attribute',
	'Rel_ID',
	'R111');
INSERT INTO O_RATTR
	VALUES (1412,
	1028,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (1412,
	1028,
	1408,
	'Rel_ID',
	'',
	'',
	'Rel_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	1028);
INSERT INTO O_OIDA
	VALUES (1405,
	1028,
	0,
	'ROid_ID');
INSERT INTO O_OIDA
	VALUES (1408,
	1028,
	0,
	'RAttr_ID');
INSERT INTO O_OIDA
	VALUES (1410,
	1028,
	0,
	'OIR_ID');
INSERT INTO O_OIDA
	VALUES (1413,
	1028,
	0,
	'ROIR_ID');
INSERT INTO O_OIDA
	VALUES (1407,
	1028,
	0,
	'RObj_ID');
INSERT INTO O_OIDA
	VALUES (1425,
	1028,
	0,
	'Obj_ID');
INSERT INTO O_OIDA
	VALUES (1412,
	1028,
	0,
	'Rel_ID');
INSERT INTO O_ID
	VALUES (1,
	1028);
INSERT INTO O_OIDA
	VALUES (1035,
	1028,
	1,
	'ARef_ID');
INSERT INTO O_ID
	VALUES (2,
	1028);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (37,
	'Attribute',
	103,
	'O_ATTR',
	'An attribute is an abstraction of a single characteristic possessed by a class.  Usually classes contain a set of attributes to completely capture all pertinent information.  Each attribute is given a unique name within a class.',
	979);
INSERT INTO O_TFR
	VALUES (1430,
	37,
	'dispose',
	'Dispose this Attribute.
',
	19,
	1,
	'// Subsystem Subsystem
select many oidas related by self->O_OIDA[R105];
for each oida in oidas
  oida.dispose();
end for;
select one battr related by self->O_BATTR[R106];
if (not_empty battr)
  battr.dispose();
else
  select one rattr related by self->O_RATTR[R106];
  rattr.dispose();
end if;
select one dt related by self->S_DT[R114];
if ( not_empty dt )
  unrelate self from dt across R114;
end if;
select one owningClass related by self->O_OBJ[R102];
select one nextAttr related by self->O_ATTR[R103.''precedes''];
::changeNotificationEnablement(enabled:false);
if(not_empty nextAttr)
  // We need to disable the listeners because the ordering change
  // causes a NPE when the display updates midstream
  if (self.PAttr_ID == GD::NULL_UNIQUE_ID())
    // this attribute is at the top of the list
    unrelate self from nextAttr across R103.''precedes'';
  else
    // otherwise this attribute is somewhere in the middle
    // or at the end
    select many attrs related by owningClass->O_ATTR[R102];
    for each attr in attrs
      select one thisAttr related by attr->O_ATTR[R103.''precedes''];
      if (self == thisAttr)
        // now tell the next attribute that this is not
        // the attribute that it succeeds anymore
        unrelate self from nextAttr across R103.''precedes'';
        // and tell this attribute that it no longer succeeds
        // any attribute. 
        // *NOTE* this is not really required for deletion but
        // more for restoration
        unrelate self from attr across R103.''succeeds'';
        // finally connect the two attributes that this
        // attribute was between
        relate nextAttr to attr across R103.''succeeds'';
        break;
      end if;
    end for;
  end if;
else
  // we are at the end of the list
  select one priorAttr related by self->O_ATTR[R103.''succeeds''];
  if ( not_empty priorAttr )
    unrelate self from priorAttr across R103.''succeeds'';
  end if;
end if;
::changeNotificationEnablement(enabled:true);
unrelate self from owningClass across R102;
//
// Communication and Access Subsystem
select many smoaas related by self->CA_SMOAA[R419];
for each smoaa in smoaas
  smoaa.dispose();
end for;
//
// Value Subsystem
select many selref_set related by self->V_SLR[R812];
for each selref in selref_set
  unrelate self from selref across R812;
end for;
select many attrvals related by self->V_AVL[R806];
for each attrval in attrvals
  unrelate self from attrval across R806;
end for;
//
// Instance Subsystem
select many avls related by self->I_AVL[R2910];
for each avl in avls
  unrelate self from avl across R2910;
  avl.dispose();
end for;
//
// Sequence subsystem
select many attrValues related by self->SQ_AV[R938];
for each attrValue in attrValues
  attrValue.dispose();
end for;
select many dims related by self->S_DIM[R120];
for each dim in dims
  unrelate self from dim across R120;
  delete object instance dim;
end for;
//
// Finally delete self
delete object instance self;',
	1,
	'',
	1431);
INSERT INTO O_TFR
	VALUES (1432,
	37,
	'initialize',
	'Initialize this new Attribute.
',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
self.Prefix = "";
self.Pfx_Mode = 0;
name = ::getUniqueInitialName( 
    instance: self.convertToInstance(), 
    candidateName: "Unnamed Attribute");
success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:true);    
if ( success!="") 
 self.Root_Nam=success;
else 
 self.dispose();
end if;        
select any dom from instances of S_DOM;
select any intdt related by dom->S_DT[R14] where selected.Name == "integer";
if not_empty dom
  if(empty intdt)
    // if the integer dt was not found check the system level
    // dts, but only if the domain found is the formal content
    // of a component
    if(dom.participatesInSystem())
      select one system related by dom->CN_DC[R4204]->C_C[R4204]->CP_CP[R4608]
                                                                 ->S_SYS[R4606];
      dt_id = GD::NULL_UNIQUE_ID();
      if not_empty system
        dt_id = system.getCoreTypeId(name:"integer");
      end if;
      select any pe from instances of PE_PE where selected.Element_ID == dt_id;
      select one intdt related by pe->S_DT[R8001]; 
    else
      // this is an error, if the domain is not
      // participating at the system level and
      // we cannot find the type at the domain
      // level we have a problem
      USER::logError(msg:"Unable to locate expected data type: integer",path:"");
    end if;
  end if;
else
  // Owning Class is in a package . . .
  select one system related by self->O_OBJ[R102]->PE_PE[R8001]->
                                                    EP_PKG[R8000]->S_SYS[R1405];
  if not_empty system
    dt_id = system.getCoreTypeId(name:"integer");
    select any pe from instances of PE_PE where selected.Element_ID == dt_id;
    select one intdt related by pe->S_DT[R8001]; 
  else
    // this is an error, if the system is not
    // found we cannot find the core type
    USER::logError(msg:"Unable to locate system root for data type: integer",path:"");
  end if;
end if;
relate self to intdt across R114;
create object instance ba of O_BATTR;
relate self to ba across R106;
create object instance nba of O_NBATTR;
relate ba to nba across R107;',
	1,
	'',
	1433);
INSERT INTO O_TFR
	VALUES (1434,
	37,
	'isAllowedType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Attribute::isAllowedType()
select one packageableElem related by self->O_OBJ[R102]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;
if isInGenericPackage
  select any dt related by package->PE_VIS[R8002]->
                PE_PE[R8002]->S_DT[R8001] where selected.Name == param.typeName;
  if not_empty component
    select any dt related by component->PE_CVS[R8004]->
                PE_PE[R8004]->S_DT[R8001] where selected.Name == param.typeName;
  end if;
  if not_empty dt
    select one rattr related by self->O_RATTR[R106];
    if ( not_empty rattr )
      select one base_attr related by rattr->O_BATTR[R113]->O_ATTR[R106];
      if ( empty base_attr )
        return  param.typeName == "same_as<Base_Attribute>";
      else
        select one base_dt related by base_attr->S_DT[R114];
        return param.typeName == base_dt.Name;
      end if;
    else
      if ( dt.isCommonAllowedType() )
        return true;
      elif ( param.typeName == "state<State_Model>"  )
        return true;
      end if;
    end if;
  end if;
  return false;
else
  select one dom related by self->O_OBJ[R102]->S_SS[R2]->S_DOM[R1];
  select any dt related by dom->S_DT[R14] where selected.Name == param.typeName;
  if(empty dt)
    if(dom.participatesInSystem())
      select one system related by dom->CN_DC[R4204]->C_C[R4204]->CP_CP[R4608]
                                                                 ->S_SYS[R4606];
      dt_id = GD::NULL_UNIQUE_ID();
      if not_empty system
        dt_id = system.getCoreTypeId(name:param.typeName);
      end if;
      select any pe from instances of PE_PE where selected.Element_ID == dt_id;
      select one dt related by pe->S_DT[R8001]; 
    else
      // this is an error, if the domain is not
      // participating at the system level and
      // we cannot find the type at the domain
      // level we have a problem
      USER::logError(msg:"Unable to locate expected data type.",path:"");
    end if;
  end if;
  if not_empty dt 
    select one rattr related by self->O_RATTR[R106];
    if ( not_empty rattr )
      select one base_attr related by rattr->O_BATTR[R113]->O_ATTR[R106];
      if ( empty base_attr )
        return  param.typeName == "same_as<Base_Attribute>";
      else
        select one base_dt related by base_attr->S_DT[R114];
        return param.typeName == base_dt.Name;
      end if;
    else
      if ( dt.isCommonAllowedType() )
        return true;
      elif ( param.typeName == "state<State_Model>"  )
        return true;
      end if;
    end if;
  end if;
  return false;
end if;',
	1,
	'',
	1432);
INSERT INTO O_TPARM
	VALUES (1435,
	1434,
	'typeName',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1436,
	37,
	'actionFilter',
	'Bridge: UI
',
	316,
	1,
	'if (param.name == "subtype" )
  if (param.value =="O_NBATTR" )
    select one nba related by self->O_BATTR[R106]->O_NBATTR[R107];
    return not_empty nba;
  elif (param.value == "O_DBATTR" )
    select one dba related by self->O_BATTR[R106]->O_DBATTR[R107];
    return not_empty dba;
  elif (param.value == "O_RATTR" )
    select one ra related by self->O_RATTR[R106];
    return not_empty ra;
  end if;
elif (param.name == "id" )
  select many cia related by self->O_OIDA[R105];
  if ( param.value == "none" )
    return empty cia;
  elif ( param.value == "some" )
    return not_empty cia;
  elif ( param.value == "not all" )
    select many id_set related by self->O_OBJ[R102]->O_ID[R104];
    return cardinality cia != cardinality id_set;
  elif ( param.value == "all" )
    select many id_set related by self->O_OBJ[R102]->O_ID[R104];
    return cardinality cia == cardinality id_set;
  end if;
elif (param.name == "can" )
  if ( param.value == "move up" )
    select one prev_attr related by self->O_ATTR[R103.''succeeds''];
    return not_empty prev_attr;
  elif ( param.value == "move down" )
    select one next_attr related by self->O_ATTR[R103.''precedes''];
    return not_empty next_attr;
  elif ( param.value == "combine" )
     select one rattr related by self->O_RATTR[R106];
       if ( not_empty rattr )
         select one base_attr related by rattr->O_BATTR[R113];
          select many candidate_set related by self->O_OBJ[R102]->O_ATTR[R102]->O_RATTR[R106]
            where selected.BAttr_ID == base_attr.Attr_ID and 
                  selected.BObj_ID == base_attr.Obj_ID;
            for each candidate in candidate_set
             if ( not rattr.alreadyCombinedWith( id: candidate.Attr_ID ) )
               return true;
             end if;
           end for;
       end if;
       return false;
  elif ( param.value == "split" )
   	 select one rattr related by self->O_RATTR[R106];
   	  if ( not_empty rattr )
   	    select many ref_set related by rattr->O_REF[R108];
   	    return cardinality ref_set > 1;
      end if;
      return false;  
  elif(param.value == "SetType")
     select one refAttr related by self->O_RATTR[R106];
     if(not_empty refAttr)
       return false;
     else
       return true;
     end if;
   end if;
end if;
return false;
',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (1437,
	1436,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (1438,
	1436,
	'value',
	322,
	0,
	'',
	1437,
	'');
INSERT INTO O_TFR
	VALUES (1439,
	37,
	'isPartOfId',
	'',
	316,
	1,
	'select any oida related by self->O_OIDA[R105] where (selected.Oid_ID == param.id );
return not_empty oida;
',
	1,
	'',
	1434);
INSERT INTO O_TPARM
	VALUES (1440,
	1439,
	'id',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1441,
	37,
	'migrateBaseToDerived',
	'',
	19,
	1,
	'select one battr related by self->O_BATTR[R106];
if ( not_empty battr )
  select one nbattr related by battr->O_NBATTR[R107];
  if ( not_empty nbattr )
    create object instance dbattr of O_DBATTR;
    dbattr.Suc_Pars = ParseStatus::parseInitial;
    unrelate battr from nbattr across R107;
    relate battr to dbattr across R107;
    delete object instance nbattr;
  end if;
end if;
',
	1,
	'',
	1442);
INSERT INTO O_TFR
	VALUES (1443,
	37,
	'migrateDerivedToBase',
	'',
	19,
	1,
	'select one battr related by self->O_BATTR[R106];
if ( not_empty battr )
  select one dbattr related by battr->O_DBATTR[R107];
  if ( not_empty dbattr )
    create object instance nbattr of O_NBATTR;
    unrelate battr from dbattr across R107;
    relate battr to nbattr across R107;
    delete object instance dbattr;
  end if;
end if;
',
	1,
	'',
	1444);
INSERT INTO O_TFR
	VALUES (1444,
	37,
	'migrateBaseToReferential',
	'',
	19,
	1,
	'select one battr related by self->O_BATTR[R106];
if ( not_empty battr )
  battr.dispose();
end if;
create object instance rattr of O_RATTR;
rattr.Ref_Mode = 1;  // use referred to attribute name
relate self to rattr across R106;

rattr.setDatatype();
',
	1,
	'',
	1441);
INSERT INTO O_TFR
	VALUES (1445,
	37,
	'moveUp',
	'',
	19,
	1,
	'::changeNotificationEnablement(enabled:false);
select one prev_attr related by self->O_ATTR[R103.''succeeds''];
select one prev_prev_attr related by prev_attr->O_ATTR[R103.''succeeds''];
select one next_attr related by self->O_ATTR[R103.''precedes''];

if ( not_empty prev_prev_attr )
  unrelate prev_attr from prev_prev_attr across R103.''succeeds'';
end if;
if ( not_empty next_attr )
  unrelate next_attr from self across R103.''succeeds'';
end if;
unrelate self from prev_attr across R103.''succeeds'';

if ( not_empty prev_prev_attr )
  relate self to prev_prev_attr across R103.''succeeds'';
end if;
// want to enable listeners at the last possible moment
if ( empty next_attr )
  ::changeNotificationEnablement(enabled:true);
end if;
relate prev_attr to self across R103.''succeeds'';
if ( not_empty next_attr )
  ::changeNotificationEnablement(enabled:true);
  relate next_attr to prev_attr across R103.''succeeds'';
end if;
',
	1,
	'',
	1446);
INSERT INTO O_TFR
	VALUES (1446,
	37,
	'moveDown',
	'',
	19,
	1,
	'::changeNotificationEnablement(enabled:false);
select one next_attr related by self->O_ATTR[R103.''precedes''];
select one prev_attr related by self->O_ATTR[R103.''succeeds''];
select one next_next_attr related by next_attr->O_ATTR[R103.''precedes''];

if ( not_empty next_next_attr )
  unrelate next_next_attr from next_attr across R103.''succeeds'';
end if;
if ( not_empty prev_attr )
  unrelate self from prev_attr across R103.''succeeds'';
end if;
unrelate next_attr from self across R103.''succeeds'';

if ( not_empty prev_attr )
  relate next_attr to prev_attr across R103.''succeeds'';
end if;
   
// want to enable listeners at the last possible moment
if ( empty next_next_attr )
  ::changeNotificationEnablement(enabled:true);
end if;
relate self to next_attr across R103.''succeeds'';
if ( not_empty next_next_attr )
  ::changeNotificationEnablement(enabled:true);
  relate next_next_attr to self across R103.''succeeds'';
end if;',
	1,
	'',
	1443);
INSERT INTO O_TFR
	VALUES (1447,
	37,
	'addToIdentifier',
	'',
	19,
	1,
	'select any oid related by self->O_OBJ[R102]->O_ID[R104]
     where selected.Oid_ID == param.oid;
create object instance oida of O_OIDA;
relate self to oid across R105 using oida;
select many rto_set related by oid->R_RTO[R109];
for each rto in rto_set
  rto.addAttributeToIdentifier( attr_id: self.Attr_ID );
end for;',
	1,
	'',
	1436);
INSERT INTO O_TPARM
	VALUES (1448,
	1447,
	'oid',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1449,
	37,
	'removeFromIdentifier',
	'',
	322,
	1,
	'select any oida related by self->O_OIDA[R105]
    where selected.Oid_ID == param.oid;
select one oid related by oida->O_ID[R105];
select many id_attr_set related by oid->O_OIDA[R105];
if ( cardinality id_attr_set == 1 )
  // if this is the last attribute in this id, make sure it''s not
  // being referenced
  select any rtida related by oida->O_RTIDA[R110];
  if ( not_empty rtida )
    return "Operation not allowed.  Cannot remove the last attribute from an identifying attribute used to formalize an association.";
  end if;
end if;

oida.dispose();

return "";
',
	1,
	'',
	1445);
INSERT INTO O_TPARM
	VALUES (1450,
	1449,
	'oid',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1451,
	37,
	'canDelete',
	'',
	316,
	1,
	'if (self.Name == "current_state")
  select one dt related by self->S_DT[R114];
  if (dt.Name == "state<State_Model>")
    select one ism related by self->O_OBJ[R102]->SM_ISM[R518];
    if (not_empty ism)
      /*Now check if there are other attributes with same name & dt, if there 
      are any let this be deleteable and renameable*/
      select many attrs related by self->O_OBJ[R102]->O_ATTR[R102] where selected.Name == "current_state";
      if (cardinality attrs > 1)
        exist = false;
        for each attr in attrs
          select one adt related by attr->S_DT[R114];
          if (adt.Name == "state<State_Model>" and self != attr)
            exist = true;
          end if;
        end for;
        return exist;
      else
        return false;
      end if;
    end if;
  end if;
else   
  select one refAttr related by self->O_RATTR[R106];
  if (not_empty refAttr)
    return false;
  end if;
end if;
return true;',
	1,
	'',
	1447);
INSERT INTO O_TFR
	VALUES (1452,
	37,
	'canRename',
	'',
	316,
	1,
	'if (self.Name == "current_state")
  select one dt related by self->S_DT[R114];
  if (dt.Name == "state<State_Model>")
    select one ism related by self->O_OBJ[R102]->SM_ISM[R518];
    if (not_empty ism)
      /*Now check if there are other attributes with same name & dt, if there 
      are any let this be deleteable and renameable*/
      select many attrs related by self->O_OBJ[R102]->O_ATTR[R102] where selected.Name == "current_state";
      if (cardinality attrs > 1)
        exist = false;
        for each attr in attrs
          select one adt related by attr->S_DT[R114];
          if (adt.Name == "state<State_Model>" and self != attr)
            exist = true;
          end if;
        end for;
        return exist;
      else
        return false;
      end if;
    end if;
  end if;
else   
  select one refAttr related by self->O_RATTR[R106];
  if (not_empty refAttr)
    if (refAttr.Ref_Mode != 0)
      return false;
    end if;
  end if;
end if;
return true;',
	1,
	'',
	1453);
INSERT INTO O_TFR
	VALUES (1433,
	37,
	'get_root',
	'',
	322,
	1,
	'select one battr related by self->O_BATTR[R106];
if ( not_empty battr )
  return self.Root_Nam;
else
  select one rattr related by self->O_RATTR[R106];
  return rattr.get_root();
end if;',
	1,
	'',
	1454);
INSERT INTO O_TFR
	VALUES (1454,
	37,
	'get_prefix',
	'',
	322,
	1,
	'select one battr related by self->O_BATTR[R106];
if ( not_empty battr )
  if ( self.Pfx_Mode == 1 )  // use local prefix
    return self.Prefix;
  else
    // can''t be referred to prefix, must be no prefix
    return "";
  end if;
else
  select one rattr related by self->O_RATTR[R106];
  return rattr.get_prefix();
end if;',
	1,
	'',
	1455);
INSERT INTO O_TFR
	VALUES (1431,
	37,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'// just return this instance as an Object
return this;',
	0,
	'',
	1452);
INSERT INTO O_TFR
	VALUES (1455,
	37,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Attr_ID;',
	1,
	'',
	1456);
INSERT INTO O_TFR
	VALUES (1457,
	37,
	'resolveDatatype',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.

// if this attribute is a proxy do not
// try to resolve the dt, it can be a
// proxy when a supertype model class
// has been exported for state machine
// resolution purposes
if(Util::isProxy(element:self.convertToInstance()))
  return;
end if;

select one dtProxy related by self->S_DT[R114];
if(not_empty dtProxy)
  name = dtProxy.Name;
  unrelate dtProxy from self across R114;
  
  select one packageableElem related by self->O_OBJ[R102]->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = not_empty package or not_empty component;
  if isInGenericPackage
    id = packageableElem.resolveDataTypeRelativeToSelf(default_name:"integer",
                                                            expected_name:name);                                                          
    select any resolvedDt related by package->PE_VIS[R8002]->
                         PE_PE[R8002]->S_DT[R8001] where selected.DT_ID == id;
    if (empty resolvedDt)
      select any resolvedDt related by component->PE_CVS[R8004]->
                       PE_PE[R8004]->S_DT[R8001] where selected.DT_ID == id;
    end if;	
    if not_empty resolvedDt
      relate resolvedDt to self across R114;
    end if;
  else
    select one domain related by self->O_OBJ[R102]->S_SS[R2]->S_DOM[R1];
    id = domain.resolveDataTypeRelativeToSelf(default_name:"integer",
  													        expected_name:name);
    // until we have instance reference passing, we search for
    // the data type related to the domain first then to the
    // system
    select any resolvedDT related by domain->S_DT[R14]
  												   where (selected.DT_ID == id);
    if(empty resolvedDT)
      select one system related by domain->CN_DC[R4204]->C_C[R4204]
    				                               ->CP_CP[R4608]->S_SYS[R4606];
      select any resolvedDT related by system->SLD_SDINP[R4402]->S_DT[R4401]
    				 						       where (selected.DT_ID == id);
      if empty resolvedDT and not_empty system and system.useGlobals
        select any resolvedDT related by system->G_EIS[R9100]->PE_PE[R9100]->
                                       S_DT[R8001] where (selected.DT_ID == id);
      end if;
    end if;
    if(not_empty resolvedDT)
      relate resolvedDT to self across R114;
    end if;
  end if;
end if;',
	1,
	'',
	1458);
INSERT INTO O_TFR
	VALUES (1456,
	37,
	'getDimensionsCnt',
	'',
	298,
	1,
	'select many dims related by self->S_DIM[R120];
dimensions = cardinality dims;
return dimensions;',
	1,
	'',
	1430);
INSERT INTO O_TFR
	VALUES (1458,
	37,
	'resizeDimensions',
	'',
	19,
	1,
	'// If the number of dimensions has increased then add dimensions
while (param.numDimensions > self.getDimensionsCnt())
  create object instance dim of S_DIM;
  dim.dimensionCount = self.getDimensionsCnt();
  relate dim to self across R120;
end while;

// If the number of dimensions has decreased then remove dimensions
while (param.numDimensions < self.getDimensionsCnt())
  select any dim related by self->S_DIM[R120] where (selected.dimensionCount == (self.getDimensionsCnt()-1));
  unrelate dim from self across R120;
  delete object instance dim;
end while;

// Update the specific dimension that was passed-in if its elementCount has 
// changed.
if (param.numDimensions > 0) 
  select any dim related by self->S_DIM[R120] where (selected.dimensionCount == param.dimension);
  if (dim.elementCount != param.elementCount)
    dim.elementCount = param.elementCount;
  end if;
end if;
',
	1,
	'',
	1449);
INSERT INTO O_TPARM
	VALUES (1459,
	1458,
	'numDimensions',
	298,
	0,
	'',
	1460,
	'');
INSERT INTO O_TPARM
	VALUES (1460,
	1458,
	'elementCount',
	298,
	0,
	'',
	1461,
	'');
INSERT INTO O_TPARM
	VALUES (1461,
	1458,
	'dimension',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1453,
	37,
	'canReferToDataType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// select the dt
select one dt related by self->S_DT[R114];
if(not_empty dt)
  select one packageableElem related by self->O_OBJ[R102]->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = not_empty package or not_empty component;

  if (isInGenericPackage)
    return packageableElem.canReferToDataType(dtID:dt.DT_ID, dtName: dt.Name);
  else
    // if the data type package is at the system
    // level we can use the data type as long as
    // this element belongs to a formal component
    select one domain related by self->O_OBJ[R102]->S_SS[R2]->S_DOM[R1];
    select one dtPkg related by dt->S_DIP[R39]->S_DPK[R39];
    if(not dtPkg.isDomainLevel())
      if(domain.participatesInSystem())
        return true;
      else
        return false;
      end if;
    else
      // otherwise the DT must be in the same domain
      select one dtDomain related by dt->S_DOM[R14];
      if(dtDomain == domain)
        return true;
      end if;
    end if;
  end if;   
end if;
return false;',
	1,
	'',
	1451);
INSERT INTO O_TFR
	VALUES (1442,
	37,
	'isReferringToDefaultDataType',
	'',
	316,
	1,
	'select one dt related by self->S_DT[R114];
elementType = Util::getSimpleClassName(element:self.convertToInstance());
if(dt.Name == S_DT::getDefaultDataTypeName(elementType:elementType))
  return true;
end if;
return false;',
	1,
	'',
	1439);
INSERT INTO O_TFR
	VALUES (1462,
	37,
	'canUseDataType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Attribute::canUseDataType()
select one packageableElem related by self->O_OBJ[R102]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;
if isInGenericPackage
  // Find the previously created visibility list
  select any resultSet related by package->PE_SRS[R8005] where
        selected.Name == "" and selected.Type == ElementTypeConstants::DATATYPE;
  select any dt related by resultSet->PE_VIS[R8006]->
                     PE_PE[R8002]->S_DT[R8001] where selected.DT_ID == param.id;
  if not_empty component
    // Find the previously created visibility list
    select any compResultSet related by component->PE_CRS[R8007] where
        selected.Name == "" and selected.Type == ElementTypeConstants::DATATYPE;
    select any dt related by compResultSet->PE_CVS[R8008]->
                     PE_PE[R8004]->S_DT[R8001] where selected.DT_ID == param.id;
  end if;
  if(not_empty dt)
    if(self.isAllowedType(typeName:dt.Name))
      return true;
    end if;
  end if;
  return false;
else
  select one domain related by self->O_OBJ[R102]->S_SS[R2]->S_DOM[R1];
  if not_empty domain
    if(domain.participatesInSystem())
      // system level check both the system
      // and the domain for the dt
      select one system related by domain->CN_DC[R4204]->C_C[R4204]->
                                                     CP_CP[R4608]->S_SYS[R4606];
      select any dt related by system->SLD_SDINP[R4402]->S_DT[R4401]
                                             where (selected.DT_ID == param.id);
      if empty dt and not_empty system and system.useGlobals
        select any dt related by system->G_EIS[R9100]->PE_PE[R9100]->
                                 S_DT[R8001] where (selected.DT_ID == param.id);
      end if;
      if(empty dt)
        select any dt related by domain->S_DT[R14]
                                             where (selected.DT_ID == param.id);
      end if;
      if(not_empty dt)
        if(self.isAllowedType(typeName:dt.Name))
          return true;
        end if;
      end if;
    else
      // only check the domain for the dt
      select any dt related by domain->S_DT[R14] where (selected.DT_ID == param.id);
      if(not_empty dt)
        if(self.isAllowedType(typeName:dt.Name))
          return true;
        end if;
      end if;
    end if;
  else
    select one system related by self->O_OBJ[R102]->PE_PE[R8001]->
                                                    EP_PKG[R8000]->S_SYS[R1405];
    select any dt related by system->SLD_SDINP[R4402]->S_DT[R4401]
                                             where (selected.DT_ID == param.id);
    if empty dt and not_empty system and system.useGlobals
      select any dt related by system->G_EIS[R9100]->PE_PE[R9100]->
                                 S_DT[R8001] where (selected.DT_ID == param.id);
    end if;
    if not_empty dt
      if self.isAllowedType(typeName:dt.Name)
        return true;
      end if;
    end if;
  end if;
  return false;
end if;',
	1,
	'',
	1457);
INSERT INTO O_TPARM
	VALUES (1463,
	1462,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1464,
	37,
	'checkIntegrity',
	'',
	19,
	1,
	'// check for any attributes with the same name
select one package related by self->O_OBJ[R102]->PE_PE[R8001]->EP_PKG[R8000];
select many attributes related by self->O_OBJ[R102]->O_ATTR[R102];
for each attribute in attributes
  if(attribute != self and attribute.Name == self.Name)
    select one system related by package->S_SYS[R1405];
    sys_id = GD::NULL_UNIQUE_ID();
    if(not_empty system)
      sys_id = system.Sys_ID;
    end if;
    select one class related by self->O_OBJ[R102];
	MI_IM::createIssue(sys_id:sys_id, description:
	               "Found another attribute under the same class " +
	            "with the same name.", severity:Severity::Error, name:self.Name,
	   path:class.getPath(path:self.Name, includeSelf:true), id:self.Attr_ID,
	                                          element:self.convertToInstance());
  end if;
end for;',
	1,
	'',
	1462);
INSERT INTO O_NBATTR
	VALUES (168,
	37);
INSERT INTO O_BATTR
	VALUES (168,
	37);
INSERT INTO O_ATTR
	VALUES (168,
	37,
	0,
	'Attr_ID',
	'Full Name: Attribute Identifier
Description: A unique identifier for an instance of attribute.',
	'',
	'Attr_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_REF
	VALUES (37,
	37,
	0,
	168,
	1004,
	1006,
	1005,
	1465,
	1466,
	0,
	0,
	'',
	'Attribute',
	'Attr_ID',
	'R103');
INSERT INTO O_RATTR
	VALUES (1465,
	37,
	168,
	37,
	1,
	'Attr_ID');
INSERT INTO O_ATTR
	VALUES (1465,
	37,
	169,
	'PAttr_ID',
	'',
	'P',
	'Attr_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (1467,
	37,
	'if ( self.Pfx_Mode == 1 )  // use local prefix
  select one rattr related by self->O_RATTR[R106];
  if ( empty rattr )
    self.Name = self.Prefix + self.Root_Nam;
  else
    self.Name = self.Prefix + rattr.get_root_name();
      end if;
elif ( self.Pfx_Mode == 2 )  // use referred to prefix
  select one rattr related by self->O_RATTR[R106];
  if ( empty rattr )
    self.Name = ::getOrphanedElementName();
  else
    self.Name = rattr.get_prefix_string() + rattr.get_root_name();
      end if;
else  // no prefix
  select one rattr related by self->O_RATTR[R106];
  if ( empty rattr )
    self.Name = self.Root_Nam;
  else
    self.Name = rattr.get_root_name();
  end if;
end if;
',
	1);
INSERT INTO O_BATTR
	VALUES (1467,
	37);
INSERT INTO O_ATTR
	VALUES (1467,
	37,
	1465,
	'Name',
	'Full Name: Attribute Name
Description: The name of the class attribute as it appears on the OIM of the application analysis domain.  The name of the class attribute is mathematically derived from ''O_ATTR.Root_Nam'', ''O_ATTR.Prefix'', and ''O_ATTR.Prx_Mode''.',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1468,
	37);
INSERT INTO O_BATTR
	VALUES (1468,
	37);
INSERT INTO O_ATTR
	VALUES (1468,
	37,
	1467,
	'Descrip',
	'Full Name: Description
Description:  A textual description of the class attribute as specified in the application analysis domain.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1469,
	37);
INSERT INTO O_BATTR
	VALUES (1469,
	37);
INSERT INTO O_ATTR
	VALUES (1469,
	37,
	1468,
	'Prefix',
	'Full Name: Attribute Name Prefix
Description: Prefix for the attribute.',
	'',
	'Prefix',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1470,
	37);
INSERT INTO O_BATTR
	VALUES (1470,
	37);
INSERT INTO O_ATTR
	VALUES (1470,
	37,
	1469,
	'Root_Nam',
	'Full Name: Attribute Root Name
Description: The root name (name without prefix) of the attribute',
	'',
	'Root_Nam',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1471,
	37);
INSERT INTO O_BATTR
	VALUES (1471,
	37);
INSERT INTO O_ATTR
	VALUES (1471,
	37,
	1470,
	'Pfx_Mode',
	'Full Name: Prefix Mode
Description: Indicates usage of a prefix.
Data Domain: 0 = uses no prefix, 1 = uses local prefix, 2 = uses referred to prefix

enum0: No Prefix
enum1: Prefix
enum2: Referred To Prefix
',
	'',
	'Pfx_Mode',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1472,
	37);
INSERT INTO O_BATTR
	VALUES (1472,
	37);
INSERT INTO O_ATTR
	VALUES (1472,
	37,
	1473,
	'Dimensions',
	'Full Name: Array Dimensions',
	'',
	'Dimensions',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1474,
	37);
INSERT INTO O_BATTR
	VALUES (1474,
	37);
INSERT INTO O_ATTR
	VALUES (1474,
	37,
	1472,
	'DefaultValue',
	'Full Name: Default Value
Description: This attribute holds text representing the initialization value for this attribute upon instance creation.
',
	'',
	'DefaultValue',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (37,
	32,
	0,
	156,
	1007,
	1009,
	1008,
	1473,
	1475,
	0,
	0,
	'',
	'Data Type',
	'DT_ID',
	'R114');
INSERT INTO O_RATTR
	VALUES (1473,
	37,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (1473,
	37,
	1471,
	'DT_ID',
	'',
	'',
	'Element_ID',
	2,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (37,
	30,
	0,
	150,
	1001,
	1002,
	1003,
	169,
	1476,
	0,
	0,
	'',
	'Model Class',
	'Obj_ID',
	'R102');
INSERT INTO O_REF
	VALUES (37,
	37,
	0,
	169,
	1004,
	1006,
	1005,
	169,
	1477,
	1476,
	0,
	'',
	'Attribute',
	'Obj_ID',
	'R103');
INSERT INTO O_RATTR
	VALUES (169,
	37,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (169,
	37,
	168,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	37);
INSERT INTO O_OIDA
	VALUES (168,
	37,
	0,
	'Attr_ID');
INSERT INTO O_OIDA
	VALUES (169,
	37,
	0,
	'Obj_ID');
INSERT INTO O_ID
	VALUES (1,
	37);
INSERT INTO O_ID
	VALUES (2,
	37);
-- BP 7.1 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (1478,
	'State Machine',
	'Classes (O_OBJ) that have interesting behavior are given lifecycles. These lifecycles are described using state machines (SM_SM). A state machine consists of states, events, transitions and state actions. The state machine exists for each instance of the class for which it has been modeled (SM_ISM). A state machine can also be an assigner state machine (SM_ASM) of which only one can exists for all class instances. The purpose of the assigner state machine is to act as a single point of control through which competing requests are serialized.',
	'SM',
	501,
	1,
	1479);
INSERT INTO S_SID
	VALUES (1,
	1478);
INSERT INTO O_IOBJ
	VALUES (1480,
	32,
	5,
	1478,
	'Data Type',
	'S_DT');
INSERT INTO O_IOBJ
	VALUES (1481,
	30,
	5,
	1478,
	'Model Class',
	'O_OBJ');
INSERT INTO O_IOBJ
	VALUES (1482,
	1483,
	0,
	1478,
	'Provided Signal',
	'SPR_PS');
INSERT INTO O_IOBJ
	VALUES (1484,
	1485,
	0,
	1478,
	'Required Signal',
	'SPR_RS');
INSERT INTO O_IOBJ
	VALUES (1486,
	59,
	0,
	1478,
	'Dimensions',
	'S_DIM');
INSERT INTO R_SIMP
	VALUES (1487);
INSERT INTO R_REL
	VALUES (1487,
	502,
	'',
	1478);
INSERT INTO R_FORM
	VALUES (1488,
	1487,
	1489,
	1,
	1,
	'can be communicated to via');
INSERT INTO R_RGO
	VALUES (1488,
	1487,
	1489);
INSERT INTO R_OIR
	VALUES (1488,
	1487,
	1489,
	0);
INSERT INTO R_PART
	VALUES (565,
	1487,
	1490,
	0,
	0,
	'');
INSERT INTO O_RTIDA
	VALUES (564,
	565,
	0,
	1487,
	1490);
INSERT INTO R_RTO
	VALUES (565,
	1487,
	1490,
	0);
INSERT INTO R_OIR
	VALUES (565,
	1487,
	1490,
	0);
INSERT INTO R_SIMP
	VALUES (1491);
INSERT INTO R_REL
	VALUES (1491,
	501,
	'',
	1478);
INSERT INTO R_FORM
	VALUES (1492,
	1491,
	1493,
	1,
	1,
	'is decomposed into');
INSERT INTO R_RGO
	VALUES (1492,
	1491,
	1493);
INSERT INTO R_OIR
	VALUES (1492,
	1491,
	1493,
	0);
INSERT INTO R_PART
	VALUES (565,
	1491,
	1494,
	0,
	0,
	'');
INSERT INTO O_RTIDA
	VALUES (564,
	565,
	0,
	1491,
	1494);
INSERT INTO R_RTO
	VALUES (565,
	1491,
	1494,
	0);
INSERT INTO R_OIR
	VALUES (565,
	1491,
	1494,
	0);
INSERT INTO R_SUBSUP
	VALUES (1495);
INSERT INTO R_REL
	VALUES (1495,
	504,
	'',
	1478);
INSERT INTO R_SUPER
	VALUES (1496,
	1495,
	1497);
INSERT INTO O_RTIDA
	VALUES (1498,
	1496,
	0,
	1495,
	1497);
INSERT INTO O_RTIDA
	VALUES (1499,
	1496,
	0,
	1495,
	1497);
INSERT INTO O_RTIDA
	VALUES (1500,
	1496,
	0,
	1495,
	1497);
INSERT INTO O_RTIDA
	VALUES (1501,
	1496,
	0,
	1495,
	1497);
INSERT INTO R_RTO
	VALUES (1496,
	1495,
	1497,
	0);
INSERT INTO R_OIR
	VALUES (1496,
	1495,
	1497,
	0);
INSERT INTO R_SUB
	VALUES (1502,
	1495,
	1503);
INSERT INTO R_RGO
	VALUES (1502,
	1495,
	1503);
INSERT INTO R_OIR
	VALUES (1502,
	1495,
	1503,
	0);
INSERT INTO R_SUB
	VALUES (1504,
	1495,
	1505);
INSERT INTO R_RGO
	VALUES (1504,
	1495,
	1505);
INSERT INTO R_OIR
	VALUES (1504,
	1495,
	1505,
	0);
INSERT INTO R_SUB
	VALUES (1506,
	1495,
	1507);
INSERT INTO R_RGO
	VALUES (1506,
	1495,
	1507);
INSERT INTO R_OIR
	VALUES (1506,
	1495,
	1507,
	0);
INSERT INTO R_SUBSUP
	VALUES (1508);
INSERT INTO R_REL
	VALUES (1508,
	507,
	'',
	1478);
INSERT INTO R_SUPER
	VALUES (1509,
	1508,
	1510);
INSERT INTO O_RTIDA
	VALUES (1511,
	1509,
	0,
	1508,
	1510);
INSERT INTO O_RTIDA
	VALUES (1512,
	1509,
	0,
	1508,
	1510);
INSERT INTO R_RTO
	VALUES (1509,
	1508,
	1510,
	0);
INSERT INTO R_OIR
	VALUES (1509,
	1508,
	1510,
	0);
INSERT INTO R_SUB
	VALUES (1513,
	1508,
	1514);
INSERT INTO R_RGO
	VALUES (1513,
	1508,
	1514);
INSERT INTO R_OIR
	VALUES (1513,
	1508,
	1514,
	0);
INSERT INTO R_SUB
	VALUES (1515,
	1508,
	1516);
INSERT INTO R_RGO
	VALUES (1515,
	1508,
	1516);
INSERT INTO R_OIR
	VALUES (1515,
	1508,
	1516,
	0);
INSERT INTO R_SUB
	VALUES (1506,
	1508,
	1517);
INSERT INTO R_RGO
	VALUES (1506,
	1508,
	1517);
INSERT INTO R_OIR
	VALUES (1506,
	1508,
	1517,
	0);
INSERT INTO R_SIMP
	VALUES (1518);
INSERT INTO R_REL
	VALUES (1518,
	508,
	'',
	1478);
INSERT INTO R_FORM
	VALUES (1513,
	1518,
	1519,
	1,
	1,
	'is origination of');
INSERT INTO R_RGO
	VALUES (1513,
	1518,
	1519);
INSERT INTO R_OIR
	VALUES (1513,
	1518,
	1519,
	0);
INSERT INTO R_PART
	VALUES (1492,
	1518,
	1520,
	0,
	0,
	'originates from');
INSERT INTO O_RTIDA
	VALUES (1521,
	1492,
	0,
	1518,
	1520);
INSERT INTO O_RTIDA
	VALUES (1522,
	1492,
	0,
	1518,
	1520);
INSERT INTO R_RTO
	VALUES (1492,
	1518,
	1520,
	0);
INSERT INTO R_OIR
	VALUES (1492,
	1518,
	1520,
	0);
INSERT INTO R_SIMP
	VALUES (1523);
INSERT INTO R_REL
	VALUES (1523,
	506,
	'',
	1478);
INSERT INTO R_FORM
	VALUES (1509,
	1523,
	1524,
	1,
	1,
	'is destination of');
INSERT INTO R_RGO
	VALUES (1509,
	1523,
	1524);
INSERT INTO R_OIR
	VALUES (1509,
	1523,
	1524,
	0);
INSERT INTO R_PART
	VALUES (1492,
	1523,
	1525,
	0,
	0,
	'is destined to');
INSERT INTO O_RTIDA
	VALUES (1526,
	1492,
	1,
	1523,
	1525);
INSERT INTO O_RTIDA
	VALUES (1522,
	1492,
	1,
	1523,
	1525);
INSERT INTO O_RTIDA
	VALUES (1521,
	1492,
	1,
	1523,
	1525);
INSERT INTO R_RTO
	VALUES (1492,
	1523,
	1525,
	1);
INSERT INTO R_OIR
	VALUES (1492,
	1523,
	1525,
	0);
INSERT INTO R_SIMP
	VALUES (1527);
INSERT INTO R_REL
	VALUES (1527,
	505,
	'',
	1478);
INSERT INTO R_FORM
	VALUES (1509,
	1527,
	1528,
	1,
	1,
	'contains');
INSERT INTO R_RGO
	VALUES (1509,
	1527,
	1528);
INSERT INTO R_OIR
	VALUES (1509,
	1527,
	1528,
	0);
INSERT INTO R_PART
	VALUES (565,
	1527,
	1529,
	0,
	0,
	'');
INSERT INTO O_RTIDA
	VALUES (564,
	565,
	0,
	1527,
	1529);
INSERT INTO R_RTO
	VALUES (565,
	1527,
	1529,
	0);
INSERT INTO R_OIR
	VALUES (565,
	1527,
	1529,
	0);
INSERT INTO R_SUBSUP
	VALUES (1530);
INSERT INTO R_REL
	VALUES (1530,
	510,
	'',
	1478);
INSERT INTO R_SUPER
	VALUES (565,
	1530,
	1531);
INSERT INTO O_RTIDA
	VALUES (564,
	565,
	0,
	1530,
	1531);
INSERT INTO R_RTO
	VALUES (565,
	1530,
	1531,
	0);
INSERT INTO R_OIR
	VALUES (565,
	1530,
	1531,
	0);
INSERT INTO R_SUB
	VALUES (1532,
	1530,
	1533);
INSERT INTO R_RGO
	VALUES (1532,
	1530,
	1533);
INSERT INTO R_OIR
	VALUES (1532,
	1530,
	1533,
	0);
INSERT INTO R_SUB
	VALUES (1534,
	1530,
	1535);
INSERT INTO R_RGO
	VALUES (1534,
	1530,
	1535);
INSERT INTO R_OIR
	VALUES (1534,
	1530,
	1535,
	0);
INSERT INTO R_ASSOC
	VALUES (1536);
INSERT INTO R_REL
	VALUES (1536,
	511,
	'',
	1478);
INSERT INTO R_AONE
	VALUES (1534,
	1536,
	1537,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (1538,
	1534,
	0,
	1536,
	1537);
INSERT INTO R_RTO
	VALUES (1534,
	1536,
	1537,
	0);
INSERT INTO R_OIR
	VALUES (1534,
	1536,
	1537,
	0);
INSERT INTO R_AOTH
	VALUES (1492,
	1536,
	1539,
	1,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (1521,
	1492,
	0,
	1536,
	1539);
INSERT INTO O_RTIDA
	VALUES (1522,
	1492,
	0,
	1536,
	1539);
INSERT INTO R_RTO
	VALUES (1492,
	1536,
	1539,
	0);
INSERT INTO R_OIR
	VALUES (1492,
	1536,
	1539,
	0);
INSERT INTO R_ASSR
	VALUES (1540,
	1536,
	1541,
	0);
INSERT INTO R_RGO
	VALUES (1540,
	1536,
	1541);
INSERT INTO R_OIR
	VALUES (1540,
	1536,
	1541,
	0);
INSERT INTO R_ASSOC
	VALUES (1542);
INSERT INTO R_REL
	VALUES (1542,
	512,
	'',
	1478);
INSERT INTO R_AONE
	VALUES (1532,
	1542,
	1543,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (1544,
	1532,
	0,
	1542,
	1543);
INSERT INTO R_RTO
	VALUES (1532,
	1542,
	1543,
	0);
INSERT INTO R_OIR
	VALUES (1532,
	1542,
	1543,
	0);
INSERT INTO R_AOTH
	VALUES (1509,
	1542,
	1545,
	1,
	0,
	'');
INSERT INTO O_RTIDA
	VALUES (1511,
	1509,
	0,
	1542,
	1545);
INSERT INTO O_RTIDA
	VALUES (1512,
	1509,
	0,
	1542,
	1545);
INSERT INTO R_RTO
	VALUES (1509,
	1542,
	1545,
	0);
INSERT INTO R_OIR
	VALUES (1509,
	1542,
	1545,
	0);
INSERT INTO R_ASSR
	VALUES (1546,
	1542,
	1547,
	0);
INSERT INTO R_RGO
	VALUES (1546,
	1542,
	1547);
INSERT INTO R_OIR
	VALUES (1546,
	1542,
	1547,
	0);
INSERT INTO R_SUBSUP
	VALUES (1548);
INSERT INTO R_REL
	VALUES (1548,
	513,
	'',
	1478);
INSERT INTO R_SUPER
	VALUES (1549,
	1548,
	1550);
INSERT INTO O_RTIDA
	VALUES (1551,
	1549,
	0,
	1548,
	1550);
INSERT INTO O_RTIDA
	VALUES (1552,
	1549,
	0,
	1548,
	1550);
INSERT INTO R_RTO
	VALUES (1549,
	1548,
	1550,
	0);
INSERT INTO R_OIR
	VALUES (1549,
	1548,
	1550,
	0);
INSERT INTO R_SUB
	VALUES (1540,
	1548,
	1553);
INSERT INTO R_RGO
	VALUES (1540,
	1548,
	1553);
INSERT INTO R_OIR
	VALUES (1540,
	1548,
	1553,
	0);
INSERT INTO R_SUB
	VALUES (1546,
	1548,
	1554);
INSERT INTO R_RGO
	VALUES (1546,
	1548,
	1554);
INSERT INTO R_OIR
	VALUES (1546,
	1548,
	1554,
	0);
INSERT INTO R_SUB
	VALUES (1555,
	1548,
	1556);
INSERT INTO R_RGO
	VALUES (1555,
	1548,
	1556);
INSERT INTO R_OIR
	VALUES (1555,
	1548,
	1556,
	0);
INSERT INTO R_SIMP
	VALUES (1557);
INSERT INTO R_REL
	VALUES (1557,
	514,
	'',
	1478);
INSERT INTO R_FORM
	VALUES (1549,
	1557,
	1558,
	0,
	0,
	'resides in');
INSERT INTO R_RGO
	VALUES (1549,
	1557,
	1558);
INSERT INTO R_OIR
	VALUES (1549,
	1557,
	1558,
	0);
INSERT INTO R_PART
	VALUES (1559,
	1557,
	1560,
	0,
	0,
	'houses');
INSERT INTO O_RTIDA
	VALUES (1561,
	1559,
	0,
	1557,
	1560);
INSERT INTO O_RTIDA
	VALUES (1562,
	1559,
	0,
	1557,
	1560);
INSERT INTO R_RTO
	VALUES (1559,
	1557,
	1560,
	0);
INSERT INTO R_OIR
	VALUES (1559,
	1557,
	1560,
	0);
INSERT INTO R_SIMP
	VALUES (1563);
INSERT INTO R_REL
	VALUES (1563,
	515,
	'',
	1478);
INSERT INTO R_FORM
	VALUES (1559,
	1563,
	1564,
	1,
	1,
	'contains');
INSERT INTO R_RGO
	VALUES (1559,
	1563,
	1564);
INSERT INTO R_OIR
	VALUES (1559,
	1563,
	1564,
	0);
INSERT INTO R_PART
	VALUES (565,
	1563,
	1565,
	0,
	0,
	'');
INSERT INTO O_RTIDA
	VALUES (564,
	565,
	0,
	1563,
	1565);
INSERT INTO R_RTO
	VALUES (565,
	1563,
	1565,
	0);
INSERT INTO R_OIR
	VALUES (565,
	1563,
	1565,
	0);
INSERT INTO R_SUBSUP
	VALUES (1566);
INSERT INTO R_REL
	VALUES (1566,
	517,
	'',
	1478);
INSERT INTO R_SUPER
	VALUES (565,
	1566,
	1567);
INSERT INTO O_RTIDA
	VALUES (564,
	565,
	0,
	1566,
	1567);
INSERT INTO R_RTO
	VALUES (565,
	1566,
	1567,
	0);
INSERT INTO R_OIR
	VALUES (565,
	1566,
	1567,
	0);
INSERT INTO R_SUB
	VALUES (1568,
	1566,
	1569);
INSERT INTO R_RGO
	VALUES (1568,
	1566,
	1569);
INSERT INTO R_OIR
	VALUES (1568,
	1566,
	1569,
	0);
INSERT INTO R_SUB
	VALUES (1570,
	1566,
	1571);
INSERT INTO R_RGO
	VALUES (1570,
	1566,
	1571);
INSERT INTO R_OIR
	VALUES (1570,
	1566,
	1571,
	0);
INSERT INTO R_SIMP
	VALUES (1572);
INSERT INTO R_REL
	VALUES (1572,
	518,
	'',
	1478);
INSERT INTO R_FORM
	VALUES (1568,
	1572,
	1573,
	0,
	1,
	'');
INSERT INTO R_RGO
	VALUES (1568,
	1572,
	1573);
INSERT INTO R_OIR
	VALUES (1568,
	1572,
	1573,
	0);
INSERT INTO R_PART
	VALUES (30,
	1572,
	1574,
	0,
	0,
	'');
INSERT INTO O_RTIDA
	VALUES (150,
	30,
	0,
	1572,
	1574);
INSERT INTO R_RTO
	VALUES (30,
	1572,
	1574,
	0);
INSERT INTO R_OIR
	VALUES (30,
	1572,
	1574,
	1481);
INSERT INTO R_SIMP
	VALUES (1575);
INSERT INTO R_REL
	VALUES (1575,
	519,
	'',
	1478);
INSERT INTO R_FORM
	VALUES (1570,
	1575,
	1576,
	0,
	1,
	'');
INSERT INTO R_RGO
	VALUES (1570,
	1575,
	1576);
INSERT INTO R_OIR
	VALUES (1570,
	1575,
	1576,
	0);
INSERT INTO R_PART
	VALUES (30,
	1575,
	1577,
	0,
	0,
	'');
INSERT INTO O_RTIDA
	VALUES (150,
	30,
	0,
	1575,
	1577);
INSERT INTO R_RTO
	VALUES (30,
	1575,
	1577,
	0);
INSERT INTO R_OIR
	VALUES (30,
	1575,
	1577,
	1481);
INSERT INTO R_SIMP
	VALUES (1578);
INSERT INTO R_REL
	VALUES (1578,
	516,
	'',
	1478);
INSERT INTO R_FORM
	VALUES (52,
	1578,
	1579,
	1,
	1,
	'can asynchronously communicate via');
INSERT INTO R_RGO
	VALUES (52,
	1578,
	1579);
INSERT INTO R_OIR
	VALUES (52,
	1578,
	1579,
	0);
INSERT INTO R_PART
	VALUES (565,
	1578,
	1580,
	0,
	0,
	'is carried on events into');
INSERT INTO O_RTIDA
	VALUES (564,
	565,
	0,
	1578,
	1580);
INSERT INTO R_RTO
	VALUES (565,
	1578,
	1580,
	0);
INSERT INTO R_OIR
	VALUES (565,
	1578,
	1580,
	0);
INSERT INTO R_SIMP
	VALUES (1581);
INSERT INTO R_REL
	VALUES (1581,
	521,
	'This association is deprecated.
                              
Events now locate their data across simple association R532.',
	1478);
INSERT INTO R_FORM
	VALUES (1492,
	1581,
	1582,
	1,
	1,
	'is delivered by received event to');
INSERT INTO R_RGO
	VALUES (1492,
	1581,
	1582);
INSERT INTO R_OIR
	VALUES (1492,
	1581,
	1582,
	0);
INSERT INTO R_PART
	VALUES (1583,
	1581,
	1584,
	0,
	1,
	'receives asynchronous data via');
INSERT INTO O_RTIDA
	VALUES (1585,
	1583,
	0,
	1581,
	1584);
INSERT INTO O_RTIDA
	VALUES (1586,
	1583,
	0,
	1581,
	1584);
INSERT INTO R_RTO
	VALUES (1583,
	1581,
	1584,
	0);
INSERT INTO R_OIR
	VALUES (1583,
	1581,
	1584,
	0);
INSERT INTO R_SIMP
	VALUES (1587);
INSERT INTO R_REL
	VALUES (1587,
	520,
	'This association is deprecated.
                              
Events now locate their data across simple association R532.',
	1478);
INSERT INTO R_FORM
	VALUES (1488,
	1587,
	1588,
	1,
	0,
	'defines signature of');
INSERT INTO R_RGO
	VALUES (1488,
	1587,
	1588);
INSERT INTO R_OIR
	VALUES (1488,
	1587,
	1588,
	0);
INSERT INTO R_PART
	VALUES (1583,
	1587,
	1589,
	0,
	1,
	'carries');
INSERT INTO O_RTIDA
	VALUES (1585,
	1583,
	0,
	1587,
	1589);
INSERT INTO O_RTIDA
	VALUES (1586,
	1583,
	0,
	1587,
	1589);
INSERT INTO R_RTO
	VALUES (1583,
	1587,
	1589,
	0);
INSERT INTO R_OIR
	VALUES (1583,
	1587,
	1589,
	0);
INSERT INTO R_ASSOC
	VALUES (1590);
INSERT INTO R_REL
	VALUES (1590,
	522,
	'This association is deprecated.
                              
Events now locate their data across simple association R532.',
	1478);
INSERT INTO R_AONE
	VALUES (1583,
	1590,
	1591,
	1,
	1,
	'makes up');
INSERT INTO O_RTIDA
	VALUES (1585,
	1583,
	0,
	1590,
	1591);
INSERT INTO O_RTIDA
	VALUES (1586,
	1583,
	0,
	1590,
	1591);
INSERT INTO R_RTO
	VALUES (1583,
	1590,
	1591,
	0);
INSERT INTO R_OIR
	VALUES (1583,
	1590,
	1591,
	0);
INSERT INTO R_AOTH
	VALUES (52,
	1590,
	1592,
	1,
	1,
	'is made up of');
INSERT INTO O_RTIDA
	VALUES (276,
	52,
	0,
	1590,
	1592);
INSERT INTO O_RTIDA
	VALUES (277,
	52,
	0,
	1590,
	1592);
INSERT INTO R_RTO
	VALUES (52,
	1590,
	1592,
	0);
INSERT INTO R_OIR
	VALUES (52,
	1590,
	1592,
	0);
INSERT INTO R_ASSR
	VALUES (1593,
	1590,
	1594,
	0);
INSERT INTO R_RGO
	VALUES (1593,
	1590,
	1594);
INSERT INTO R_OIR
	VALUES (1593,
	1590,
	1594,
	0);
INSERT INTO R_SIMP
	VALUES (1595);
INSERT INTO R_REL
	VALUES (1595,
	523,
	'',
	1478);
INSERT INTO R_FORM
	VALUES (1583,
	1595,
	1596,
	1,
	1,
	'contains');
INSERT INTO R_RGO
	VALUES (1583,
	1595,
	1596);
INSERT INTO R_OIR
	VALUES (1583,
	1595,
	1596,
	0);
INSERT INTO R_PART
	VALUES (565,
	1595,
	1597,
	0,
	0,
	'is assigned to');
INSERT INTO O_RTIDA
	VALUES (564,
	565,
	0,
	1595,
	1597);
INSERT INTO R_RTO
	VALUES (565,
	1595,
	1597,
	0);
INSERT INTO R_OIR
	VALUES (565,
	1595,
	1597,
	0);
INSERT INTO R_SIMP
	VALUES (1598);
INSERT INTO R_REL
	VALUES (1598,
	524,
	'Association Description:

Purpose of Abstraction:

CrossComponent:true',
	1478);
INSERT INTO R_PART
	VALUES (32,
	1598,
	1599,
	0,
	0,
	'is defined by');
INSERT INTO O_RTIDA
	VALUES (156,
	32,
	0,
	1598,
	1599);
INSERT INTO R_RTO
	VALUES (32,
	1598,
	1599,
	0);
INSERT INTO R_OIR
	VALUES (32,
	1598,
	1599,
	1480);
INSERT INTO R_FORM
	VALUES (52,
	1598,
	1600,
	1,
	1,
	'defines the type of');
INSERT INTO R_RGO
	VALUES (52,
	1598,
	1600);
INSERT INTO R_OIR
	VALUES (52,
	1598,
	1600,
	0);
INSERT INTO R_SUBSUP
	VALUES (1601);
INSERT INTO R_REL
	VALUES (1601,
	525,
	'',
	1478);
INSERT INTO R_SUPER
	VALUES (1488,
	1601,
	1602);
INSERT INTO O_RTIDA
	VALUES (1603,
	1488,
	1,
	1601,
	1602);
INSERT INTO O_RTIDA
	VALUES (1604,
	1488,
	1,
	1601,
	1602);
INSERT INTO O_RTIDA
	VALUES (1605,
	1488,
	1,
	1601,
	1602);
INSERT INTO R_RTO
	VALUES (1488,
	1601,
	1602,
	1);
INSERT INTO R_OIR
	VALUES (1488,
	1601,
	1602,
	0);
INSERT INTO R_SUB
	VALUES (1606,
	1601,
	1607);
INSERT INTO R_RGO
	VALUES (1606,
	1601,
	1607);
INSERT INTO R_OIR
	VALUES (1606,
	1601,
	1607,
	0);
INSERT INTO R_SUB
	VALUES (1608,
	1601,
	1609);
INSERT INTO R_RGO
	VALUES (1608,
	1601,
	1609);
INSERT INTO R_OIR
	VALUES (1608,
	1601,
	1609,
	0);
INSERT INTO R_ASSOC
	VALUES (1610);
INSERT INTO R_REL
	VALUES (1610,
	503,
	'',
	1478);
INSERT INTO R_AONE
	VALUES (1492,
	1610,
	1611,
	1,
	1,
	'is received by');
INSERT INTO O_RTIDA
	VALUES (1521,
	1492,
	0,
	1610,
	1611);
INSERT INTO O_RTIDA
	VALUES (1522,
	1492,
	0,
	1610,
	1611);
INSERT INTO R_RTO
	VALUES (1492,
	1610,
	1611,
	0);
INSERT INTO R_OIR
	VALUES (1492,
	1610,
	1611,
	0);
INSERT INTO R_AOTH
	VALUES (1606,
	1610,
	1612,
	1,
	1,
	'receives');
INSERT INTO O_RTIDA
	VALUES (1613,
	1606,
	0,
	1610,
	1612);
INSERT INTO O_RTIDA
	VALUES (1614,
	1606,
	0,
	1610,
	1612);
INSERT INTO O_RTIDA
	VALUES (1615,
	1606,
	0,
	1610,
	1612);
INSERT INTO R_RTO
	VALUES (1606,
	1610,
	1612,
	0);
INSERT INTO R_OIR
	VALUES (1606,
	1610,
	1612,
	0);
INSERT INTO R_ASSR
	VALUES (1496,
	1610,
	1616,
	0);
INSERT INTO R_RGO
	VALUES (1496,
	1610,
	1616);
INSERT INTO R_OIR
	VALUES (1496,
	1610,
	1616,
	0);
INSERT INTO R_SUBSUP
	VALUES (1617);
INSERT INTO R_REL
	VALUES (1617,
	526,
	'',
	1478);
INSERT INTO R_SUPER
	VALUES (1606,
	1617,
	1618);
INSERT INTO O_RTIDA
	VALUES (1613,
	1606,
	0,
	1617,
	1618);
INSERT INTO O_RTIDA
	VALUES (1614,
	1606,
	0,
	1617,
	1618);
INSERT INTO O_RTIDA
	VALUES (1615,
	1606,
	0,
	1617,
	1618);
INSERT INTO R_RTO
	VALUES (1606,
	1617,
	1618,
	0);
INSERT INTO R_OIR
	VALUES (1606,
	1617,
	1618,
	0);
INSERT INTO R_SUB
	VALUES (1619,
	1617,
	1620);
INSERT INTO R_RGO
	VALUES (1619,
	1617,
	1620);
INSERT INTO R_OIR
	VALUES (1619,
	1617,
	1620,
	0);
INSERT INTO R_SUB
	VALUES (1621,
	1617,
	1622);
INSERT INTO R_RGO
	VALUES (1621,
	1617,
	1622);
INSERT INTO R_OIR
	VALUES (1621,
	1617,
	1622,
	0);
INSERT INTO R_SUB
	VALUES (1623,
	1617,
	1624);
INSERT INTO R_RGO
	VALUES (1623,
	1617,
	1624);
INSERT INTO R_OIR
	VALUES (1623,
	1617,
	1624,
	0);
INSERT INTO R_SIMP
	VALUES (1625);
INSERT INTO R_REL
	VALUES (1625,
	509,
	'',
	1478);
INSERT INTO R_FORM
	VALUES (1515,
	1625,
	1626,
	0,
	1,
	'has assigned to it');
INSERT INTO R_RGO
	VALUES (1515,
	1625,
	1626);
INSERT INTO R_OIR
	VALUES (1515,
	1625,
	1626,
	0);
INSERT INTO R_PART
	VALUES (1621,
	1625,
	1627,
	0,
	1,
	'is assigned to');
INSERT INTO O_RTIDA
	VALUES (1628,
	1621,
	0,
	1625,
	1627);
INSERT INTO O_RTIDA
	VALUES (1629,
	1621,
	0,
	1625,
	1627);
INSERT INTO R_RTO
	VALUES (1621,
	1625,
	1627,
	0);
INSERT INTO R_OIR
	VALUES (1621,
	1625,
	1627,
	0);
INSERT INTO R_SIMP
	VALUES (1630);
INSERT INTO R_REL
	VALUES (1630,
	527,
	'CrossComponent:true',
	1478);
INSERT INTO R_PART
	VALUES (1608,
	1630,
	1631,
	0,
	0,
	'is defined by');
INSERT INTO O_RTIDA
	VALUES (1632,
	1608,
	0,
	1630,
	1631);
INSERT INTO O_RTIDA
	VALUES (1633,
	1608,
	0,
	1630,
	1631);
INSERT INTO R_RTO
	VALUES (1608,
	1630,
	1631,
	0);
INSERT INTO R_OIR
	VALUES (1608,
	1630,
	1631,
	0);
INSERT INTO R_FORM
	VALUES (1619,
	1630,
	1634,
	1,
	1,
	'is aliased by');
INSERT INTO R_RGO
	VALUES (1619,
	1630,
	1634);
INSERT INTO R_OIR
	VALUES (1619,
	1630,
	1634,
	0);
INSERT INTO R_SIMP
	VALUES (1635);
INSERT INTO R_REL
	VALUES (1635,
	528,
	'CrossComponent:true',
	1478);
INSERT INTO R_PART
	VALUES (1483,
	1635,
	1636,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (1637,
	1483,
	0,
	1635,
	1636);
INSERT INTO R_RTO
	VALUES (1483,
	1635,
	1636,
	0);
INSERT INTO R_OIR
	VALUES (1483,
	1635,
	1636,
	1482);
INSERT INTO R_FORM
	VALUES (1623,
	1635,
	1638,
	0,
	1,
	'');
INSERT INTO R_RGO
	VALUES (1623,
	1635,
	1638);
INSERT INTO R_OIR
	VALUES (1623,
	1635,
	1638,
	0);
INSERT INTO R_SIMP
	VALUES (1639);
INSERT INTO R_REL
	VALUES (1639,
	529,
	'CrossComponent:true',
	1478);
INSERT INTO R_PART
	VALUES (1485,
	1639,
	1640,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (1641,
	1485,
	0,
	1639,
	1640);
INSERT INTO R_RTO
	VALUES (1485,
	1639,
	1640,
	0);
INSERT INTO R_OIR
	VALUES (1485,
	1639,
	1640,
	1484);
INSERT INTO R_FORM
	VALUES (1623,
	1639,
	1642,
	0,
	1,
	'');
INSERT INTO R_RGO
	VALUES (1623,
	1639,
	1642);
INSERT INTO R_OIR
	VALUES (1623,
	1639,
	1642,
	0);
INSERT INTO R_SIMP
	VALUES (1643);
INSERT INTO R_REL
	VALUES (1643,
	530,
	'',
	1478);
INSERT INTO R_FORM
	VALUES (1555,
	1643,
	1644,
	0,
	1,
	'houses action for');
INSERT INTO R_RGO
	VALUES (1555,
	1643,
	1644);
INSERT INTO R_OIR
	VALUES (1555,
	1643,
	1644,
	0);
INSERT INTO R_PART
	VALUES (1509,
	1643,
	1645,
	0,
	0,
	'');
INSERT INTO O_RTIDA
	VALUES (1511,
	1509,
	0,
	1643,
	1645);
INSERT INTO O_RTIDA
	VALUES (1512,
	1509,
	0,
	1643,
	1645);
INSERT INTO R_RTO
	VALUES (1509,
	1643,
	1645,
	0);
INSERT INTO R_OIR
	VALUES (1509,
	1643,
	1645,
	0);
INSERT INTO R_SIMP
	VALUES (1646);
INSERT INTO R_REL
	VALUES (1646,
	531,
	'',
	1478);
INSERT INTO R_PART
	VALUES (52,
	1646,
	1647,
	0,
	1,
	'specifies occurrences of');
INSERT INTO O_RTIDA
	VALUES (276,
	52,
	0,
	1646,
	1647);
INSERT INTO O_RTIDA
	VALUES (277,
	52,
	0,
	1646,
	1647);
INSERT INTO R_RTO
	VALUES (52,
	1646,
	1647,
	0);
INSERT INTO R_OIR
	VALUES (52,
	1646,
	1647,
	0);
INSERT INTO R_FORM
	VALUES (59,
	1646,
	1648,
	1,
	1,
	'may have');
INSERT INTO R_RGO
	VALUES (59,
	1646,
	1648);
INSERT INTO R_OIR
	VALUES (59,
	1646,
	1648,
	1486);
INSERT INTO R_SIMP
	VALUES (1649);
INSERT INTO R_REL
	VALUES (1649,
	532,
	'',
	1478);
INSERT INTO R_PART
	VALUES (1488,
	1649,
	1650,
	0,
	0,
	'carried by');
INSERT INTO O_RTIDA
	VALUES (1604,
	1488,
	0,
	1649,
	1650);
INSERT INTO R_RTO
	VALUES (1488,
	1649,
	1650,
	0);
INSERT INTO R_OIR
	VALUES (1488,
	1649,
	1650,
	0);
INSERT INTO R_FORM
	VALUES (52,
	1649,
	1651,
	1,
	1,
	'carries');
INSERT INTO R_RGO
	VALUES (52,
	1649,
	1651);
INSERT INTO R_OIR
	VALUES (52,
	1649,
	1651,
	0);
INSERT INTO R_SIMP
	VALUES (1652);
INSERT INTO R_REL
	VALUES (1652,
	533,
	'',
	1478);
INSERT INTO R_PART
	VALUES (52,
	1652,
	1653,
	0,
	1,
	'succeeds');
INSERT INTO O_RTIDA
	VALUES (276,
	52,
	0,
	1652,
	1653);
INSERT INTO O_RTIDA
	VALUES (277,
	52,
	0,
	1652,
	1653);
INSERT INTO R_RTO
	VALUES (52,
	1652,
	1653,
	0);
INSERT INTO R_OIR
	VALUES (52,
	1652,
	1653,
	0);
INSERT INTO R_FORM
	VALUES (52,
	1652,
	1654,
	0,
	1,
	'precedes');
INSERT INTO R_RGO
	VALUES (52,
	1652,
	1654);
INSERT INTO R_OIR
	VALUES (52,
	1652,
	1654,
	0);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (1555,
	'Transition Action Home',
	529,
	'SM_TAH',
	'',
	1478);
INSERT INTO O_TFR
	VALUES (1655,
	1555,
	'dispose',
	'',
	19,
	1,
	'// Note: let SM_AH.dispose call this
select one trans related by self->SM_TXN[R530];
unrelate self from trans across R530;
select one ah related by self->SM_AH[R513];
unrelate self from ah across R513;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (1555,
	1549,
	0,
	1551,
	1548,
	1556,
	1550,
	1656,
	1657,
	0,
	0,
	'',
	'Action Home',
	'Act_ID',
	'R513');
INSERT INTO O_RATTR
	VALUES (1656,
	1555,
	1562,
	1559,
	1,
	'Act_ID');
INSERT INTO O_ATTR
	VALUES (1656,
	1555,
	0,
	'Act_ID',
	'',
	'',
	'Act_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1555,
	1549,
	0,
	1552,
	1548,
	1556,
	1550,
	1658,
	1659,
	0,
	0,
	'',
	'Action Home',
	'SM_ID',
	'R513');
INSERT INTO O_REF
	VALUES (1555,
	1509,
	0,
	1512,
	1643,
	1644,
	1645,
	1658,
	1660,
	1659,
	0,
	'',
	'Transition',
	'SM_ID',
	'R530');
INSERT INTO O_RATTR
	VALUES (1658,
	1555,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (1658,
	1555,
	1656,
	'SM_ID',
	'',
	'',
	'SM_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1555,
	1509,
	0,
	1511,
	1643,
	1644,
	1645,
	1661,
	1662,
	0,
	0,
	'',
	'Transition',
	'Trans_ID',
	'R530');
INSERT INTO O_RATTR
	VALUES (1661,
	1555,
	1511,
	1509,
	1,
	'Trans_ID');
INSERT INTO O_ATTR
	VALUES (1661,
	1555,
	1658,
	'Trans_ID',
	'',
	'',
	'Trans_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	1555);
INSERT INTO O_OIDA
	VALUES (1656,
	1555,
	0,
	'Act_ID');
INSERT INTO O_OIDA
	VALUES (1658,
	1555,
	0,
	'SM_ID');
INSERT INTO O_ID
	VALUES (1,
	1555);
INSERT INTO O_ID
	VALUES (2,
	1555);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (1509,
	'Transition',
	508,
	'SM_TXN',
	'A transition represents a change in state of an instance.  It is represented by a line between to states (SM_NETXN and SM_NSTXN), or a line into a single state (SM_CRTXN).  Transitions are labeled with a single event (SM_EVT).',
	1478);
INSERT INTO O_TFR
	VALUES (1663,
	1509,
	'get_connector_text',
	'Returns the empty string for all ends except the Middle. In this case,
it selects the subtype and delegates the call.
-----------------------------------------------------------------------------------
Bridge:GD
',
	322,
	1,
	'result = "";
if (param.at == End::Middle)
  select one nst related by self->SM_NSTXN[R507];
  if (not_empty nst)
    result = nst.get_connector_text();
  end if;
  select one net related by self->SM_NETXN[R507];
  if (not_empty net)
    result = net.get_connector_text();
  end if;
  select one action related by self->SM_TAH[R530]->SM_AH[R513]->SM_ACT[R514];
  if not_empty action and action.Action_Semantics != ""
    result = result + "/";
    if PREF::getBoolean(name:"bridgepoint_prefs_show_transition_actions")
      result = result + GD::newline() + action.Action_Semantics;
    else
      result = result + "...";
    end if;
  end if;
end if;
return result;',
	1,
	'',
	1664);
INSERT INTO O_TPARM
	VALUES (1665,
	1663,
	'OOA_ID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (1666,
	1663,
	'OOA_TypeIsImportedClass',
	316,
	0,
	'',
	1665,
	'');
INSERT INTO O_TPARM
	VALUES (1667,
	1663,
	'at',
	880,
	0,
	'',
	1666,
	'');
INSERT INTO O_TPARM
	VALUES (1668,
	1663,
	'parent_ID',
	296,
	0,
	'',
	1667,
	'');
INSERT INTO O_TFR
	VALUES (1669,
	1509,
	'get_style',
	'Most Transitions have an arrow at the end and no adornment at the
start. The exception is the Creation Transition which has it''s own
get_style operation, called from here when necessary.
-----------------------------------------------------------------------------------
Bridge:GD',
	784,
	1,
	'select one crt related by self->SM_CRTXN[R507];
if (not_empty crt)
  return crt.get_style(at:param.at);
else
  if (param.at == End::End)
    return Style::OpenArrow;
  else
    return Style::None;
  end if;
end if;',
	1,
	'',
	1670);
INSERT INTO O_TPARM
	VALUES (1671,
	1669,
	'at',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1664,
	1509,
	'dispose',
	'Dispose this Transition.',
	19,
	1,
	'select one nstxn related by self->SM_NSTXN[R507];
if (not_empty nstxn)
  select one sig related by nstxn->SM_SEME[R504]->SM_SEVT[R503]->SM_SGEVT[R526];
  if (not_empty sig)
    self.removeSignal();
  else
    // migrate to a No Event Transition (SM_NETXN)
    // which will be deleted below
    self.removeEvent();
  end if;
end if;
                                   
select one crtxn related by self->SM_CRTXN[R507];
if (not_empty crtxn)
  self.removeEvent();
  unrelate self from crtxn across R507;
  delete object instance crtxn;
end if; 
select one netxn related by self->SM_NETXN[R507];
if (not_empty netxn)
  unrelate self from netxn across R507;
  select one state related by netxn->SM_STATE[R508];
  unrelate netxn from state across R508;
  delete object instance netxn;
end if;
                                   
select one sm related by self->SM_SM[R505];
unrelate self from sm across R505;
select one state related by self->SM_STATE[R506];
unrelate self from state across R506;
select one act related by self->SM_TAH[R530]->SM_AH[R513]->SM_ACT[R514];
if (not_empty act )
  act.dispose();
else
  // the dispose unit tests don''t populate everything
  select one meah related by self->SM_MEAH[R512];
  if ( not_empty meah )
    select one mealy related by meah->SM_MEALY[R512];
    unrelate mealy from self across R512 using meah;
  end if;
end if;
select many insts related by self->I_INS[R2953];
for each inst in insts
  unrelate self from inst across R2953;
end for;
delete object instance self;',
	1,
	'',
	1672);
INSERT INTO O_TFR
	VALUES (1670,
	1509,
	'get_ooa_id',
	'The ooa_id of a Transition is its Trans_ID
-----------------------------------------------------------
Bridge:GD',
	296,
	1,
	'return self.Trans_ID;',
	1,
	'',
	1673);
INSERT INTO O_TFR
	VALUES (1674,
	1509,
	'actionFilter',
	'Bridge: UI
',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
if (param.name == "event" )
  
  if (param.value == "exists spec pkg" ) or (param.value == "exists generic pkg" )
  
    select one cls related by self->SM_SM[R505]->SM_ASM[R517]->O_OBJ[R519];
    if (empty cls)
      select one cls related by self->SM_SM[R505]->SM_ISM[R517]->O_OBJ[R518];
    end if;
    select one packageableElem related by cls->PE_PE[R8001];
    select one package related by packageableElem->EP_PKG[R8000];
    select one cc related by packageableElem->C_C[R8003];
    isInGenericPackage = not_empty package or not_empty cc;
    if ((param.value == "exists spec pkg") and (isInGenericPackage))
      return false;
    end if;
    if ((param.value == "exists generic pkg") and (not isInGenericPackage))
      return false;
    end if;
      
    // might want to enforce data set consistency here
    // i.e. events only exist if they match the state''s data set
    select one net related by self->SM_NETXN[R507];
    select one nst related by self->SM_NSTXN[R507];
    select one ct related by self->SM_CRTXN[R507];
    select one stateMachine related by self->SM_SM[R505];
    select many selfTypeEvents related by stateMachine->SM_EVT[R502];
    
	// if this transition belongs to an instance state machine, and is not
	// a creation transition
	select one instanceStateMachine related by stateMachine->SM_ISM[R517];
	numSupertypeEvents = 0;
	numSelfTypeEvents = cardinality selfTypeEvents;
	if (not_empty instanceStateMachine and empty ct)
		// for each event in the domain
		select many events from instances of SM_EVT;
		for each event in events
			// if this event does not belong to this transition''s state machine,
			// but is assignable to this transition''s state machine
			if (event.SM_ID != self.SM_ID 
				and event.isAssignableToStateMachine(
					assignToMachineId:self.SM_ID, isCreationTransition:false))
				// there is one more supertype event which might possibly
				// be assigned to this transition
				numSupertypeEvents = numSupertypeEvents + 1;
			end if;
		end for;	
		
		// for each event that belongs to this transition''s state machine
	    select many events related by stateMachine->SM_EVT[R502]; 
		for each event in events
			// if this event is assigned in a subtype state machine
			if (event.isAssignedInSubtypeStateMachine(
				supertypeId:instanceStateMachine.Obj_ID))
				// there is one less self-type event which might possibly
				// be assigned to this transition 			
				numSelfTypeEvents = numSelfTypeEvents - 1;
			end if;
		end for;
    else	
      select many events related by stateMachine->SM_EVT[R502]; 
	  for each event in events
	    // if this event is a signal event
	    select one sigEvt related by event->SM_SEVT[R525]->SM_SGEVT[R526];
	    if not_empty sigEvt
          // there is one less self-type event which might possibly
          // be assigned to this transition 			
          numSelfTypeEvents = numSelfTypeEvents - 1;
		end if;
	  end for;
	end if;

    if (not_empty net)
      select one state related by net->SM_STATE[R508];
      select many newStateTransitions related by state->
                                                  SM_SEME[R503]->SM_NSTXN[R504];
      // We discounted signals above, so we need to
      // discount transitions with signals here.
      select many signalDrivers related by newStateTransitions->
                                   SM_SEME[R504]->SM_SEVT[R503]->SM_SGEVT[R526];
      eventDrivenNewStateTransitions = cardinality newStateTransitions -
                                                      cardinality signalDrivers;
      return numSelfTypeEvents + numSupertypeEvents >
                                                 eventDrivenNewStateTransitions;
    elif (not_empty nst)
      select one state related by nst->SM_SEME[R504]->SM_STATE[R503];    
      select many newStateTransitions related by state->
                                                  SM_SEME[R503]->SM_NSTXN[R504];
      // discount signal driven transitions.
      select many signalDrivers related by newStateTransitions->
                                   SM_SEME[R504]->SM_SEVT[R503]->SM_SGEVT[R526];
      eventDrivenNewStateTransitions = cardinality newStateTransitions -
                                                      cardinality signalDrivers;
      return numSelfTypeEvents + numSupertypeEvents >
                                                 eventDrivenNewStateTransitions;
    elif (not_empty ct)
      select one state related by self->SM_STATE[R506];          
      select many creationTransitionsAssigned related by selfTypeEvents
      	                         ->SM_SEVT[R525]->SM_LEVT[R526]->SM_CRTXN[R509];
      return numSelfTypeEvents > cardinality creationTransitionsAssigned;
    end if;  

  elif (param.value == "assigned" )
    select one levt related by self->SM_NSTXN[R507]->SM_SEME[R504]->
                                                   SM_SEVT[R503]->SM_LEVT[R526];
    if empty levt
      select one levt related by self->SM_CRTXN[R507]->SM_LEVT[R509];
    end if;
    return not_empty levt;
  end if;
elif param.name == "signal"
  if (param.value == "exists spec pkg") or (param.value == "exists generic pkg") 
    select one cls related by self->SM_SM[R505]->SM_ASM[R517]->O_OBJ[R519];
    if (empty cls)
      select one cls related by self->SM_SM[R505]->SM_ISM[R517]->O_OBJ[R518];
    end if;
    select one packageableElem related by cls->PE_PE[R8001];
    select one package related by packageableElem->EP_PKG[R8000];
    // Currently component will always be null, but this may change
    select one component related by packageableElem->C_C[R8003];
    if not_empty package
      compId = package.getContainingComponentId();
      select any component from instances of C_C where (selected.Id == compId);
    end if;
    isInGenericPackage = not_empty package or not_empty component;
    // if there is no containing component, then this action should be
    // filtered
    if(isInGenericPackage and empty component)
      return false;
    end if;
    if ((param.value == "exists spec pkg") and (isInGenericPackage))
      return false;
    end if;
    if ((param.value == "exists generic pkg") and (not isInGenericPackage))
      return false;
    end if;
      
    if (not isInGenericPackage)   
      select one component related by self->SM_SM[R505]->SM_ASM[R517]->
                     O_OBJ[R519]->S_SS[R2]->S_DOM[R1]->CN_DC[R4204]->C_C[R4204];
    end if;
      
    select many provisions related by component->
                                           C_PO[R4010]->C_IR[R4016]->C_P[R4009];
    for each provision in provisions
      if provision.hasAvailableSignalsFor(transition_id:self.Trans_ID)
        return true;
      end if;
    end for;
    select many requirements related by component->
                                           C_PO[R4010]->C_IR[R4016]->C_R[R4009];
    for each requirement in requirements
      if requirement.hasAvailableSignalsFor(transition_id:self.Trans_ID)
        return true;
      end if;
    end for;
  elif param.value == "assigned"
    select one sgEvt related by self->SM_NSTXN[R507]->SM_SEME[R504]->
                                                  SM_SEVT[R503]->SM_SGEVT[R526];
    return not_empty sgEvt;
  end if;
end if;
return false;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (1675,
	1674,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (1676,
	1674,
	'value',
	322,
	0,
	'',
	1675,
	'');
INSERT INTO O_TFR
	VALUES (1677,
	1509,
	'addEvent',
	'',
	19,
	1,
	'// find the event corresponding to the one given that is associated with 
// this transition''s state machine, which in fact may be the one given, or not
// if the given event is polymorphic
select any event from instances of SM_EVT 
	where selected.SMevt_ID == param.eventId
		and selected.SM_ID == param.eventStateMachineId;
select one sm related by self->SM_SM[R505];
eventId = event.getAssociatedEventForStateMachine(stateMachineId:sm.SM_ID);
select any event from instances of SM_EVT where selected.SMevt_ID == eventId;
 		
 select one no_evt_txn related by self->SM_NETXN[R507];
 if ( not_empty no_evt_txn )
   select one orig_state related by no_evt_txn->SM_STATE[R508];
   unrelate no_evt_txn from orig_state across R508;
   unrelate no_evt_txn from self across R507;
   delete object instance no_evt_txn;
   create object instance ns_txn of SM_NSTXN;
   relate self to ns_txn across R507;
   
   select any seme related by orig_state->SM_SEME[R503] 
       where selected.SMevt_ID == event.SMevt_ID;
   seme.disposeChOrEi();
   relate ns_txn to seme across R504;
 else
   select one ns_txn related by self->SM_NSTXN[R507];
   if ( not_empty ns_txn )
     select one seme related by ns_txn->SM_SEME[R504];
     select one orig_state related by seme->SM_STATE[R503];

	 // change SEME caused by old event to be cant happen
	 create object instance ch of SM_CH;
     unrelate ns_txn from seme across R504;
     relate seme to ch across R504;
     
     // find SEME caused by new event
     select any new_seme related by orig_state->SM_SEME[R503] 
         where selected.SMevt_ID == event.SMevt_ID;
     new_seme.disposeChOrEi();
     relate new_seme to ns_txn across R504;
     // state supplemental dataset should be unchanged
   else
     select one cr_txn related by self->SM_CRTXN[R507];
     select one levt related by cr_txn->SM_LEVT[R509];
     if ( not_empty levt )
       unrelate cr_txn from levt across R509;
     end if;
     select one new_evt related by event->SM_SEVT[R525]->SM_LEVT[R526];         
     relate cr_txn to new_evt across R509;
   end if;
 end if;

',
	1,
	'',
	1674);
INSERT INTO O_TPARM
	VALUES (1678,
	1677,
	'eventId',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (1679,
	1677,
	'eventStateMachineId',
	296,
	0,
	'',
	1678,
	'');
INSERT INTO O_TFR
	VALUES (1680,
	1509,
	'removeEvent',
	'',
	19,
	1,
	'select one ns_txn related by self->SM_NSTXN[R507];
if ( not_empty ns_txn )
 
  select one seme related by ns_txn->SM_SEME[R504];
  create object instance ch of SM_CH;
  unrelate ns_txn from seme across R504;
  relate seme to ch across R504;

  create object instance ne_txn of SM_NETXN;
  unrelate ns_txn from self across R507;
  relate self to ne_txn across R507;
  delete object instance ns_txn;
  select one orig_state related by seme->SM_STATE[R503];
  relate ne_txn to orig_state across R508;
  select one dest_state related by self->SM_STATE[R506];
else
  select one cr_txn related by self->SM_CRTXN[R507];
  select one levt related by cr_txn->SM_LEVT[R509];
  if ( not_empty levt )
    unrelate cr_txn from levt across R509;
    select one st related by self->SM_STATE[R506];
  else
    // transition doesn''t have an event assigned -- UI prevents this from happening
  end if;
end if;',
	1,
	'',
	1681);
INSERT INTO O_TFR
	VALUES (1682,
	1509,
	'updateAssignedEvent',
	'',
	19,
	1,
	'// Transition.updateAssignedEvent()
select one stateMachine related by self->SM_SM[R505];
select one evt related by self->SM_NSTXN[R507]->SM_SEME[R504]->
                                                    SM_SEVT[R503]->SM_EVT[R525];
select one sm related by self->SM_SM[R505];
select one creationTrans related by self->SM_CRTXN[R507];
select any polyClass from instances of O_OBJ where
                                        selected.Obj_ID == GD::NULL_UNIQUE_ID();
isPoly = false;
if(not_empty evt)
  // if the copied event is a poly, convert it to a local event
  select one nlevt related by evt->SM_SEVT[R525]->SM_NLEVT[R526];
  if(not_empty nlevt)
    isPoly = true;
  end if;
end if;
creation = false;
if(not_empty creationTrans)
  creation = true;
  select one evt related by creationTrans->SM_LEVT[R509]->
                                                    SM_SEVT[R526]->SM_EVT[R525];
end if;
// there was no event previously assigned, nothing to do.
if(empty evt)
  return;
end if;
select many dataItems related by evt->SM_EVTDI[R532];
eventID = sm.findMatchingEvent(id:evt.SMevt_ID,
                                       isCreation:creation, machineID:sm.SM_ID);
select any existingEvt related by sm->SM_EVT[R502] where
                                                   selected.SMevt_ID == eventID;
if not_empty existingEvt
  // remove the currently assigned event
  self.removeEvent();
  // if a match was found then
  //   - remove any pasted data items already assigned to the existing event.
  //   - move any new data items to the existing event and
  //   - dispose the pasted event instance.
  warnings = ""; sep = "";
  for each dataItem in dataItems
    select one pastedDIDatatype related by dataItem->S_DT[R524];
    select any existingDataItem related by existingEvt->SM_EVTDI[R532] where
                                                 selected.Name == dataItem.Name;
    select one existingDIDatatype related by existingDataItem->S_DT[R524];
    if not_empty existingDataItem and
                  existingDIDatatype.Name == pastedDIDatatype.Name and
                         OS::remove_spaces(s:existingDataItem.Dimensions) ==
                                        OS::remove_spaces(s:dataItem.Dimensions)
      dataItem.dispose();
    else
      // Report that event parameters were added to the target
      if empty existingDataItem 
        warnings = warnings + sep + "Event parameter " + dataItem.Name +
                                                                   " was added";
      else  // not_empty existingDataItem and
        warnType = "";
        if existingDIDatatype.Name != pastedDIDatatype.Name
          // Report that an added event parameter type conflict exists
          warnType = " a type conflict ";
        else
          // Report that a dimension declaration incompatibility exists
          warnType = " an array incompatibility ";
        end if;
        warnings = warnings + sep + "An existing event parameter " +
        dataItem.Name + " was found, but has" + warnType + "with the pasted " +
        "parameter. The paste has been executed as an additional parameter " +
        "with the same name. You will need to combine the two parameters or " +
        "rename one.";
      end if;
      sep = ", ";
      unrelate dataItem from evt across R532;
      relate dataItem to existingEvt across R532;
      select one pasteSM related by dataItem->SM_SM[R516];
      if not_empty pasteSM
        unrelate dataItem from pasteSM across R516;
      end if;
      relate dataItem to sm across R516;
    end if;
  end for;
  if warnings != ""
    // we must relate the event to the state machine to allow for the
    // get_name operation to work correctly for the error report.
    select one pasteSM related by evt->SM_SM[R502];
    if empty pasteSM
      relate evt to sm across R502;
    end if;
    Util::addPastedElementToProblemList(elementName:evt.get_name(),
      		                                                  message:warnings);
  end if;
  evt.dispose();
  // and now associate the pasted transition with the match
  self.addEvent(eventId:existingEvt.SMevt_ID, eventStateMachineId:sm.SM_ID);
else // existing event was not found in this state machine
  // if the copied event is a polymorphic event and we didn''t find
  // a match above we need to try and find a matching one within
  // the hierarchy
  relateToSM = true;
  if(isPoly)
    polyId = self.locateMatchingPolymorphicEvent(id:evt.SMevt_ID);
    if(polyId != GD::NULL_UNIQUE_ID())
      select any polyEvt from instances of SM_EVT where
                                                    selected.SMevt_ID == polyId;
      if(not_empty polyEvt)
        select one poly related by polyEvt->SM_PEVT[R525];
        if(empty poly)
          // the instance will not exist unless another
          // transition has the poly assigned so we create
          // it here
          create object instance poly of SM_PEVT;
          select one matrixEvent related by polyEvt->SM_SEVT[R525];
          matrixEvent.dispose();
          relate poly to polyEvt across R525;
        end if;
        select one nlevt related by evt->SM_SEVT[R525]->SM_NLEVT[R526];
        relate nlevt to poly across R527;
      else
        evt.dispose();
        relateToSM = false;
      end if;
    else
      // we must relate the event to the state machine to allow for the
      // get_name operation to work correctly for the error report.
      relate evt to sm across R502;
      message = ::getMissingInheritedEventMessage(missingInheritedEvent:false);
      Util::addPastedElementToProblemList(elementName:evt.get_name(),
      		message:message);
      evt.dispose();
      relateToSM = false;
    end if;
  end if;
  if(relateToSM)
    // otherwise hook up the copied event and data items if any
    relate evt to sm across R502;
    for each dataItem in dataItems
      relate dataItem to sm across R516;
    end for;
    select one sevt related by evt->SM_SEVT[R525];
    if not_empty sevt
      // create SEM entry instances
      //
      select many states related by sm->SM_STATE[R501];
      for each state in states
        select any existingEvt related by state->SM_SEME[R503]->
              SM_SEVT[R503]->SM_EVT[R525] where selected.Drv_Lbl == evt.Drv_Lbl;
        if empty existingEvt
          create object instance seme of SM_SEME;
          relate sevt to state across R503 using seme;
        end if;
      end for;
    else
      pathMsg = "<No Path Available - Empty instance>";
    if (not_empty stateMachine)
      pathMsg = stateMachine.getPath();
    end if;
	USER::logError(msg:"Internal Error in updateAssignedEvent:" +
               " No State Event Matrix Event instance found for pasted event.",path:pathMsg);
    end if;
    // guarantee a unique number for the event
    evt.setUniqueNumber(checkForDuplicate:true);
  end if;
end if;',
	1,
	'',
	1683);
INSERT INTO O_TFR
	VALUES (1681,
	1509,
	'locateMatchingPolymorphicEvent',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
/*
Recursively checks the hierarchy tree, to find a polymorpic event that
matches the copied polymorphic event.
*/
select one stateMachine related by self->SM_SM[R505];
select one asm related by self->SM_SM[R505]->SM_ASM[R517];
isClassBased = not_empty asm;
select one mclass related by asm->O_OBJ[R519];
if(empty mclass)
  select one mclass related by self->SM_SM[R505]->SM_ISM[R517]->O_OBJ[R518];
end if;
select many machines related by mclass->S_SS[R2]->S_DOM[R1]->S_SS[R1]
     ->O_OBJ[R2]->SM_ISM[R518]->SM_SM[R517];
if(isClassBased)
  select many machines related by mclass->S_SS[R2]->S_DOM[R1]->S_SS[R1]
     ->O_OBJ[R2]->SM_ASM[R519]->SM_SM[R517];  
end if;

select one packageableElem related by mclass->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;
if (isInGenericPackage)
  if (not_empty package)
    select many machines related by package->S_SYS[R1405]->EP_PKG[R1405]->PE_PE[R8000]->O_OBJ[R8001]
           ->SM_ASM[R519]->SM_SM[R517];
  else
    rootCompIdInPkg = component.getRootComponentId();
    select any rootComponent from instances of C_C where (selected.Id == rootCompIdInPkg);
    select many machines related by rootComponent->PE_PE[R8001]->EP_PKG[R8000]
           ->S_SYS[R1405]->EP_PKG[R1405]->PE_PE[R8000]->O_OBJ[R8001]->SM_ASM[R519]->SM_SM[R517];
  end if;
end if;
select many events related by machines->SM_EVT[R502];
select one copiedEvt related by self->SM_NSTXN[R507]->SM_SEME[R504]->SM_SEVT[R503]->SM_EVT[R525];
// for all of the possible events see if any match
for each evt in events
  // ignore the copied event
  if(copiedEvt == evt)
    continue;
  end if;
  // do not look for non-local events
  select one nlevt related by evt->SM_SEVT[R525]->SM_NLEVT[R526];
  if(not_empty nlevt)
    continue;
  end if;
  // do not use any event that is within the same machine
  select one sm related by evt->SM_SM[R502];
  if(sm == stateMachine)
    continue;
  end if;
  if(stateMachine.canAssignEvent(eventId:evt.SMevt_ID, eventStateMachineId:evt.SM_ID, isCreationTransition:false))
    eventID = sm.findMatchingEvent(id:copiedEvt.SMevt_ID, isCreation:false, machineID:stateMachine.SM_ID);
    if(eventID != GD::NULL_UNIQUE_ID())
      return eventID;
    end if;
  end if;
end for;
return GD::NULL_UNIQUE_ID();',
	1,
	'',
	1684);
INSERT INTO O_TPARM
	VALUES (1685,
	1681,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1672,
	1509,
	'addSignal',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// find the signal for the passed id
select any signal related by self->SM_SM[R505]->SM_ASM[R517]->O_OBJ[R519]->
                 S_SS[R2]->S_DOM[R1]->CN_DC[R4204]->C_C[R4204]->C_PO[R4010]->
                                           C_IR[R4016]->C_I[R4012]->C_EP[R4003]
                                          where(selected.Id == param.signal_id);
// check for isInGenericPackage
if (empty signal)
  select one pe related by self->SM_SM[R505]->SM_ASM[R517]->O_OBJ[R519]
                                                                 ->PE_PE[R8001];
  if(not_empty pe)
    select one package related by pe->EP_PKG[R8000];
    // the next call can return a null id, however
    // the UI code will prevent us from ever getting
    // here unless a container component exists
    compId = package.getContainingComponentId();
    select any component from instances of C_C where (selected.Id == compId);
    if(not_empty component)
      select any signal related by component->C_PO[R4010]->C_IR[R4016]
               ->C_I[R4012]->C_EP[R4003] where (selected.Id == param.signal_id);
    end if;
  end if;
end if;                                          
select any reqEP related by signal->SPR_REP[R4500]
                     where (selected.ExecutableProperty_Id == param.signal_id
                             and selected.Requirement_Id == param.interface_id);
select one reqSignal related by reqEP->SPR_RS[R4502];
select any provEP related by signal->SPR_PEP[R4501]
                     where (selected.ExecutableProperty_Id == param.signal_id
                               and selected.Provision_Id == param.interface_id);
select one provSignal related by provEP->SPR_PS[R4503];
select one sm related by self->SM_SM[R505];
select one signalEvent related by provSignal->SM_SGEVT[R528];
if empty signalEvent
  select one signalEvent related by reqSignal->SM_SGEVT[R529];
end if;
if empty signalEvent
  create object instance signalEvent of SM_SGEVT;
  create object instance semEvt of SM_SEVT;
  relate semEvt to signalEvent across R526;
  name = "";
  if not_empty provSignal
    relate signalEvent to provSignal across R528;
    name = provSignal.Name;
  else
    relate signalEvent to reqSignal across R529;
    name = reqSignal.Name;
  end if;
  create object instance evt of SM_EVT;
  relate evt to semEvt across R525;
  relate evt to sm across R502;
  evt.Mning = name;
  evt.Numb = 1;
  evt.setUniqueNumber(checkForDuplicate:false);
  semEvt.createDefaultMatrixEntries();
end if;
select one no_evt_txn related by self->SM_NETXN[R507];
if ( not_empty no_evt_txn )
  select one orig_state related by no_evt_txn->SM_STATE[R508];
  unrelate no_evt_txn from orig_state across R508;
  unrelate no_evt_txn from self across R507;
  delete object instance no_evt_txn;
  create object instance ns_txn of SM_NSTXN;
  relate self to ns_txn across R507;
  select any seme related by orig_state->SM_SEME[R503]
                                where selected.SMevt_ID == signalEvent.SMevt_ID;
  seme.disposeChOrEi();
  relate ns_txn to seme across R504;
else
  select one ns_txn related by self->SM_NSTXN[R507];
  if ( not_empty ns_txn )
    select one seme related by ns_txn->SM_SEME[R504];
    select one orig_state related by seme->SM_STATE[R503];
                             
    // change SEME caused by old event to be cant happen
    create object instance ch of SM_CH;
    unrelate ns_txn from seme across R504;
    relate seme to ch across R504;
                             
    // find SEME caused by new event
    select any new_seme related by orig_state->SM_SEME[R503]
                                where selected.SMevt_ID == signalEvent.SMevt_ID;
    new_seme.disposeChOrEi();
    relate new_seme to ns_txn across R504;
  end if;
end if;',
	1,
	'',
	1677);
INSERT INTO O_TPARM
	VALUES (1686,
	1672,
	'signal_id',
	296,
	0,
	'',
	1687,
	'');
INSERT INTO O_TPARM
	VALUES (1687,
	1672,
	'interface_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1683,
	1509,
	'removeSignal',
	'',
	19,
	1,
	'// Transition::removeSignal()
select one ns_txn related by self->SM_NSTXN[R507];
if ( not_empty ns_txn )
  select one seme related by ns_txn->SM_SEME[R504];
  create object instance ch of SM_CH;
  unrelate ns_txn from seme across R504;
  relate seme to ch across R504;
  create object instance ne_txn of SM_NETXN;
  unrelate ns_txn from self across R507;
  relate self to ne_txn across R507;
  delete object instance ns_txn;
  select one orig_state related by seme->SM_STATE[R503];
  relate ne_txn to orig_state across R508;
  select one sevt related by seme->SM_SEVT[R503];
  select many chs related by sevt->SM_SEME[R503]->SM_CH[R504];
  select many states related by sevt->SM_STATE[R503];
  if cardinality chs == cardinality states
    // There are no consumers of this signal left, dispose it.
    select one evt related by sevt->SM_EVT[R525];
    evt.dispose();    
  end if;
end if;',
	1,
	'',
	1680);
INSERT INTO O_TFR
	VALUES (1684,
	1509,
	'initialize',
	'',
	19,
	1,
	'// Transition.initialize()
// Create the action home
create object instance ah of SM_AH;
create object instance tah of SM_TAH;
relate ah to tah across R513;
select one sm related by self->SM_SM[R505];  
create object instance act of SM_ACT;
act.Suc_Pars = ParseStatus::parseInitial;
relate act to ah across R514;
relate act to sm across R515;
relate self to tah across R530;
',
	1,
	'',
	1669);
INSERT INTO O_TFR
	VALUES (1673,
	1509,
	'get_name',
	'',
	322,
	1,
	'// Transition.get_name()
result = "";
select one nst related by self->SM_NSTXN[R507];
if not_empty nst
  result = nst.get_name();
end if;
select one net related by self->SM_NETXN[R507];
if not_empty net
  result = net.get_connector_text();
end if;
select one ctxn related by self->SM_CRTXN[R507];
if(not_empty ctxn)
  select one evt related by ctxn->SM_LEVT[R509]->SM_SEVT[R526]
                                                                                              ->SM_EVT[R525];
  if(not_empty evt)
    result = evt.get_event_text();
  else
    result = "No Event Assigned";
  end if;
end if;
return result;',
	1,
	'',
	1663);
INSERT INTO O_TFR
	VALUES (1688,
	1509,
	'updateAssignedSignal',
	'',
	19,
	1,
	'select one evt related by self->SM_NSTXN[R507]->SM_SEME[R504]->SM_SEVT[R503];
select one machine related by self->SM_SM[R505];
// note the selection from instances of will work below as we are contained in
// the same model root as the component
componentId = machine.getContainingComponentId();
select any component from instances of C_C where (selected.Id == componentId);
if(not_empty component)
  select one signalEvt related by evt->SM_SGEVT[R526];
  select one proSignal related by signalEvt->SPR_PS[R528];
  select many interfaces related by component->C_PO[R4010]->C_IR[R4016]
                                                                   ->C_I[R4012];
  if(not_empty proSignal and Util::isProxy(element:proSignal.convertToInstance()))
    signalId = self.locateMatchingProvidedSignal();
    select any matchingSignal related by interfaces->C_EP[R4003]
                ->SPR_PEP[R4501]->SPR_PS[R4503] where (selected.Id == signalId);
    if(not_empty matchingSignal)
      self.removeSignal();
      select one pep related by matchingSignal->SPR_PEP[R4503];
      self.addSignal(interface_id: pep.Provision_Id,
                                          signal_id: pep.ExecutableProperty_Id);
    else
      // look for a matching required signal
      signalId = self.locateMatchingRequiredSignal();
      select any matchingReqSignal related by interfaces->C_EP[R4003]
                ->SPR_REP[R4500]->SPR_RS[R4502] where (selected.Id == signalId);
      if(not_empty matchingReqSignal)
        self.removeSignal();
        select one rep related by matchingReqSignal->SPR_REP[R4502];
        self.addSignal(interface_id: rep.Requirement_Id,
                                          signal_id: rep.ExecutableProperty_Id);
      else
        // indicate to the user that no matching signal was
        // found in the destination
        message = "Matching signals for the following were not found in the ";
        message = message + "destination.";
        Util::addPastedElementToProblemList(
                      elementName:signalEvt.get_event_text(), message: message);
        self.removeSignal();
      end if;
    end if;
  end if;
  select one reqSignal related by signalEvt->SPR_RS[R529];
  if(not_empty reqSignal and Util::isProxy(element:reqSignal.convertToInstance()))
    signalId = self.locateMatchingRequiredSignal();
    select any matchingSignal related by interfaces->C_EP[R4003]
                ->SPR_REP[R4500]->SPR_RS[R4502] where (selected.Id == signalId);
    if(not_empty matchingSignal)
      self.removeSignal();
      select one rep related by matchingSignal->SPR_REP[R4502];
      self.addSignal(interface_id: rep.Requirement_Id,
                                          signal_id: rep.ExecutableProperty_Id);
    else
      // look for a matching provided signal
      signalId = self.locateMatchingProvidedSignal();
      select any matchingProSignal related by interfaces->C_EP[R4003]
                ->SPR_PEP[R4501]->SPR_PS[R4503] where (selected.Id == signalId);
      if(not_empty matchingProSignal)
        self.removeSignal();
        select one pep related by matchingProSignal->SPR_PEP[R4503];
        self.addSignal(interface_id: pep.Provision_Id,
                                          signal_id: pep.ExecutableProperty_Id);
      else
        // indicate to the user that no matching signal was
        // found in the destination
        message = "Matching signals for the following were not found in the ";
        message = message + "destination.";
        Util::addPastedElementToProblemList(
                      elementName:signalEvt.get_event_text(), message: message);
        self.removeSignal();
      end if;
    end if;
  end if;
end if;',
	1,
	'',
	1682);
INSERT INTO O_TFR
	VALUES (1689,
	1509,
	'updateAssignedEventOrSignal',
	'',
	19,
	1,
	'select one creationTrans related by self->SM_CRTXN[R507];
if(not_empty creationTrans)
  self.updateAssignedEvent();
  return;
end if;
select one evt related by self->SM_NSTXN[R507]->SM_SEME[R504]->SM_SEVT[R503];
if(not_empty evt)
  select one signalEvent related by evt->SM_SGEVT[R526];
  if(not_empty signalEvent)
    self.updateAssignedSignal();
  else
    self.updateAssignedEvent();
  end if;
end if;',
	1,
	'',
	1688);
INSERT INTO O_TFR
	VALUES (1690,
	1509,
	'locateMatchingProvidedSignal',
	'',
	296,
	1,
	'select one stateMachine related by self->SM_SM[R505];
select one evt related by self->SM_NSTXN[R507]->SM_SEME[R504]->SM_SEVT[R503];
select one signalEvt related by evt->SM_SGEVT[R526];
select one proSignal related by signalEvt->SPR_PS[R528];

name = "";
direction = IFDirectionType::ClientServer;
select any ep from instances of C_EP
                                    where (selected.Id == GD::NULL_UNIQUE_ID());
if(not_empty proSignal)
  name = proSignal.Name;
  select one ep related by proSignal->SPR_PEP[R4503]->C_EP[R4501];
  select one sig related by ep->C_AS[R4004];
  direction = sig.Direction;
else
  select one reqSignal related by signalEvt->SPR_RS[R529];
  if(not_empty reqSignal)
    name = reqSignal.Name;
    direction = IFDirectionType::ClientServer;
    select one ep related by reqSignal->SPR_REP[R4502]->C_EP[R4500];
  else
    pathMsg = "<No Path Available - Empty instance>";
    if (not_empty stateMachine)
      pathMsg = stateMachine.getPath();
    end if;
	USER::logError(msg:"Signal Event had no associated signal.",path:pathMsg);
    return GD::NULL_UNIQUE_ID();
  end if;
end if;
select one machine related by self->SM_SM[R505];
// note the selection from instances of will work below as we are contained in
// the same model root as the component
componentId = machine.getContainingComponentId();
select any component from instances of C_C where (selected.Id == componentId);
select many interfaces related by component->C_PO[R4010]->C_IR[R4016]
                                                                   ->C_I[R4012];
select many testParameters related by ep->C_PP[R4006];
select any matchingSignal from instances of SPR_PS
                                    where (selected.Id == GD::NULL_UNIQUE_ID());
select many existingProSignals related by interfaces->C_EP[R4003]
                                                ->SPR_PEP[R4501]->SPR_PS[R4503];
for each existingSignal in existingProSignals
  select one existingAS related by existingSignal->SPR_PEP[R4503]->C_EP[R4501]
                                                                  ->C_AS[R4004];
  if(existingSignal.Name == name and existingAS.Direction == direction)
    select many parameters related by existingSignal->SPR_PEP[R4503]
                                                     ->C_EP[R4501]->C_PP[R4006];
    index = 0;
    matchNotFound = false; 
    for each testParm in testParameters
      internalIndex = 0;
      select one testType related by testParm->S_DT[R4007];
      for each parameter in parameters
        if(internalIndex == index)
          // param to test
          if(testParm.Name != parameter.Name)
            matchNotFound = true;
            break;
          end if;
          select one type related by parameter->S_DT[R4007];
          if(testType.Name != type.Name)
            matchNotFound = true;
            break;
          end if;
        end if;
        internalIndex = internalIndex + 1;
      end for;
      if(matchNotFound)
        break;
      end if;
      index = index + 1;
      if(cardinality parameters < cardinality testParameters)
        // this is not OK, the existing signal will not satisfy
        // the copied signal
        matchNotFound = true;
        break;
      end if;
    end for;
    if(not matchNotFound)
      // ask the signal if it can be allocated to this
      // transition
      if(existingSignal.isAvailableForAllocationTo(transition_id:self.Trans_ID))
        matchingSignal = existingSignal;
        break;
      end if;
    end if;
  end if;
end for;
if(not_empty matchingSignal)
  return matchingSignal.Id;
else
  return GD::NULL_UNIQUE_ID();
end if;',
	1,
	'',
	1689);
INSERT INTO O_TFR
	VALUES (1691,
	1509,
	'locateMatchingRequiredSignal',
	'',
	296,
	1,
	'select one evt related by self->SM_NSTXN[R507]->SM_SEME[R504]->SM_SEVT[R503];
select one signalEvt related by evt->SM_SGEVT[R526];
select one reqSignal related by signalEvt->SPR_RS[R529];
select one machine related by self->SM_SM[R505];
name = "";
direction = IFDirectionType::ServerClient;
select any ep from instances of C_EP
                                    where (selected.Id == GD::NULL_UNIQUE_ID());
if(not_empty reqSignal)
  name = reqSignal.Name;
  select one ep related by reqSignal->SPR_REP[R4502]->C_EP[R4500];
  select one sig related by ep->C_AS[R4004];
  direction = sig.Direction;
else
  select one proSignal related by signalEvt->SPR_PS[R528];
  if(not_empty proSignal)
    name = proSignal.Name;
    direction = IFDirectionType::ServerClient;
    select one ep related by proSignal->SPR_PEP[R4503]->C_EP[R4501];
  else
    pathMsg = "<No Path Available - Empty instance>";
    if (not_empty machine)
      pathMsg = machine.getPath();
    end if;
	USER::logError(msg:"Signal Event had no associated signal.",path:pathMsg);
    return GD::NULL_UNIQUE_ID();
  end if;
end if;
// note the selection from instances of will work below as we are contained in
// the same model root as the component
componentId = machine.getContainingComponentId();
select any component from instances of C_C where (selected.Id == componentId);
select many interfaces related by component->C_PO[R4010]->C_IR[R4016]
                                                                   ->C_I[R4012];
select many testParameters related by ep->C_PP[R4006];
select any matchingSignal from instances of SPR_RS
                                    where (selected.Id == GD::NULL_UNIQUE_ID());
select many existingReqSignals related by interfaces->C_EP[R4003]
                                                ->SPR_REP[R4500]->SPR_RS[R4502];
for each existingSignal in existingReqSignals
  select one existingSigAS related by existingSignal->SPR_REP[R4502]
                                                     ->C_EP[R4500]->C_AS[R4004];
  if(existingSignal.Name == name and existingSigAS.Direction == direction)
    select many parameters related by existingSignal->SPR_REP[R4502]
                                                     ->C_EP[R4500]->C_PP[R4006];
    index = 0;
    matchNotFound = false;
    for each testParm in testParameters
      internalIndex = 0;
      select one testType related by testParm->S_DT[R4007];
      for each parameter in parameters
        if(internalIndex == index)
          // param to test
          if(testParm.Name != parameter.Name)
            matchNotFound = true;
            break;
          end if;
          select one type related by parameter->S_DT[R4007];
          if(testType.Name != type.Name)
            matchNotFound = true;
            break;
          end if;
        end if;
        internalIndex = internalIndex + 1;
      end for;
      if(matchNotFound)
        break;
      end if;
      index = index + 1;
      if(cardinality parameters < cardinality testParameters)
        // this is not OK, the existing signal will not satisfy
        // the copied signal
        matchNotFound = true;
        break;
      end if;
    end for;
    if(not matchNotFound)
      // ask the signal if it can be allocated to this
      // transition
      if(existingSignal.isAvailableForAllocationTo(transition_id:self.Trans_ID))
        matchingSignal = existingSignal;
        break;
      end if;
    end if;
  end if;
end for;
if(not_empty matchingSignal)
  return matchingSignal.Id;
else
  return GD::NULL_UNIQUE_ID();
end if; ',
	1,
	'',
	1690);
INSERT INTO O_TFR
	VALUES (1692,
	1509,
	'get_label',
	'',
	322,
	1,
	'// Transition.get_name()
result = "";
select one nst related by self->SM_NSTXN[R507];
if not_empty nst
  result = nst.get_name();
end if;
select one net related by self->SM_NETXN[R507];
if not_empty net
  result = net.get_connector_text();
end if;
select one destState related by self->SM_STATE[R506];
select one srcState related by nst->SM_SEME[R504]->SM_STATE[R503];
if not_empty srcState
  result = result + " in " + srcState.Name + " to " + destState.Name;
else
  result = result + " to creation state: " + destState.Name;
end if;
return result;',
	1,
	'',
	1691);
INSERT INTO O_TFR
	VALUES (1693,
	1509,
	'mergeDispose',
	'',
	19,
	1,
	'select one nstxn related by self->SM_NSTXN[R507];
if (not_empty nstxn)
  unrelate nstxn from self across R507;
  select one seme related by nstxn->SM_SEME[R504];
  if(not_empty seme)
    unrelate nstxn from seme across R504;
  end if;
  delete object instance nstxn;
end if;
                                   
select one crtxn related by self->SM_CRTXN[R507];
if (not_empty crtxn)
  unrelate self from crtxn across R507;
  select one evt related by crtxn->SM_LEVT[R509];
  if(not_empty evt)
    unrelate evt from crtxn across R509;
  end if;
  delete object instance crtxn;
end if; 
select one netxn related by self->SM_NETXN[R507];
if (not_empty netxn)
  unrelate self from netxn across R507;
  select one state related by netxn->SM_STATE[R508];
  unrelate netxn from state across R508;
  delete object instance netxn;
end if;
                                   
select one sm related by self->SM_SM[R505];
unrelate self from sm across R505;
select one state related by self->SM_STATE[R506];
unrelate self from state across R506;
select one act related by self->SM_TAH[R530]->SM_AH[R513]->SM_ACT[R514];
if (not_empty act )
  act.dispose();
else
  // the dispose unit tests don''t populate everything
  select one meah related by self->SM_MEAH[R512];
  if ( not_empty meah )
    select one mealy related by meah->SM_MEALY[R512];
    unrelate mealy from self across R512 using meah;
  end if;
end if;
select many insts related by self->I_INS[R2953];
for each inst in insts
  unrelate self from inst across R2953;
end for;
delete object instance self;',
	1,
	'',
	1692);
INSERT INTO O_TFR
	VALUES (1694,
	1509,
	'checkIntegrity',
	'',
	19,
	1,
	'/**
 *  Create an integrity issue if any other transition a the same source state 
 *  and shares the same assigned event
 */
select one class related by self->SM_SM[R505]->SM_ISM[R517]->O_OBJ[R518];
select one package related by class->PE_PE[R8001]->EP_PKG[R8000];
machineName = "Instance State Machine";
if(empty package)
  select one class related by self->SM_SM[R505]->SM_ASM[R517]->O_OBJ[R519];
  select one package related by class->PE_PE[R8001]->EP_PKG[R8000];
  machineName = "Class State Machine";
end if;
select one state related by self->SM_NSTXN[R507]->SM_SEME[R504]->SM_STATE[R503];
select many transitions related by state->SM_SEME[R503]
                                                 ->SM_NSTXN[R504]->SM_TXN[R507];
for each transition in transitions
  select one selfEvt related by self->SM_NSTXN[R507]->SM_SEME[R504]
                                                                ->SM_SEVT[R503];
  select one otherEvt related by transition->SM_NSTXN[R507]->SM_SEME[R504]
                                                                ->SM_SEVT[R503];                                                                
  if(transition != self and otherEvt == selfEvt)
    select one system related by package->S_SYS[R1405];
    sys_id = GD::NULL_UNIQUE_ID();
    if(not_empty system)
      sys_id = system.Sys_ID;
    end if;
	MI_IM::createIssue(sys_id:sys_id, description:
	               "Found another transition with the same event assignment " +
  "leaving the same state.", severity:Severity::Error, name:self.get_name(),
	                path:class.getPath(path:self.get_name(), includeSelf:true) +
	              "::" + machineName + "::" + self.get_name(), id:self.SMstt_ID,
	                                          element:self.convertToInstance());
  end if;
end for;',
	1,
	'',
	1693);
INSERT INTO O_TFR
	VALUES (1695,
	1509,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'// just return this instance as an Object
return this;',
	0,
	'',
	1694);
INSERT INTO O_TFR
	VALUES (1696,
	1509,
	'mergeStateMachineEventAssignedLocalEvent',
	'',
	316,
	1,
	'// only process this if it is a removal, which the given UUID will be null
if(param.event_id == GD::NULL_UNIQUE_ID())
  select one ns_txn related by self->SM_NSTXN[R507];
  if ( not_empty ns_txn )
    select one seme related by ns_txn->SM_SEME[R504];
    select one event related by seme->SM_SEVT[R503];
    select one state related by seme->SM_STATE[R503];
    select many existing related by event->SM_SEME[R503]
                                 where (selected.SMevt_ID == event.SMevt_ID and
                                           selected.SMstt_ID == state.SMstt_ID);
    if(cardinality existing == 1)
      create object instance ch of SM_CH;
      relate seme to ch across R504;
    end if;
    unrelate ns_txn from seme across R504;
    create object instance ne_txn of SM_NETXN;
    unrelate ns_txn from self across R507;
    relate self to ne_txn across R507;
    delete object instance ns_txn;
    select one orig_state related by seme->SM_STATE[R503];
    relate ne_txn to orig_state across R508;
    select one dest_state related by self->SM_STATE[R506];
  else
    select one cr_txn related by self->SM_CRTXN[R507];
    select one levt related by cr_txn->SM_LEVT[R509];
    if ( not_empty levt )
      unrelate cr_txn from levt across R509;
    end if;
  end if;
  return true;
end if;
return false;',
	1,
	'',
	1695);
INSERT INTO O_TPARM
	VALUES (1697,
	1696,
	'event_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1698,
	1509,
	'getDescription',
	'',
	322,
	1,
	'select one action related by self->SM_TAH[R530]->SM_AH[R513]
                                                                 ->SM_ACT[R514];
return action.Descrip;',
	1,
	'',
	1696);
INSERT INTO O_NBATTR
	VALUES (1511,
	1509);
INSERT INTO O_BATTR
	VALUES (1511,
	1509);
INSERT INTO O_ATTR
	VALUES (1511,
	1509,
	0,
	'Trans_ID',
	'Full Name: Transition Identifier',
	'',
	'Trans_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_REF
	VALUES (1509,
	565,
	0,
	564,
	1527,
	1528,
	1529,
	1512,
	1699,
	0,
	0,
	'',
	'State Machine',
	'SM_ID',
	'R505');
INSERT INTO O_REF
	VALUES (1509,
	1492,
	1,
	1521,
	1523,
	1524,
	1525,
	1512,
	1700,
	1699,
	0,
	'',
	'State Machine State',
	'SM_ID',
	'R506.''is destined to''');
INSERT INTO O_RATTR
	VALUES (1512,
	1509,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (1512,
	1509,
	1511,
	'SM_ID',
	'',
	'',
	'SM_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1509,
	1492,
	1,
	1522,
	1523,
	1524,
	1525,
	1701,
	1702,
	0,
	0,
	'',
	'State Machine State',
	'SMstt_ID',
	'R506.''is destined to''');
INSERT INTO O_RATTR
	VALUES (1701,
	1509,
	1522,
	1492,
	1,
	'SMstt_ID');
INSERT INTO O_ATTR
	VALUES (1701,
	1509,
	1512,
	'SMstt_ID',
	'',
	'',
	'SMstt_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1509,
	1492,
	1,
	1526,
	1523,
	1524,
	1525,
	1703,
	1704,
	0,
	0,
	'',
	'State Machine State',
	'SMspd_ID',
	'R506.''is destined to''');
INSERT INTO O_RATTR
	VALUES (1703,
	1509,
	1585,
	1583,
	1,
	'SMspd_ID');
INSERT INTO O_ATTR
	VALUES (1703,
	1509,
	1701,
	'SMspd_ID',
	'',
	'',
	'SMspd_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	1509);
INSERT INTO O_OIDA
	VALUES (1511,
	1509,
	0,
	'Trans_ID');
INSERT INTO O_OIDA
	VALUES (1512,
	1509,
	0,
	'SM_ID');
INSERT INTO O_ID
	VALUES (1,
	1509);
INSERT INTO O_ID
	VALUES (2,
	1509);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (1593,
	'Supplemental Data Items',
	519,
	'SM_SDI',
	'It used to help organize event parameters (SM_EVTDI) into common sets to enforce
the rule that all events (SM_EVT) causing transitions (SM_TXN) into the same
state (SM_STATE) must carry the same data set.

This rule was retired with BridgePoint engineering Job i3208 after customer
requests that transition actions were less useful if this rule is enforced.

Events now locate their data across simple association 2.

Deprecated:true',
	1478);
INSERT INTO O_TFR
	VALUES (1705,
	1593,
	'dispose',
	'Dispose of this SM_SDI.
',
	19,
	1,
	'select one supdt related by self->SM_SUPDT[R522];
select one evtdi related by self->SM_EVTDI[R522];
unrelate supdt from evtdi across R522 using self;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (1706,
	1593,
	'get_name',
	'',
	322,
	1,
	'select one edi related by self->SM_EVTDI[R522];
return edi.Name;
',
	1,
	'',
	1705);
INSERT INTO O_REF
	VALUES (1593,
	52,
	0,
	277,
	1590,
	1594,
	1592,
	1707,
	1708,
	0,
	0,
	'',
	'State Machine Event Data Item',
	'SMedi_ID',
	'R522');
INSERT INTO O_RATTR
	VALUES (1707,
	1593,
	277,
	52,
	1,
	'SMedi_ID');
INSERT INTO O_ATTR
	VALUES (1707,
	1593,
	0,
	'SMedi_ID',
	'',
	'',
	'SMedi_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1593,
	1583,
	0,
	1585,
	1590,
	1594,
	1591,
	1709,
	1710,
	0,
	0,
	'',
	'Event Supplemental Data',
	'SMspd_ID',
	'R522');
INSERT INTO O_RATTR
	VALUES (1709,
	1593,
	1585,
	1583,
	1,
	'SMspd_ID');
INSERT INTO O_ATTR
	VALUES (1709,
	1593,
	1707,
	'SMspd_ID',
	'',
	'',
	'SMspd_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1593,
	52,
	0,
	276,
	1590,
	1594,
	1592,
	1711,
	1712,
	0,
	0,
	'',
	'State Machine Event Data Item',
	'SM_ID',
	'R522');
INSERT INTO O_REF
	VALUES (1593,
	1583,
	0,
	1586,
	1590,
	1594,
	1591,
	1711,
	1713,
	1712,
	0,
	'',
	'Event Supplemental Data',
	'SM_ID',
	'R522');
INSERT INTO O_RATTR
	VALUES (1711,
	1593,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (1711,
	1593,
	1709,
	'SM_ID',
	'',
	'',
	'SM_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	1593);
INSERT INTO O_OIDA
	VALUES (1707,
	1593,
	0,
	'SMedi_ID');
INSERT INTO O_OIDA
	VALUES (1709,
	1593,
	0,
	'SMspd_ID');
INSERT INTO O_OIDA
	VALUES (1711,
	1593,
	0,
	'SM_ID');
INSERT INTO O_ID
	VALUES (1,
	1593);
INSERT INTO O_ID
	VALUES (2,
	1593);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (1492,
	'State Machine State',
	502,
	'SM_STATE',
	'Represents a state in the state machine.',
	1478);
INSERT INTO O_TFR
	VALUES (1714,
	1492,
	'get_style',
	'A State is shown as a round cornered box.
-----------------------------------------------------------------------------------
Bridge:GD',
	784,
	1,
	'return Style::RoundBox;',
	1,
	'',
	1715);
INSERT INTO O_TFR
	VALUES (1716,
	1492,
	'get_compartments',
	'A State has two compartments, one for the Name and one for the
Action Semantics.
-----------------------------------------------------------------------------------
Bridge:GD',
	298,
	1,
	'return 2;',
	1,
	'',
	1717);
INSERT INTO O_TFR
	VALUES (1717,
	1492,
	'get_compartment_text',
	'Returns the Name or Action Semantics depending on the compartment
requested.
-----------------------------------------------------------------------------------
Bridge:GD',
	322,
	1,
	'result = "";
//
// Compartment 1
//
if (param.comp_num == 1)
  if (param.at == Justification::Left)
    // State number needs leading space to clear
    // rounded corners of state symbol
    result = " " + GD::int_to_string(value:self.Numb) + ". " + self.Name;
  end if;
//
// Compartment 2
//
elif (param.comp_num == 2)
 if (param.at == Justification::Left)
    select one moore_action related by self->SM_MOAH[R511]->SM_AH[R513]->SM_ACT[R514];
    if (not_empty moore_action)
      if (moore_action.Suc_Pars == ParseStatus::parseSuccessful)
        result = "entry/" + GD::newline();
      elif (moore_action.Suc_Pars == ParseStatus::parseUnsuccessful)
        result = "*** PARSE ERROR(S) ***" + GD::newline();
      end if;
      result = result + moore_action.Action_Semantics;
    end if;
  end if;
end if;
return result;',
	1,
	'',
	1718);
INSERT INTO O_TPARM
	VALUES (1719,
	1717,
	'comp_num',
	298,
	0,
	'',
	1720,
	'');
INSERT INTO O_TPARM
	VALUES (1721,
	1717,
	'ent_num',
	298,
	0,
	'',
	1719,
	'');
INSERT INTO O_TPARM
	VALUES (1720,
	1717,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1722,
	1492,
	'get_entries',
	'Both compartments have just one entry.
-----------------------------------------------------------------------------------
Bridge:GD',
	298,
	1,
	'return 1;',
	1,
	'',
	1716);
INSERT INTO O_TPARM
	VALUES (1723,
	1722,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1724,
	1492,
	'get_text_style',
	'A State requires no special text style.
-----------------------------------------------------------------------------------
Bridge:GD',
	784,
	1,
	'return Style::None;',
	1,
	'',
	1714);
INSERT INTO O_TPARM
	VALUES (1725,
	1724,
	'comp_num',
	298,
	0,
	'',
	1726,
	'');
INSERT INTO O_TPARM
	VALUES (1727,
	1724,
	'ent_num',
	298,
	0,
	'',
	1725,
	'');
INSERT INTO O_TPARM
	VALUES (1726,
	1724,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1715,
	1492,
	'get_ooa_id',
	'The ooa_id of a State is it''s SMstt_ID.
-----------------------------------------------------------------------------------
Bridge:GD',
	296,
	1,
	'return self.SMstt_ID;',
	1,
	'',
	1722);
INSERT INTO O_TFR
	VALUES (1728,
	1492,
	'initialize',
	'Initialize a new State instance.',
	19,
	1,
	'name = ::getUniqueInitialName( 
    instance: self.convertToInstance(), 
    candidateName: "Unnamed State");
success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:true);    
if ( success!="") 
 self.Name=success;
else 
 self.dispose();
end if;    
// set this state''s number to a default value
self.Numb = 1;

// for each state associated with this state''s state machine
select many states related by self->SM_SM[R501]->SM_STATE[R501];
for each state in states
  // if this state equals self, skip it
  if (state.SMstt_ID == self.SMstt_ID) continue; end if;

  // if this other state''s number is greater than this state''s number
  if ( state.Numb >= self.Numb )
    // have this state''s number be just greater than this
    // other state''s number
    self.Numb = state.Numb + 1;
  end if;
end for;

create object instance ah of SM_AH;
create object instance moah of SM_MOAH;
relate ah to moah across R513;
select one sm related by self->SM_SM[R501];
select one msm related by sm->SM_MOORE[R510];
relate self to msm across R511 using moah;
create object instance act of SM_ACT;
act.Suc_Pars = ParseStatus::parseInitial;
relate act to ah across R514;
relate act to sm across R515;
//
// create SEM entry instances
//
select many event_set related by sm->SM_EVT[R502]->SM_SEVT[R525];
for each event in event_set
  create object instance sem of SM_SEME;
  // TODO: get default subtype from preferences
  create object instance ch of SM_CH;
  relate self to event across R503 using sem;
  relate ch to sem across R504;
end for;',
	1,
	'',
	1724);
INSERT INTO O_TFR
	VALUES (1729,
	1492,
	'dispose',
	'Dispose this State Machine State',
	19,
	1,
	'select one sm_sm related by self->SM_SM[R501];
unrelate self from sm_sm across R501;
select many semes related by self->SM_SEME[R503];
for each seme in semes
  seme.dispose();
end for;
// New state xtns become No event xtns.
// No-event-transitions related by R508 are handled in txn.dispose
select many txns related by self->SM_TXN[R506];
for each txn in txns
  txn.dispose();
end for;
select many netxns related by self->SM_NETXN[R508]->SM_TXN[R507];
for each netxn in netxns
  netxn.dispose();
end for;
//
// Instance Subsystem
select many ins_sts related by self->I_INS[R2915];
for each ins_st in ins_sts
  unrelate self from ins_st across R2915;
end for;
//
delete object instance self;
',
	1,
	'',
	1730);
INSERT INTO O_TFR
	VALUES (1731,
	1492,
	'actionFilter',
	'Bridge: UI
',
	316,
	1,
	'if (param.name == "can" )
  if ((param.value =="ch generic pkg" or param.value =="ignore spec pkg") or
      (param.value =="ch spec pkg" or param.value =="ignore generic pkg"))
  
    select one cls related by self->SM_SM[R501]->SM_ASM[R517]->O_OBJ[R519];
    if (empty cls)
      select one cls related by self->SM_SM[R501]->SM_ISM[R517]->O_OBJ[R518];
    end if;
    select one packageableElem related by cls->PE_PE[R8001];
    select one package related by packageableElem->EP_PKG[R8000];
    select one cc related by packageableElem->C_C[R8003];
    isInGenericPackage = not_empty package or not_empty cc;
    
    if (((param.value == "ch spec pkg") or (param.value == "ignore spec pkg")) and (isInGenericPackage))
      return false;
    end if;
    if (((param.value == "ch generic pkg") or (param.value == "ignore generic pkg")) and (not isInGenericPackage))
      return false;
    end if;

	select any event from instances of SM_EVT
		where ::canStateIgnoreOrSayEventCantHappen(
			eventId:selected.SMevt_ID, eventStateMachineId:selected.SM_ID,
    		stateId:self.SMstt_ID, stateStateMachineId:self.SM_ID,
    		considerCantHappen:((param.value == "ch spec pkg") or (param.value == "ch generic pkg")));
    return not_empty event;
  end if;
end if;
return false;
',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (1732,
	1731,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (1733,
	1731,
	'value',
	322,
	0,
	'',
	1732,
	'');
INSERT INTO O_TFR
	VALUES (1734,
	1492,
	'notAlreadyAssigned',
	'',
	316,
	1,
	'// if the given event is polymorphic and has an non-local event for
// this state''s state machine
select any event from instances of SM_EVT 
	where selected.SMevt_ID == param.eventId 
		and selected.SM_ID == param.eventStateMachineId;
select any nonLocalEvent related by event->SM_PEVT[R525]->SM_NLEVT[R527]->
	SM_SEVT[R526]->SM_EVT[R525] where selected.SM_ID == self.SM_ID;
if (not_empty nonLocalEvent)
	// consider the non-local event instead, since that is the one that would
	// be assigned within this state''s state machine
	event = nonLocalEvent;
end if;

if ( param.crtxn )
  select any crt related by self->SM_SM[R501]->SM_TXN[R505]->SM_CRTXN[R507]
      where selected.SMevt_ID == event.SMevt_ID;
  return empty crt;
else
  select any nst related by self->SM_SEME[R503]->SM_NSTXN[R504]
      where selected.SMevt_ID == event.SMevt_ID;
  return empty nst;
end if;

',
	1,
	'',
	1728);
INSERT INTO O_TPARM
	VALUES (1735,
	1734,
	'eventId',
	296,
	0,
	'',
	1736,
	'');
INSERT INTO O_TPARM
	VALUES (1736,
	1734,
	'crtxn',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (1737,
	1734,
	'eventStateMachineId',
	296,
	0,
	'',
	1735,
	'');
INSERT INTO O_TFR
	VALUES (1738,
	1492,
	'canIgnoreOrSayEventCantHappen',
	'',
	316,
	1,
	'/*
Returns whether the given event may be selected to be marked as ignored by, 
or said to can''t-happen on (as dictated by the considerCantHappen parameter), 
this state.
*/

// if the given event or this state belongs to a class state machine
select any event from instances of SM_EVT 
	where selected.SMevt_ID == param.eventId 
	and selected.SM_ID == param.eventStateMachineId;
if empty event
    return false;
end if;
select one eventClassStateMachine related by event->SM_SM[R502]->SM_ASM[R517];
select one selfStateMachine related by self->SM_SM[R501];
select one selfClassStateMachine related by selfStateMachine->SM_ASM[R517];
if (not_empty eventClassStateMachine or not_empty selfClassStateMachine)
	// if the the given event doesn''t belong to this state''s state machine 
	if (event.SM_ID != self.SM_ID) 
		// this state may not ignore the event or say it can''t happen
		return false;
 	end if;

// otherwise, it belongs to an instance state machine	
else 
	// if the given event is non-local
	select one nonLocalEvent related by event->SM_SEVT[R525]->SM_NLEVT[R526];
	if (not_empty nonLocalEvent) 
		// don''t allow it to be ignored/can''t-happened; during a separate call to 
		// this operation, we''ll consider the associated polymorphic event, 
		// instead, so there aren''t duplicates in the list that is presented to the user
		return false;
	end if;
		
	// if the given event doesn''t belong to this state''s state machine 
	select one selfClass related by selfStateMachine->SM_ISM[R517]->O_OBJ[R518];
	select one eventStateMachine related by event->SM_SM[R502]->SM_ISM[R517];
	if (param.eventStateMachineId != self.SM_ID)
		
		// if the given event doesn''t belong to a supertype of this state''s 
		// owning class
		select one eventClass related by eventStateMachine->O_OBJ[R518];
		if (not eventClass.isSupertypeOf(classId:selfClass.Obj_ID))
			// it can''t be ignored/can''t-happened within this state''s state machine
			return false;
		end if;
		
		// if the given event is assigned (or ignored/can''t-happened) anywhere 
		// on the path from the supertype state machine (inclusive) to this 
		// state''s state machine (exclusive)  
		if (event.isAssignedInSupertypeStateMachine(subtypeId:selfClass.Obj_ID))
			// it can''t be ignored/can''t-happened within this state''s state machine
			return false;
		end if;
		
	end if;
	
	// if the given event is assigned (or ignored/can''t-happened) in any subtype 
	// state machine of this state''s state machine  
	if (event.isAssignedInSubtypeStateMachine(supertypeId:selfClass.Obj_ID))
		// it can''t be ignored/can''t-happened within this state''s state machine
		return false;
	end if;
end if;
	
// if the given event has no associated matrix event
select one matrixEvent related by event->SM_SEVT[R525];
if (empty matrixEvent) 
	// it must be polymorphic, so use the aliasing event''s matrix event, instead
	select any matrixEvent related by event->SM_PEVT[R525]->SM_NLEVT[R527]->SM_SEVT[R526]
		where selected.SM_ID == self.SM_ID;
end if;

// if the matrix event has a matrix entry for this state
select any matrixEntry related by matrixEvent->SM_SEME[R503]
	where selected.SMstt_ID == self.SMstt_ID and selected.SM_ID == self.SM_ID;
if (not_empty matrixEntry) 
	// if we are considering whether the event can be made a can''t happen
	if (param.considerCantHappen)
		// if the matrix entry isn''t an ignore 
		select one ignore related by matrixEntry->SM_EIGN[R504];
		if (empty ignore) 
			// the event can''t be changed to a can''t happen
			return false;
		end if;

	// otherwise, we are considering whether the event can be ignored
	else
		// if the matrix entry isn''t a can''t happen 
		select one cantHappen related by matrixEntry->SM_CH[R504];
		if (empty cantHappen) 
			// the event can''t be changed to being ignored
			return false;
		end if;
	end if;

// otherwise, we''ll consider the lack of an entry to mean the default value, 
// which is can''t-happen 
else 
	// if we are considering whether the event can be made a can''t happen
	if (param.considerCantHappen)
		// the event is already considered to have that status
		return false;
	end if;
end if;

// the given event may be ignored/can''t-happened by this state
return true;',
	1,
	'',
	1731);
INSERT INTO O_TPARM
	VALUES (1739,
	1738,
	'eventId',
	296,
	0,
	'',
	1740,
	'');
INSERT INTO O_TPARM
	VALUES (1741,
	1738,
	'eventStateMachineId',
	296,
	0,
	'',
	1739,
	'');
INSERT INTO O_TPARM
	VALUES (1740,
	1738,
	'considerCantHappen',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1718,
	1492,
	'getNameWithClass',
	'',
	322,
	1,
	'/*
Returns this state''s name, qualified by the key-letters of its owning class.
*/
select one clazz related by self->SM_SM[R501]->SM_ISM[R517]->O_OBJ[R518];
if (empty clazz) 
	select one clazz related by self->SM_SM[R501]->SM_ASM[R517]->O_OBJ[R519];
end if;	
return clazz.Key_Lett + ": " + self.Name;',
	1,
	'',
	1729);
INSERT INTO O_TFR
	VALUES (1730,
	1492,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'// just return this instance as an Object
return this;',
	0,
	'',
	1742);
INSERT INTO O_TFR
	VALUES (1742,
	1492,
	'checkBreakpoint',
	'',
	316,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return false;',
	1,
	'',
	1738);
INSERT INTO O_TPARM
	VALUES (1743,
	1742,
	'changeType',
	1744,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1745,
	1492,
	'checkIntegrity',
	'',
	19,
	1,
	'// check for any states with the same state number
select one class related by self->SM_SM[R501]->SM_ISM[R517]->O_OBJ[R518];
select one package related by class->PE_PE[R8001]->EP_PKG[R8000];
machineName = "Instance State Machine";
if(empty package)
  select one class related by self->SM_SM[R501]->SM_ASM[R517]->O_OBJ[R519];
  select one package related by class->PE_PE[R8001]->EP_PKG[R8000];
  machineName = "Class State Machine";
end if;
select one system related by package->S_SYS[R1405];
sys_id = GD::NULL_UNIQUE_ID();
if(not_empty system)
  sys_id = system.Sys_ID;
end if;
select many states related by self->SM_SM[R501]->SM_STATE[R501];
for each state in states
  if(state != self and state.Numb == self.Numb)
	MI_IM::createIssue(sys_id:sys_id, description:
	                   "Found another state under the same state machine " +
 	    "with the same state number.", severity:Severity::Error, name:self.Name,
	                     path:class.getPath(path:self.Name, includeSelf:true) +
	                    "::" + machineName + "::" + self.Name, id:self.SMstt_ID,
	                                          element:self.convertToInstance());
  end if;
  if(state != self and state.Name == self.Name)
	MI_IM::createIssue(sys_id:sys_id, description:
	                   "Found another state under the same state machine " +
 	    "with a matching name.", severity:Severity::Error, name:self.Name,
	                     path:class.getPath(path:self.Name, includeSelf:true) +
	                    "::" + machineName + "::" + self.Name, id:self.SMstt_ID,
	                                          element:self.convertToInstance());  
  end if;
end for;',
	1,
	'',
	1734);
INSERT INTO O_TFR
	VALUES (1746,
	1492,
	'getDescription',
	'',
	322,
	1,
	'select one action related by self->SM_MOAH[R511]->SM_AH[R513]->SM_ACT[R514];
return action.Descrip;',
	1,
	'',
	1745);
INSERT INTO O_NBATTR
	VALUES (1522,
	1492);
INSERT INTO O_BATTR
	VALUES (1522,
	1492);
INSERT INTO O_ATTR
	VALUES (1522,
	1492,
	0,
	'SMstt_ID',
	'Full Name: State Machine State Identifier',
	'',
	'SMstt_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_REF
	VALUES (1492,
	565,
	0,
	564,
	1491,
	1493,
	1494,
	1521,
	1747,
	0,
	0,
	'',
	'State Machine',
	'SM_ID',
	'R501');
INSERT INTO O_REF
	VALUES (1492,
	1583,
	0,
	1586,
	1581,
	1582,
	1584,
	1521,
	1748,
	1747,
	0,
	'',
	'Event Supplemental Data',
	'SM_ID',
	'R521.''receives asynchronous data via''');
INSERT INTO O_RATTR
	VALUES (1521,
	1492,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (1521,
	1492,
	1522,
	'SM_ID',
	'',
	'',
	'SM_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1492,
	1583,
	0,
	1585,
	1581,
	1582,
	1584,
	1526,
	1749,
	0,
	0,
	'',
	'Event Supplemental Data',
	'SMspd_ID',
	'R521.''receives asynchronous data via''');
INSERT INTO O_RATTR
	VALUES (1526,
	1492,
	1585,
	1583,
	1,
	'SMspd_ID');
INSERT INTO O_ATTR
	VALUES (1526,
	1492,
	1521,
	'SMspd_ID',
	'',
	'',
	'SMspd_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1750,
	1492);
INSERT INTO O_BATTR
	VALUES (1750,
	1492);
INSERT INTO O_ATTR
	VALUES (1750,
	1492,
	1526,
	'Name',
	'Full Name: State Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1751,
	1492);
INSERT INTO O_BATTR
	VALUES (1751,
	1492);
INSERT INTO O_ATTR
	VALUES (1751,
	1492,
	1750,
	'Numb',
	'Full Name: State Number
min_value: 0
max_value: 9999
',
	'',
	'Numb',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1752,
	1492);
INSERT INTO O_BATTR
	VALUES (1752,
	1492);
INSERT INTO O_ATTR
	VALUES (1752,
	1492,
	1751,
	'Final',
	'Full Name: Final State Indicator
Description: Indicates whether or not the state is a final state
Data Domain: 0 = not a final state, 1 = final state
enum0: Non-final state
enum1: Final state
',
	'',
	'Final',
	0,
	298,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	1492);
INSERT INTO O_OIDA
	VALUES (1521,
	1492,
	0,
	'SM_ID');
INSERT INTO O_OIDA
	VALUES (1522,
	1492,
	0,
	'SMstt_ID');
INSERT INTO O_ID
	VALUES (1,
	1492);
INSERT INTO O_OIDA
	VALUES (1526,
	1492,
	1,
	'SMspd_ID');
INSERT INTO O_OIDA
	VALUES (1522,
	1492,
	1,
	'SMstt_ID');
INSERT INTO O_OIDA
	VALUES (1521,
	1492,
	1,
	'SM_ID');
INSERT INTO O_ID
	VALUES (2,
	1492);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (52,
	'State Machine Event Data Item',
	517,
	'SM_EVTDI',
	'Each state machine (SM_SM) has a pool of event data items that can be used as supplemental data (SM_SUPDT) for the events (SM_EVT) of the state machine.  When an event data item is used as supplemental data for an event an instance of SM_SDI is created.',
	1478);
INSERT INTO O_TFR
	VALUES (1753,
	52,
	'dispose',
	'Dispose this State Machine Event Data Item',
	19,
	1,
	'// State Machine Subsystem
select one sm related by self->SM_SM[R516];
unrelate self from sm across R516;
select one dt related by self->S_DT[R524];
unrelate self from dt across R524;
select many sdis related by self->SM_SDI[R522];
for each sdi in sdis
  sdi.dispose();
end for;
//
select one event related by self->SM_EVT[R532];
if not_empty event
  unrelate self from event across R532;
end if;
//
select one successor related by self->SM_EVTDI[R533.''precedes''];
select one predecessor related by self->SM_EVTDI[R533.''succeeds''];
if (not empty successor)
  unrelate self from successor across R533.''precedes'';
end if;
if (not empty predecessor)
  unrelate self from predecessor across R533.''succeeds'';
end if;
if (not_empty successor and not_empty predecessor)
  relate successor to predecessor across R533.''succeeds'';
end if;
//
// Value Subsystem
select many evdiValRefs related by self->V_EPR[R846];
for each evdiValRef in evdiValRefs
  evdiValRef.dispose();
end for;
//
// Instance Subsystem
select many divs related by self->I_DIV[R2934];
for each div in divs
  unrelate self from div across R2934;
  div.dispose();
end for;
// dispose each message argument
// associated with this parm
select many args related by self->MSG_EA[R1017];
for each arg in args
  arg.dispose();
end for;
select many dims related by self->S_DIM[R531];
for each dim in dims
  unrelate self from dim across R531;
  delete object instance dim;
end for;
//
// Finally, delete self;
delete object instance self;',
	1,
	'',
	1754);
INSERT INTO O_TFR
	VALUES (1755,
	52,
	'initialize',
	'Initialize this SM_EVTDI.  Set the name and data type to default values.',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one stateMachine related by self->SM_SM[R516];
select one evt related by self->SM_EVT[R532];
evt.addDataItemToOrder(id:self.SMedi_ID);
select one packageableElem related by self->SM_SM[R516]->SM_ASM[R517]->O_OBJ[R519]->PE_PE[R8001]; 
if (empty packageableElem)
  select one packageableElem related by self->SM_SM[R516]->SM_ISM[R517]->O_OBJ[R518]->PE_PE[R8001];
end if;
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;
if isInGenericPackage
  id = packageableElem.resolveDataTypeRelativeToSelf(default_name:"integer",
                                                          expected_name:"integer");                                                          
  select any dt related by package->PE_VIS[R8002]->
                       PE_PE[R8002]->S_DT[R8001] where selected.DT_ID == id;
  if (empty dt)
    select any dt related by component->PE_CVS[R8004]->
                     PE_PE[R8004]->S_DT[R8001] where selected.DT_ID == id;
  end if;	
  relate self to dt across R524;
  name = ::getUniqueInitialName( 
      instance: self.convertToInstance(), 
      candidateName: "Unnamed Data Item");
       success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:true);    
         if ( success!="") 
           self.Name=success;
         else 
           self.dispose();
        end if;  
else
  select any dom from instances of S_DOM;
  select any dt related by dom->S_DT[R14] where selected.Name == "integer";
  if(empty dt)
    // if the integer dt was not found check the system level
    // dts, but only if the domain found is the formal content
    // of a component
    if(dom.participatesInSystem())
      select one system related by dom->CN_DC[R4204]->C_C[R4204]->CP_CP[R4608]
                                                                   ->S_SYS[R4606];
      dt_id = GD::NULL_UNIQUE_ID();
      if not_empty system
        dt_id = system.getCoreTypeId(name:"integer");
      end if;
      select any pe from instances of PE_PE where selected.Element_ID == dt_id;
      select one dt related by pe->S_DT[R8001]; 
    else
      // this is an error, if the domain is not
      // participating at the system level and
      // we cannot find the type at the domain
      // level we have a problem
      pathMsg = "<No Path Available - Empty instance>";
    if (not_empty  stateMachine)
      pathMsg =  stateMachine.getPath();
    end if;
	USER::logError(msg:"Unable to locate expected data type: integer",path:pathMsg);
    end if;
  end if;
  relate self to dt across R524;
  self.Name = ::getUniqueInitialName( 
      instance: self.convertToInstance(), 
      candidateName: "Unnamed Data Item");
end if;',
	1,
	'',
	1756);
INSERT INTO O_TFR
	VALUES (1757,
	52,
	'isAllowedType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// if this element is at the system level check the
// system level data types, otherwise check the 
// domain
// State Machine Event Data Item.isAllowedType()
select one machine related by self->SM_SM[R516];
select one clazz related by machine->SM_ISM[R517]->O_OBJ[R518];
if(empty clazz)
  select one clazz related by machine->SM_ASM[R517]->O_OBJ[R519];
end if;
select one packageableElem related by clazz->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;
if isInGenericPackage
  return packageableElem.isAllowedType(isReturnType:false,
                                                       typeName:param.typeName);
else
  select one domain related by clazz->S_SS[R2]->S_DOM[R1];
  if(not_empty domain)
    select one system related by domain->S_SYS[R28];
    if(not_empty system)
      return S_DT::isAllowedParameterType( typeName: param.typeName,
                                  			dom_id: domain.get_ooa_id());
    else
      // first check the domain level
      result = S_DT::isAllowedParameterType( typeName: param.typeName,
                                   			dom_id: domain.get_ooa_id());
      if(not result)
        // if nothing valid check the system level
        select one system related by domain->CN_DC[R4204]->C_C[R4204]
      											   ->CP_CP[R4608]->S_SYS[R4606];
        if(not_empty system)
          return Util::isAllowedParameterType(system:system.convertToInstance(),
                                                       typeName:param.typeName);
        else
          // we should never get here, log an error if we
          // do
          pathMsg = "<No Path Available - Empty instance>";
    if (not_empty machine)
      pathMsg = machine.getPath();
    end if;
	USER::logError(msg:"Unable to locate the system.",path:pathMsg);
        end if;
      else
        return result;
      end if;
    end if;
  end if;
  return false;
end if;',
	1,
	'',
	1755);
INSERT INTO O_TPARM
	VALUES (1758,
	1757,
	'typeName',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1754,
	52,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'// just return this instance as an Object
return this;',
	0,
	'',
	1759);
INSERT INTO O_TFR
	VALUES (1760,
	52,
	'resolveDatatype',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one dtProxy related by self->S_DT[R524];
if(not_empty dtProxy and not Util::isProxy(element:self.convertToInstance()))
  name = dtProxy.Name;
  unrelate dtProxy from self across R524;
  
  select one packageableElem related by self->SM_SM[R516]->SM_ASM[R517]->O_OBJ[R519]->PE_PE[R8001]; 
  if (empty packageableElem)
    select one packageableElem related by self->SM_SM[R516]->SM_ISM[R517]->O_OBJ[R518]->PE_PE[R8001];
  end if;
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = not_empty package or not_empty component;
  if isInGenericPackage
    id = packageableElem.resolveDataTypeRelativeToSelf(default_name:"integer",
                                                            expected_name:name);                                                          
    select any resolvedDt related by package->PE_VIS[R8002]->
                         PE_PE[R8002]->S_DT[R8001] where selected.DT_ID == id;
    if (empty resolvedDt)
      select any resolvedDt related by component->PE_CVS[R8004]->
                       PE_PE[R8004]->S_DT[R8001] where selected.DT_ID == id;
    end if;	
    if not_empty resolvedDt
      relate resolvedDt to self across R524;
    end if;
  else
    select one domain related by self->SM_SM[R516]->SM_ASM[R517]->O_OBJ[R519]
                                                          ->S_SS[R2]->S_DOM[R1];
    if(empty domain)
      select one domain related by self->SM_SM[R516]->SM_ISM[R517]->O_OBJ[R518]
                                                           ->S_SS[R2]->S_DOM[R1];
    end if; 
    id = domain.resolveDataTypeRelativeToSelf(default_name:"integer",
  													        expected_name:name);
    // until we have instance reference passing, we search for
    // the data type related to the domain first then to the
    // system
    select any resolvedDT related by domain->S_DT[R14]
  												   where (selected.DT_ID == id);
    if(empty resolvedDT)
      select one system related by domain->CN_DC[R4204]->C_C[R4204]
    				                               ->CP_CP[R4608]->S_SYS[R4606];
      select any resolvedDT related by system->SLD_SDINP[R4402]->S_DT[R4401]
    				 						       where (selected.DT_ID == id);
      if empty resolvedDT and not_empty system and system.useGlobals
        select any resolvedDT related by system->G_EIS[R9100]->PE_PE[R9100]->
                                       S_DT[R8001] where (selected.DT_ID == id);
      end if;
    end if;  
    if(not_empty resolvedDT)
      relate resolvedDT to self across R524;
    end if;
  end if;
end if;',
	1,
	'',
	1761);
INSERT INTO O_TFR
	VALUES (1762,
	52,
	'resolveExistingDataItem',
	'',
	296,
	1,
	'select any sm from instances of SM_SM where (selected.SM_ID == param.id);
if(not_empty sm)
  foundDI = false;
  select any resolvedDI from instances of SM_EVTDI where (selected.SMedi_ID == GD::NULL_UNIQUE_ID());
  // resolve a data item by name and type
  select many existingDIs related by sm->SM_EVTDI[R516] where (selected.Name == self.Name);
  for each existingDI in existingDIs
    select one dt related by self->S_DT[R524];
    select one otherDt related by existingDI->S_DT[R524];
    if(dt.Name == otherDt.Name)
      foundDI = true;
      resolvedDI = existingDI;
      break;
    end if;
  end for;
  if(foundDI)
    return resolvedDI.SMedi_ID;
  end if;
end if;
return GD::NULL_UNIQUE_ID();',
	1,
	'',
	1760);
INSERT INTO O_TPARM
	VALUES (1763,
	1762,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1761,
	52,
	'resizeDimensions',
	'',
	19,
	1,
	'// If the number of dimensions has increased then add dimensions
while (param.numDimensions > self.getDimensionsCnt())
  create object instance dim of S_DIM;
  dim.dimensionCount = self.getDimensionsCnt();
  relate dim to self across R531;
end while;

// If the number of dimensions has decreased then remove dimensions
while (param.numDimensions < self.getDimensionsCnt())
  select any dim related by self->S_DIM[R531] where (selected.dimensionCount == (self.getDimensionsCnt()-1));
  unrelate dim from self across R531;
  delete object instance dim;
end while;

// Update the specific dimension that was passed-in if its elementCount has 
// changed.
if (param.numDimensions > 0) 
  select any dim related by self->S_DIM[R531] where (selected.dimensionCount == param.dimension);
  if (dim.elementCount != param.elementCount)
    dim.elementCount = param.elementCount;
  end if;
end if;
',
	1,
	'',
	1764);
INSERT INTO O_TPARM
	VALUES (1765,
	1761,
	'elementCount',
	298,
	0,
	'',
	1766,
	'');
INSERT INTO O_TPARM
	VALUES (1766,
	1761,
	'dimension',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (1767,
	1761,
	'numDimensions',
	298,
	0,
	'',
	1765,
	'');
INSERT INTO O_TFR
	VALUES (1756,
	52,
	'getDimensionsCnt',
	'',
	298,
	1,
	'select many dims related by self->S_DIM[R531];
dimensions = cardinality dims;
return dimensions;',
	1,
	'',
	1753);
INSERT INTO O_TFR
	VALUES (1764,
	52,
	'moveUp',
	'',
	19,
	1,
	'::changeNotificationEnablement(enabled:false);
select one prev_attr related by self->SM_EVTDI[R533.''succeeds''];
select one prev_prev_attr related by prev_attr->SM_EVTDI[R533.''succeeds''];
select one next_attr related by self->SM_EVTDI[R533.''precedes''];

if ( not_empty prev_prev_attr )
  unrelate prev_attr from prev_prev_attr across R533.''succeeds'';
end if;
if ( not_empty next_attr )
  unrelate next_attr from self across R533.''succeeds'';
end if;
unrelate self from prev_attr across R533.''succeeds'';

if ( not_empty prev_prev_attr )
  relate self to prev_prev_attr across R533.''succeeds'';
end if;
// want to enable listeners at the last possible moment
if ( empty next_attr )
  ::changeNotificationEnablement(enabled:true);
end if;
relate prev_attr to self across R533.''succeeds'';
if ( not_empty next_attr )
  ::changeNotificationEnablement(enabled:true);
  relate next_attr to prev_attr across R533.''succeeds'';
end if;
',
	1,
	'',
	1768);
INSERT INTO O_TFR
	VALUES (1768,
	52,
	'moveDown',
	'',
	19,
	1,
	'::changeNotificationEnablement(enabled:false);
select one next_attr related by self->SM_EVTDI[R533.''precedes''];
select one prev_attr related by self->SM_EVTDI[R533.''succeeds''];
select one next_next_attr related by next_attr->SM_EVTDI[R533.''precedes''];

if ( not_empty next_next_attr )
  unrelate next_next_attr from next_attr across R533.''succeeds'';
end if;
if ( not_empty prev_attr )
  unrelate self from prev_attr across R533.''succeeds'';
end if;
unrelate next_attr from self across R533.''succeeds'';

if ( not_empty prev_attr )
  relate next_attr to prev_attr across R533.''succeeds'';
end if;
   
// want to enable listeners at the last possible moment
if ( empty next_next_attr )
  ::changeNotificationEnablement(enabled:true);
end if;
relate self to next_attr across R533.''succeeds'';
if ( not_empty next_next_attr )
  ::changeNotificationEnablement(enabled:true);
  relate next_next_attr to self across R533.''succeeds'';
end if;
',
	1,
	'',
	1769);
INSERT INTO O_TFR
	VALUES (1770,
	52,
	'actionFilter',
	'',
	316,
	1,
	'if (param.name == "can" )
  if ( param.value == "move up" )
    select one prev_attr related by self->SM_EVTDI[R533.''succeeds''];
    return not_empty prev_attr;
  elif ( param.value == "move down" )
    select one next_attr related by self->SM_EVTDI[R533.''precedes''];
    return not_empty next_attr;
  end if;
end if;
return false;
',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (1771,
	1770,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (1772,
	1770,
	'value',
	322,
	0,
	'',
	1771,
	'');
INSERT INTO O_TFR
	VALUES (1773,
	52,
	'canReferToDataType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// select the dt
select one dt related by self->S_DT[R524];
if(not_empty dt)
  select one packageableElem related by self->SM_SM[R516]->SM_ASM[R517]->O_OBJ[R519]->PE_PE[R8001];
  if (empty packageableElem)
    select one packageableElem related by self->SM_SM[R516]->SM_ISM[R517]->O_OBJ[R518]->PE_PE[R8001];
  end if;
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = not_empty package or not_empty component;

  if (isInGenericPackage)
    return packageableElem.canReferToDataType(dtID:dt.DT_ID, dtName: dt.Name);
  else
    // if the data type package is at the system
    // level we can use the data type as long as
    // this element belongs to a formal component
    select one clazz related by self->SM_SM[R516]->SM_ISM[R517]->O_OBJ[R518];
    if(empty clazz)
      select one clazz related by self->SM_SM[R516]->SM_ASM[R517]->O_OBJ[R519];
    end if;
    select one domain related by clazz->S_SS[R2]->S_DOM[R1];
    select one dtPkg related by dt->S_DIP[R39]->S_DPK[R39];
    if(not dtPkg.isDomainLevel())
      if(domain.participatesInSystem())
        return true;
      else
        return false;
      end if;
    else
      // otherwise the DT must be in the same domain
      select one dtDomain related by dt->S_DOM[R14];
      if(dtDomain == domain)
        return true;
      end if;
    end if;
  end if;
end if;
return false;
',
	1,
	'',
	1770);
INSERT INTO O_TFR
	VALUES (1769,
	52,
	'isReferringToDefaultDataType',
	'',
	316,
	1,
	'select one dt related by self->S_DT[R524];
elementType = Util::getSimpleClassName(element:self.convertToInstance());
if(dt.Name == S_DT::getDefaultDataTypeName(elementType:elementType))
  return true;
end if;
return false;
',
	1,
	'',
	1757);
INSERT INTO O_TFR
	VALUES (1759,
	52,
	'canUseDataType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// State Machine Event Data Item.canUseDataType()
select one machine related by self->SM_SM[R516];
select one clazz related by machine->SM_ISM[R517]->O_OBJ[R518];
if(empty clazz)
  select one clazz related by machine->SM_ASM[R517]->O_OBJ[R519];
end if;
select one packageableElem related by clazz->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;
if isInGenericPackage
  // Find the previously created visibility list
  select any resultSet related by package->PE_SRS[R8005] where
        selected.Name == "" and selected.Type == ElementTypeConstants::DATATYPE;
  select any dt related by resultSet->PE_VIS[R8006]->
                     PE_PE[R8002]->S_DT[R8001] where selected.DT_ID == param.id;
  if not_empty component
    // Find the previously created visibility list
    select any compResultSet related by component->PE_CRS[R8007] where
        selected.Name == "" and selected.Type == ElementTypeConstants::DATATYPE;
    select any dt related by compResultSet->PE_CVS[R8008]->
                     PE_PE[R8004]->S_DT[R8001] where selected.DT_ID == param.id;
  end if;
  if(not_empty dt)
    if(self.isAllowedType(typeName:dt.Name))
      return true;
    end if;
  end if;
  return false;
else
  select one domain related by clazz->S_SS[R2]->S_DOM[R1];
  if(domain.participatesInSystem())
    // system level check both the system
    // and the domain for the dt
    select one system related by domain->CN_DC[R4204]->C_C[R4204]->CP_CP[R4608]
                                                                 ->S_SYS[R4606];
    select any dt related by system->SLD_SDINP[R4402]->S_DT[R4401]
                                             where (selected.DT_ID == param.id);
    if empty dt and not_empty system and system.useGlobals
      select any dt related by system->G_EIS[R9100]->PE_PE[R9100]->S_DT[R8001]
                                             where (selected.DT_ID == param.id);
    end if;
    if(empty dt)
      select any dt related by domain->S_DT[R14]
                                             where (selected.DT_ID == param.id);
    end if;
    if(not_empty dt)
      if(self.isAllowedType(typeName:dt.Name))
        return true;
      end if;
    end if;
  else
    // only check the domain for the dt
    select any dt related by domain->S_DT[R14] where (selected.DT_ID == param.id);
    if(not_empty dt)
      if(self.isAllowedType(typeName:dt.Name))
        return true;
      end if;
    end if;
  end if;
  return false;
end if;',
	1,
	'',
	1773);
INSERT INTO O_TPARM
	VALUES (1774,
	1759,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1775,
	52,
	'checkIntegrity',
	'',
	19,
	1,
	'/**
 *  Create an integrity issue if there are any other parameters in the same
 *  event with a matching name
 */
select one event related by self->SM_EVT[R532];
select one machine related by event->SM_SM[R502];
select one clazz related by machine->SM_ISM[R517]->O_OBJ[R518];
if(empty clazz)
  select one clazz related by machine->SM_ASM[R517]->O_OBJ[R519];
end if;
select one package related by clazz->PE_PE[R8001]->EP_PKG[R8000];
select one system related by package->S_SYS[R1405];
sys_id = GD::NULL_UNIQUE_ID();
if(not_empty system)
  sys_id = system.Sys_ID;
end if;
select many parameters related by event->SM_EVTDI[R532];
for each parameter in parameters
  if(parameter != self and parameter.Name == self.Name)
    MI_IM::createIssue(sys_id:sys_id, description:
         "Found another parameter under the same event with a " +
                                                          "matching name.",
                                      severity:Severity::Error, name:self.Name,
                                     path:event.getPath() + "::" + self.Name,
                    id:self.SMedi_ID, element:self.convertToInstance());
  end if;
end for;',
	1,
	'',
	1762);
INSERT INTO O_NBATTR
	VALUES (277,
	52);
INSERT INTO O_BATTR
	VALUES (277,
	52);
INSERT INTO O_ATTR
	VALUES (277,
	52,
	0,
	'SMedi_ID',
	'Full Name: Event Data Item Identifier',
	'',
	'SMedi_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_REF
	VALUES (52,
	565,
	0,
	564,
	1578,
	1579,
	1580,
	276,
	1776,
	0,
	0,
	'',
	'State Machine',
	'SM_ID',
	'R516');
INSERT INTO O_REF
	VALUES (52,
	52,
	0,
	276,
	1652,
	1654,
	1653,
	276,
	1777,
	1776,
	0,
	'',
	'State Machine Event Data Item',
	'SM_ID',
	'R533');
INSERT INTO O_RATTR
	VALUES (276,
	52,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (276,
	52,
	277,
	'SM_ID',
	'',
	'',
	'SM_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1778,
	52);
INSERT INTO O_BATTR
	VALUES (1778,
	52);
INSERT INTO O_ATTR
	VALUES (1778,
	52,
	276,
	'Name',
	'Full Name: Event Data Item Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1779,
	52);
INSERT INTO O_BATTR
	VALUES (1779,
	52);
INSERT INTO O_ATTR
	VALUES (1779,
	52,
	1778,
	'Descrip',
	'Full Name: Event Data Item Description',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1780,
	52);
INSERT INTO O_BATTR
	VALUES (1780,
	52);
INSERT INTO O_ATTR
	VALUES (1780,
	52,
	1781,
	'Dimensions',
	'Full Name: Array Dimensions',
	'',
	'Dimensions',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (52,
	1488,
	0,
	1604,
	1649,
	1651,
	1650,
	1782,
	1783,
	0,
	0,
	'',
	'State Machine Event',
	'SMevt_ID',
	'R532');
INSERT INTO O_RATTR
	VALUES (1782,
	52,
	1604,
	1488,
	1,
	'SMevt_ID');
INSERT INTO O_ATTR
	VALUES (1782,
	52,
	1780,
	'SMevt_ID',
	'',
	'',
	'SMevt_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (52,
	52,
	0,
	277,
	1652,
	1654,
	1653,
	1784,
	1785,
	0,
	0,
	'',
	'State Machine Event Data Item',
	'SMedi_ID',
	'R533');
INSERT INTO O_RATTR
	VALUES (1784,
	52,
	277,
	52,
	1,
	'SMedi_ID');
INSERT INTO O_ATTR
	VALUES (1784,
	52,
	1782,
	'Previous_SMedi_ID',
	'',
	'Previous_',
	'SMedi_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (52,
	32,
	0,
	156,
	1598,
	1600,
	1599,
	1781,
	1786,
	0,
	0,
	'',
	'Data Type',
	'DT_ID',
	'R524');
INSERT INTO O_RATTR
	VALUES (1781,
	52,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (1781,
	52,
	1779,
	'DT_ID',
	'',
	'',
	'Element_ID',
	2,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	52);
INSERT INTO O_OIDA
	VALUES (276,
	52,
	0,
	'SM_ID');
INSERT INTO O_OIDA
	VALUES (277,
	52,
	0,
	'SMedi_ID');
INSERT INTO O_ID
	VALUES (1,
	52);
INSERT INTO O_ID
	VALUES (2,
	52);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (1488,
	'State Machine Event',
	503,
	'SM_EVT',
	'Represents an event for this state machine.  Events can be either State Event Matrix events (SM_SEVT) or polymorphic events (SM_PEVT).',
	1478);
INSERT INTO O_TFR
	VALUES (1787,
	1488,
	'get_event_text',
	'Gets the text for the Event. It obtains the full formatted text of the
message in the form <KL><EVT_NUM>:<Meaning>( Datum List ).
-----------------------------------------------------------------------------------
Bridge:GD
',
	322,
	1,
	'// Event.get_event_text
result = self.get_name();
select any parameter related by self->SM_EVTDI[R532] 
                     where (selected.Previous_SMedi_ID == GD::NULL_UNIQUE_ID());
select one nl related by self->SM_SEVT[R525]->SM_NLEVT[R526];
// if this event is non-local find the data in the supertype event
if not_empty nl
  select many parameters related by nl->SM_PEVT[R527]->
                                                   SM_EVT[R525]->SM_EVTDI[R532]
                         where (selected.Previous_SMedi_ID == GD::NULL_UNIQUE_ID());
end if;
if PREF::getBoolean(name:"bridgepoint_prefs_show_event_parameters")
  if not_empty parameter
    result = result + "(";
    sep = "";
    while (not_empty parameter)
      result = result + sep + parameter.Name;
      sep = ", ";
      select one parameter related by parameter->SM_EVTDI[R533.''precedes''];
    end while;
    result = result + ")";
  end if;
else
  if not_empty parameter
    result = result + "(...)";
  end if;
end if;
return result;',
	1,
	'',
	1788);
INSERT INTO O_TFR
	VALUES (1789,
	1488,
	'get_name',
	'Creates a string containing a descriptive name for the instance.',
	322,
	1,
	'select one nlevt related by self->SM_SEVT[R525]->SM_NLEVT[R526];
if(not_empty nlevt)
  select one poly related by nlevt->SM_PEVT[R527];
  if(not_empty poly)
    return self.Mning + "::" + poly.localClassName;
  else
    return self.Mning + "::" + ::getOrphanedElementName();
  end if;
else
  select one signalEvt related by self->SM_SEVT[R525]->SM_SGEVT[R526];
  if(not_empty signalEvt)
    return self.Drv_Lbl;
  else
    return self.Drv_Lbl + ": " + self.Mning;
  end if;
end if;',
	1,
	'',
	1787);
INSERT INTO O_TFR
	VALUES (1790,
	1488,
	'dispose',
	'Dispose this State Machine Event.
',
	19,
	1,
	'// State Machine Event.dispose()
select one sm related by self->SM_SM[R502];
unrelate self from sm across R502;
select one sevt related by self->SM_SEVT[R525];
if (not_empty sevt)
  sevt.dispose();
end if;
select one pevt related by self->SM_PEVT[R525];
if (not_empty pevt)
  pevt.dispose();
end if;
select many dis related by self->SM_EVTDI[R532];
for each di in dis
  di.dispose();
end for;
// Communication and Access Subsystem
select many smsmes related by self->CA_SMSME[R409];
for each smsme in smsmes
  smsme.dispose();
end for;
select many eesmes related by self->CA_EESME[R405];
for each eesme in eesmes
  eesme.dispose();
end for;
//Event subsystem
select many csmes related by self->E_CSME[R706];
for each csme in csmes
  unrelate self from csme across R706;
end for;
select many gsmes related by self->E_GSME[R707];
for each gsme in gsmes
  unrelate self from gsme across R707;
end for;
// for each message that this event
// is associated with
select many ems related by self->MSG_E[R1009];
for each em in ems
  select one message related by em->MSG_AM[R1019];
  message.unformalize();
end for;
//
// Instance Subsystem
select many pend_evts related by self->I_EVI[R2906];
for each pend_evt in pend_evts
  unrelate self from pend_evt across R2906;
  pend_evt.dispose();
end for;
//
// Finally, delete self
delete object instance self;',
	1,
	'',
	1791);
INSERT INTO O_TFR
	VALUES (1792,
	1488,
	'initialize',
	'Initialize this State Machine Event.
',
	19,
	1,
	'name = ::getUniqueInitialName( 
    instance: self.convertToInstance(), 
    candidateName: "Unnamed Event");
success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:true);    
if ( success!="") 
 self.Mning=success;
else 
 self.dispose();
end if;    
// set this event''s number to a default value
self.Numb = 1;

// give this event a unique number
self.setUniqueNumber(checkForDuplicate:false);

select one sm related by self->SM_SM[R502];                                   
create object instance semEvt of SM_SEVT;
relate self to semEvt across R525;
create object instance locEvt of SM_LEVT;
relate semEvt to locEvt across R526;
//
semEvt.createDefaultMatrixEntries();
',
	1,
	'',
	1793);
INSERT INTO O_TFR
	VALUES (1794,
	1488,
	'actionFilter',
	'Bridge: UI
',
	316,
	1,
	'if (param.name == "subtype" )
  if (param.value =="SM_SEVT" )
    select one sevt related by self->SM_SEVT[R525];
    return not_empty sevt;
  elif (param.value == "SM_PEVT" )
    select one pevt related by self->SM_PEVT[R525];
    return not_empty pevt;
  end if;
elif (param.name == "can" )

  if ((param.value =="ch generic pkg" or param.value =="ignore spec pkg") or
      (param.value =="ch spec pkg" or param.value =="ignore generic pkg"))
    
    select one cls related by self->SM_SM[R502]->SM_ASM[R517]->O_OBJ[R519];
    if (empty cls)
      select one cls related by self->SM_SM[R502]->SM_ISM[R517]->O_OBJ[R518];
    end if;
    select one packageableElem related by cls->PE_PE[R8001];
    select one package related by packageableElem->EP_PKG[R8000];
    select one cc related by packageableElem->C_C[R8003];
    isInGenericPackage = not_empty package or not_empty cc;
    
    if (((param.value == "ch spec pkg") or (param.value == "ignore spec pkg")) and (isInGenericPackage))
      return false;
    end if;
    if (((param.value == "ch generic pkg") or (param.value == "ignore generic pkg")) and (not isInGenericPackage))
      return false;
    end if;
    
	select any state from instances of SM_STATE
		where ::canStateIgnoreOrSayEventCantHappen(
			eventId:self.SMevt_ID, eventStateMachineId:self.SM_ID,
    		stateId:selected.SMstt_ID, stateStateMachineId:selected.SM_ID,
    		considerCantHappen:((param.value == "ch spec pkg") or (param.value == "ch generic pkg")));
    return not_empty state;
  end if;
end if;
return false;
',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (1795,
	1794,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (1796,
	1794,
	'value',
	322,
	0,
	'',
	1795,
	'');
INSERT INTO O_TFR
	VALUES (1797,
	1488,
	'hasDataItem',
	'',
	316,
	1,
	'select any item related by self->SM_EVTDI[R532] where
                                                  selected.SMedi_ID == param.id;
return not_empty item;
',
	1,
	'',
	1798);
INSERT INTO O_TPARM
	VALUES (1799,
	1797,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1800,
	1488,
	'isAssignableToStateMachine',
	'',
	316,
	1,
	'/*
Returns whether this event is assignable to the state machine of the given ID,
taking into account Bridepoint''s strange rule regarding event polymorphism
where an event may not be assigned at more than one level in a generalization
hierarchy.

param isCreationTransition 	whether the assignment would be to a creation 
							transition
*/
// if this event belongs to a class state machine
select one classStateMachine related by self->SM_SM[R502]->SM_ASM[R517];
if (not_empty classStateMachine)
  // First exclude all signal events from consideration
  select one sigEvt related by self->SM_SEVT[R525]->SM_SGEVT[R526];
  if not_empty sigEvt
    return false;
  end if;
  // else, assignability rests solely on whether the given state machine is
  // the one to which this event belongs
  return param.assignToMachineId == self.SM_ID;
end if;
	
// if this event''s state machine is not the given state machine,
// and this event''s owning class is not a supertype of the given state 
// machine''s class
select one selfClass related by self->SM_SM[R502]->SM_ISM[R517]->O_OBJ[R518];
select any assignToMachine from instances of SM_SM
	where selected.SM_ID == param.assignToMachineId;
select one assignToMachineClass related by 
	assignToMachine->SM_ISM[R517]->O_OBJ[R518];
isSupertype = selfClass.isSupertypeOf(classId:assignToMachineClass.Obj_ID);
if ((param.assignToMachineId != self.SM_ID and not isSupertype) or
		(param.assignToMachineId != self.SM_ID and param.isCreationTransition))
	// this event is not applicable to the given state machine
	return false;
end if;

// if this event is polymorphic
select one polymorphic related by self->SM_PEVT[R525];
if (not empty polymorphic)
	// if any of the given state machine''s subtype state
	// machines have this event assigned to a transition
	if (self.isAssignedInSubtypeStateMachine(
		supertypeId:assignToMachineClass.Obj_ID))
		// this event may not be assigned to the given state machine
		return false;
	end if;
end if;

// if this event is a non-local alias
select one nonLocal related by self->SM_SEVT[R525]->SM_NLEVT[R526];
if (not empty nonLocal)
	// the associated polymorphic event will be the one that is possibly
	// assignable, not this one (to prevent duplicates in the list that is
	// presented to the user)
	return false;
end if;
	
// if this event''s state machine is a supertype machine of the one given,
// and any of the given state machine''s supertype state
// machines have this event assigned to a transition
if (isSupertype and self.isAssignedInSupertypeStateMachine(
	subtypeId:assignToMachineClass.Obj_ID))
	// this event may not be assigned to the given state machine
	return false;
end if;

// this event may be assigned to the given state machine
return true;
	
	
	


',
	1,
	'',
	1801);
INSERT INTO O_TPARM
	VALUES (1802,
	1800,
	'assignToMachineId',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (1803,
	1800,
	'isCreationTransition',
	316,
	0,
	'',
	1802,
	'');
INSERT INTO O_TFR
	VALUES (1804,
	1488,
	'isAssignedInSubtypeStateMachine',
	'',
	316,
	1,
	'/*
Recursively traverses the subtree of subtypes rooted at the supertype 
of the given ID, returning whether this event is assigned 
(or ignored) in at least one of those subtypes'' state machines.
*/
 
// for each subtype of the given supertype 
select any supertype from instances of O_OBJ
	where selected.Obj_ID == param.supertypeId;
select many subtypes related by supertype->R_OIR[R201]->R_RTO[R203]->R_SUPER[R204]
	->R_SUBSUP[R212]->R_SUB[R213]->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201];
for each subtype in subtypes
	// if this subtype has an instance state machine
	select one subtypeMachine related by subtype->SM_ISM[R518]->SM_SM[R517];
	if (not_empty subtypeMachine)
		// if this event is consumed in this subtype''s state machine, as
		// signalled by its being aliased by a non-local event 
		select any aliasedEvent related by subtypeMachine->SM_EVT[R502]
			->SM_SEVT[R525]->SM_NLEVT[R526]->SM_PEVT[R527]->SM_EVT[R525]
			where selected.SMevt_ID == self.SMevt_ID and selected.SM_ID == self.SM_ID;
		if (not empty aliasedEvent)
			// we have a positive result
			return true;
		end if;
	end if;
	
	// recurse to the next level of subtype state machines
	if (self.isAssignedInSubtypeStateMachine(supertypeId:subtype.Obj_ID))
		return true;
	end if;
end for;		

return false;	
',
	1,
	'',
	1800);
INSERT INTO O_TPARM
	VALUES (1805,
	1804,
	'supertypeId',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1806,
	1488,
	'isAssignedInSupertypeStateMachine',
	'',
	316,
	1,
	'/*
Recursively traverses the upwards subtree of supertypes rooted at the 
subtype of the given ID, returning whether this event is assigned 
(or ignored) in at least one of those supertypes'' state machines.
*/
 
// for each supertype of given subtype 
select any subtype from instances of O_OBJ 
	where selected.Obj_ID == param.subtypeId;
select many supertypes related by subtype->R_OIR[R201]->R_RGO[R203]->R_SUB[R205]
	->R_SUBSUP[R213]->R_SUPER[R212]->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201];
for each supertype in supertypes
	// if this supertype has an instance state machine
	select one supertypeMachine related by supertype->SM_ISM[R518]->SM_SM[R517];
	if (not_empty supertypeMachine) 
		// if this event belongs to this supertype''s state machine
		select any event related by supertypeMachine->SM_EVT[R502]
			where selected.SMevt_ID == self.SMevt_ID and selected.SM_ID == self.SM_ID;
		if (not_empty event)
			// if this event is assigned to a transition in this supertype''s state machine 
			select any transition related by event->SM_SEVT[R525]->SM_SEME[R503]
				->SM_NSTXN[R504];
			if (not_empty transition)
				// we have a positive result
				return true;
			end if;
	
			// if this event is ignored by any state in this supertype''s state machine 
			select any ignored related by event->SM_SEVT[R525]->SM_SEME[R503]
				->SM_EIGN[R504];
			if (not_empty ignored)
				// we have a positive result
				return true;
			end if;
		end if;
		
		// if this event is consumed in this supertype''s state machine, as
		// signalled by its being aliased by a non-local event 
		select any aliasedEvent related by supertypeMachine->SM_EVT[R502]
			->SM_SEVT[R525]->SM_NLEVT[R526]->SM_PEVT[R527]->SM_EVT[R525]
			where selected.SMevt_ID == self.SMevt_ID 
				and selected.SM_ID == self.SM_ID;
		if (not_empty aliasedEvent)
			// we have a positive result
			return true;
		end if;
	end if;
	
	// recurse to the next level of supertype state machines
	if (self.isAssignedInSupertypeStateMachine(
		subtypeId:supertype.Obj_ID))
		return true;
	end if;
end for;		

return false;	
',
	1,
	'',
	1804);
INSERT INTO O_TPARM
	VALUES (1807,
	1806,
	'subtypeId',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1808,
	1488,
	'canStateIgnoreOrSayCantHappen',
	'',
	316,
	1,
	'/*
This is merely a pass-through operation, meant as a workaround to an MC-Java 
bug where method calls made on the ''selected'' instance in the ''where'' clause of a 
select statement are not generated correctly.  If a handle to an event instance
is available, a call to this operation may be made in some cases to access 
the desired operation on the given state indirectly.
*/
select any state from instances of SM_STATE
	where selected.SMstt_ID == param.stateId 
		and selected.SM_ID == param.stateStateMachineId;
return state.canIgnoreOrSayEventCantHappen(eventId:self.SMevt_ID,
	eventStateMachineId:self.SM_ID, considerCantHappen:param.considerCantHappen);
	',
	1,
	'',
	1809);
INSERT INTO O_TPARM
	VALUES (1810,
	1808,
	'stateId',
	296,
	0,
	'',
	1811,
	'');
INSERT INTO O_TPARM
	VALUES (1812,
	1808,
	'stateStateMachineId',
	296,
	0,
	'',
	1810,
	'');
INSERT INTO O_TPARM
	VALUES (1811,
	1808,
	'considerCantHappen',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1793,
	1488,
	'ignoreOnState',
	'',
	19,
	1,
	'/*
Has this event (or its relevant subtype alias event) change its matrix entry 
for the given state from a can''t happen to an ignore.  This operation presumes 
that the matrix entry is a can''t happen.
*/
 
// find the event corresponding to the one given that is associated with 
// the given state''s state-machine, which may in fact be this event, or an alias
// (if this event is polymorphic)
select any state from instances of SM_STATE 
	where selected.SMstt_ID == param.stateId 
		and selected.SM_ID == param.stateStateMachineId;
eventId = self.getAssociatedEventForStateMachine(stateMachineId:state.SM_ID);		
select any event from instances of SM_EVT where selected.SMevt_ID == eventId;
		
// change the matrix entry for the event found above from a can''t happen
// to an ignore
select any seme related by event->SM_SEVT[R525]->SM_SEME[R503] 
	where (selected.SMstt_ID == state.SMstt_ID);
seme.migrateChToEi();
',
	1,
	'',
	1797);
INSERT INTO O_TPARM
	VALUES (1813,
	1793,
	'stateId',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (1814,
	1793,
	'stateStateMachineId',
	296,
	0,
	'',
	1813,
	'');
INSERT INTO O_TFR
	VALUES (1788,
	1488,
	'getAssociatedEventForStateMachine',
	'',
	296,
	1,
	'/*
Returns an event related to this one that applies to the given state
machine.  If the given state machine is the one to which this event belongs,
then this event is returned.  Else, if this event is polymorphic, 
the alias associated with the given state machine is returned (with one being
created if it doesn''t already exist).  Otherwise, this event is made 
polymorphic, and an alias for the given state machine is created and 
returned.
*/

// if this event is directly associated with the given state machine
if (self.SM_ID == param.stateMachineId)
	// return this event
	return self.SMevt_ID;
end if;

// if this event is polymorphic
select any machine from instances of SM_STATE
	where selected.SM_ID == param.stateMachineId;
select one polyEvent related by self->SM_PEVT[R525];
if (not_empty polyEvent)
	// if there is an aliasing non-local event associated
	// with the given state machine
	select any nonLocalEvent related by polyEvent->SM_NLEVT[R527]
		where selected.SM_ID == machine.SM_ID; 		
	if (not_empty nonLocalEvent)
		// return that event
		return nonLocalEvent.SMevt_ID;

 	// otherwise
	else
		// create an aliasing non-local event, and return it
		return polyEvent.createNonLocalEventForStateMachine(stateMachineId:machine.SM_ID);
	end if;
		
// otherwise
else
	// dispose this event''s associated local and event-matrix event instances
	select one matrixEvent related by self->SM_SEVT[R525];
	matrixEvent.dispose();

	// make the event polymorphic
	create object instance polyEvent of SM_PEVT;
	relate polyEvent to self across R525;
 		
	// create a non-local event to alias the above polymorphic event, and return it
	return polyEvent.createNonLocalEventForStateMachine(stateMachineId:machine.SM_ID);
end if;

',
	1,
	'',
	1790);
INSERT INTO O_TPARM
	VALUES (1815,
	1788,
	'stateMachineId',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1816,
	1488,
	'sayCantHappenOnState',
	'',
	19,
	1,
	'/*
Has this event change its matrix entry for the given state from an ignore
to a can''t happen.  This operation presumes that the matrix entry is an ignore.
*/
 
// find the event corresponding to the one given that is associated with 
// the given state''s state-machine, which may in fact be this event, or an alias
// (if this event is polymorphic)
select any state from instances of SM_STATE 
	where selected.SMstt_ID == param.stateId 
		and selected.SM_ID == param.stateStateMachineId;
eventId = self.getAssociatedEventForStateMachine(stateMachineId:state.SM_ID);		
select any event from instances of SM_EVT where selected.SMevt_ID == eventId;
		
// change the matrix entry for the event found above from an
// ignore to a can''t happen
select any seme related by event->SM_SEVT[R525]->SM_SEME[R503] 
	where (selected.SMstt_ID == state.SMstt_ID);
seme.migrateEiToCh();
',
	1,
	'',
	1817);
INSERT INTO O_TPARM
	VALUES (1818,
	1816,
	'stateId',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (1819,
	1816,
	'stateStateMachineId',
	296,
	0,
	'',
	1818,
	'');
INSERT INTO O_TFR
	VALUES (1820,
	1488,
	'isClassBased',
	'',
	316,
	1,
	'result = false;
select one asm related by self->SM_SM[R502]->SM_ASM[R517];
select one creationTransition related by self->SM_SEVT[R525]->SM_LEVT[R526]->SM_CRTXN[R509];
if(not_empty asm) or (not_empty creationTransition)
  result = true;
end if;
return result;',
	1,
	'',
	1806);
INSERT INTO O_TFR
	VALUES (1791,
	1488,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'// just return this instance as an Object
return this;',
	0,
	'',
	1821);
INSERT INTO O_TFR
	VALUES (1798,
	1488,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.SMevt_ID;',
	1,
	'',
	1789);
INSERT INTO O_TFR
	VALUES (1821,
	1488,
	'checkBreakpoint',
	'',
	316,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return false;',
	1,
	'',
	1808);
INSERT INTO O_TPARM
	VALUES (1822,
	1821,
	'processType',
	1823,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1824,
	1488,
	'setUniqueNumber',
	'',
	19,
	1,
	'// for each event associated with this event''s state machine
select one sm related by self->SM_SM[R502];
select many events related by sm->SM_EVT[R502];
foundDuplicate = false;
originalNumb = self.Numb;
for each event in events
  // if this event is self, skip it
  if (event.SMevt_ID == self.SMevt_ID)  continue;  end if;

  if(event.Numb == self.Numb)
    foundDuplicate = true;
  end if;

  // if this other event''s number is greater than this event''s number
  if (event.Numb >= self.Numb)
    // have this event''s number be just greater than that of 
    // this other event
    self.Numb = event.Numb + 1;
  end if;
end for;
if(not foundDuplicate and param.checkForDuplicate)
  self.Numb = originalNumb;
end if;',
	1,
	'',
	1816);
INSERT INTO O_TPARM
	VALUES (1825,
	1824,
	'checkForDuplicate',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1809,
	1488,
	'canRename',
	'',
	316,
	1,
	'// we do not allow renaming of non-local events
select one nlevt related by self->SM_SEVT[R525]->SM_NLEVT[R526];
return empty nlevt;',
	1,
	'',
	1794);
INSERT INTO O_TFR
	VALUES (1817,
	1488,
	'newParameter',
	'',
	19,
	1,
	'// State Machine Event.newDataItem()
create object instance newEvtdi of SM_EVTDI;
relate self to newEvtdi across R532;
select one sm related by self->SM_SM[R502];
relate newEvtdi to sm across R516;
newEvtdi.initialize();
self.createMessageArgumentsForParameter(id:newEvtdi.SMedi_ID);',
	1,
	'',
	1820);
INSERT INTO O_TFR
	VALUES (1801,
	1488,
	'initializeOrder',
	'',
	19,
	1,
	'// Alpha-sort the SM_EVTDI elements if they have not yet been ordered
select many peers related by self->SM_EVTDI[R532];
if (cardinality peers > 1)
    initialOrderingCheckPerformed = false;
	select any head related by self->SM_EVTDI[R532] where (selected.SMedi_ID == GD::NULL_UNIQUE_ID());
	endOfList = head;
	loopCnt = 0;
	for each peer in peers
	  if ( not initialOrderingCheckPerformed)
	    select one predecessor related by peer->SM_EVTDI[R533.''precedes''];
	    select one successor related by peer->SM_EVTDI[R533.''succeeds''];
	    initialOrderingCheckPerformed = true;
	    if (not_empty  predecessor or not_empty  successor)
	      // Already ordered
	      break;
	    end if;
	    head = peer;
	    endOfList = peer;
	  end if;
	  
      if (loopCnt == 1)
        if (peer.Name < head.Name)
          relate peer to head across R533.''precedes'';
          endOfList = peer;
        else
          relate head to peer across R533.''precedes'';
          head = peer;
        end if;
      elif (loopCnt > 1)
        insertPoint = head;
        select one next related by head->SM_EVTDI[R533.''succeeds''];
        while (not_empty next)
          if (next.Name < peer.Name)
            break;
          else
            insertPoint = next;          
            select one next related by next->SM_EVTDI[R533.''succeeds''];
          end if;
        end while;
        
        if (empty next)
          // New end of list
          relate peer to endOfList across R533.''precedes'';   
          endOfList = peer;       
        else
          if ((insertPoint == head) and (peer.Name > head.Name))
            // New head
            relate head to peer across R533.''precedes'';
            head = peer;
          else
            unrelate next from insertPoint across R533.''precedes'';
            relate peer to insertPoint across R533.''precedes'';
            relate next to peer across R533.''precedes'';
          end if;          
        end if;
      end if;
      
      loopCnt = loopCnt + 1;
	end for;
end if;',
	1,
	'',
	1792);
INSERT INTO O_TFR
	VALUES (1826,
	1488,
	'pasteStateMachineEventDataItem',
	'',
	19,
	1,
	'select any item from instances of SM_EVTDI
                                          where (selected.SMedi_ID == param.id);
if(not_empty item)
  select one existingSm related by item->SM_SM[R516];
  if(not_empty existingSm)
    unrelate existingSm from item across R516;
  end if;
  select one existingEvt related by item->SM_EVT[R532];
  if(not_empty existingEvt)
    unrelate existingEvt from item across R532;
  end if;
  relate item to self across R532;
  select one machine related by self->SM_SM[R502];
  relate item to machine across R516;
  self.addDataItemToOrder(id:item.SMedi_ID);
  item.Name = ::getUniqueInitialNameInParent( 
      instance: item.convertToInstance(), 
      name: item.Name, parent:self.convertToInstance());
  self.createMessageArgumentsForParameter(id:item.SMedi_ID);
end if;',
	1,
	'',
	1824);
INSERT INTO O_TPARM
	VALUES (1827,
	1826,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1828,
	1488,
	'addDataItemToOrder',
	'',
	19,
	1,
	'select any item from instances of SM_EVTDI
                                          where (selected.SMedi_ID == param.id);
if(not_empty item)
  ::changeNotificationEnablement(enabled:false);
  select many peers related by self->SM_EVTDI[R532];
  for each peer in peers
    if (peer != item)
      select one predecessor related by peer->SM_EVTDI[R533.''precedes''];
      if (empty predecessor)
        relate item to peer across R533.''succeeds'';
      end if;
    end if;
  end for;
  ::changeNotificationEnablement(enabled:true);
end if;',
	1,
	'',
	1826);
INSERT INTO O_TPARM
	VALUES (1829,
	1828,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1830,
	1488,
	'createMessageArgumentsForParameter',
	'',
	19,
	1,
	'select any parameter from instances of SM_EVTDI
                                          where (selected.SMedi_ID == param.id);
if(not_empty parameter)
  // for each message associated with this
  // event, create a message argument.
  select many messages related by self->MSG_E[R1009]->MSG_AM[R1019]
                                                                 ->MSG_M[R1018];
  for each message in messages
    create object instance arg of MSG_A;
    create object instance ea of MSG_EA;
    relate ea to parameter across R1017;
    relate ea to arg across R1013;
    relate message to arg across R1001;
  end for;
end if;
',
	1,
	'',
	1828);
INSERT INTO O_TPARM
	VALUES (1831,
	1830,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1832,
	1488,
	'getPath',
	'',
	322,
	1,
	'result= self.Drv_Lbl;
select one sm related by self ->SM_SM[R502];
select one classSM related by sm->SM_ASM[R517];
select one instSM related by sm->SM_ISM[R517];
if (not_empty classSM)
    select one modelClass related by classSM->O_OBJ[R519];
    result =result+"::Class Based Satate Machine::"+modelClass.getPath(path:modelClass.Name,includeSelf:true);
elif (not_empty instSM)
    select one modelClass related by instSM->O_OBJ[R518];
    result =result+"::Instance Based Satate Machine::"+modelClass.getPath(path:modelClass.Name,includeSelf:true);
end if; 

return result;




',
	1,
	'',
	1830);
INSERT INTO O_TFR
	VALUES (1833,
	1488,
	'getCachedDrv_Lbl',
	'Translate: native',
	322,
	1,
	'	return m_drv_lbl;',
	0,
	'',
	1832);
INSERT INTO O_TFR
	VALUES (1834,
	1488,
	'checkIntegrity',
	'',
	19,
	1,
	'/**
 *  Create integrity issues if there are any other events with a
 *  matching signature or events sharing the same event number
 */
select one machine related by self->SM_SM[R502];
select one clazz related by machine->SM_ISM[R517]->O_OBJ[R518];
if(empty clazz)
  select one clazz related by machine->SM_ASM[R517]->O_OBJ[R519];
end if;
select one package related by clazz->PE_PE[R8001]->EP_PKG[R8000];
select one system related by package->S_SYS[R1405];
sys_id = GD::NULL_UNIQUE_ID();
if(not_empty system)
  sys_id = system.Sys_ID;
end if;
select many events related by machine->SM_EVT[R502];
for each evt in events
  if(evt != self and evt.getSignature() == self.getSignature())
    MI_IM::createIssue(sys_id:sys_id, description:
               "Found another event under the same state machine with a " +
                                                          "matching signature."
          + GD::newline() + GD::newline() + "Signature: " + self.getSignature(),
                                      severity:Severity::Error, name:self.Mning,
                           path:self.getPath(),
                            id:self.SMevt_ID, element:self.convertToInstance());
  end if;
  if(evt != self and evt.Numb == self.Numb)
    MI_IM::createIssue(sys_id:sys_id, description:
               "Found another event under the same state machine with a " +
                                                          "matching number.",
                                      severity:Severity::Error, name:self.Mning,
                           path:self.getPath(),
                            id:self.SMevt_ID, element:self.convertToInstance());    
  end if;
end for;',
	1,
	'',
	1833);
INSERT INTO O_TFR
	VALUES (1835,
	1488,
	'getSignature',
	'',
	322,
	1,
	'/**
 *  Return a string representation of this events signature
 */
signature = self.Mning;
count = 0;
select many parameters related by self->SM_EVTDI[R532];
paramLength = cardinality parameters;
if(paramLength > 0)
  signature = signature + "(";
end if;
for each parameter in parameters
  select one type related by parameter->S_DT[R524];
  if(count > 0 and count != paramLength - 1)
    signature = signature + ", ";
  end if;
  signature = signature + type.Name;
  count = count + 1;
end for;
if(paramLength > 0)
  signature = signature + ")";
end if;
return signature;',
	1,
	'',
	1834);
INSERT INTO O_NBATTR
	VALUES (1604,
	1488);
INSERT INTO O_BATTR
	VALUES (1604,
	1488);
INSERT INTO O_ATTR
	VALUES (1604,
	1488,
	0,
	'SMevt_ID',
	'Full Name: State Machine Event Identifier',
	'',
	'SMevt_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_REF
	VALUES (1488,
	565,
	0,
	564,
	1487,
	1489,
	1490,
	1603,
	1836,
	0,
	0,
	'',
	'State Machine',
	'SM_ID',
	'R502');
INSERT INTO O_REF
	VALUES (1488,
	1583,
	0,
	1586,
	1587,
	1588,
	1589,
	1603,
	1837,
	1836,
	0,
	'',
	'Event Supplemental Data',
	'SM_ID',
	'R520.''carries''');
INSERT INTO O_RATTR
	VALUES (1603,
	1488,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (1603,
	1488,
	1604,
	'SM_ID',
	'',
	'',
	'SM_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1488,
	1583,
	0,
	1585,
	1587,
	1588,
	1589,
	1605,
	1838,
	0,
	0,
	'',
	'Event Supplemental Data',
	'SMspd_ID',
	'R520.''carries''');
INSERT INTO O_RATTR
	VALUES (1605,
	1488,
	1585,
	1583,
	1,
	'SMspd_ID');
INSERT INTO O_ATTR
	VALUES (1605,
	1488,
	1603,
	'SMspd_ID',
	'',
	'',
	'SMspd_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1839,
	1488);
INSERT INTO O_BATTR
	VALUES (1839,
	1488);
INSERT INTO O_ATTR
	VALUES (1839,
	1488,
	1605,
	'Numb',
	'Full Name: Event Number
min_value: 0
max_value: 9999
',
	'',
	'Numb',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1840,
	1488);
INSERT INTO O_BATTR
	VALUES (1840,
	1488);
INSERT INTO O_ATTR
	VALUES (1840,
	1488,
	1839,
	'Mning',
	'Full Name: Event Meaning',
	'',
	'Mning',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1841,
	1488);
INSERT INTO O_BATTR
	VALUES (1841,
	1488);
INSERT INTO O_ATTR
	VALUES (1841,
	1488,
	1840,
	'Is_Lbl_U',
	'Full Name: State Machine Event Label Unique Indicator
Description: This is a flag that indicates whether custom label keyletters are used for the event.
Data Domain: 0 = class keyletters are used, 1 = custom label keyletters are used
enum0: Class Keyletters
enum1: Custom Keyletters
',
	'',
	'Is_Lbl_U',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1842,
	1488);
INSERT INTO O_BATTR
	VALUES (1842,
	1488);
INSERT INTO O_ATTR
	VALUES (1842,
	1488,
	1841,
	'Unq_Lbl',
	'''Full Name: State Machine Event Unique Label
Description: Custom keyletters for the state machine event',
	'',
	'Unq_Lbl',
	0,
	322,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (1843,
	1488,
	'If ( self. Is_Lbl_U == 0 )
  select one nlevt related by self->SM_SEVT[R525]->SM_NLEVT[R526];
  if ( not_empty nlevt )
    select one poly related by nlevt->SM_PEVT[R527];
    select one pevt related by poly->SM_EVT[R525];
    if ( not_empty pevt )
      self.Drv_Lbl = pevt.Drv_Lbl + "*";
    else
      if(not_empty poly)
        self.Drv_Lbl = poly.localClassKL + GD::int_to_string(value:self.Numb) + "*";
      else
        self.Drv_Lbl = ::getOrphanedElementKL() +  GD::int_to_string(value:self.Numb) + "*";
      end if;
    end if;
  else
    select one cl related by self->SM_SM[R502]->SM_ISM[R517]->O_OBJ[R518];
    if ( empty cl )
      select one cl related by self->SM_SM[R502]->SM_ASM[R517]->O_OBJ[R519];
      if ( not_empty cl )
        select one signalEvt related by self->SM_SEVT[R525]->SM_SGEVT[R526];
        if(not_empty signalEvt)
          self.Drv_Lbl = signalEvt.get_name();
        else
          self.Drv_Lbl = cl.Key_Lett + "_A" +  GD::int_to_string(value:self.Numb);
        end if;
      else
       // may be orphaned during dispose operation
        self.Drv_Lbl = self.getCachedDrv_Lbl() +  GD::int_to_string(value:self.Numb);
      end if;
    else
      select one signalEvt related by self->SM_SEVT[R525]->SM_SGEVT[R526];
      if(not_empty signalEvt)
        self.Drv_Lbl = signalEvt.get_name();
      else
        self.Drv_Lbl = cl.Key_Lett +  GD::int_to_string(value:self.Numb);
      end if;
    end if;
  end if;
else
  self.Drv_Lbl = self.Unq_Lbl +  GD::int_to_string(value:self.Numb);
end if;',
	1);
INSERT INTO O_BATTR
	VALUES (1843,
	1488);
INSERT INTO O_ATTR
	VALUES (1843,
	1488,
	1842,
	'Drv_Lbl',
	'Full Name: State Machine Event Derived Label
Description: contains  the event label derived by concatenating the keyletters and the event number.
Data Domain: 0 = derived label created by concatenating class keyletters + event number, 1 = derived label created by concatenating Unq_Lbl with event number',
	'',
	'Drv_Lbl',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1844,
	1488);
INSERT INTO O_BATTR
	VALUES (1844,
	1488);
INSERT INTO O_ATTR
	VALUES (1844,
	1488,
	1843,
	'Descrip',
	'Full Name: Description',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	1488);
INSERT INTO O_OIDA
	VALUES (1604,
	1488,
	0,
	'SMevt_ID');
INSERT INTO O_ID
	VALUES (1,
	1488);
INSERT INTO O_OIDA
	VALUES (1603,
	1488,
	1,
	'SM_ID');
INSERT INTO O_OIDA
	VALUES (1604,
	1488,
	1,
	'SMevt_ID');
INSERT INTO O_OIDA
	VALUES (1605,
	1488,
	1,
	'SMspd_ID');
INSERT INTO O_ID
	VALUES (2,
	1488);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (565,
	'State Machine',
	501,
	'SM_SM',
	'A State Machine represents the lifecycle of a class in terms of states, transitions, events, and actions.',
	1478);
INSERT INTO O_TFR
	VALUES (1845,
	565,
	'get_name',
	'Creates a string containing a descriptive name for the instance.',
	322,
	1,
	'select one ism related by self->SM_ISM[R517];
if not_empty ism
  return ism.get_name();
else
  select one asm related by self->SM_ASM[R517];
  if not_empty asm
    return asm.get_name();
  else
    // during import, may not be related yet
    return "";
  end if;
end if;
',
	1,
	'',
	1846);
INSERT INTO O_TFR
	VALUES (1847,
	565,
	'newState',
	'Create a new State in this State Machine',
	19,
	1,
	'create object instance st of SM_STATE;
relate self to st across R501;
st.initialize();',
	1,
	'',
	1848);
INSERT INTO O_TFR
	VALUES (1849,
	565,
	'dispose',
	'The dispose operation for this class.
',
	19,
	1,
	'select one ism related by self->SM_ISM[R517];
if (not_empty ism)
  select one ismclass related by ism->O_OBJ[R518];
  select any attr related by ismclass->O_ATTR[R102] where selected.Name == "current_state";
  if (not_empty attr)
    attr.dispose();
  end if;
  unrelate ism from ismclass across R518;
  unrelate self from ism across R517;
  delete object instance ism;
end if;
select one asm related by self->SM_ASM[R517];
if (not_empty asm)
  select one asmclass related by asm->O_OBJ[R519];
  unrelate asm from asmclass across R519;
  unrelate self from asm across R517;
  delete object instance asm;
end if;
select many evts related by self->SM_EVT[R502];
for each evt in evts
  evt.dispose();
end for;
select many evtdis related by self->SM_EVTDI[R516];
for each evtdi in evtdis
  evtdi.dispose();
end for;
select many supdts related by self->SM_SUPDT[R523];
for each supdt in supdts
  supdt.dispose();
end for;
select many states related by self->SM_STATE[R501];
for each state in states
  state.dispose();
end for;
select many trans related by self->SM_TXN[R505];
for each tran in trans
  tran.dispose();
end for;
// moore.dispose will clean up all actions to related to this SM_SM
//select many actions related by self->SM_ACT[R515];
//for each action in actions
//end for;
select one moore related by self->SM_MOORE[R510];
if (not_empty moore)
  moore.dispose();
end if;
//
select many aps related by self->CA_ACC[R416];
for each ap in aps
  ap.dispose();
end for;
select many ecps related by self->CA_EESMC[R403]->CA_COMM[R401];
for each ecp in ecps
  ecp.dispose();
end for;
select many scps related by self->CA_SMSMC[R406]->CA_COMM[R401];
for each scp in scps
  scp.dispose();
end for;
select many ocps related by self->CA_SMSMC[R407]->CA_COMM[R401];
for each ocp in ocps
  ocp.dispose();
end for;
select many secps related by self->CA_SMEEC[R410]->CA_COMM[R401];
for each secp in secps
  secp.dispose();
end for;
delete object instance self;',
	1,
	'',
	1850);
INSERT INTO O_TFR
	VALUES (1848,
	565,
	'newEvent',
	'Create a new Event in this State Machine',
	19,
	1,
	'create object instance newEvent of SM_EVT;
relate self to newEvent across R502;
newEvent.initialize();

',
	1,
	'',
	1851);
INSERT INTO O_TFR
	VALUES (1852,
	565,
	'newTransition',
	'',
	316,
	1,
	'select any fromState related by self->SM_STATE[R501] where (selected.SMstt_ID == param.from);
select any toState related by self->SM_STATE[R501] where (selected.SMstt_ID == param.to);
if (not_empty fromState and not_empty toState)
  create object instance tr of SM_TXN;
  create object instance net of SM_NETXN;
  relate tr to net across R507;
  relate net to fromState across R508;
  relate tr to toState across R506;
  relate self to tr across R505;
  tr.initialize();
  return true;
else
  return false;
end if;',
	1,
	'',
	1847);
INSERT INTO O_TPARM
	VALUES (1853,
	1852,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (1854,
	1852,
	'to',
	296,
	0,
	'',
	1853,
	'');
INSERT INTO O_TFR
	VALUES (1851,
	565,
	'newCreationTransition',
	'',
	316,
	1,
	'//
// Note: for compatibility with BridgePoint builder, the
// target state ID is passed in the from argument.
//
select any state related by self->SM_STATE[R501] where (selected.SMstt_ID == param.from);
if (not_empty state)
  create object instance tr of SM_TXN;
  create object instance ct of SM_CRTXN;
  relate tr to ct across R507;
  relate tr to state across R506;
  relate self to tr across R505;
  tr.initialize();
  return true;
else
  return false;
end if;',
	1,
	'',
	1855);
INSERT INTO O_TPARM
	VALUES (1856,
	1851,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (1857,
	1851,
	'to',
	296,
	0,
	'',
	1856,
	'');
INSERT INTO O_TFR
	VALUES (1858,
	565,
	'canAssignEvent',
	'',
	316,
	1,
	'/*
This operation only exists because of a bug in MC-Java where an operation may 
not be called on the selected item in the where clause of a select statement.
There is a function in cme_functions.sql that needs to call 
[State Machine Event].isAssignableToStateMachine() in such a circumstance, 
so it instead calls this, which then makes the desired call.
*/

select any event from instances of SM_EVT 
	where selected.SMevt_ID == param.eventId 
	and selected.SM_ID == param.eventStateMachineId;
if(not_empty event)
  return event.isAssignableToStateMachine(assignToMachineId:self.SM_ID,
	  isCreationTransition:param.isCreationTransition);
end if;
return false;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (1859,
	1858,
	'eventId',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (1860,
	1858,
	'eventStateMachineId',
	296,
	0,
	'',
	1859,
	'');
INSERT INTO O_TPARM
	VALUES (1861,
	1858,
	'isCreationTransition',
	316,
	0,
	'',
	1860,
	'');
INSERT INTO O_TFR
	VALUES (1862,
	565,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.SM_ID;',
	1,
	'',
	1845);
INSERT INTO O_TFR
	VALUES (1863,
	565,
	'pasteTransition',
	'',
	19,
	1,
	'select any transition from instances of SM_TXN where
                                                  selected.Trans_ID == param.id;
if(not_empty transition)
  // update the association of the Action to the new state machine
  select one action related by transition->SM_TAH[R530]->
                                                      SM_AH[R513]->SM_ACT[R514];
  if(not_empty action)
    select one prevMachine related by action->SM_SM[R515];
    if(not_empty prevMachine)
      unrelate action from prevMachine across R515;
    end if;
    relate action to self across R515;
  end if;
  select one existingSM related by transition->SM_SM[R505];
  if(not_empty existingSM)
    unrelate transition from existingSM across R505;
  end if;
  relate transition to self across R505;
  transition.updateAssignedEventOrSignal();
end if;',
	1,
	'',
	1864);
INSERT INTO O_TPARM
	VALUES (1865,
	1863,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1864,
	565,
	'pasteStateMachineState',
	'',
	19,
	1,
	'select any state from instances of SM_STATE where (selected.SMstt_ID == param.id);
if(not_empty state)
  // remove any matrix entries where the event is not copied as well
  select many semes related by state->SM_SEME[R503];
  for each seme in semes
    select one semEvt related by seme->SM_SEVT[R503];
    if(empty semEvt)
      seme.dispose();
    end if;
  end for;
  // update the association of the Action to the new state machine
  select one action related by state->SM_MOAH[R511]->SM_AH[R513]->SM_ACT[R514];
  select one prevMachine related by action->SM_SM[R515];
  if(not_empty prevMachine)
    unrelate action from prevMachine across R515;
  end if;
  select one ism related by self->SM_ISM[R517];
  select one asm related by self->SM_ASM[R517];
  relate action to self across R515;
  if(not_empty asm)
    // guarantee unique name
    state.Name = ::getUniqueInitialNameInParent(instance:state.convertToInstance(),
  						name:state.Name, parent:asm.convertToInstance());
  elif(not_empty ism)
    // guarantee unique name
    state.Name = ::getUniqueInitialNameInParent(instance:state.convertToInstance(),
  						name:state.Name, parent:ism.convertToInstance());  
  end if;
  select one mah related by state->SM_MOAH[R511];
  select one prevMooreMachine related by mah->SM_MOORE[R511];
  if(not_empty prevMooreMachine)
    unrelate state from prevMooreMachine across R511 using mah;
  end if;
  select one msm related by self->SM_MOORE[R510];
  relate state to msm across R511 using mah;
  // guarantee unique state number
  select many existingStates related by self->SM_STATE[R501];
  select any sameNumberState related by self->SM_STATE[R501] where (selected.Numb == state.Numb);
  if(not_empty sameNumberState)
    greatestNumb = 1;
    for each existingState in existingStates
      // store the greatest state number
      if(existingState.Numb > greatestNumb)
        greatestNumb = existingState.Numb;
      end if;
    end for;
    state.Numb = greatestNumb + 1;
  end if;
  // create SEM entry instances
  //
  select many event_set related by self->SM_EVT[R502]->SM_SEVT[R525];
  for each event in event_set
    create object instance sem of SM_SEME;
    // TODO: get default subtype from preferences
    create object instance ch of SM_CH;
    relate state to event across R503 using sem;
    relate ch to sem across R504;
  end for;
  relate state to self across R501;
end if;',
	1,
	'',
	1852);
INSERT INTO O_TPARM
	VALUES (1866,
	1864,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1867,
	565,
	'removeIncompleteNonLocalEvents',
	'',
	19,
	1,
	'// for each non-local event in this machine, convert
// it to a local one if necessary
select many evts related by self->SM_EVT[R502];
for each evt in evts
  select one nlevt related by evt->SM_SEVT[R525]->SM_NLEVT[R526];
  if(not_empty nlevt)
    nlevt.resolveInheritedEvent();
  end if;
  select one sigEvt related by evt->SM_SEVT[R525]->SM_SGEVT[R526];
  if(not_empty sigEvt)
    // for all transitions that this event is assigned to
    select many transitions related by evt->SM_SEVT[R525]->SM_SEME[R503]
                                                 ->SM_NSTXN[R504]->SM_TXN[R507];
    for each transition in transitions
      // have the transition update the signal
      transition.updateAssignedSignal();
    end for;
  end if;
end for;',
	1,
	'',
	1863);
INSERT INTO O_TFR
	VALUES (1868,
	565,
	'findMatchingEvent',
	'',
	296,
	1,
	'/*
Find an event within this machine that matches the given event.
The event will match if the name and signature are identical.
*/
foundMatch = false;
select any existingEvt related by self->SM_EVT[R502];
select any evt from instances of SM_EVT where (selected.SMevt_ID == param.id);
if(not_empty evt)
  select one nlevt related by evt->SM_SEVT[R525]->SM_NLEVT[R526];
  isPoly = false;
  if(not_empty nlevt)
    isPoly = true;
  end if;
  name = evt.Mning;
  numb = evt.Numb;
  select many events related by self->SM_EVT[R502];
  for each existingEvent in events
    if(param.isCreation)
      select many creationTransitionsAssigned related by events->
                                   SM_SEVT[R525]->SM_LEVT[R526]->SM_CRTXN[R509];
      if(not (cardinality events > cardinality creationTransitionsAssigned))
        // if all events are used by other creation transitions we
        // cannot use an existing one
        continue;
      else
        select any otherEvt related by self->SM_EVT[R502] where
                                                         selected.Mning == name;
        select one existingCreationTrans related by otherEvt->SM_SEVT[R525]->
                                                  SM_LEVT[R526]->SM_CRTXN[R509];
        if(not_empty existingCreationTrans)
          // if the resolved event is already assigned to a creation transition
          // it cannot be used
          continue;
        end if;
      end if;
    end if;
    if(existingEvent.Mning == name)
      // we cannot use any event that is a polymorphic event and that
      // is referenced by any subtype 
      select one poly related by existingEvent->SM_PEVT[R525];
      if(not_empty poly)
        select any nlevt related by poly->SM_NLEVT[R527];
        if(not_empty nlevt)
          select any evtSM from instances of SM_SM where
                                              selected.SM_ID == param.machineID;
          if(evtSM == self)
            // can''t be used
            continue;
          end if;
        end if;
      end if;
      foundMatch = true;
      existingEvt = existingEvent;
      break;
    end if;
  end for;
end if;
if(foundMatch)
  return existingEvt.SMevt_ID;
end if;
return GD::NULL_UNIQUE_ID();',
	1,
	'',
	1849);
INSERT INTO O_TPARM
	VALUES (1869,
	1868,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (1870,
	1868,
	'isCreation',
	316,
	0,
	'',
	1869,
	'');
INSERT INTO O_TPARM
	VALUES (1871,
	1868,
	'machineID',
	296,
	0,
	'',
	1870,
	'');
INSERT INTO O_TFR
	VALUES (1850,
	565,
	'canAssignSignal',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
/* State Machine.canAssignSignal
This operation only exists because of a bug in generator where an operation may
not be called on the selected item in the where clause of a select statement.
There is a function in cme_functions.sql that needs to call
[Required/Provided Signal].canAssignSignal in such a circumstance,
so it instead calls this, which then makes the desired call.
*/
select any interfaceSignal related by self->SM_ASM[R517]->O_OBJ[R519]->S_SS[R2]
     ->S_DOM[R1]->CN_DC[R4204]->C_C[R4204]->C_PO[R4010]->C_IR[R4016]->C_I[R4012]
                           ->C_EP[R4003] where (selected.Id == param.signal_id);

select one packageableElem related by self->SM_ASM[R517]->O_OBJ[R519]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
isInGenericPackage = not_empty package;
if (isInGenericPackage)
  // Check for isInGenericPackage
  select any containingComponent from instances of C_C where
                                            selected.Id == GD::NULL_UNIQUE_ID();
  if not_empty package
    containingComponentId = package.getContainingComponentId();
    select any containingComponent from instances of C_C where
                                           selected.Id == containingComponentId;
  end if;
  select any interfaceSignal related by containingComponent->C_PO[R4010]->
                                        C_IR[R4016]->C_I[R4012]->C_EP[R4003] 
                                         where (selected.Id == param.signal_id);
end if;

select any reqEP related by interfaceSignal->SPR_REP[R4500] where
                               selected.ExecutableProperty_Id == param.signal_id
                              and selected.Requirement_Id == param.interface_id;
if not_empty reqEP
  select one reqSig related by reqEP->SPR_RS[R4502];
  return reqSig.isAvailableForAllocationTo(transition_id:param.transition_id);
else
  select any provEP related by interfaceSignal->SPR_PEP[R4501] where
                               selected.ExecutableProperty_Id == param.signal_id
                                and selected.Provision_Id == param.interface_id;
  if not_empty provEP
    select one provSig related by provEP->SPR_PS[R4503];
    return provSig.isAvailableForAllocationTo(transition_id:
                                                           param.transition_id);
  end if;
end if;
return false;',
	1,
	'',
	1858);
INSERT INTO O_TPARM
	VALUES (1872,
	1850,
	'signal_id',
	296,
	0,
	'',
	1873,
	'');
INSERT INTO O_TPARM
	VALUES (1874,
	1850,
	'transition_id',
	296,
	0,
	'',
	1872,
	'');
INSERT INTO O_TPARM
	VALUES (1873,
	1850,
	'interface_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1855,
	565,
	'hasValidSignals',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// State Machine.hasValidSignals()
select any ifRef related by self->SM_ASM[R517]->O_OBJ[R519]->
           S_SS[R2]->S_DOM[R1]->CN_DC[R4204]->C_C[R4204]->C_PO[R4010]->
                            C_IR[R4016] where selected.Id == param.interface_id;

select one packageableElem related by self->SM_ASM[R517]->O_OBJ[R519]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
isInGenericPackage = not_empty package;
if (isInGenericPackage)
  containingComponentId = package.getContainingComponentId();
  select any containingComponent from instances of C_C where
                                           selected.Id == containingComponentId;
  select any ifRef related by containingComponent->C_PO[R4010]->C_IR[R4016] 
                                        where selected.Id == param.interface_id;
end if;

select many signals related by ifRef->C_I[R4012]->C_EP[R4003]->C_AS[R4004];
for each sig in signals
  if self.canAssignSignal(signal_id:sig.Id, transition_id:param.transition_id,
                                                          interface_id:ifRef.Id)
    return true;
  end if;
end for;
return false;',
	1,
	'',
	1862);
INSERT INTO O_TPARM
	VALUES (1875,
	1855,
	'interface_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (1876,
	1855,
	'transition_id',
	296,
	0,
	'',
	1875,
	'');
INSERT INTO O_TFR
	VALUES (1846,
	565,
	'getContainingComponentId',
	'',
	296,
	1,
	'select one clazz related by self->SM_ASM[R517]->O_OBJ[R519];
if(empty clazz)
  select one clazz related by self->SM_ISM[R517]->O_OBJ[R518];
end if;
return clazz.getContainingComponentId();',
	1,
	'',
	1868);
INSERT INTO O_TFR
	VALUES (1877,
	565,
	'getContainerId',
	'',
	296,
	1,
	'// State Machine.getContainerId()
select one clazz related by self->SM_ASM[R517]->O_OBJ[R519];
if(empty clazz)
  select one clazz related by self->SM_ISM[R517]->O_OBJ[R518];
end if;
return clazz.getContainerId();',
	1,
	'',
	1867);
INSERT INTO O_TFR
	VALUES (1878,
	565,
	'pasteStateMachineEvent',
	'',
	19,
	1,
	'select any evt from instances of SM_EVT where (selected.SMevt_ID == param.id);
if(not_empty evt)
  select one existingMachine related by evt->SM_SM[R502];
  if(not_empty existingMachine)
    unrelate existingMachine from evt across R502;
  end if;
  relate self to evt across R502;
  select one ism related by self->SM_ISM[R517];
  if(not_empty ism)
    evt.Mning = ::getUniqueInitialNameInParent( 
      instance: evt.convertToInstance(), 
      name: evt.Mning, parent:ism.convertToInstance());
  else
    select one asm related by self->SM_ASM[R517];
    evt.Mning = ::getUniqueInitialNameInParent( 
      instance: evt.convertToInstance(), 
      name: evt.Mning, parent:asm.convertToInstance());    
  end if;
  evt.setUniqueNumber(checkForDuplicate:false);
  select one sem related by evt->SM_SEVT[R525];
  sem.createDefaultMatrixEntries();
  // for each data item copied associate it with
  // self
  select many items related by evt->SM_EVTDI[R532];
  for each item in items
    select one existingSm related by item->SM_SM[R516];
    if(not_empty existingSm)
      unrelate item from existingSm across R516;
    end if;
    relate item to self across R516;
  end for;
end if;',
	1,
	'',
	1877);
INSERT INTO O_TPARM
	VALUES (1879,
	1878,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1880,
	565,
	'canCopyStateMachineEvent',
	'',
	316,
	1,
	'select any evt from instances of SM_EVT where (selected.SMevt_ID == param.id);
if(not_empty evt)
  select one poly related by evt->SM_PEVT[R525];
  if(not_empty poly)
    return false;
  end if;
  select one nonlocal related by evt->SM_SEVT[R525]->SM_NLEVT[R526];
  if(not_empty nonlocal)
    return false;
  end if;
else
  return false;
end if;
return true;',
	1,
	'',
	1878);
INSERT INTO O_TPARM
	VALUES (1881,
	1880,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1882,
	565,
	'removeIncompleteSignalEvents',
	'',
	19,
	1,
	'// for each signal event in this machine, convert
// it to a local one if necessary
select many evts related by self->SM_EVT[R502];
for each evt in evts
  select one sigEvt related by evt->SM_SEVT[R525]->SM_SGEVT[R526];
  if(not_empty sigEvt)
    // for all transitions that this event is assigned to
    select many transitions related by evt->SM_SEVT[R525]->SM_SEME[R503]
                                                 ->SM_NSTXN[R504]->SM_TXN[R507];
    for each transition in transitions
      // have the transition update the signal
      transition.updateAssignedSignal();
    end for;
  end if;
end for;',
	1,
	'',
	1880);
INSERT INTO O_TFR
	VALUES (1883,
	565,
	'getPath',
	'',
	322,
	1,
	'result= "";
select one classSM related by self->SM_ASM[R517];
select one instSM related by self->SM_ISM[R517];
if (not_empty classSM)
    select one modelClass related by classSM->O_OBJ[R519];
    result ="::Class Based Satate Machine::"+modelClass.getPath(path:modelClass.Name,includeSelf:true);
elif (not_empty instSM)
    select one modelClass related by instSM->O_OBJ[R518];
    result ="::Instance Based Satate Machine::"+modelClass.getPath(path:modelClass.Name,includeSelf:true);
end if; 

return result;

',
	1,
	'',
	1882);
INSERT INTO O_NBATTR
	VALUES (564,
	565);
INSERT INTO O_BATTR
	VALUES (564,
	565);
INSERT INTO O_ATTR
	VALUES (564,
	565,
	0,
	'SM_ID',
	'Full Name: State Machine Identifier',
	'',
	'SM_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1884,
	565);
INSERT INTO O_BATTR
	VALUES (1884,
	565);
INSERT INTO O_ATTR
	VALUES (1884,
	565,
	564,
	'Descrip',
	'Full Name: Description
User_Visible:false',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1885,
	565);
INSERT INTO O_BATTR
	VALUES (1885,
	565);
INSERT INTO O_ATTR
	VALUES (1885,
	565,
	1884,
	'Config_ID',
	'Full Name: Configuration Identifier
Description: The component ID of  this state machine.
impl_detail: true
min_value: 0
max_value: 510
readonly: true
User_Visible:false
',
	'',
	'Config_ID',
	0,
	298,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	565);
INSERT INTO O_OIDA
	VALUES (564,
	565,
	0,
	'SM_ID');
INSERT INTO O_ID
	VALUES (1,
	565);
INSERT INTO O_ID
	VALUES (2,
	565);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (1496,
	'State Event Matrix Entry',
	504,
	'SM_SEME',
	'This class represents an entry in the state event matrix (SEM).  A state event matrix entry describes what happens in each state (SM_STATE) for each event (SM_EVT).  The SEM can be thought of as a two-dimensional array where the states of a state machine  are represented by rows and events are represented by columns.  An entry consists of one of the following: transition to another state, event ignored, event cant happen.',
	1478);
INSERT INTO O_TFR
	VALUES (1886,
	1496,
	'get_name',
	'Creates a string containing a descriptive name for the instance.',
	322,
	1,
	'select one evt related by self->SM_SEVT[R503]->SM_EVT[R525];
if(empty evt)
  return "State Event Matrix Entry (" + ::getOrphanedElementName() + ")";
end if;
return "State Event Matrix Entry (" + evt.get_name() + ")";
',
	1,
	'',
	1887);
INSERT INTO O_TFR
	VALUES (1888,
	1496,
	'dispose',
	'Dispose this SM_SEME.
',
	19,
	1,
	'select one fromState related by self->SM_STATE[R503];
select one event related by self->SM_SEVT[R503];
unrelate fromState from event across R503 using self;
self.disposeChOrEi();
select one nstxn related by self->SM_NSTXN[R504];
if (not_empty nstxn)
  unrelate self from nstxn across R504;
  select one txn related by nstxn->SM_TXN[R507];
  create object instance netxn of SM_NETXN;
  unrelate nstxn from txn across R507;
  relate txn to netxn across R507;
  relate fromState to netxn across R508;
  delete object instance nstxn;
end if;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (1889,
	1496,
	'migrateChToEi',
	'',
	19,
	1,
	'select one ch related by self->SM_CH[R504];
if ( not_empty ch )
  create object instance ei of SM_EIGN;
  unrelate self from ch across R504;
  relate self to ei across R504;
  delete object instance ch;
end if;
',
	1,
	'',
	1886);
INSERT INTO O_TFR
	VALUES (1890,
	1496,
	'migrateEiToCh',
	'',
	19,
	1,
	'select one ei related by self->SM_EIGN[R504];
if ( not_empty ei )
  create object instance ch of SM_CH;
  unrelate self from ei across R504;
  relate self to ch across R504;
  delete object instance ei;
end if;
',
	1,
	'',
	1889);
INSERT INTO O_TFR
	VALUES (1887,
	1496,
	'disposeChOrEi',
	'',
	19,
	1,
	'select one chevt related by self->SM_CH[R504];
if (not_empty chevt)
  unrelate self from chevt across R504;
  delete object instance chevt;
end if;
select one igevt related by self->SM_EIGN[R504];
if (not_empty igevt)
  unrelate self from igevt across R504;
  delete object instance igevt;
end if;
',
	1,
	'',
	1888);
INSERT INTO O_TFR
	VALUES (1891,
	1496,
	'mergeDispose',
	'',
	19,
	1,
	'select one fromState related by self->SM_STATE[R503];
select one event related by self->SM_SEVT[R503];
unrelate fromState from event across R503 using self;
self.disposeChOrEi();
delete object instance self;
',
	1,
	'',
	1890);
INSERT INTO O_REF
	VALUES (1496,
	1492,
	0,
	1522,
	1610,
	1616,
	1611,
	1501,
	1892,
	0,
	0,
	'',
	'State Machine State',
	'SMstt_ID',
	'R503');
INSERT INTO O_RATTR
	VALUES (1501,
	1496,
	1522,
	1492,
	1,
	'SMstt_ID');
INSERT INTO O_ATTR
	VALUES (1501,
	1496,
	0,
	'SMstt_ID',
	'

',
	'',
	'SMstt_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1496,
	1606,
	0,
	1613,
	1610,
	1616,
	1612,
	1499,
	1893,
	0,
	0,
	'',
	'SEM Event',
	'SMevt_ID',
	'R503');
INSERT INTO O_RATTR
	VALUES (1499,
	1496,
	1604,
	1488,
	1,
	'SMevt_ID');
INSERT INTO O_ATTR
	VALUES (1499,
	1496,
	1501,
	'SMevt_ID',
	'

',
	'',
	'SMevt_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1496,
	1492,
	0,
	1521,
	1610,
	1616,
	1611,
	1500,
	1894,
	0,
	0,
	'',
	'State Machine State',
	'SM_ID',
	'R503');
INSERT INTO O_REF
	VALUES (1496,
	1606,
	0,
	1614,
	1610,
	1616,
	1612,
	1500,
	1895,
	1894,
	0,
	'',
	'SEM Event',
	'SM_ID',
	'R503');
INSERT INTO O_RATTR
	VALUES (1500,
	1496,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (1500,
	1496,
	1499,
	'SM_ID',
	'

',
	'',
	'SM_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1496,
	1606,
	0,
	1615,
	1610,
	1616,
	1612,
	1498,
	1896,
	0,
	0,
	'',
	'SEM Event',
	'SMspd_ID',
	'R503');
INSERT INTO O_RATTR
	VALUES (1498,
	1496,
	1585,
	1583,
	1,
	'SMspd_ID');
INSERT INTO O_ATTR
	VALUES (1498,
	1496,
	1500,
	'SMspd_ID',
	'

',
	'',
	'SMspd_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	1496);
INSERT INTO O_OIDA
	VALUES (1498,
	1496,
	0,
	'SMspd_ID');
INSERT INTO O_OIDA
	VALUES (1499,
	1496,
	0,
	'SMevt_ID');
INSERT INTO O_OIDA
	VALUES (1500,
	1496,
	0,
	'SM_ID');
INSERT INTO O_OIDA
	VALUES (1501,
	1496,
	0,
	'SMstt_ID');
INSERT INTO O_ID
	VALUES (1,
	1496);
INSERT INTO O_ID
	VALUES (2,
	1496);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (1623,
	'Signal Event',
	528,
	'SM_SGEVT',
	'',
	1478);
INSERT INTO O_TFR
	VALUES (1897,
	1623,
	'dispose',
	'',
	19,
	1,
	'// Signal Event.dispose()
select one provSig related by self->SPR_PS[R528];
if not_empty provSig
  unrelate self from provSig across R528;
end if;
select one reqSig related by self->SPR_RS[R529];
if not_empty reqSig
  unrelate self from reqSig across R529;
end if;
select one sevt related by self->SM_SEVT[R526];
if not_empty sevt
  unrelate self from sevt across R526;
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (1898,
	1623,
	'get_event_text',
	'',
	322,
	1,
	'select one provSig related by self->SPR_PS[R528];
select one reqSig related by self->SPR_RS[R529];
if empty provSig and empty reqSig
  return self.signal_name;
else
  result = self.signal_name;
  select one ifRef related by provSig->SPR_PEP[R4503]->C_P[R4501]
                                                                                                 ->C_IR[R4009];
  if empty ifRef
    select one ifRef related by reqSig->SPR_REP[R4502]->C_R[R4500]
                                                                                                ->C_IR[R4009];
  end if;
  select many parameters related by provSig->SPR_PEP[R4503]->
                                                       C_EP[R4501]->C_PP[R4006];
  if not_empty reqSig
    select many parameters related by reqSig->SPR_REP[R4502]->
                                                                             C_EP[R4500]->C_PP[R4006];
  end if;
  if (not_empty parameters)
    result = result + " (";
    sep = "";
    for each parameter in parameters
      select one dt related by parameter->S_DT[R4007];
      result = result + sep + parameter.Name + ":" + dt.Name;
      sep = ", ";
    end for;
    result = result + ")";
  end if;
  return result;
end if;',
	1,
	'',
	1897);
INSERT INTO O_TFR
	VALUES (1899,
	1623,
	'get_name',
	'',
	322,
	1,
	'//Signal Event.get_name()
return self.signal_name;',
	1,
	'',
	1898);
INSERT INTO O_TFR
	VALUES (1900,
	1623,
	'getCachedSignalName',
	'Translate:native',
	322,
	1,
	'	return m_signal_name;',
	0,
	'',
	1899);
INSERT INTO O_TFR
	VALUES (1901,
	1623,
	'setCachedSignalName',
	'Translate:native',
	19,
	1,
	'	m_signal_name = p_Value;',
	0,
	'',
	1900);
INSERT INTO O_TPARM
	VALUES (1902,
	1901,
	'value',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (1623,
	1606,
	0,
	1613,
	1617,
	1624,
	1618,
	1903,
	1904,
	0,
	0,
	'',
	'SEM Event',
	'SMevt_ID',
	'R526');
INSERT INTO O_RATTR
	VALUES (1903,
	1623,
	1604,
	1488,
	1,
	'SMevt_ID');
INSERT INTO O_ATTR
	VALUES (1903,
	1623,
	0,
	'SMevt_ID',
	'',
	'',
	'SMevt_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1623,
	1606,
	0,
	1614,
	1617,
	1624,
	1618,
	1905,
	1906,
	0,
	0,
	'',
	'SEM Event',
	'SM_ID',
	'R526');
INSERT INTO O_RATTR
	VALUES (1905,
	1623,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (1905,
	1623,
	1903,
	'SM_ID',
	'',
	'',
	'SM_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1623,
	1606,
	0,
	1615,
	1617,
	1624,
	1618,
	1907,
	1908,
	0,
	0,
	'',
	'SEM Event',
	'SMspd_ID',
	'R526');
INSERT INTO O_RATTR
	VALUES (1907,
	1623,
	1585,
	1583,
	1,
	'SMspd_ID');
INSERT INTO O_ATTR
	VALUES (1907,
	1623,
	1905,
	'SMspd_ID',
	'',
	'',
	'SMspd_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1623,
	1483,
	0,
	1637,
	1635,
	1638,
	1636,
	1909,
	1910,
	0,
	0,
	'',
	'Provided Signal',
	'Id',
	'R528');
INSERT INTO O_RATTR
	VALUES (1909,
	1623,
	263,
	61,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (1909,
	1623,
	1907,
	'Provided_Signal_Id',
	'',
	'Provided_Signal_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1623,
	1485,
	0,
	1641,
	1639,
	1642,
	1640,
	1911,
	1912,
	0,
	0,
	'',
	'Required Signal',
	'Id',
	'R529');
INSERT INTO O_RATTR
	VALUES (1911,
	1623,
	267,
	63,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (1911,
	1623,
	1909,
	'Required_Signal_Id',
	'',
	'Required_Signal_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (1913,
	1623,
	'/*
 * Get the signal name for the signal or use the cached value if a signal
 * cannot be found
 */
select one proSignal related by self->SPR_PS[R528];
select one reqSignal related by self->SPR_RS[R529];
if(not_empty proSignal or not_empty reqSignal)
  result = "";
  select one ifRef related by proSignal->SPR_PEP[R4503]->C_P[R4501]->C_IR[R4009];
  if empty ifRef
    select one ifRef related by reqSignal->SPR_REP[R4502]->C_R[R4500]->C_IR[R4009];
  end if;
  select one port related by ifRef->C_PO[R4016];
  if not_empty port
    if port.Name != ""
      result = port.Name + "::";
    else
      select one interface related by ifRef->C_I[R4012];
      if not_empty interface
        if interface.Name != "";
          result = interface.Name + "::";
        end if;
      else
        self.signal_name = self.getCachedSignalName();
      end if;
    end if;
    if not_empty proSignal
      result = result + proSignal.Name;
    else
      result = result + reqSignal.Name;
    end if;
    self.setCachedSignalName(value: result);
    self.signal_name = result;
  else
    self.signal_name = self.getCachedSignalName();
  end if;
else
  self.signal_name = self.getCachedSignalName();
end if; 
',
	1);
INSERT INTO O_BATTR
	VALUES (1913,
	1623);
INSERT INTO O_ATTR
	VALUES (1913,
	1623,
	1911,
	'signal_name',
	'User_Visible:false',
	'',
	'signal_name',
	0,
	322,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	1623);
INSERT INTO O_OIDA
	VALUES (1903,
	1623,
	0,
	'SMevt_ID');
INSERT INTO O_OIDA
	VALUES (1905,
	1623,
	0,
	'SM_ID');
INSERT INTO O_OIDA
	VALUES (1907,
	1623,
	0,
	'SMspd_ID');
INSERT INTO O_ID
	VALUES (1,
	1623);
INSERT INTO O_ID
	VALUES (2,
	1623);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (1606,
	'SEM Event',
	525,
	'SM_SEVT',
	'An SEM (State Event Matrix) event is one that appears in the state event matrix.  Contrast this to a polymorphic event which is defined at the supertype-level but does not appear in the SEM for the super-type.  An SEM event can either be a local event (SM_LEVT), in the case of an event that is defined in the state machine for the class, or a non-local event (SM_NLEVT) which is an alias for a polymorphic event (SM_PEVT) defined in the super-type but accessible via the subtype.',
	1478);
INSERT INTO O_TFR
	VALUES (1914,
	1606,
	'dispose',
	'Dispose this SM_SEVT.',
	19,
	1,
	'select one evt related by self->SM_EVT[R525];
unrelate self from evt across R525;
select many semes related by self->SM_SEME[R503];
for each seme in semes
  seme.dispose();
end for;
select one levt related by self->SM_LEVT[R526];
if (not_empty levt)
  levt.dispose();
end if;
select one nlevt related by self->SM_NLEVT[R526];
if (not_empty nlevt)
  nlevt.dispose();
end if;
select one signalEvt related by self->SM_SGEVT[R526];
if not_empty signalEvt
  signalEvt.dispose();
end if;
delete object instance self;
',
	1,
	'',
	1915);
INSERT INTO O_TFR
	VALUES (1915,
	1606,
	'createDefaultMatrixEntries',
	'',
	19,
	1,
	'/*
Creates a can''t-happen matrix entry for this event for each state in this event''s 
state machine.
*/

// for each state in this event''s state machine
select many states related by self->SM_EVT[R525]->SM_SM[R502]->SM_STATE[R501];
for each state in states
	// create an event-matrix-entry to relate this state to this event
	create object instance entry of SM_SEME;
	relate state to self across R503 using entry;
	
	// create a can''t-happen entry to classify the event-matrix
	// entry created above
	create object instance cantHappen of SM_CH;
	relate cantHappen to entry across R504;
end for;
',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (1606,
	1488,
	1,
	1604,
	1601,
	1607,
	1602,
	1613,
	1916,
	0,
	0,
	'',
	'State Machine Event',
	'SMevt_ID',
	'R525');
INSERT INTO O_RATTR
	VALUES (1613,
	1606,
	1604,
	1488,
	1,
	'SMevt_ID');
INSERT INTO O_ATTR
	VALUES (1613,
	1606,
	0,
	'SMevt_ID',
	'',
	'',
	'SMevt_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1606,
	1488,
	1,
	1603,
	1601,
	1607,
	1602,
	1614,
	1917,
	0,
	0,
	'',
	'State Machine Event',
	'SM_ID',
	'R525');
INSERT INTO O_RATTR
	VALUES (1614,
	1606,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (1614,
	1606,
	1613,
	'SM_ID',
	'',
	'',
	'SM_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1606,
	1488,
	1,
	1605,
	1601,
	1607,
	1602,
	1615,
	1918,
	0,
	0,
	'',
	'State Machine Event',
	'SMspd_ID',
	'R525');
INSERT INTO O_RATTR
	VALUES (1615,
	1606,
	1585,
	1583,
	1,
	'SMspd_ID');
INSERT INTO O_ATTR
	VALUES (1615,
	1606,
	1614,
	'SMspd_ID',
	'',
	'',
	'SMspd_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	1606);
INSERT INTO O_OIDA
	VALUES (1613,
	1606,
	0,
	'SMevt_ID');
INSERT INTO O_OIDA
	VALUES (1614,
	1606,
	0,
	'SM_ID');
INSERT INTO O_OIDA
	VALUES (1615,
	1606,
	0,
	'SMspd_ID');
INSERT INTO O_ID
	VALUES (1,
	1606);
INSERT INTO O_ID
	VALUES (2,
	1606);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (1608,
	'Polymorphic Event',
	522,
	'SM_PEVT',
	'A polymorphic event (SM_PEVT) is one that is defined in a super-type state machine  and used in one or more sub-type state machines.  Each polymorphic event has one or more aliases (SM_NLEVT) in one or more sub-types.',
	1478);
INSERT INTO O_TFR
	VALUES (1919,
	1608,
	'dispose',
	'',
	19,
	1,
	'select one evt related by self->SM_EVT[R525];
unrelate self from evt across R525;
select many nlevts related by self->SM_NLEVT[R527];
for each nlevt in nlevts
  unrelate self from nlevt across R527;
  nlevt.dispose();
end for;
',
	1,
	'',
	1920);
INSERT INTO O_TFR
	VALUES (1920,
	1608,
	'createNonLocalEventForStateMachine',
	'',
	296,
	1,
	'/*
Creates (and returns the ID of) a non-local event that is an alias of this 
polymorphic event for the given state machine.
*/

// create a non-local event to alias this polymorphic event
create object instance nonlocalEvent of SM_NLEVT;
relate nonlocalEvent to self across R527;

// create the supertype instances of the above non-local event, 
// and copy into them the attribute values of the corresponding
// instances of this polymorphic event
create object instance matrixEvent of SM_SEVT;
relate matrixEvent to nonlocalEvent across R526;
create object instance newEvent of SM_EVT;
relate newEvent to matrixEvent across R525;
select one event related by self->SM_EVT[R525];
newEvent.Numb = event.Numb;
newEvent.Mning = event.Mning;
newEvent.Is_Lbl_U = event.Is_Lbl_U;
newEvent.Unq_Lbl = event.Unq_Lbl;
newEvent.Descrip = event.Descrip;
select any machine from instances of SM_SM
	where selected.SM_ID == param.stateMachineId;
relate newEvent to machine across R502;
matrixEvent.createDefaultMatrixEntries();

return newEvent.SMevt_ID;
',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (1921,
	1920,
	'stateMachineId',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1922,
	1608,
	'migrateToLocalEvent',
	'',
	19,
	1,
	'// if there are no more non-local events that are aliasing this
// poly
select many aliases related by self->SM_NLEVT[R527];
if (empty aliases)
  // migrate this polymorphic event back to a local event
  select one event related by self->SM_EVT[R525];
  self.dispose();
  create object instance matrixEvent of SM_SEVT;
  relate matrixEvent to event across R525;
  matrixEvent.createDefaultMatrixEntries();
  create object instance localEvent of SM_LEVT;
  relate localEvent to matrixEvent across R526;
end if;',
	1,
	'',
	1919);
INSERT INTO O_TFR
	VALUES (1923,
	1608,
	'convertToInstance',
	'Translate:native',
	317,
	1,
	'return this;',
	0,
	'',
	1922);
INSERT INTO O_TFR
	VALUES (1924,
	1608,
	'getCachedLocalClassName',
	'Translate:native',
	322,
	1,
	'	return m_localclassname;',
	0,
	'',
	1923);
INSERT INTO O_TFR
	VALUES (1925,
	1608,
	'getCachedLocalClassKL',
	'Translate:native',
	322,
	1,
	'	return m_localclasskl;',
	0,
	'',
	1924);
INSERT INTO O_TFR
	VALUES (1926,
	1608,
	'setCachedLocalClassName',
	'Translate:native',
	19,
	1,
	'	m_localclassname = p_Value;',
	0,
	'',
	1925);
INSERT INTO O_TPARM
	VALUES (1927,
	1926,
	'value',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1928,
	1608,
	'setCachedLocalClassKL',
	'Translate:native',
	19,
	1,
	'	m_localclasskl = p_Value;',
	0,
	'',
	1926);
INSERT INTO O_TPARM
	VALUES (1929,
	1928,
	'value',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (1930,
	1608,
	'get_name',
	'',
	322,
	1,
	'return self.localEventMning;',
	1,
	'',
	1928);
INSERT INTO O_TFR
	VALUES (1931,
	1608,
	'getCachedLocalEventMning',
	'Translate:native',
	322,
	1,
	'	return m_localeventmning;',
	0,
	'',
	1930);
INSERT INTO O_TFR
	VALUES (1932,
	1608,
	'setCachedLocalEventMning',
	'Translate:native',
	19,
	1,
	'	m_localeventmning = p_Value;',
	0,
	'',
	1931);
INSERT INTO O_TPARM
	VALUES (1933,
	1932,
	'value',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (1608,
	1488,
	1,
	1604,
	1601,
	1609,
	1602,
	1633,
	1934,
	0,
	0,
	'',
	'State Machine Event',
	'SMevt_ID',
	'R525');
INSERT INTO O_RATTR
	VALUES (1633,
	1608,
	1604,
	1488,
	1,
	'SMevt_ID');
INSERT INTO O_ATTR
	VALUES (1633,
	1608,
	0,
	'SMevt_ID',
	'',
	'',
	'SMevt_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1608,
	1488,
	1,
	1603,
	1601,
	1609,
	1602,
	1632,
	1935,
	0,
	0,
	'',
	'State Machine Event',
	'SM_ID',
	'R525');
INSERT INTO O_RATTR
	VALUES (1632,
	1608,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (1632,
	1608,
	1633,
	'SM_ID',
	'',
	'',
	'SM_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1608,
	1488,
	1,
	1605,
	1601,
	1609,
	1602,
	1936,
	1937,
	0,
	0,
	'',
	'State Machine Event',
	'SMspd_ID',
	'R525');
INSERT INTO O_RATTR
	VALUES (1936,
	1608,
	1585,
	1583,
	1,
	'SMspd_ID');
INSERT INTO O_ATTR
	VALUES (1936,
	1608,
	1632,
	'SMspd_ID',
	'',
	'',
	'SMspd_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (1938,
	1608,
	'select one clazz related by self->SM_EVT[R525]->SM_SM[R502]->SM_ASM[R517]
                                                                  ->O_OBJ[R519];
if(empty clazz)
  select one clazz related by self->SM_EVT[R525]->SM_SM[R502]->SM_ISM[R517]
                                                                  ->O_OBJ[R518];
end if;
if(not_empty clazz)
  self.setCachedLocalClassName(value: clazz.Name);
  self.localClassName = clazz.Name;
else
  self.localClassName = self.getCachedLocalClassName();
end if;',
	1);
INSERT INTO O_BATTR
	VALUES (1938,
	1608);
INSERT INTO O_ATTR
	VALUES (1938,
	1608,
	1936,
	'localClassName',
	'User_Visible:false',
	'',
	'localClassName',
	0,
	322,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (1939,
	1608,
	'select one clazz related by self->SM_EVT[R525]->SM_SM[R502]->SM_ASM[R517]
                                                                  ->O_OBJ[R519];
if(empty clazz)
  select one clazz related by self->SM_EVT[R525]->SM_SM[R502]->SM_ISM[R517]
                                                                  ->O_OBJ[R518];
end if;
if(not_empty clazz)
  self.setCachedLocalClassKL(value: clazz.Key_Lett);
  self.localClassKL = clazz.Key_Lett;
else
  self.localClassKL = self.getCachedLocalClassKL();
end if;',
	1);
INSERT INTO O_BATTR
	VALUES (1939,
	1608);
INSERT INTO O_ATTR
	VALUES (1939,
	1608,
	1938,
	'localClassKL',
	'User_Visible:false',
	'',
	'localClassKL',
	0,
	322,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (1940,
	1608,
	'select one evt related by self->SM_EVT[R525];
if(not_empty evt)
  self.setCachedLocalEventMning(value: evt.Mning); 
  self.localEventMning = evt.Mning;
else
  self.localEventMning = self.getCachedLocalEventMning();
end if;',
	1);
INSERT INTO O_BATTR
	VALUES (1940,
	1608);
INSERT INTO O_ATTR
	VALUES (1940,
	1608,
	1939,
	'localEventMning',
	'User_Visible:false',
	'',
	'localEventMning',
	0,
	322,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	1608);
INSERT INTO O_OIDA
	VALUES (1632,
	1608,
	0,
	'SM_ID');
INSERT INTO O_OIDA
	VALUES (1633,
	1608,
	0,
	'SMevt_ID');
INSERT INTO O_ID
	VALUES (1,
	1608);
INSERT INTO O_ID
	VALUES (2,
	1608);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (1619,
	'Non Local Event',
	526,
	'SM_NLEVT',
	'A non-local event is one that is defined in another state machine.  Non-local events represent entries in SEMs for events that are defined in a super-type but used on transitions in the sub-type.',
	1478);
INSERT INTO O_TFR
	VALUES (1941,
	1619,
	'get_name',
	'',
	322,
	1,
	'select one evt related by self->SM_SEVT[R526]->SM_EVT[R525];
return evt.get_name();
',
	1,
	'',
	1942);
INSERT INTO O_TFR
	VALUES (1942,
	1619,
	'dispose',
	'',
	19,
	1,
	'select one sevt related by self->SM_SEVT[R526];
unrelate self from sevt across R526;
select one evt related by sevt->SM_EVT[R525];
if(not_empty evt)
  evt.dispose();
end if;
select one pevt related by self->SM_PEVT[R527];
if (not_empty pevt)
  unrelate self from pevt across R527;
  pevt.migrateToLocalEvent();
end if;
delete object instance self;
',
	1,
	'',
	1943);
INSERT INTO O_TFR
	VALUES (1944,
	1619,
	'checkIfNoLongerAssigned',
	'',
	19,
	1,
	'/*
Checks to see if this non-local event is no longer assigned anywhere in its
state machine, and if so, disposes of it.  Further, if this event is disposed,
then if it was the last alias of its associated polymorphic event, then that
polymorphic event is migrated back to a local event.
*/

// if this transition has the last assignment (or marked-as-ignored status)
// of the non-local event within this transitions''s state machine 
select many assignments related by self->SM_SEVT[R526]->SM_SEME[R503]->SM_NSTXN[R504];
select many ignores related by self->SM_SEVT[R526]->SM_SEME[R503]->SM_EIGN[R504];
if (empty assignments and empty ignores)
	// destroy the non-local event
	select one event related by self->SM_SEVT[R526]->SM_EVT[R525];
	select one polyEvent related by self->SM_PEVT[R527];
	event.dispose();
	
    polyEvent.migrateToLocalEvent();
end if;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (1945,
	1619,
	'resolveInheritedEvent',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one poly related by self->SM_PEVT[R527];
if(not_empty poly and not Util::isProxy(element:self.convertToInstance()))
  remove = false;
  select one evt related by poly->SM_EVT[R525];
  select one nlevt related by self->SM_SEVT[R526]->SM_EVT[R525];
  select one sm related by nlevt->SM_SM[R502];
  select one clazz related by sm->SM_ASM[R517]->O_OBJ[R519];
  if(empty clazz)
    select one clazz related by sm->SM_ISM[R517]->O_OBJ[R518];
  end if;
  select any superClass from instances of O_OBJ where (selected.Obj_ID == GD::NULL_UNIQUE_ID());
  if(not_empty evt)
    select one superSm related by evt->SM_SM[R502];
    select one superClass related by superSm->SM_ASM[R517]->O_OBJ[R519];
    if(empty superClass)
      select one superClass related by superSm->SM_ISM[R517]->O_OBJ[R518];
    end if;
    if(not_empty superClass)
      if(not superClass.isSupertypeOf(classId:clazz.Obj_ID))
        // the supertype was not resolved, the would indicate
        // that the supertype/subtype association was not fully
        // copied
        remove = true;
      else
       if(not Util::isProxy(element:evt.convertToInstance()))
         // if the event is not a proxy it has already been
         // resolved
         return;
        end if;
        // the supertype was resolved, but may actually be imported
        // in which case we need to trigger imported class resolution
        // and determine if the resolved model class has a matching
        // event
        select one originalClass related by evt->SM_SM[R502]->SM_ISM[R517]
      		->O_OBJ[R518];
        iobjID = clazz.findImportedSupertypeClass(supertypeClassId:originalClass.Obj_ID);
        if(iobjID != GD::NULL_UNIQUE_ID())
          // if the imported class was found
          // and is not the same class
          select any iobj from instances of O_IOBJ where (selected.IObj_ID == iobjID);
          // the subsystems should match for both the imported class
          // which represents the supertype and the subtype class
          // if not we are pasting both classes and the imported
          // class has not been related to the new subsystem yet
          // we do that now.
          select one iobjSS related by iobj->S_SS[R3];
          select one clazzSS related by clazz->S_SS[R2];
          if(iobjSS != clazzSS)
            unrelate iobj from iobjSS across R3;
            relate iobj to clazzSS across R3;
          end if;
          iobj.resolveModelClass();
          select one resolvedClass related by iobj->O_OBJ[R101];
          if(empty resolvedClass)
            remove = true;
          else
            if(originalClass != resolvedClass)
              select many otherNLevts related by sm->SM_EVT[R502]->SM_SEVT[R525]->SM_NLEVT[R526];
              for each otherNLevt in otherNLevts
                select one otherSuperSM related by otherNLevt->SM_PEVT[R527]->SM_EVT[R525]->SM_SM[R502];
                if(superSm == otherSuperSM)
                  select one otherEvt related by otherNLevt->SM_SEVT[R526]->SM_EVT[R525];
                  select any transition related by otherEvt->SM_SEVT[R525]->SM_SEME[R503]
            	      ->SM_NSTXN[R504]->SM_TXN[R507]; 
                  id = transition.locateMatchingPolymorphicEvent(id:otherEvt.SMevt_ID);
                  if(id != GD::NULL_UNIQUE_ID())
                    select any resolvedEvent from instances of SM_EVT where (selected.SMevt_ID == id);
                    if(not_empty resolvedEvent)
                      // if the polymorphic instance does not exist for the
                      // resolved event, create it now
                      select one polyEvt related by resolvedEvent->SM_PEVT[R525];
                      if(empty polyEvt)
                        create object instance polyEvt of SM_PEVT;
                        select one matrixEvent related by resolvedEvent->SM_SEVT[R525];
                        matrixEvent.dispose();
                        relate polyEvt to resolvedEvent across R525;
                      end if;
                      unrelate poly from otherNLevt across R527;
                      relate polyEvt to otherNLevt across R527;
                    else
                      // no polymorphic event could be resolved
                      // delete the event
                      message = ::getMissingInheritedEventMessage(missingInheritedEvent:true);
                      // add message to a list that will display in a warning dialog at
                      // the end of the paste operation
                      Util::addPastedElementToProblemList(elementName:evt.get_name(), message:message);
                      otherNLevt.dispose();
                    end if;
                  end if;                
                end if;
              end for;
            end if;
          end if;
        end if;
      end if;
    else
      // the supertype class was not copied as well
      remove = true;
    end if;
  else
    remove = true;
  end if;
  if(remove)
    // no polymorphic event could be resolved
    // delete remove the event from the transition
    // which will also delete the non-local event
    message = ::getMissingInheritedEventMessage(missingInheritedEvent:true);
    evtName = nlevt.get_name();
    if (not_empty evt)
      evtName = evt.get_name();
    end if;
    // add message to a list that will display in a warning dialog at
    // the end of the paste operation
    Util::addPastedElementToProblemList(elementName:evtName, message:message);
    nlevt.dispose();
  end if;
end if;',
	1,
	'',
	1941);
INSERT INTO O_TFR
	VALUES (1943,
	1619,
	'convertToInstance',
	'Translate:native',
	317,
	1,
	'return this;',
	0,
	'',
	1944);
INSERT INTO O_REF
	VALUES (1619,
	1606,
	0,
	1613,
	1617,
	1620,
	1618,
	1946,
	1947,
	0,
	0,
	'',
	'SEM Event',
	'SMevt_ID',
	'R526');
INSERT INTO O_RATTR
	VALUES (1946,
	1619,
	1604,
	1488,
	1,
	'SMevt_ID');
INSERT INTO O_ATTR
	VALUES (1946,
	1619,
	0,
	'SMevt_ID',
	'',
	'',
	'SMevt_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1619,
	1606,
	0,
	1614,
	1617,
	1620,
	1618,
	1948,
	1949,
	0,
	0,
	'',
	'SEM Event',
	'SM_ID',
	'R526');
INSERT INTO O_RATTR
	VALUES (1948,
	1619,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (1948,
	1619,
	1946,
	'SM_ID',
	'',
	'',
	'SM_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1619,
	1606,
	0,
	1615,
	1617,
	1620,
	1618,
	1950,
	1951,
	0,
	0,
	'',
	'SEM Event',
	'SMspd_ID',
	'R526');
INSERT INTO O_RATTR
	VALUES (1950,
	1619,
	1585,
	1583,
	1,
	'SMspd_ID');
INSERT INTO O_ATTR
	VALUES (1950,
	1619,
	1948,
	'SMspd_ID',
	'',
	'',
	'SMspd_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1619,
	1608,
	0,
	1633,
	1630,
	1634,
	1631,
	1952,
	1953,
	0,
	0,
	'',
	'Polymorphic Event',
	'SMevt_ID',
	'R527');
INSERT INTO O_RATTR
	VALUES (1952,
	1619,
	1604,
	1488,
	1,
	'SMevt_ID');
INSERT INTO O_ATTR
	VALUES (1952,
	1619,
	1950,
	'polySMevt_ID',
	'

',
	'poly',
	'SMevt_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1619,
	1608,
	0,
	1632,
	1630,
	1634,
	1631,
	1954,
	1955,
	0,
	0,
	'',
	'Polymorphic Event',
	'SM_ID',
	'R527');
INSERT INTO O_RATTR
	VALUES (1954,
	1619,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (1954,
	1619,
	1952,
	'polySM_ID',
	'

',
	'poly',
	'SM_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1956,
	1619);
INSERT INTO O_BATTR
	VALUES (1956,
	1619);
INSERT INTO O_ATTR
	VALUES (1956,
	1619,
	1954,
	'polySMspd_ID',
	'This attribute is only here for backwards compatibility.

',
	'',
	'polySMspd_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1957,
	1619);
INSERT INTO O_BATTR
	VALUES (1957,
	1619);
INSERT INTO O_ATTR
	VALUES (1957,
	1619,
	1956,
	'Local_Meaning',
	'User_Visible:false
Full Name: Non-Local Event Local Meaning
Description: The local meaning of the non-local event.  The meaning can be overridden in the sup-types state machine.',
	'',
	'Local_Meaning',
	0,
	322,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (1958,
	1619,
	'select one evt related by self->SM_SEVT[R526]->SM_EVT[R525];
if(not_empty evt)
  self.Name = evt.get_name();
else
  self.Name = ::getOrphanedElementName();
end if;',
	1);
INSERT INTO O_BATTR
	VALUES (1958,
	1619);
INSERT INTO O_ATTR
	VALUES (1958,
	1619,
	1957,
	'Name',
	'readonly:true
Persistent:false
Full Name: Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	1619);
INSERT INTO O_OIDA
	VALUES (1950,
	1619,
	0,
	'SMspd_ID');
INSERT INTO O_OIDA
	VALUES (1948,
	1619,
	0,
	'SM_ID');
INSERT INTO O_OIDA
	VALUES (1946,
	1619,
	0,
	'SMevt_ID');
INSERT INTO O_ID
	VALUES (1,
	1619);
INSERT INTO O_ID
	VALUES (2,
	1619);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (1513,
	'No Event Transition',
	509,
	'SM_NETXN',
	'A no event transition is a transition between to states to which no event is currently assigned. ',
	1478);
INSERT INTO O_TFR
	VALUES (1959,
	1513,
	'get_connector_text',
	'''No Event Assigned'' is always returned.
-----------------------------------------------------------------------------------
Bridge:GD
',
	322,
	1,
	'return "No Event Assigned";',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (1960,
	1513,
	'get_name',
	'',
	322,
	1,
	'select one initial_state related by self->SM_STATE[R508];
select one final_state related by self->SM_TXN[R507]->SM_STATE[R506];
if ( not_empty initial_state and not_empty final_state )
  return initial_state.Name + "/" + final_state.Name;
else
  // during import may not be related yet
  return "";
end if;
',
	1,
	'',
	1959);
INSERT INTO O_REF
	VALUES (1513,
	1509,
	0,
	1511,
	1508,
	1514,
	1510,
	1961,
	1962,
	0,
	0,
	'',
	'Transition',
	'Trans_ID',
	'R507');
INSERT INTO O_RATTR
	VALUES (1961,
	1513,
	1511,
	1509,
	1,
	'Trans_ID');
INSERT INTO O_ATTR
	VALUES (1961,
	1513,
	0,
	'Trans_ID',
	'

',
	'',
	'Trans_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1513,
	1492,
	0,
	1521,
	1518,
	1519,
	1520,
	1963,
	1964,
	0,
	0,
	'',
	'State Machine State',
	'SM_ID',
	'R508');
INSERT INTO O_REF
	VALUES (1513,
	1509,
	0,
	1512,
	1508,
	1514,
	1510,
	1963,
	1965,
	1964,
	0,
	'',
	'Transition',
	'SM_ID',
	'R507');
INSERT INTO O_RATTR
	VALUES (1963,
	1513,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (1963,
	1513,
	1961,
	'SM_ID',
	'',
	'',
	'SM_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1513,
	1492,
	0,
	1522,
	1518,
	1519,
	1520,
	1966,
	1967,
	0,
	0,
	'',
	'State Machine State',
	'SMstt_ID',
	'R508');
INSERT INTO O_RATTR
	VALUES (1966,
	1513,
	1522,
	1492,
	1,
	'SMstt_ID');
INSERT INTO O_ATTR
	VALUES (1966,
	1513,
	1963,
	'SMstt_ID',
	'',
	'',
	'SMstt_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (1968,
	1513);
INSERT INTO O_BATTR
	VALUES (1968,
	1513);
INSERT INTO O_ATTR
	VALUES (1968,
	1513,
	1966,
	'SMspd_ID',
	'

',
	'',
	'SMspd_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	1513);
INSERT INTO O_OIDA
	VALUES (1963,
	1513,
	0,
	'SM_ID');
INSERT INTO O_OIDA
	VALUES (1961,
	1513,
	0,
	'Trans_ID');
INSERT INTO O_ID
	VALUES (1,
	1513);
INSERT INTO O_ID
	VALUES (2,
	1513);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (1506,
	'New State Transition',
	505,
	'SM_NSTXN',
	'A new state transition is an entry in the state event matrix (SEM) that  represents a transition from one state to another upon the receipt of an event while in a particular state.',
	1478);
INSERT INTO O_TFR
	VALUES (1969,
	1506,
	'get_connector_text',
	'Gets the text for the Transition. To do this it calls State Machine
Event::get_event_text for the event associated with the Transition.
-----------------------------------------------------------------------------------
Bridge:GD
',
	322,
	1,
	'select one signalEvt related by self->SM_SEME[R504]->
                                                  SM_SEVT[R503]->SM_SGEVT[R526];
if not_empty signalEvt
  return signalEvt.get_event_text();
else
  select one evt related by self->SM_SEME[R504]->SM_SEVT[R503]->SM_EVT[R525];
  if (not_empty evt)
    return evt.get_event_text();
  else
    return ::getOrphanedElementName();
  end if;
end if;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (1970,
	1506,
	'get_name',
	'',
	322,
	1,
	'select one signalEvt related by self->SM_SEME[R504]->
                                                  SM_SEVT[R503]->SM_SGEVT[R526];
if not_empty signalEvt
  return signalEvt.get_name();
else
  select one evt related by self->SM_SEME[R504]->SM_SEVT[R503]->SM_EVT[R525];
  if (not_empty evt)
    return evt.get_name();
  else
    return ::getOrphanedElementName();
  end if;
end if;',
	1,
	'',
	1969);
INSERT INTO O_REF
	VALUES (1506,
	1509,
	0,
	1511,
	1508,
	1517,
	1510,
	1971,
	1972,
	0,
	0,
	'',
	'Transition',
	'Trans_ID',
	'R507');
INSERT INTO O_RATTR
	VALUES (1971,
	1506,
	1511,
	1509,
	1,
	'Trans_ID');
INSERT INTO O_ATTR
	VALUES (1971,
	1506,
	0,
	'Trans_ID',
	'

',
	'',
	'Trans_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1506,
	1496,
	0,
	1500,
	1495,
	1507,
	1497,
	1973,
	1974,
	0,
	0,
	'',
	'State Event Matrix Entry',
	'SM_ID',
	'R504');
INSERT INTO O_REF
	VALUES (1506,
	1509,
	0,
	1512,
	1508,
	1517,
	1510,
	1973,
	1975,
	1974,
	0,
	'',
	'Transition',
	'SM_ID',
	'R507');
INSERT INTO O_RATTR
	VALUES (1973,
	1506,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (1973,
	1506,
	1971,
	'SM_ID',
	'

',
	'',
	'SM_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1506,
	1496,
	0,
	1501,
	1495,
	1507,
	1497,
	1976,
	1977,
	0,
	0,
	'',
	'State Event Matrix Entry',
	'SMstt_ID',
	'R504');
INSERT INTO O_RATTR
	VALUES (1976,
	1506,
	1522,
	1492,
	1,
	'SMstt_ID');
INSERT INTO O_ATTR
	VALUES (1976,
	1506,
	1973,
	'SMstt_ID',
	'

',
	'',
	'SMstt_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1506,
	1496,
	0,
	1499,
	1495,
	1507,
	1497,
	1978,
	1979,
	0,
	0,
	'',
	'State Event Matrix Entry',
	'SMevt_ID',
	'R504');
INSERT INTO O_RATTR
	VALUES (1978,
	1506,
	1604,
	1488,
	1,
	'SMevt_ID');
INSERT INTO O_ATTR
	VALUES (1978,
	1506,
	1976,
	'SMevt_ID',
	'

',
	'',
	'SMevt_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1506,
	1496,
	0,
	1498,
	1495,
	1507,
	1497,
	1980,
	1981,
	0,
	0,
	'',
	'State Event Matrix Entry',
	'SMspd_ID',
	'R504');
INSERT INTO O_RATTR
	VALUES (1980,
	1506,
	1585,
	1583,
	1,
	'SMspd_ID');
INSERT INTO O_ATTR
	VALUES (1980,
	1506,
	1978,
	'SMspd_ID',
	'

',
	'',
	'SMspd_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	1506);
INSERT INTO O_OIDA
	VALUES (1978,
	1506,
	0,
	'SMevt_ID');
INSERT INTO O_OIDA
	VALUES (1976,
	1506,
	0,
	'SMstt_ID');
INSERT INTO O_OIDA
	VALUES (1980,
	1506,
	0,
	'SMspd_ID');
INSERT INTO O_OIDA
	VALUES (1973,
	1506,
	0,
	'SM_ID');
INSERT INTO O_ID
	VALUES (1,
	1506);
INSERT INTO O_OIDA
	VALUES (1973,
	1506,
	1,
	'SM_ID');
INSERT INTO O_OIDA
	VALUES (1971,
	1506,
	1,
	'Trans_ID');
INSERT INTO O_ID
	VALUES (2,
	1506);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (1534,
	'Moore State Machine',
	511,
	'SM_MOORE',
	'A Moore state machine is one in which actions (SM_ACT) are assigned to states (SM_STATE).  The state action is executed upon entry into the state.',
	1478);
INSERT INTO O_TFR
	VALUES (1982,
	1534,
	'dispose',
	'Dispose of this Moore State Machine',
	19,
	1,
	'select many actions related by self->SM_MOAH[R511]->SM_AH[R513]->SM_ACT[R514];
for each action in actions
  action.dispose();
end for;
select one sm related by self->SM_SM[R510];
if (not_empty sm)
  unrelate self from sm across R510;
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (1534,
	565,
	0,
	564,
	1530,
	1535,
	1531,
	1538,
	1983,
	0,
	0,
	'',
	'State Machine',
	'SM_ID',
	'R510');
INSERT INTO O_RATTR
	VALUES (1538,
	1534,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (1538,
	1534,
	0,
	'SM_ID',
	'',
	'',
	'SM_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	1534);
INSERT INTO O_OIDA
	VALUES (1538,
	1534,
	0,
	'SM_ID');
INSERT INTO O_ID
	VALUES (1,
	1534);
INSERT INTO O_ID
	VALUES (2,
	1534);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (1540,
	'Moore Action Home',
	513,
	'SM_MOAH',
	'A Moore action home represents the home for a Moore action.',
	1478);
INSERT INTO O_TFR
	VALUES (1984,
	1540,
	'dispose',
	'Dispose this Moore Action Home. 
',
	19,
	1,
	'// Note: let SM_ACT.dispose call this
select one moore related by self->SM_MOORE[R511];
select one state related by self->SM_STATE[R511];
unrelate moore from state across R511 using self;
select one ah related by self->SM_AH[R513];
unrelate self from ah across R513;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (1540,
	1549,
	0,
	1551,
	1548,
	1553,
	1550,
	1985,
	1986,
	0,
	0,
	'',
	'Action Home',
	'Act_ID',
	'R513');
INSERT INTO O_RATTR
	VALUES (1985,
	1540,
	1562,
	1559,
	1,
	'Act_ID');
INSERT INTO O_ATTR
	VALUES (1985,
	1540,
	0,
	'Act_ID',
	'',
	'',
	'Act_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1540,
	1549,
	0,
	1552,
	1548,
	1553,
	1550,
	1987,
	1988,
	0,
	0,
	'',
	'Action Home',
	'SM_ID',
	'R513');
INSERT INTO O_REF
	VALUES (1540,
	1534,
	0,
	1538,
	1536,
	1541,
	1537,
	1987,
	1989,
	1988,
	0,
	'',
	'Moore State Machine',
	'SM_ID',
	'R511');
INSERT INTO O_REF
	VALUES (1540,
	1492,
	0,
	1521,
	1536,
	1541,
	1539,
	1987,
	1990,
	1989,
	0,
	'',
	'State Machine State',
	'SM_ID',
	'R511');
INSERT INTO O_RATTR
	VALUES (1987,
	1540,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (1987,
	1540,
	1985,
	'SM_ID',
	'',
	'',
	'SM_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1540,
	1492,
	0,
	1522,
	1536,
	1541,
	1539,
	1991,
	1992,
	0,
	0,
	'',
	'State Machine State',
	'SMstt_ID',
	'R511');
INSERT INTO O_RATTR
	VALUES (1991,
	1540,
	1522,
	1492,
	1,
	'SMstt_ID');
INSERT INTO O_ATTR
	VALUES (1991,
	1540,
	1987,
	'SMstt_ID',
	'',
	'',
	'SMstt_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	1540);
INSERT INTO O_OIDA
	VALUES (1987,
	1540,
	0,
	'SM_ID');
INSERT INTO O_OIDA
	VALUES (1991,
	1540,
	0,
	'SMstt_ID');
INSERT INTO O_ID
	VALUES (1,
	1540);
INSERT INTO O_OIDA
	VALUES (1985,
	1540,
	1,
	'Act_ID');
INSERT INTO O_OIDA
	VALUES (1987,
	1540,
	1,
	'SM_ID');
INSERT INTO O_ID
	VALUES (2,
	1540);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (1532,
	'Mealy State Machine',
	512,
	'SM_MEALY',
	'A Mealy state machine is one in which actions (SM_ACT) are assigned to transitions (SM_TXN).  The action is executed during the transition from one state to another.  Support for mealy state machines is currently absent from the tool.',
	1478);
INSERT INTO O_REF
	VALUES (1532,
	565,
	0,
	564,
	1530,
	1533,
	1531,
	1544,
	1993,
	0,
	0,
	'',
	'State Machine',
	'SM_ID',
	'R510');
INSERT INTO O_RATTR
	VALUES (1544,
	1532,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (1544,
	1532,
	0,
	'SM_ID',
	'',
	'',
	'SM_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	1532);
INSERT INTO O_OIDA
	VALUES (1544,
	1532,
	0,
	'SM_ID');
INSERT INTO O_ID
	VALUES (1,
	1532);
INSERT INTO O_ID
	VALUES (2,
	1532);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (1546,
	'Mealy Action Home',
	514,
	'SM_MEAH',
	'A Mealy action home represents the home for a Mealy action.',
	1478);
INSERT INTO O_TFR
	VALUES (1994,
	1546,
	'dispose',
	'',
	19,
	1,
	'// Note: let SM_ACT.dispose call this
select one mealy related by self->SM_MEALY[R512];
select one trans related by self->SM_TXN[R512];
unrelate mealy from trans across R512 using self;
select one ah related by self->SM_AH[R513];
unrelate self from ah across R513;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (1546,
	1549,
	0,
	1551,
	1548,
	1554,
	1550,
	1995,
	1996,
	0,
	0,
	'',
	'Action Home',
	'Act_ID',
	'R513');
INSERT INTO O_RATTR
	VALUES (1995,
	1546,
	1562,
	1559,
	1,
	'Act_ID');
INSERT INTO O_ATTR
	VALUES (1995,
	1546,
	0,
	'Act_ID',
	'',
	'',
	'Act_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1546,
	1549,
	0,
	1552,
	1548,
	1554,
	1550,
	1997,
	1998,
	0,
	0,
	'',
	'Action Home',
	'SM_ID',
	'R513');
INSERT INTO O_REF
	VALUES (1546,
	1532,
	0,
	1544,
	1542,
	1547,
	1543,
	1997,
	1999,
	1998,
	0,
	'',
	'Mealy State Machine',
	'SM_ID',
	'R512');
INSERT INTO O_REF
	VALUES (1546,
	1509,
	0,
	1512,
	1542,
	1547,
	1545,
	1997,
	2000,
	1999,
	0,
	'',
	'Transition',
	'SM_ID',
	'R512');
INSERT INTO O_RATTR
	VALUES (1997,
	1546,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (1997,
	1546,
	1995,
	'SM_ID',
	'',
	'',
	'SM_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1546,
	1509,
	0,
	1511,
	1542,
	1547,
	1545,
	2001,
	2002,
	0,
	0,
	'',
	'Transition',
	'Trans_ID',
	'R512');
INSERT INTO O_RATTR
	VALUES (2001,
	1546,
	1511,
	1509,
	1,
	'Trans_ID');
INSERT INTO O_ATTR
	VALUES (2001,
	1546,
	1997,
	'Trans_ID',
	'',
	'',
	'Trans_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	1546);
INSERT INTO O_OIDA
	VALUES (2001,
	1546,
	0,
	'Trans_ID');
INSERT INTO O_OIDA
	VALUES (1997,
	1546,
	0,
	'SM_ID');
INSERT INTO O_ID
	VALUES (1,
	1546);
INSERT INTO O_OIDA
	VALUES (1997,
	1546,
	1,
	'SM_ID');
INSERT INTO O_OIDA
	VALUES (1995,
	1546,
	1,
	'Act_ID');
INSERT INTO O_ID
	VALUES (2,
	1546);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (1621,
	'Local Event',
	527,
	'SM_LEVT',
	'A local event is one that is defined in the state machine.  Contrast this to a non-local event which is defined in a different state machine (that of the super-type) than the one in which it is used.',
	1478);
INSERT INTO O_TFR
	VALUES (2003,
	1621,
	'dispose',
	'Dispose this SM_LEVT.
',
	19,
	1,
	'select one sevt related by self->SM_SEVT[R526];
unrelate self from sevt across R526;
select one crtxn related by self->SM_CRTXN[R509];
if (not_empty crtxn)
  unrelate self from crtxn across R509;
end if;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (2004,
	1621,
	'get_name',
	'Return the meaning of this local event.',
	322,
	1,
	'select one evt related by self->SM_SEVT[R526]->SM_EVT[R525];
if (empty evt)
  return ::getOrphanedElementName();
else
  return evt.get_name();
end if;
',
	1,
	'',
	2003);
INSERT INTO O_REF
	VALUES (1621,
	1606,
	0,
	1613,
	1617,
	1622,
	1618,
	1629,
	2005,
	0,
	0,
	'',
	'SEM Event',
	'SMevt_ID',
	'R526');
INSERT INTO O_RATTR
	VALUES (1629,
	1621,
	1604,
	1488,
	1,
	'SMevt_ID');
INSERT INTO O_ATTR
	VALUES (1629,
	1621,
	0,
	'SMevt_ID',
	'',
	'',
	'SMevt_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1621,
	1606,
	0,
	1614,
	1617,
	1622,
	1618,
	1628,
	2006,
	0,
	0,
	'',
	'SEM Event',
	'SM_ID',
	'R526');
INSERT INTO O_RATTR
	VALUES (1628,
	1621,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (1628,
	1621,
	1629,
	'SM_ID',
	'',
	'',
	'SM_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1621,
	1606,
	0,
	1615,
	1617,
	1622,
	1618,
	2007,
	2008,
	0,
	0,
	'',
	'SEM Event',
	'SMspd_ID',
	'R526');
INSERT INTO O_RATTR
	VALUES (2007,
	1621,
	1585,
	1583,
	1,
	'SMspd_ID');
INSERT INTO O_ATTR
	VALUES (2007,
	1621,
	1628,
	'SMspd_ID',
	'',
	'',
	'SMspd_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	1621);
INSERT INTO O_OIDA
	VALUES (1628,
	1621,
	0,
	'SM_ID');
INSERT INTO O_OIDA
	VALUES (1629,
	1621,
	0,
	'SMevt_ID');
INSERT INTO O_ID
	VALUES (1,
	1621);
INSERT INTO O_ID
	VALUES (2,
	1621);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (1568,
	'Instance State Machine',
	520,
	'SM_ISM',
	'An instance state machine is a state machine for an instance of a class.  Each instance of a class can be thought of as executing its own private version of the state machine.  This is in contrast to an assigner state machine (SM_ASM) which is a state machine for the entire class.',
	1478);
INSERT INTO O_TFR
	VALUES (2009,
	1568,
	'get_name',
	'This operation returns the name of the class it belongs to.
----------------------------------------------------------------------------------------------------------
Bridge:GD,TEXT
',
	322,
	1,
	'select one obj related by self->O_OBJ[R518];
if ( not_empty obj )
  return obj.Name;
else
  return ::getOrphanedElementName();
end if;',
	1,
	'',
	2010);
INSERT INTO O_TFR
	VALUES (2011,
	1568,
	'newState',
	'',
	19,
	1,
	'select one sm related by self->SM_SM[R517];
sm.newState();

',
	1,
	'',
	2012);
INSERT INTO O_TFR
	VALUES (2012,
	1568,
	'newEvent',
	'',
	19,
	1,
	'select one sm related by self->SM_SM[R517];
sm.newEvent();

',
	1,
	'',
	2013);
INSERT INTO O_TFR
	VALUES (2014,
	1568,
	'newTransition',
	'',
	316,
	1,
	'select one sm related by self->SM_SM[R517];
return sm.newTransition(from:param.from, to:param.to);',
	1,
	'',
	2011);
INSERT INTO O_TPARM
	VALUES (2015,
	2014,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (2016,
	2014,
	'to',
	296,
	0,
	'',
	2017,
	'');
INSERT INTO O_TPARM
	VALUES (2017,
	2014,
	'fromTypeIsImportedClass',
	316,
	0,
	'',
	2015,
	'');
INSERT INTO O_TPARM
	VALUES (2018,
	2014,
	'toTypeIsImportedClass',
	316,
	0,
	'',
	2016,
	'');
INSERT INTO O_TFR
	VALUES (2013,
	1568,
	'newCreationTransition',
	'',
	316,
	1,
	'select one sm related by self->SM_SM[R517];
return sm.newCreationTransition(from:param.from, to:param.to);',
	1,
	'',
	2019);
INSERT INTO O_TPARM
	VALUES (2020,
	2013,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (2021,
	2013,
	'to',
	296,
	0,
	'',
	2022,
	'');
INSERT INTO O_TPARM
	VALUES (2022,
	2013,
	'fromTypeIsImportedClass',
	316,
	0,
	'',
	2020,
	'');
INSERT INTO O_TPARM
	VALUES (2023,
	2013,
	'toTypeIsImportedClass',
	316,
	0,
	'',
	2021,
	'');
INSERT INTO O_TFR
	VALUES (2019,
	1568,
	'get_ooa_id',
	'The ooa_id of a State Machine is it''''s SM_ID.
-----------------------------------------------------------------------------------
Bridge:GD',
	296,
	1,
	'return self.SM_ID;',
	1,
	'',
	2009);
INSERT INTO O_TFR
	VALUES (2010,
	1568,
	'dispose',
	'',
	19,
	1,
	'select one sm related by self->SM_SM[R517];
sm.dispose();',
	1,
	'',
	2024);
INSERT INTO O_TFR
	VALUES (2025,
	1568,
	'pasteStateMachineState',
	'',
	19,
	1,
	'select one sm related by self->SM_SM[R517];
sm.pasteStateMachineState(id:param.id);',
	1,
	'',
	2026);
INSERT INTO O_TPARM
	VALUES (2027,
	2025,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2024,
	1568,
	'convertToInstance',
	'// return an instance representation of self
Translate:native',
	317,
	1,
	'return this;',
	0,
	'',
	0);
INSERT INTO O_TFR
	VALUES (2028,
	1568,
	'pasteTransition',
	'',
	19,
	1,
	'select one sm related by self->SM_SM[R517];
sm.pasteTransition(id:param.id);',
	1,
	'',
	2025);
INSERT INTO O_TPARM
	VALUES (2029,
	2028,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2026,
	1568,
	'pasteCreationTransition',
	'',
	19,
	1,
	'select one sm related by self->SM_SM[R517];
sm.pasteTransition(id:param.id);',
	1,
	'',
	2014);
INSERT INTO O_TPARM
	VALUES (2030,
	2026,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2031,
	1568,
	'getStateCount',
	'',
	298,
	1,
	'select many states related by self->SM_SM[R517]->SM_STATE[R501];
return cardinality states;',
	1,
	'',
	2028);
INSERT INTO O_TFR
	VALUES (2032,
	1568,
	'getStateId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many states related by self->SM_SM[R517]->SM_STATE[R501];
// We''re preincrementing the index
count = -1;
for each state in states
  if (not_empty state)
      count = count+1;
  end if;
  if (count == param.index)
      return state.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	2031);
INSERT INTO O_TPARM
	VALUES (2033,
	2032,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2034,
	1568,
	'pasteStateMachineEvent',
	'',
	19,
	1,
	'select one sm related by self->SM_SM[R517];
sm.pasteStateMachineEvent(id:param.id);',
	1,
	'',
	2032);
INSERT INTO O_TPARM
	VALUES (2035,
	2034,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (1568,
	565,
	0,
	564,
	1566,
	1569,
	1567,
	2036,
	2037,
	0,
	0,
	'',
	'State Machine',
	'SM_ID',
	'R517');
INSERT INTO O_RATTR
	VALUES (2036,
	1568,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (2036,
	1568,
	0,
	'SM_ID',
	'',
	'',
	'SM_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1568,
	30,
	0,
	150,
	1572,
	1573,
	1574,
	2038,
	2039,
	0,
	0,
	'',
	'Model Class',
	'Obj_ID',
	'R518');
INSERT INTO O_RATTR
	VALUES (2038,
	1568,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (2038,
	1568,
	2036,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	1568);
INSERT INTO O_OIDA
	VALUES (2036,
	1568,
	0,
	'SM_ID');
INSERT INTO O_ID
	VALUES (1,
	1568);
INSERT INTO O_ID
	VALUES (2,
	1568);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (1583,
	'Event Supplemental Data',
	518,
	'SM_SUPDT',
	'Each event (SM_EVT) may carry supplemental event data defined by state machine event data items (SM_EVTDI).  The supplemental data items for the event are defined by instances of supplemental data items (SM_SDI).

Events now locate their data across simple association R532.

Deprecated:true',
	1478);
INSERT INTO O_TFR
	VALUES (2040,
	1583,
	'dispose',
	'Dispose of this SM_SUPDT.
',
	19,
	1,
	'select many states related by self->SM_STATE[R521];
for each state in states
  unrelate self from state across R521;
end for;
select one sm related by self->SM_SM[R523];
if(not_empty sm)
  unrelate self from sm across R523;
end if;
select many sdis related by self->SM_SDI[ R522];
for each sdi in sdis
  sdi.dispose();
end for;
select many events related by self->SM_EVT[R520];
for each event in events
  unrelate self from event across R520;
end for;
delete object instance self;


',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (2041,
	1583,
	'get_name',
	'',
	322,
	1,
	'select many edi_set related by self->SM_EVTDI[R522];
if ( self.Non_Local )
  select any nlevt related by self->SM_EVT[R520]->SM_SEVT[R525]->SM_NLEVT[R526];
  select one pevtdi related by nlevt->SM_PEVT[R527]->SM_EVT[R525]->SM_SUPDT[R520];;
  select many edi_set related by pevtdi->SM_EVTDI[R522];
end if;
result = "(";
first = true;
for each edi in edi_set
  if ( not first )
    result = result + ",";
  end if;
  result = result + edi.Name;
  first = false;
end for;
return result + ")";
',
	1,
	'',
	2042);
INSERT INTO O_TFR
	VALUES (2042,
	1583,
	'findWithChangedData',
	'',
	296,
	1,
	'select many my_sdi related by self->SM_SDI[R522];
select many other_supdt_set related by self->SM_SM[R523]->SM_SUPDT[R523]
    where selected.SMspd_ID != self.SMspd_ID;
if ( param.addToSet )
  for each other_supdt in other_supdt_set
    select many other_sdi_set related by other_supdt->SM_SDI[R522];
    if ( cardinality other_sdi_set - 1 == cardinality my_sdi )
      found_all = true;
      for each other_sdi in other_sdi_set
        found = false;
        for each sdi in my_sdi
          if ( other_sdi.SMedi_ID == sdi.SMedi_ID )
            found = true;
            break;
          end if;
        end for;  // for each sdi 
        if ( not found )
          if ( other_sdi.SMedi_ID != param.data )
            found_all = false;
            break;
          end if;
        end if;
      end for;  // for each other_sdi
      if ( found_all )
        return other_supdt.SMspd_ID;
      end if;
    end if;
  end for;
else
  for each other_supdt in other_supdt_set
    select many other_sdi_set related by other_supdt->SM_SDI[R522];
    if ( cardinality other_sdi_set + 1 == cardinality my_sdi )
      found_all = true;
      for each sdi in my_sdi
        found = false;
        for each other_sdi in other_sdi_set
          if ( other_sdi.SMedi_ID == sdi.SMedi_ID )
            found = true;
            break;
          end if;
        end for;  // for each other_sdi
        if ( not found )
          if ( sdi.SMedi_ID != param.data )
            found_all = false;
            break;
          end if;
        end if;
      end for;  // for each sdi
      if ( found_all )
        return other_supdt.SMspd_ID;
      end if;
    end if;
  end for;
end if;
return GD::NULL_UNIQUE_ID();
',
	1,
	'',
	2040);
INSERT INTO O_TPARM
	VALUES (2043,
	2042,
	'data',
	296,
	0,
	'',
	2044,
	'');
INSERT INTO O_TPARM
	VALUES (2044,
	2042,
	'addToSet',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_NBATTR
	VALUES (1585,
	1583);
INSERT INTO O_BATTR
	VALUES (1585,
	1583);
INSERT INTO O_ATTR
	VALUES (1585,
	1583,
	0,
	'SMspd_ID',
	'Full Name: Event Supplemental Data Identifier',
	'',
	'SMspd_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_REF
	VALUES (1583,
	565,
	0,
	564,
	1595,
	1596,
	1597,
	1586,
	2045,
	0,
	0,
	'',
	'State Machine',
	'SM_ID',
	'R523');
INSERT INTO O_RATTR
	VALUES (1586,
	1583,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (1586,
	1583,
	1585,
	'SM_ID',
	'',
	'',
	'SM_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (2046,
	1583,
	'select any nlevt related by self->SM_EVT[R520]->SM_SEVT[R525]->SM_NLEVT[R526];
self.Non_Local = not_empty nlevt;
',
	1);
INSERT INTO O_BATTR
	VALUES (2046,
	1583);
INSERT INTO O_ATTR
	VALUES (2046,
	1583,
	1586,
	'Non_Local',
	'Full Name: Non local event indicator
Description: This attribute captures that the event supplemental data is for a non-local event.
User_Visible:false',
	'',
	'Non_Local',
	0,
	316,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	1583);
INSERT INTO O_OIDA
	VALUES (1585,
	1583,
	0,
	'SMspd_ID');
INSERT INTO O_OIDA
	VALUES (1586,
	1583,
	0,
	'SM_ID');
INSERT INTO O_ID
	VALUES (1,
	1583);
INSERT INTO O_ID
	VALUES (2,
	1583);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (1502,
	'Event Ignored',
	506,
	'SM_EIGN',
	'An event ignored is an entry in the state event matrix (SEM) specifying that the event (SM_EVT) is ignored when received in the state SM_STATE.  When the analyst asserts that the event is ignored he is saying that the event is expected, but the state machine should not transition on the event, but ignore it.  ',
	1478);
INSERT INTO O_TFR
	VALUES (2047,
	1502,
	'get_name',
	'Creates a string containing a descriptive name for the instance.',
	322,
	1,
	'return "Event Ignored";',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (2048,
	1502,
	'get_label',
	'',
	322,
	1,
	'select one seme related by self->SM_SEME[R504];
if not_empty seme
  select one event related by seme->SM_SEVT[R503]->SM_EVT[R525];
  select one state related by seme->SM_STATE[R503];
  if ( not_empty state and not_empty event )
    return event.Drv_Lbl + "/" + state.Name;
  else
    // during import may not be related yet
    return "";
  end if;
else
  // during import may not be related yet
  return "";
end if;',
	1,
	'',
	2047);
INSERT INTO O_REF
	VALUES (1502,
	1496,
	0,
	1501,
	1495,
	1503,
	1497,
	2049,
	2050,
	0,
	0,
	'',
	'State Event Matrix Entry',
	'SMstt_ID',
	'R504');
INSERT INTO O_RATTR
	VALUES (2049,
	1502,
	1522,
	1492,
	1,
	'SMstt_ID');
INSERT INTO O_ATTR
	VALUES (2049,
	1502,
	0,
	'SMstt_ID',
	'

',
	'',
	'SMstt_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1502,
	1496,
	0,
	1499,
	1495,
	1503,
	1497,
	2051,
	2052,
	0,
	0,
	'',
	'State Event Matrix Entry',
	'SMevt_ID',
	'R504');
INSERT INTO O_RATTR
	VALUES (2051,
	1502,
	1604,
	1488,
	1,
	'SMevt_ID');
INSERT INTO O_ATTR
	VALUES (2051,
	1502,
	2049,
	'SMevt_ID',
	'

',
	'',
	'SMevt_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1502,
	1496,
	0,
	1500,
	1495,
	1503,
	1497,
	2053,
	2054,
	0,
	0,
	'',
	'State Event Matrix Entry',
	'SM_ID',
	'R504');
INSERT INTO O_RATTR
	VALUES (2053,
	1502,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (2053,
	1502,
	2051,
	'SM_ID',
	'

',
	'',
	'SM_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1502,
	1496,
	0,
	1498,
	1495,
	1503,
	1497,
	2055,
	2056,
	0,
	0,
	'',
	'State Event Matrix Entry',
	'SMspd_ID',
	'R504');
INSERT INTO O_RATTR
	VALUES (2055,
	1502,
	1585,
	1583,
	1,
	'SMspd_ID');
INSERT INTO O_ATTR
	VALUES (2055,
	1502,
	2053,
	'SMspd_ID',
	'

',
	'',
	'SMspd_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2057,
	1502);
INSERT INTO O_BATTR
	VALUES (2057,
	1502);
INSERT INTO O_ATTR
	VALUES (2057,
	1502,
	2055,
	'Descrip',
	'Full Name: Description
Description: An explanation of why the event can be ignored if received in this state.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	1502);
INSERT INTO O_OIDA
	VALUES (2051,
	1502,
	0,
	'SMevt_ID');
INSERT INTO O_OIDA
	VALUES (2053,
	1502,
	0,
	'SM_ID');
INSERT INTO O_OIDA
	VALUES (2055,
	1502,
	0,
	'SMspd_ID');
INSERT INTO O_OIDA
	VALUES (2049,
	1502,
	0,
	'SMstt_ID');
INSERT INTO O_ID
	VALUES (1,
	1502);
INSERT INTO O_ID
	VALUES (2,
	1502);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (1515,
	'Creation Transition',
	510,
	'SM_CRTXN',
	'A creation transition is a transition into a state from no other state.  ',
	1478);
INSERT INTO O_TFR
	VALUES (2058,
	1515,
	'get_connector_text',
	'Gets the text for the Transition. If an Event is associated with this
Transition, it calls State Machine Event::get_event_text on that Event
associated with the Transition. If no Event is associated, ''No Event
Assigned'' is returned.
-----------------------------------------------------------------------------------
Bridge:GD
',
	322,
	1,
	'// Creation Transition.get_connector_text()
result = "";
if (param.at == End::Middle)
  select one evt related by self->SM_LEVT[R509]->SM_SEVT[R526]->SM_EVT[R525];
  if (not_empty evt)
    result = evt.get_event_text();
  else
    result = "No Event Assigned";
  end if;
  select one action related by self->SM_TXN[R507]->SM_TAH[R530]->
                                                      SM_AH[R513]->SM_ACT[R514];
  if not_empty action and action.Action_Semantics != ""
    result = result + "/";
    if PREF::getBoolean(name:"bridgepoint_prefs_show_transition_actions")
      result = result + GD::newline() + action.Action_Semantics;
    else
      result = result + "...";
    end if;
  end if;
end if;
return result;',
	1,
	'',
	2059);
INSERT INTO O_TPARM
	VALUES (2060,
	2058,
	'OOA_ID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (2061,
	2058,
	'OOA_TypeIsImportedClass',
	316,
	0,
	'',
	2060,
	'');
INSERT INTO O_TPARM
	VALUES (2062,
	2058,
	'at',
	880,
	0,
	'',
	2061,
	'');
INSERT INTO O_TPARM
	VALUES (2063,
	2058,
	'parent_ID',
	296,
	0,
	'',
	2062,
	'');
INSERT INTO O_TFR
	VALUES (2064,
	1515,
	'get_style',
	'A Creation Transition has a filled circle at the end and an arrow at the
start (notice that it is back to front).
-----------------------------------------------------------------------------------
Bridge:GD',
	784,
	1,
	'if (param.at == End::End)
  return Style::FilledCircle;
elif (param.at == End::Start)
  return Style::OpenArrow;
else
  return Style::None;
end if;',
	1,
	'',
	2065);
INSERT INTO O_TPARM
	VALUES (2066,
	2064,
	'at',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2065,
	1515,
	'get_ooa_id',
	'The ooa_id of a Creation Transition is its Trans_ID
-----------------------------------------------------------
Bridge:GD',
	296,
	1,
	'return self.Trans_ID;',
	1,
	'',
	2067);
INSERT INTO O_TFR
	VALUES (2059,
	1515,
	'actionFilter',
	'',
	316,
	1,
	'select one trans related by self->SM_TXN[R507];
return trans.actionFilter(name:param.name, value:param.value);',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (2068,
	2059,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (2069,
	2059,
	'value',
	322,
	0,
	'',
	2068,
	'');
INSERT INTO O_TFR
	VALUES (2067,
	1515,
	'get_name',
	'',
	322,
	1,
	'// Creation Transition.get_name()
result = "No Event Assigned";
select one evt related by self->SM_LEVT[R509]->SM_SEVT[R526]->SM_EVT[R525];
if not_empty evt
  result = evt.get_name();
end if;
result = result + " to creation state";
select one destState related by self->SM_TXN[R507]->SM_STATE[R506];
if not_empty destState
  result = result + ": " + destState.Name;
end if;
return result;',
	1,
	'',
	2058);
INSERT INTO O_TFR
	VALUES (2070,
	1515,
	'mergeStateMachineEventCreationEvent',
	'',
	316,
	1,
	'select one transition related by self->SM_TXN[R507];
return 
    transition.mergeStateMachineEventAssignedLocalEvent(event_id:param.eventId);',
	1,
	'',
	2064);
INSERT INTO O_TPARM
	VALUES (2071,
	2070,
	'eventId',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2072,
	1515,
	'getDescription',
	'',
	322,
	1,
	'select one transition related by self->SM_TXN[R507];
return transition.getDescription();',
	1,
	'',
	2070);
INSERT INTO O_REF
	VALUES (1515,
	1509,
	0,
	1511,
	1508,
	1516,
	1510,
	2073,
	2074,
	0,
	0,
	'',
	'Transition',
	'Trans_ID',
	'R507');
INSERT INTO O_RATTR
	VALUES (2073,
	1515,
	1511,
	1509,
	1,
	'Trans_ID');
INSERT INTO O_ATTR
	VALUES (2073,
	1515,
	0,
	'Trans_ID',
	'

',
	'',
	'Trans_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1515,
	1509,
	0,
	1512,
	1508,
	1516,
	1510,
	2075,
	2076,
	0,
	0,
	'',
	'Transition',
	'SM_ID',
	'R507');
INSERT INTO O_REF
	VALUES (1515,
	1621,
	0,
	1628,
	1625,
	1626,
	1627,
	2075,
	2077,
	2076,
	0,
	'',
	'Local Event',
	'SM_ID',
	'R509.''is assigned to''');
INSERT INTO O_RATTR
	VALUES (2075,
	1515,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (2075,
	1515,
	2073,
	'SM_ID',
	'

',
	'',
	'SM_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1515,
	1621,
	0,
	1629,
	1625,
	1626,
	1627,
	2078,
	2079,
	0,
	0,
	'',
	'Local Event',
	'SMevt_ID',
	'R509.''is assigned to''');
INSERT INTO O_RATTR
	VALUES (2078,
	1515,
	1604,
	1488,
	1,
	'SMevt_ID');
INSERT INTO O_ATTR
	VALUES (2078,
	1515,
	2075,
	'SMevt_ID',
	'

',
	'',
	'SMevt_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2080,
	1515);
INSERT INTO O_BATTR
	VALUES (2080,
	1515);
INSERT INTO O_ATTR
	VALUES (2080,
	1515,
	2078,
	'SMspd_ID',
	'

',
	'',
	'SMspd_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	1515);
INSERT INTO O_OIDA
	VALUES (2075,
	1515,
	0,
	'SM_ID');
INSERT INTO O_OIDA
	VALUES (2073,
	1515,
	0,
	'Trans_ID');
INSERT INTO O_ID
	VALUES (1,
	1515);
INSERT INTO O_ID
	VALUES (2,
	1515);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (1570,
	'Class State Machine',
	521,
	'SM_ASM',
	'An assigner state machine is a state machine for a class.  This is in contrast to an instance state machine (SM_ISM) which is a state machine for an instance.',
	1478);
INSERT INTO O_TFR
	VALUES (2081,
	1570,
	'get_name',
	'This operation returns the name of the class it belongs to.
----------------------------------------------------------------------------------------------------------
Bridge:GD, TEXT
',
	322,
	1,
	'select one obj related by self->O_OBJ[R519];
if ( not_empty obj )
  return obj.Name;
else
  return ::getOrphanedElementName();
end if;
',
	1,
	'',
	2082);
INSERT INTO O_TFR
	VALUES (2083,
	1570,
	'newState',
	'',
	19,
	1,
	'select one sm related by self->SM_SM[R517];
sm.newState();',
	1,
	'',
	2084);
INSERT INTO O_TFR
	VALUES (2084,
	1570,
	'newEvent',
	'',
	19,
	1,
	'select one sm related by self->SM_SM[R517];
sm.newEvent();

',
	1,
	'',
	2085);
INSERT INTO O_TFR
	VALUES (2086,
	1570,
	'newTransition',
	'',
	316,
	1,
	'select one sm related by self->SM_SM[R517];
return sm.newTransition(from:param.from, to:param.to);',
	1,
	'',
	2083);
INSERT INTO O_TPARM
	VALUES (2087,
	2086,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (2088,
	2086,
	'to',
	296,
	0,
	'',
	2089,
	'');
INSERT INTO O_TPARM
	VALUES (2089,
	2086,
	'fromTypeIsImportedClass',
	316,
	0,
	'',
	2087,
	'');
INSERT INTO O_TPARM
	VALUES (2090,
	2086,
	'toTypeIsImportedClass',
	316,
	0,
	'',
	2088,
	'');
INSERT INTO O_TFR
	VALUES (2085,
	1570,
	'newCreationTransition',
	'',
	316,
	1,
	'select one sm related by self->SM_SM[R517];
return sm.newCreationTransition(from:param.from, to:param.to);',
	1,
	'',
	2091);
INSERT INTO O_TPARM
	VALUES (2092,
	2085,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (2093,
	2085,
	'to',
	296,
	0,
	'',
	2094,
	'');
INSERT INTO O_TPARM
	VALUES (2094,
	2085,
	'fromTypeIsImportedClass',
	316,
	0,
	'',
	2092,
	'');
INSERT INTO O_TPARM
	VALUES (2095,
	2085,
	'toTypeIsImportedClass',
	316,
	0,
	'',
	2093,
	'');
INSERT INTO O_TFR
	VALUES (2091,
	1570,
	'get_ooa_id',
	'The ooa_id of a State Machine is it''''s SM_ID.
-----------------------------------------------------------------------------------
Bridge:GD',
	296,
	1,
	'return self.SM_ID;',
	1,
	'',
	2081);
INSERT INTO O_TFR
	VALUES (2082,
	1570,
	'dispose',
	'',
	19,
	1,
	'select one sm related by self->SM_SM[R517];
sm.dispose();',
	1,
	'',
	2096);
INSERT INTO O_TFR
	VALUES (2096,
	1570,
	'convertToInstance',
	'// return this as an instance
Translate:native',
	317,
	1,
	'return this;',
	0,
	'',
	0);
INSERT INTO O_TFR
	VALUES (2097,
	1570,
	'pasteTransition',
	'',
	19,
	1,
	'select one sm related by self->SM_SM[R517];
sm.pasteTransition(id:param.id);',
	1,
	'',
	2098);
INSERT INTO O_TPARM
	VALUES (2099,
	2097,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2098,
	1570,
	'pasteStateMachineState',
	'',
	19,
	1,
	'select one sm related by self->SM_SM[R517];
sm.pasteStateMachineState(id:param.id);',
	1,
	'',
	2086);
INSERT INTO O_TPARM
	VALUES (2100,
	2098,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2101,
	1570,
	'getStateCount',
	'',
	298,
	1,
	'select many states related by self->SM_SM[R517]->SM_STATE[R501];
return cardinality states;',
	1,
	'',
	2097);
INSERT INTO O_TFR
	VALUES (2102,
	1570,
	'getStateId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many states related by self->SM_SM[R517]->SM_STATE[R501];
// We''re preincrementing the index
count = -1;
for each state in states
  if (not_empty state)
      count = count+1;
  end if;
  if (count == param.index)
      return state.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	2101);
INSERT INTO O_TPARM
	VALUES (2103,
	2102,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2104,
	1570,
	'pasteStateMachineEvent',
	'',
	19,
	1,
	'select one sm related by self->SM_SM[R517];
sm.pasteStateMachineEvent(id:param.id);',
	1,
	'',
	2102);
INSERT INTO O_TPARM
	VALUES (2105,
	2104,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (1570,
	565,
	0,
	564,
	1566,
	1571,
	1567,
	2106,
	2107,
	0,
	0,
	'',
	'State Machine',
	'SM_ID',
	'R517');
INSERT INTO O_RATTR
	VALUES (2106,
	1570,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (2106,
	1570,
	0,
	'SM_ID',
	'',
	'',
	'SM_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1570,
	30,
	0,
	150,
	1575,
	1576,
	1577,
	2108,
	2109,
	0,
	0,
	'',
	'Model Class',
	'Obj_ID',
	'R519');
INSERT INTO O_RATTR
	VALUES (2108,
	1570,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (2108,
	1570,
	2106,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	1570);
INSERT INTO O_OIDA
	VALUES (2106,
	1570,
	0,
	'SM_ID');
INSERT INTO O_ID
	VALUES (1,
	1570);
INSERT INTO O_ID
	VALUES (2,
	1570);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (1504,
	'Cant Happen',
	507,
	'SM_CH',
	'A cant happen is an entry in the state event matrix (SEM) specifying that the event (SM_EVT) should never happen under normal circumstances when received in the state SM_STATE.  When the analyst asserts that the event cant happen in the state he is saying that the event is not expected and an error should be flagged.  ',
	1478);
INSERT INTO O_TFR
	VALUES (2110,
	1504,
	'get_name',
	'Translate:native',
	322,
	1,
	'	return "Can''t Happen";',
	0,
	'',
	0);
INSERT INTO O_TFR
	VALUES (2111,
	1504,
	'dispose',
	'',
	19,
	1,
	'select one seme related by self->SM_SEME[R504];
if(not_empty seme)
  unrelate self from seme across R504;
end if;
delete object instance self;',
	1,
	'',
	2110);
INSERT INTO O_TFR
	VALUES (2112,
	1504,
	'get_label',
	'',
	322,
	1,
	'select one seme related by self->SM_SEME[R504];
if not_empty seme
  select one event related by seme->SM_SEVT[R503]->SM_EVT[R525];
  select one state related by seme->SM_STATE[R503];
  if ( not_empty state and not_empty event )
    return event.Drv_Lbl + "/" + state.Name;
  else
    // during import may not be related yet
    return "";
  end if;
else
  // during import may not be related yet
  return "";
end if;
',
	1,
	'',
	2111);
INSERT INTO O_REF
	VALUES (1504,
	1496,
	0,
	1501,
	1495,
	1505,
	1497,
	2113,
	2114,
	0,
	0,
	'',
	'State Event Matrix Entry',
	'SMstt_ID',
	'R504');
INSERT INTO O_RATTR
	VALUES (2113,
	1504,
	1522,
	1492,
	1,
	'SMstt_ID');
INSERT INTO O_ATTR
	VALUES (2113,
	1504,
	0,
	'SMstt_ID',
	'

',
	'',
	'SMstt_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1504,
	1496,
	0,
	1499,
	1495,
	1505,
	1497,
	2115,
	2116,
	0,
	0,
	'',
	'State Event Matrix Entry',
	'SMevt_ID',
	'R504');
INSERT INTO O_RATTR
	VALUES (2115,
	1504,
	1604,
	1488,
	1,
	'SMevt_ID');
INSERT INTO O_ATTR
	VALUES (2115,
	1504,
	2113,
	'SMevt_ID',
	'

',
	'',
	'SMevt_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1504,
	1496,
	0,
	1500,
	1495,
	1505,
	1497,
	2117,
	2118,
	0,
	0,
	'',
	'State Event Matrix Entry',
	'SM_ID',
	'R504');
INSERT INTO O_RATTR
	VALUES (2117,
	1504,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (2117,
	1504,
	2115,
	'SM_ID',
	'

',
	'',
	'SM_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1504,
	1496,
	0,
	1498,
	1495,
	1505,
	1497,
	2119,
	2120,
	0,
	0,
	'',
	'State Event Matrix Entry',
	'SMspd_ID',
	'R504');
INSERT INTO O_RATTR
	VALUES (2119,
	1504,
	1585,
	1583,
	1,
	'SMspd_ID');
INSERT INTO O_ATTR
	VALUES (2119,
	1504,
	2117,
	'SMspd_ID',
	'

',
	'',
	'SMspd_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2121,
	1504);
INSERT INTO O_BATTR
	VALUES (2121,
	1504);
INSERT INTO O_ATTR
	VALUES (2121,
	1504,
	2119,
	'Descrip',
	'Full Name: Description
Description: An explanation of why the event cant happen while the instance is in this state.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	1504);
INSERT INTO O_OIDA
	VALUES (2119,
	1504,
	0,
	'SMspd_ID');
INSERT INTO O_OIDA
	VALUES (2115,
	1504,
	0,
	'SMevt_ID');
INSERT INTO O_OIDA
	VALUES (2117,
	1504,
	0,
	'SM_ID');
INSERT INTO O_OIDA
	VALUES (2113,
	1504,
	0,
	'SMstt_ID');
INSERT INTO O_ID
	VALUES (1,
	1504);
INSERT INTO O_ID
	VALUES (2,
	1504);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (1549,
	'Action Home',
	515,
	'SM_AH',
	'An action (SM_ACT) resides in an action home, either a Moore action home (SM_MOAH) or a Mealy action home (SM_MEAH).',
	1478);
INSERT INTO O_TFR
	VALUES (2122,
	1549,
	'dispose',
	'Dispose this SM_AH.',
	19,
	1,
	'select one moah related by self->SM_MOAH[R513];
if (not_empty moah)
  moah.dispose();
end if;
select one meah related by self->SM_MEAH[R513];
if (not_empty meah)
  meah.dispose();
end if;
select one tah related by self->SM_TAH[R513];
if (not_empty tah)
  tah.dispose();
end if;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (1549,
	1559,
	0,
	1562,
	1557,
	1558,
	1560,
	1551,
	2123,
	0,
	0,
	'',
	'Action',
	'Act_ID',
	'R514');
INSERT INTO O_RATTR
	VALUES (1551,
	1549,
	1562,
	1559,
	1,
	'Act_ID');
INSERT INTO O_ATTR
	VALUES (1551,
	1549,
	0,
	'Act_ID',
	'',
	'',
	'Act_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1549,
	1559,
	0,
	1561,
	1557,
	1558,
	1560,
	1552,
	2124,
	0,
	0,
	'',
	'Action',
	'SM_ID',
	'R514');
INSERT INTO O_RATTR
	VALUES (1552,
	1549,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (1552,
	1549,
	1551,
	'SM_ID',
	'',
	'',
	'SM_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	1549);
INSERT INTO O_OIDA
	VALUES (1551,
	1549,
	0,
	'Act_ID');
INSERT INTO O_OIDA
	VALUES (1552,
	1549,
	0,
	'SM_ID');
INSERT INTO O_ID
	VALUES (1,
	1549);
INSERT INTO O_ID
	VALUES (2,
	1549);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (1559,
	'Action',
	516,
	'SM_ACT',
	'An action defines the action language that gets executed upon arrival into the state (SM_STATE) that is related to the action.  An action may have both action language (SM_ACT.Action_Semantics)  and a description (SM_ACT.Descrip).',
	1478);
INSERT INTO O_TFR
	VALUES (2125,
	1559,
	'dispose',
	'Delete this Action.',
	19,
	1,
	'select one sm related by self->SM_SM[R515];
unrelate self from sm across R515;
select one ah related by self->SM_AH[R514];
unrelate self from ah across R514;
ah.dispose();
// Body Subsystem
select one body related by self->ACT_SAB[R691]->ACT_ACT[R698];
if empty body
  select one body related by self->ACT_TAB[R688]->ACT_ACT[R698];
end if;
if (not_empty body)
  body.dispose();
end if;
//
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (2126,
	1559,
	'get_name',
	'',
	322,
	1,
	'select one st related by self->SM_AH[R514]->SM_MOAH[R513]->SM_STATE[R511];
select one transition related by self->SM_AH[R514]->SM_TAH[R513]->SM_TXN[R530];
if (not_empty st)
  return "State Action";
else;
  if(not_empty transition)
    return "Transition Action";
  end if;
  return ::getOrphanedElementName();
end if;

',
	1,
	'',
	2125);
INSERT INTO O_TFR
	VALUES (2127,
	1559,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'// just return this instance as an Object
return this;',
	0,
	'',
	2126);
INSERT INTO O_NBATTR
	VALUES (1562,
	1559);
INSERT INTO O_BATTR
	VALUES (1562,
	1559);
INSERT INTO O_ATTR
	VALUES (1562,
	1559,
	0,
	'Act_ID',
	'Full Name: Action Identifier',
	'',
	'Act_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_REF
	VALUES (1559,
	565,
	0,
	564,
	1563,
	1564,
	1565,
	1561,
	2128,
	0,
	0,
	'',
	'State Machine',
	'SM_ID',
	'R515');
INSERT INTO O_RATTR
	VALUES (1561,
	1559,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (1561,
	1559,
	1562,
	'SM_ID',
	'',
	'',
	'SM_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2129,
	1559);
INSERT INTO O_BATTR
	VALUES (2129,
	1559);
INSERT INTO O_ATTR
	VALUES (2129,
	1559,
	1561,
	'Suc_Pars',
	'Full Name: Successful Parse Indicator
Description: Indicates the status of the parse for the state action specification in the attribute Action_Semantics
Data Domain: 0=not parsed, 1 = parse successful, 2 = parse unsuccessful, 3 = parse on apply set but never been parsed
',
	'',
	'Suc_Pars',
	0,
	1224,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (2130,
	1559,
	'self.Action_Semantics = ::convertRelocatableTags(in:self.Action_Semantics_internal);
',
	1);
INSERT INTO O_BATTR
	VALUES (2130,
	1559);
INSERT INTO O_ATTR
	VALUES (2130,
	1559,
	2129,
	'Action_Semantics',
	'Full Name: Action Semantics Field
Description: Action Semantics for the state action
Persistent:false',
	'',
	'Action_Semantics',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2131,
	1559);
INSERT INTO O_BATTR
	VALUES (2131,
	1559);
INSERT INTO O_ATTR
	VALUES (2131,
	1559,
	2132,
	'Descrip',
	'Full Name: Description
Description: Optional description for the state action.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2132,
	1559);
INSERT INTO O_BATTR
	VALUES (2132,
	1559);
INSERT INTO O_ATTR
	VALUES (2132,
	1559,
	2130,
	'Action_Semantics_internal',
	'User_Visible:false',
	'',
	'Action_Semantics_internal',
	0,
	322,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	1559);
INSERT INTO O_OIDA
	VALUES (1561,
	1559,
	0,
	'SM_ID');
INSERT INTO O_OIDA
	VALUES (1562,
	1559,
	0,
	'Act_ID');
INSERT INTO O_ID
	VALUES (1,
	1559);
INSERT INTO O_ID
	VALUES (2,
	1559);
-- BP 7.1 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (2133,
	'Sequence',
	'// This is used by schema_gen to ignore this subsystem (for publication)
TRANSLATE_FOR_EXTERNAL_USE:FALSE',
	'SQ',
	900,
	1,
	0);
INSERT INTO S_SID
	VALUES (1,
	2133);
INSERT INTO O_IOBJ
	VALUES (2134,
	701,
	0,
	2133,
	'Subsystem',
	'S_SS');
INSERT INTO O_IOBJ
	VALUES (2135,
	699,
	0,
	2133,
	'Domain',
	'S_DOM');
INSERT INTO O_IOBJ
	VALUES (2136,
	703,
	0,
	2133,
	'Interaction Participant',
	'SQ_P');
INSERT INTO O_IOBJ
	VALUES (2137,
	705,
	0,
	2133,
	'System Model',
	'S_SYS');
INSERT INTO O_IOBJ
	VALUES (2138,
	707,
	0,
	2133,
	'Component Package',
	'CP_CP');
INSERT INTO O_IOBJ
	VALUES (2139,
	709,
	0,
	2133,
	'Component',
	'C_C');
INSERT INTO O_IOBJ
	VALUES (2140,
	2141,
	0,
	2133,
	'Message',
	'MSG_M');
INSERT INTO R_SIMP
	VALUES (2142);
INSERT INTO R_REL
	VALUES (2142,
	913,
	'',
	2133);
INSERT INTO R_PART
	VALUES (699,
	2142,
	2143,
	0,
	1,
	'is shown in');
INSERT INTO O_RTIDA
	VALUES (712,
	699,
	0,
	2142,
	2143);
INSERT INTO R_RTO
	VALUES (699,
	2142,
	2143,
	0);
INSERT INTO R_OIR
	VALUES (699,
	2142,
	2143,
	2135);
INSERT INTO R_FORM
	VALUES (2144,
	2142,
	2145,
	1,
	1,
	'can show');
INSERT INTO R_RGO
	VALUES (2144,
	2142,
	2145);
INSERT INTO R_OIR
	VALUES (2144,
	2142,
	2145,
	0);
INSERT INTO R_SIMP
	VALUES (2146);
INSERT INTO R_REL
	VALUES (2146,
	914,
	'',
	2133);
INSERT INTO R_PART
	VALUES (701,
	2146,
	2147,
	0,
	1,
	'is shown in');
INSERT INTO O_RTIDA
	VALUES (717,
	701,
	0,
	2146,
	2147);
INSERT INTO R_RTO
	VALUES (701,
	2146,
	2147,
	0);
INSERT INTO R_OIR
	VALUES (701,
	2146,
	2147,
	2134);
INSERT INTO R_FORM
	VALUES (2144,
	2146,
	2148,
	1,
	1,
	'can show');
INSERT INTO R_RGO
	VALUES (2144,
	2146,
	2148);
INSERT INTO R_OIR
	VALUES (2144,
	2146,
	2148,
	0);
INSERT INTO R_SIMP
	VALUES (2149);
INSERT INTO R_REL
	VALUES (2149,
	928,
	'',
	2133);
INSERT INTO R_FORM
	VALUES (2144,
	2149,
	2150,
	1,
	1,
	'has children');
INSERT INTO R_RGO
	VALUES (2144,
	2149,
	2150);
INSERT INTO R_OIR
	VALUES (2144,
	2149,
	2150,
	0);
INSERT INTO R_PART
	VALUES (2151,
	2149,
	2152,
	0,
	1,
	'is displayed in');
INSERT INTO O_RTIDA
	VALUES (2153,
	2151,
	0,
	2149,
	2152);
INSERT INTO R_RTO
	VALUES (2151,
	2149,
	2152,
	0);
INSERT INTO R_OIR
	VALUES (2151,
	2149,
	2152,
	0);
INSERT INTO R_SIMP
	VALUES (2154);
INSERT INTO R_REL
	VALUES (2154,
	911,
	'',
	2133);
INSERT INTO R_PART
	VALUES (2144,
	2154,
	2155,
	0,
	0,
	'is shown in');
INSERT INTO O_RTIDA
	VALUES (2156,
	2144,
	0,
	2154,
	2155);
INSERT INTO R_RTO
	VALUES (2144,
	2154,
	2155,
	0);
INSERT INTO R_OIR
	VALUES (2144,
	2154,
	2155,
	0);
INSERT INTO R_FORM
	VALUES (2151,
	2154,
	2157,
	0,
	1,
	'can show');
INSERT INTO R_RGO
	VALUES (2151,
	2154,
	2157);
INSERT INTO R_OIR
	VALUES (2151,
	2154,
	2157,
	0);
INSERT INTO R_SIMP
	VALUES (2158);
INSERT INTO R_REL
	VALUES (2158,
	929,
	'',
	2133);
INSERT INTO R_PART
	VALUES (2144,
	2158,
	2159,
	0,
	1,
	'participates in');
INSERT INTO O_RTIDA
	VALUES (2156,
	2144,
	0,
	2158,
	2159);
INSERT INTO R_RTO
	VALUES (2144,
	2158,
	2159,
	0);
INSERT INTO R_OIR
	VALUES (2144,
	2158,
	2159,
	0);
INSERT INTO R_FORM
	VALUES (703,
	2158,
	2160,
	1,
	1,
	'contains');
INSERT INTO R_RGO
	VALUES (703,
	2158,
	2160);
INSERT INTO R_OIR
	VALUES (703,
	2158,
	2160,
	2136);
INSERT INTO R_SIMP
	VALUES (2161);
INSERT INTO R_REL
	VALUES (2161,
	950,
	'',
	2133);
INSERT INTO R_PART
	VALUES (705,
	2161,
	2162,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (754,
	705,
	0,
	2161,
	2162);
INSERT INTO R_RTO
	VALUES (705,
	2161,
	2162,
	0);
INSERT INTO R_OIR
	VALUES (705,
	2161,
	2162,
	2137);
INSERT INTO R_FORM
	VALUES (2144,
	2161,
	2163,
	1,
	1,
	'can show');
INSERT INTO R_RGO
	VALUES (2144,
	2161,
	2163);
INSERT INTO R_OIR
	VALUES (2144,
	2161,
	2163,
	0);
INSERT INTO R_SIMP
	VALUES (2164);
INSERT INTO R_REL
	VALUES (2164,
	951,
	'',
	2133);
INSERT INTO R_PART
	VALUES (707,
	2164,
	2165,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (758,
	707,
	0,
	2164,
	2165);
INSERT INTO R_RTO
	VALUES (707,
	2164,
	2165,
	0);
INSERT INTO R_OIR
	VALUES (707,
	2164,
	2165,
	2138);
INSERT INTO R_FORM
	VALUES (2144,
	2164,
	2166,
	1,
	1,
	'can show');
INSERT INTO R_RGO
	VALUES (2144,
	2164,
	2166);
INSERT INTO R_OIR
	VALUES (2144,
	2164,
	2166,
	0);
INSERT INTO R_SIMP
	VALUES (2167);
INSERT INTO R_REL
	VALUES (2167,
	952,
	'',
	2133);
INSERT INTO R_PART
	VALUES (709,
	2167,
	2168,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (762,
	709,
	0,
	2167,
	2168);
INSERT INTO R_RTO
	VALUES (709,
	2167,
	2168,
	0);
INSERT INTO R_OIR
	VALUES (709,
	2167,
	2168,
	2139);
INSERT INTO R_FORM
	VALUES (2144,
	2167,
	2169,
	1,
	1,
	'can show');
INSERT INTO R_RGO
	VALUES (2144,
	2167,
	2169);
INSERT INTO R_OIR
	VALUES (2144,
	2167,
	2169,
	0);
INSERT INTO R_SIMP
	VALUES (2170);
INSERT INTO R_REL
	VALUES (2170,
	953,
	'',
	2133);
INSERT INTO R_PART
	VALUES (2144,
	2170,
	2171,
	0,
	0,
	'contained in');
INSERT INTO O_RTIDA
	VALUES (2156,
	2144,
	0,
	2170,
	2171);
INSERT INTO R_RTO
	VALUES (2144,
	2170,
	2171,
	0);
INSERT INTO R_OIR
	VALUES (2144,
	2170,
	2171,
	0);
INSERT INTO R_FORM
	VALUES (2172,
	2170,
	2173,
	1,
	1,
	'contains');
INSERT INTO R_RGO
	VALUES (2172,
	2170,
	2173);
INSERT INTO R_OIR
	VALUES (2172,
	2170,
	2173,
	0);
INSERT INTO R_SIMP
	VALUES (2174);
INSERT INTO R_REL
	VALUES (2174,
	954,
	'',
	2133);
INSERT INTO R_FORM
	VALUES (2172,
	2174,
	2175,
	0,
	1,
	'contained through');
INSERT INTO R_RGO
	VALUES (2172,
	2174,
	2175);
INSERT INTO R_OIR
	VALUES (2172,
	2174,
	2175,
	0);
INSERT INTO R_PART
	VALUES (2141,
	2174,
	2176,
	0,
	0,
	'provides containment');
INSERT INTO O_RTIDA
	VALUES (2177,
	2141,
	0,
	2174,
	2176);
INSERT INTO R_RTO
	VALUES (2141,
	2174,
	2176,
	0);
INSERT INTO R_OIR
	VALUES (2141,
	2174,
	2176,
	2140);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2151,
	'Sequence in Sequence',
	906,
	'SQ_SIS',
	'',
	2133);
INSERT INTO O_REF
	VALUES (2151,
	2144,
	0,
	2156,
	2154,
	2157,
	2155,
	2153,
	2178,
	0,
	0,
	'',
	'Sequence',
	'Package_ID',
	'R911');
INSERT INTO O_RATTR
	VALUES (2153,
	2151,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (2153,
	2151,
	0,
	'Package_ID',
	'',
	'',
	'SpecificationPackage_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2151);
INSERT INTO O_OIDA
	VALUES (2153,
	2151,
	0,
	'Package_ID');
INSERT INTO O_ID
	VALUES (1,
	2151);
INSERT INTO O_ID
	VALUES (2,
	2151);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2144,
	'Sequence',
	900,
	'SQ_S',
	'',
	2133);
INSERT INTO O_TFR
	VALUES (2179,
	2144,
	'get_compartments',
	'',
	298,
	1,
	'// The sequence package symbol only contains its name
return 1;',
	1,
	'',
	2180);
INSERT INTO O_TFR
	VALUES (2181,
	2144,
	'get_entries',
	'',
	298,
	1,
	'// The sequence package symbol only contains its name
return 1;',
	1,
	'',
	2179);
INSERT INTO O_TPARM
	VALUES (2182,
	2181,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2180,
	2144,
	'get_compartment_text',
	'',
	322,
	1,
	'// The sequence package symbol only contains its name
// appended by the sequence stereotype
result = "";
if (param.at == Justification::Center_in_X)
  result = "sequence";
elif (param.at == Justification::Center)
  result = self.Name;
end if;
return result;',
	1,
	'',
	2183);
INSERT INTO O_TPARM
	VALUES (2184,
	2180,
	'comp_num',
	298,
	0,
	'',
	2185,
	'');
INSERT INTO O_TPARM
	VALUES (2186,
	2180,
	'ent_num',
	298,
	0,
	'',
	2184,
	'');
INSERT INTO O_TPARM
	VALUES (2185,
	2180,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2187,
	2144,
	'get_text_style',
	'',
	784,
	1,
	'return Style::None;',
	1,
	'',
	2188);
INSERT INTO O_TPARM
	VALUES (2189,
	2187,
	'comp_num',
	298,
	0,
	'',
	2190,
	'');
INSERT INTO O_TPARM
	VALUES (2191,
	2187,
	'ent_num',
	298,
	0,
	'',
	2189,
	'');
INSERT INTO O_TPARM
	VALUES (2190,
	2187,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2188,
	2144,
	'get_style',
	'',
	784,
	1,
	'return Style::Folder;',
	1,
	'',
	2192);
INSERT INTO O_TFR
	VALUES (2192,
	2144,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Package_ID;',
	1,
	'',
	2181);
INSERT INTO O_TFR
	VALUES (2193,
	2144,
	'initialize',
	'',
	19,
	1,
	'self.Name = ::getUniqueInitialName( 
    instance: self.convertToInstance(), 
    candidateName: "Unnamed Sequence");',
	1,
	'',
	2187);
INSERT INTO O_TFR
	VALUES (2194,
	2144,
	'newLifeSpan',
	'',
	316,
	1,
	'select any part from instances of SQ_P where (selected.Part_ID == param.from);
select any partTo from instances of SQ_P where (selected.Part_ID == param.to);
// if the element that this lifespan is drawn to is
// the instance, we must switch it so that it is the
// element from which the lifespan is drawn from 
// so that the logic below works
if(empty part) and (not_empty partTo)
  inst = partTo;
end if;
if(not_empty part)
  // dont allow more that one lifeline per
  // element
  select one otherLifeSpan related by part->SQ_LS[R940];
  if(not_empty otherLifeSpan)
    return false;
  end if;
  // otherwise create the lifespan on this instance
  create object instance lifeSpanPart of SQ_P;
  create object instance lifespan of SQ_LS;
  relate lifespan to part across R940;
  relate lifespan to lifeSpanPart across R930;
  relate lifeSpanPart to self across R929;
  return true;
end if;
return false;',
	1,
	'',
	2195);
INSERT INTO O_TPARM
	VALUES (2196,
	2194,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (2197,
	2194,
	'to',
	296,
	0,
	'',
	2198,
	'');
INSERT INTO O_TPARM
	VALUES (2198,
	2194,
	'fromIsImported',
	316,
	0,
	'',
	2196,
	'');
INSERT INTO O_TPARM
	VALUES (2199,
	2194,
	'toIsImported',
	316,
	0,
	'',
	2197,
	'');
INSERT INTO O_TFR
	VALUES (2200,
	2144,
	'newClassInstance',
	'',
	19,
	1,
	'create object instance participant of SQ_P;
create object instance inst of SQ_CIP;
relate participant to inst across R930;
relate participant to self across R929;
inst.initialize();',
	1,
	'',
	2201);
INSERT INTO O_TFR
	VALUES (2202,
	2144,
	'newClassParticipant',
	'',
	19,
	1,
	'create object instance participant of SQ_P;
create object instance cp of SQ_CP;
relate participant to cp across R930;
relate participant to self across R929;
cp.initialize();',
	1,
	'',
	2200);
INSERT INTO O_TFR
	VALUES (2203,
	2144,
	'newSequence',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
create object instance sequence of SQ_S;
create object instance sp of EP_SPKG;
relate sequence to sp across R1402;
select one sis related by self->SQ_SIS[R911];
if(empty sis)
  create object instance sis of SQ_SIS;
  relate self to sis across R911;
end if;
relate sis to sequence across R928;
sequence.initialize();',
	1,
	'',
	2204);
INSERT INTO O_TFR
	VALUES (2205,
	2144,
	'newTimingMark',
	'',
	316,
	1,
	'select any lifespan from instances of SQ_LS where (selected.Part_ID == param.from);
if(not_empty lifespan)
  create object instance mark of SQ_TM;
  relate mark to lifespan across R931;
  return true;
end if;
return false;',
	1,
	'',
	2206);
INSERT INTO O_TPARM
	VALUES (2207,
	2205,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (2208,
	2205,
	'to',
	296,
	0,
	'',
	2209,
	'');
INSERT INTO O_TPARM
	VALUES (2209,
	2205,
	'fromIsImported',
	316,
	0,
	'',
	2207,
	'');
INSERT INTO O_TPARM
	VALUES (2210,
	2205,
	'toIsImported',
	316,
	0,
	'',
	2208,
	'');
INSERT INTO O_TFR
	VALUES (2206,
	2144,
	'newTimeSpan',
	'',
	316,
	1,
	'select any mark from instances of SQ_TM where (selected.Mark_ID == param.from);
if(not_empty mark)
  select any otherMark from instances of SQ_TM where (selected.Mark_ID == param.to);
  if(not_empty otherMark)
    create object instance span of SQ_TS;
    relate span to mark across R941;
    relate span to otherMark across R942;
    return true;
  end if;
end if;
return false;',
	1,
	'',
	2211);
INSERT INTO O_TPARM
	VALUES (2212,
	2206,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (2213,
	2206,
	'to',
	296,
	0,
	'',
	2214,
	'');
INSERT INTO O_TPARM
	VALUES (2214,
	2206,
	'fromIsImported',
	316,
	0,
	'',
	2212,
	'');
INSERT INTO O_TPARM
	VALUES (2215,
	2206,
	'toIsImported',
	316,
	0,
	'',
	2213,
	'');
INSERT INTO O_TFR
	VALUES (2216,
	2144,
	'dispose',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one dom related by self->S_DOM[R913];
select one ss related by self->S_SS[R914];
select one sis related by self->SQ_SIS[R928];
select one system related by self->S_SYS[R950];
select one compPackage related by self->CP_CP[R951];
select one comp related by self->C_C[R952];
if(not_empty comp)
  unrelate self from comp across R952;
end if;
if(not_empty compPackage)
  unrelate self from compPackage across R951;
end if;
if(not_empty system)
  unrelate self from system across R950;
end if;
if(not_empty dom)
  unrelate self from dom across R913;
end if;
if(not_empty ss)
  unrelate self from ss across R914;
end if;

// unrelate from parent
select one sis related by self->SQ_SIS[R928];
if(not_empty sis)
  unrelate self from sis across R928;
  // are there any other children?
  select any other_child related by sis->SQ_S[R928];
  if empty other_child
    // no, dispose the sequence in sequence placeholder
    select one parent related by sis->SQ_S[R911];
    if(not_empty parent)
      unrelate sis from parent across R911;
    end if;
    delete object instance sis;
  end if;
end if;

//delete child sequences
select one sis related by self->SQ_SIS[R911];
select many sequences related by sis->SQ_S[R928];
for each sequence in sequences
  sequence.dispose();
end for;
// last child will delete the sis instance

select many participants related by self->SQ_P[R929];
for each participant in participants
  unrelate self from participant across R929;
  participant.dispose();
end for;

select one specPkg related by self->EP_SPKG[R1402];

if(not_empty specPkg)
  unrelate self from specPkg across R1402;
  specPkg.dispose();
end if;
select many miss related by self->SQ_MIS[R953];
for each mis in miss
  select one message related by mis->MSG_M[R954];
  unrelate mis from self across R953;
  unrelate mis from message across R954;
  message.dispose();
end for;
delete object instance self;',
	1,
	'',
	2217);
INSERT INTO O_TFR
	VALUES (2218,
	2144,
	'newExternalEntityParticipant',
	'',
	19,
	1,
	'create object instance participant of SQ_P;
create object instance eep of SQ_EEP;
relate participant to eep across R930;
relate participant to self across R929;
eep.initialize();',
	1,
	'',
	2219);
INSERT INTO O_TFR
	VALUES (2211,
	2144,
	'newSyncMessage',
	'',
	316,
	1,
	'select any fromParticipant from instances of SQ_P where (selected.Part_ID == param.from);
select any toParticipant from instances of SQ_P where (selected.Part_ID == param.to);
// it only matters that there is a toParticipant
if(not_empty toParticipant)
  create object instance message of MSG_M;
  create object instance mis of SQ_MIS;
  relate message to mis across R954;
  relate mis to self across R953;
  relate message to toParticipant across R1007;
  if(not_empty fromParticipant)
    relate message to fromParticipant across R1008;
  end if;
  create object instance sm of MSG_SM;
  relate message to sm across R1018;
  sm.initialize();
  return true;
end if;
return false;',
	1,
	'',
	2203);
INSERT INTO O_TPARM
	VALUES (2220,
	2211,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (2221,
	2211,
	'to',
	296,
	0,
	'',
	2222,
	'');
INSERT INTO O_TPARM
	VALUES (2222,
	2211,
	'fromIsImported',
	316,
	0,
	'',
	2220,
	'');
INSERT INTO O_TPARM
	VALUES (2223,
	2211,
	'toIsImported',
	316,
	0,
	'',
	2221,
	'');
INSERT INTO O_TFR
	VALUES (2224,
	2144,
	'newASyncMessage',
	'',
	316,
	1,
	'select any fromParticipant from instances of SQ_P where (selected.Part_ID == param.from);
select any toParticipant from instances of SQ_P where (selected.Part_ID == param.to);
// it only matters that there is a toParticipant
if(not_empty toParticipant)
  create object instance message of MSG_M;
  create object instance mis of SQ_MIS;
  relate message to mis across R954;
  relate mis to self across R953;
  relate message to toParticipant across R1007;
  if(not_empty fromParticipant)
    relate message to fromParticipant across R1008;
  end if;
  create object instance am of MSG_AM;
  relate message to am across R1018;
  am.initialize();
  return true;
end if;
return false;',
	1,
	'',
	2193);
INSERT INTO O_TPARM
	VALUES (2225,
	2224,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (2226,
	2224,
	'to',
	296,
	0,
	'',
	2227,
	'');
INSERT INTO O_TPARM
	VALUES (2227,
	2224,
	'fromIsImported',
	316,
	0,
	'',
	2225,
	'');
INSERT INTO O_TPARM
	VALUES (2228,
	2224,
	'toIsImported',
	316,
	0,
	'',
	2226,
	'');
INSERT INTO O_TFR
	VALUES (2195,
	2144,
	'newFunctionPackageParticipant',
	'',
	19,
	1,
	'create object instance participant of SQ_P;
create object instance fpp of SQ_FPP;
relate participant to fpp across R930;
relate participant to self across R929;
fpp.initialize();',
	1,
	'',
	2218);
INSERT INTO O_TFR
	VALUES (2204,
	2144,
	'newReturnMessage',
	'',
	316,
	1,
	'select any fromParticipant from instances of SQ_P where (selected.Part_ID == param.from);
select any toParticipant from instances of SQ_P where (selected.Part_ID == param.to);
// it only matters that there is a toParticipant
if(not_empty toParticipant)
  create object instance message of MSG_M;
  relate message to toParticipant across R1007;
  create object instance mis of SQ_MIS;
  relate message to mis across R954;
  relate mis to self across R953;
  if(not_empty fromParticipant)
    relate message to fromParticipant across R1008;
  end if;
  create object instance rm of MSG_R;
  relate rm to message across R1018;
  rm.initialize();
  return true;
end if;
return false;',
	1,
	'',
	2194);
INSERT INTO O_TPARM
	VALUES (2229,
	2204,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (2230,
	2204,
	'to',
	296,
	0,
	'',
	2231,
	'');
INSERT INTO O_TPARM
	VALUES (2231,
	2204,
	'fromIsImported',
	316,
	0,
	'',
	2229,
	'');
INSERT INTO O_TPARM
	VALUES (2232,
	2204,
	'toIsImported',
	316,
	0,
	'',
	2230,
	'');
INSERT INTO O_TFR
	VALUES (2201,
	2144,
	'newActor',
	'',
	19,
	1,
	'create object instance actor of SQ_AP;
create object instance participant of SQ_P;
relate actor to participant across R930;
relate participant to self across R929;
actor.initialize();',
	1,
	'',
	2224);
INSERT INTO O_TFR
	VALUES (2183,
	2144,
	'getPath',
	'',
	322,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one domain related by self->S_DOM[R913];
domainName = "";
result = self.Name;
if(empty domain)
  select one ss related by self->S_SS[R914];
  if(not_empty ss)
    select one domain related by ss->S_DOM[R1];
    // check subsystems
    if(not_empty domain)
      result = ss.getPath(path:"") + "::" + result;
      domainName = domain.Name;
    end if;
  else
    // check sequences in sequences
    select one sis related by self->SQ_SIS[R928]->SQ_S[R911];
    while (not_empty sis)
      result = sis.Name + "::" + result;
      prev = sis;
      select one sis related by sis->SQ_SIS[R928]->SQ_S[R911];
      if(empty sis)
        if(param.domainNameOnly)
          return prev.getPath(domainNameOnly:true);
        else
          result = prev.getPath(domainNameOnly:param.domainNameOnly) + result;
        end if;
      end if;
    end while;
  end if;
else
  domainName = domain.Name;
  result = domainName + "::" + result;
end if;
if(param.domainNameOnly and (not_empty domain))
  return domain.Name;
else
  return result;
end if;
',
	1,
	'',
	2216);
INSERT INTO O_TPARM
	VALUES (2233,
	2183,
	'domainNameOnly',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2234,
	2144,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'// just return this instance as an Object
return this;',
	0,
	'',
	2235);
INSERT INTO O_TFR
	VALUES (2219,
	2144,
	'newComponentParticipant',
	'',
	19,
	1,
	'create object instance participant of SQ_P;
create object instance cp of SQ_COP;
relate participant to cp across R930;
relate participant to self across R929;
cp.initialize();',
	1,
	'',
	2202);
INSERT INTO O_TFR
	VALUES (2236,
	2144,
	'associateWithPackage',
	'',
	19,
	1,
	'// unhook from current parent
self.deassociateFromParent();
// hook up with package
select any package from instances of EP_PKG
                                     where (selected.Package_ID == param.pkgID);
select one specPkg related by self->EP_SPKG[R1402];
relate specPkg to package across R1400;',
	1,
	'',
	2237);
INSERT INTO O_TPARM
	VALUES (2238,
	2236,
	'pkgID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2217,
	2144,
	'deassociateFromParent',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one system related by self->S_SYS[R950];
if(not_empty system)
  unrelate self from system across R950;
end if;
select one domain related by self->S_DOM[R913];
if(not_empty domain)
  unrelate self from domain across R913;
end if;
select one subsystem related by self->S_SS[R914];
if(not_empty subsystem)
  unrelate self from subsystem across R914;
end if;
select one cp related by self->CP_CP[R951];
if(not_empty cp)
  unrelate self from cp across R951;
end if;
select one comp related by self->C_C[R952];
if(not_empty comp)
  unrelate self from comp across R952;
end if;
select one specPkg related by self->EP_SPKG[R1402];
select one package related by specPkg->EP_PKG[R1400];
if(not_empty package)
  unrelate specPkg from package across R1400;
end if;
select one sis related by self->SQ_SIS[R928];
if(not_empty sis)
  select one sequence related by sis->SQ_S[R911];
  unrelate sis from self across R928;
  select many otherSeqs related by sis->SQ_S[R928];
  if(empty otherSeqs)
    unrelate sis from sequence across R911;
    delete object instance sis;
  end if;
end if;',
	1,
	'',
	2234);
INSERT INTO O_TFR
	VALUES (2235,
	2144,
	'associateWithSystem',
	'',
	19,
	1,
	'// unhook from current parent
self.deassociateFromParent();
// hook up with system
select any system from instances of S_SYS
                                         where (selected.Sys_ID == param.sysID);
relate system to self across R950;',
	1,
	'',
	2239);
INSERT INTO O_TPARM
	VALUES (2240,
	2235,
	'sysID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2241,
	2144,
	'associateWithComponent',
	'',
	19,
	1,
	'// unhook from current parent
self.deassociateFromParent();
// hook up with component
select any component from instances of C_C
                                    where (selected.Id == param.compID);
relate self to component across R952;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (2242,
	2241,
	'compID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2243,
	2144,
	'associateWithComponentPackage',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// unhook from current parent
self.deassociateFromParent();
// hook up with component package
select any cp from instances of CP_CP where (selected.Package_ID == param.cpID);
relate cp to self across R951;',
	1,
	'',
	2241);
INSERT INTO O_TPARM
	VALUES (2244,
	2243,
	'cpID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2237,
	2144,
	'associateWithDomain',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// unhook from current parent
self.deassociateFromParent();
// hook up with domain
select any domain from instances of S_DOM
                                         where (selected.Dom_ID == param.domID);
relate domain to self across R913;',
	1,
	'',
	2243);
INSERT INTO O_TPARM
	VALUES (2245,
	2237,
	'domID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2239,
	2144,
	'associateWithSubsystem',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// unhook from current parent
self.deassociateFromParent();
// hook up with domain
select any ss from instances of S_SS where (selected.SS_ID == param.ssID);
relate ss to self across R914;',
	1,
	'',
	2246);
INSERT INTO O_TPARM
	VALUES (2247,
	2239,
	'ssID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2246,
	2144,
	'associateWithSequence',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// unhook from current parent
self.deassociateFromParent();
// hook up with communication
select any seq from instances of SQ_S
                                     where (selected.Package_ID == param.seqID);
select one sis related by seq->SQ_SIS[R911];
if(empty sis)
  create object instance sis of SQ_SIS;
  relate seq to sis across R911;
end if;
relate self to sis across R928;',
	1,
	'',
	2236);
INSERT INTO O_TPARM
	VALUES (2248,
	2246,
	'seqID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2249,
	2144,
	'pasteSequence',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any seq from instances of SQ_S where (selected.Package_ID == param.id);
if(not_empty seq)
  // guarantee a unique name for the pasted element
  seq.Name = ::getUniqueInitialNameInParent (instance:seq.convertToInstance(),
         					    name:seq.Name, parent:self.convertToInstance());
  seq.associateWithSequence(seqID:self.Package_ID);
end if;',
	1,
	'',
	2205);
INSERT INTO O_TPARM
	VALUES (2250,
	2249,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2251,
	2144,
	'getSequenceCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many sequences related by self->SQ_SIS[R911]->SQ_S[R928];
return cardinality sequences;',
	1,
	'',
	2249);
INSERT INTO O_TFR
	VALUES (2252,
	2144,
	'getSequenceId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many sequences related by self->SQ_SIS[R911]->SQ_S[R928];
// We''re preincrementing the index
count = -1;
for each sequence in sequences
  if (not_empty sequence)
      count = count+1;
  end if;
  if (count == param.index)
      return sequence.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	2251);
INSERT INTO O_TPARM
	VALUES (2253,
	2252,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2254,
	2144,
	'getComponentCount',
	'',
	298,
	1,
	'select many components related by self->SQ_P[R929]->SQ_COP[R930];
return cardinality components;',
	1,
	'',
	2252);
INSERT INTO O_TFR
	VALUES (2255,
	2144,
	'getComponentId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many components related by self->SQ_P[R929]->SQ_COP[R930];
// We''re preincrementing the index
count = -1;
for each component in components
  if (not_empty component)
      count = count+1;
  end if;
  if (count == param.index)
      return component.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	2254);
INSERT INTO O_TPARM
	VALUES (2256,
	2255,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2257,
	2144,
	'getInstanceCount',
	'',
	298,
	1,
	'select many classInstances related by self->SQ_P[R929]->SQ_CIP[R930];
return cardinality classInstances;',
	1,
	'',
	2255);
INSERT INTO O_TFR
	VALUES (2258,
	2144,
	'getInstanceId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many classInstances related by self->SQ_P[R929]->SQ_CIP[R930];
// We''re preincrementing the index
count = -1;
for each classInstance in classInstances
  if (not_empty classInstance)
      count = count+1;
  end if;
  if (count == param.index)
      return classInstance.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	2257);
INSERT INTO O_TPARM
	VALUES (2259,
	2258,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2260,
	2144,
	'getActorCount',
	'',
	298,
	1,
	'select many actors related by self->SQ_P[R929]->SQ_AP[R930];
return cardinality actors;',
	1,
	'',
	2258);
INSERT INTO O_TFR
	VALUES (2261,
	2144,
	'getActorId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many actors related by self->SQ_P[R929]->SQ_AP[R930];
// We''re preincrementing the index
count = -1;
for each actor in actors
  if (not_empty actor)
      count = count+1;
  end if;
  if (count == param.index)
      return actor.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	2260);
INSERT INTO O_TPARM
	VALUES (2262,
	2261,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2263,
	2144,
	'getExternalEntityCount',
	'',
	298,
	1,
	'select many externalEntities related by self->SQ_P[R929]->SQ_EEP[R930];
return cardinality externalEntities;',
	1,
	'',
	2261);
INSERT INTO O_TFR
	VALUES (2264,
	2144,
	'getExternalEntityId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many externalEntities related by self->SQ_P[R929]->SQ_EEP[R930];
// We''re preincrementing the index
count = -1;
for each externalEntity in externalEntities
  if (not_empty externalEntity)
      count = count+1;
  end if;
  if (count == param.index)
      return externalEntity.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	2263);
INSERT INTO O_TPARM
	VALUES (2265,
	2264,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2266,
	2144,
	'getClassCount',
	'',
	298,
	1,
	'select many classes related by self->SQ_P[R929]->SQ_CP[R930];
return cardinality classes;',
	1,
	'',
	2264);
INSERT INTO O_TFR
	VALUES (2267,
	2144,
	'getClassId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many classes related by self->SQ_P[R929]->SQ_CP[R930];
// We''re preincrementing the index
count = -1;
for each classParticipant in classes
  if (not_empty classParticipant)
      count = count+1;
  end if;
  if (count == param.index)
      return classParticipant.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	2266);
INSERT INTO O_TPARM
	VALUES (2268,
	2267,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2269,
	2144,
	'getFunctionPckgCount',
	'',
	298,
	1,
	'select many functionPckgs related by self->SQ_P[R929]->SQ_FPP[R930];
return cardinality functionPckgs;',
	1,
	'',
	2267);
INSERT INTO O_TFR
	VALUES (2270,
	2144,
	'getFunctionPckgId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many functionPckgs related by self->SQ_P[R929]->SQ_FPP[R930];
// We''re preincrementing the index
count = -1;
for each functionPckg in functionPckgs
  if (not_empty functionPckg)
      count = count+1;
  end if;
  if (count == param.index)
      return functionPckg.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	2269);
INSERT INTO O_TPARM
	VALUES (2271,
	2270,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2272,
	2144,
	'getSystemId',
	'',
	296,
	1,
	'// Sequence.getSystemId()
select one system related by self->S_SYS[R950];
if not_empty system
  return system.Sys_ID;
end if;
select one compPkg related by self->CP_CP[R951];
if not_empty compPkg
  return compPkg.getSystemId();
end if;
select one component related by self->C_C[R952];
if not_empty compPkg
  return component.getSystemId();
end if;
select one parentSeq related by self->SQ_SIS[R928]->SQ_S[R911];
if not_empty parentSeq
  return parentSeq.getSystemId();
end if;
select one domain related by self->S_DOM[R913];
if not_empty domain
  return domain.getSystemId();
end if;
select one subsystem related by self->S_SS[R914];
if not_empty subsystem
  return subsystem.getSystemId();
end if;
USER::logError(msg:"getSystemId()::No parent found for sequence",path:"");
return GD::NULL_UNIQUE_ID();',
	1,
	'',
	2270);
INSERT INTO O_TFR
	VALUES (2273,
	2144,
	'pasteActorParticipant',
	'',
	19,
	1,
	'select any actor from instances of SQ_AP
                                           where (selected.Part_ID == param.id);
if(not_empty actor)
  select one part related by actor->SQ_P[R930];
  select one existingContainer related by part->SQ_S[R929];
  if(not_empty existingContainer)
    unrelate part from existingContainer across R929;
  end if;
  relate part to self across R929;
end if;',
	1,
	'',
	2272);
INSERT INTO O_TPARM
	VALUES (2274,
	2273,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2275,
	2144,
	'pasteClassParticipant',
	'',
	19,
	1,
	'select any cp from instances of SQ_CP where (selected.Part_ID == param.id);
if(not_empty cp)
  select one part related by cp->SQ_P[R930];
  select one existingContainer related by part->SQ_S[R929];
  if(not_empty existingContainer)
    unrelate part from existingContainer across R929;
  end if;
  relate part to self across R929;
end if;',
	1,
	'',
	2273);
INSERT INTO O_TPARM
	VALUES (2276,
	2275,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2277,
	2144,
	'pasteClassInstanceParticipant',
	'',
	19,
	1,
	'select any cip from instances of SQ_CIP where (selected.Part_ID == param.id);
if(not_empty cip)
  select one part related by cip->SQ_P[R930];
  select one existingContainer related by part->SQ_S[R929];
  if(not_empty existingContainer)
    unrelate part from existingContainer across R929;
  end if;
  relate part to self across R929;
end if;',
	1,
	'',
	2275);
INSERT INTO O_TPARM
	VALUES (2278,
	2277,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2279,
	2144,
	'pasteExternalEntityParticipant',
	'',
	19,
	1,
	'select any eep from instances of SQ_EEP where (selected.Part_ID == param.id);
if(not_empty eep)
  select one part related by eep->SQ_P[R930];
  select one existingContainer related by part->SQ_S[R929];
  if(not_empty existingContainer)
    unrelate part from existingContainer across R929;
  end if;
  relate part to self across R929;
end if;',
	1,
	'',
	2277);
INSERT INTO O_TPARM
	VALUES (2280,
	2279,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2281,
	2144,
	'pasteComponentParticipant',
	'',
	19,
	1,
	'select any comp from instances of SQ_COP where (selected.Part_ID == param.id);
if(not_empty comp)
  select one part related by comp->SQ_P[R930];
  select one existingContainer related by part->SQ_S[R929];
  if(not_empty existingContainer)
    unrelate part from existingContainer across R929;
  end if;
  relate part to self across R929;
end if;',
	1,
	'',
	2279);
INSERT INTO O_TPARM
	VALUES (2282,
	2281,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2283,
	2144,
	'pasteFunctionPackageParticipant',
	'',
	19,
	1,
	'select any fpp from instances of SQ_FPP where (selected.Part_ID == param.id);
if(not_empty fpp)
  select one part related by fpp->SQ_P[R930];
  select one existingContainer related by part->SQ_S[R929];
  if(not_empty existingContainer)
    unrelate part from existingContainer across R929;
  end if;
  relate part to self across R929;
end if;',
	1,
	'',
	2281);
INSERT INTO O_TPARM
	VALUES (2284,
	2283,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2285,
	2144,
	'pasteSynchronousMessage',
	'',
	19,
	1,
	'// this method does not need to do anything, just exist
// so that the menu is enabled',
	1,
	'',
	2283);
INSERT INTO O_TPARM
	VALUES (2286,
	2285,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2287,
	2144,
	'pasteAsynchronousMessage',
	'',
	19,
	1,
	'// this method does not need to do anything, just exist
// so that the menu is enabled',
	1,
	'',
	2285);
INSERT INTO O_TPARM
	VALUES (2288,
	2287,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2289,
	2144,
	'pasteReturnMessage',
	'',
	19,
	1,
	'// this method does not need to do anything, just exist
// so that the menu is enabled',
	1,
	'',
	2287);
INSERT INTO O_TPARM
	VALUES (2290,
	2289,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2291,
	2144,
	'pasteLifespan',
	'',
	19,
	1,
	'select any lifespan from instances of SQ_LS where (selected.Part_ID == param.id);
if(not_empty lifespan)
  select one part related by lifespan->SQ_P[R930];
  relate part to self across R929;
end if;',
	1,
	'',
	2289);
INSERT INTO O_TPARM
	VALUES (2292,
	2291,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2293,
	2144,
	'pasteTimingMark',
	'',
	19,
	1,
	'// this method does not need to do anything, just exist
// so that the menu is enabled',
	1,
	'',
	2291);
INSERT INTO O_TPARM
	VALUES (2294,
	2293,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2295,
	2144,
	'pasteTimeSpan',
	'',
	19,
	1,
	'// this method does not need to do anything, just exist
// so that the menu is enabled',
	1,
	'',
	2293);
INSERT INTO O_TPARM
	VALUES (2296,
	2295,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (2144,
	699,
	0,
	712,
	2142,
	2145,
	2143,
	2297,
	2298,
	0,
	0,
	'',
	'Domain',
	'Dom_ID',
	'R913');
INSERT INTO O_RATTR
	VALUES (2297,
	2144,
	712,
	699,
	1,
	'Dom_ID');
INSERT INTO O_ATTR
	VALUES (2297,
	2144,
	2156,
	'Dom_ID',
	'',
	'',
	'Dom_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2299,
	2144);
INSERT INTO O_BATTR
	VALUES (2299,
	2144);
INSERT INTO O_ATTR
	VALUES (2299,
	2144,
	2297,
	'Name',
	'Full Name: Sequence Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (2144,
	701,
	0,
	717,
	2146,
	2148,
	2147,
	2300,
	2301,
	0,
	0,
	'',
	'Subsystem',
	'SS_ID',
	'R914');
INSERT INTO O_RATTR
	VALUES (2300,
	2144,
	717,
	701,
	1,
	'SS_ID');
INSERT INTO O_ATTR
	VALUES (2300,
	2144,
	2299,
	'SS_ID',
	'',
	'',
	'SS_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2302,
	2144);
INSERT INTO O_BATTR
	VALUES (2302,
	2144);
INSERT INTO O_ATTR
	VALUES (2302,
	2144,
	2303,
	'Descrip',
	'Full Name: Sequence Description
Description: A textual description of this sequence.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (2144,
	705,
	0,
	754,
	2161,
	2163,
	2162,
	2304,
	2305,
	0,
	0,
	'',
	'System Model',
	'Sys_ID',
	'R950');
INSERT INTO O_RATTR
	VALUES (2304,
	2144,
	754,
	705,
	1,
	'Sys_ID');
INSERT INTO O_ATTR
	VALUES (2304,
	2144,
	2302,
	'Sys_ID',
	'',
	'',
	'Sys_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2144,
	773,
	0,
	772,
	854,
	2306,
	856,
	2156,
	2307,
	0,
	0,
	'',
	'Specification Package',
	'Package_ID',
	'R1402');
INSERT INTO O_RATTR
	VALUES (2156,
	2144,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (2156,
	2144,
	0,
	'Package_ID',
	'',
	'',
	'Package_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2144,
	707,
	0,
	758,
	2164,
	2166,
	2165,
	2308,
	2309,
	0,
	0,
	'',
	'Component Package',
	'Package_ID',
	'R951');
INSERT INTO O_RATTR
	VALUES (2308,
	2144,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (2308,
	2144,
	2304,
	'Component_Package_ID',
	'',
	'Component_',
	'Package_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2144,
	2151,
	0,
	2153,
	2149,
	2150,
	2152,
	2303,
	2310,
	0,
	0,
	'',
	'Sequence in Sequence',
	'Package_ID',
	'R928');
INSERT INTO O_RATTR
	VALUES (2303,
	2144,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (2303,
	2144,
	2300,
	'Prev_Package_ID',
	'',
	'Prev_',
	'Package_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2144,
	709,
	0,
	762,
	2167,
	2169,
	2168,
	2311,
	2312,
	0,
	0,
	'',
	'Component',
	'Id',
	'R952');
INSERT INTO O_RATTR
	VALUES (2311,
	2144,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (2311,
	2144,
	2308,
	'Component_Id',
	'',
	'Component_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2144);
INSERT INTO O_OIDA
	VALUES (2156,
	2144,
	0,
	'Package_ID');
INSERT INTO O_ID
	VALUES (1,
	2144);
INSERT INTO O_ID
	VALUES (2,
	2144);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2172,
	'Message In Sequence',
	907,
	'SQ_MIS',
	'',
	2133);
INSERT INTO O_REF
	VALUES (2172,
	2141,
	0,
	2177,
	2174,
	2175,
	2176,
	2313,
	2314,
	0,
	0,
	'',
	'Message',
	'Msg_ID',
	'R954');
INSERT INTO O_RATTR
	VALUES (2313,
	2172,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (2313,
	2172,
	0,
	'Msg_ID',
	'',
	'',
	'Msg_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2172,
	2144,
	0,
	2156,
	2170,
	2173,
	2171,
	2315,
	2316,
	0,
	0,
	'',
	'Sequence',
	'Package_ID',
	'R953');
INSERT INTO O_RATTR
	VALUES (2315,
	2172,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (2315,
	2172,
	2313,
	'Package_ID',
	'',
	'',
	'Package_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2172);
INSERT INTO O_OIDA
	VALUES (2313,
	2172,
	0,
	'Msg_ID');
INSERT INTO O_OIDA
	VALUES (2315,
	2172,
	0,
	'Package_ID');
INSERT INTO O_ID
	VALUES (1,
	2172);
INSERT INTO O_ID
	VALUES (2,
	2172);
-- BP 7.1 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (2317,
	'Selection',
	'This subsystem captures concepts related to selections of instances across associations. Association chain, where and instance extent selections are also covered.
Notify_Changes:false
Persistent:false
// This is used by schema_gen to ignore this subsystem (for publication)
TRANSLATE_FOR_EXTERNAL_USE:FALSE
',
	'ACT',
	600,
	1,
	2318);
INSERT INTO S_SID
	VALUES (1,
	2317);
INSERT INTO O_IOBJ
	VALUES (2319,
	70,
	5,
	2317,
	'Value',
	'V_VAL');
INSERT INTO O_IOBJ
	VALUES (2320,
	129,
	5,
	2317,
	'Variable',
	'V_VAR');
INSERT INTO O_IOBJ
	VALUES (2321,
	2322,
	5,
	2317,
	'Association',
	'R_REL');
INSERT INTO O_IOBJ
	VALUES (2323,
	30,
	5,
	2317,
	'Model Class',
	'O_OBJ');
INSERT INTO O_IOBJ
	VALUES (2324,
	30,
	5,
	2317,
	'Model Class',
	'O_OBJ');
INSERT INTO O_IOBJ
	VALUES (2325,
	70,
	5,
	2317,
	'Value',
	'V_VAL');
INSERT INTO R_SIMP
	VALUES (2326);
INSERT INTO R_REL
	VALUES (2326,
	604,
	'',
	2317);
INSERT INTO R_PART
	VALUES (2327,
	2326,
	2328,
	0,
	1,
	'precedes');
INSERT INTO O_RTIDA
	VALUES (2329,
	2327,
	0,
	2326,
	2328);
INSERT INTO R_RTO
	VALUES (2327,
	2326,
	2328,
	0);
INSERT INTO R_OIR
	VALUES (2327,
	2326,
	2328,
	0);
INSERT INTO R_FORM
	VALUES (2327,
	2326,
	2330,
	0,
	1,
	'succeeds');
INSERT INTO R_RGO
	VALUES (2327,
	2326,
	2330);
INSERT INTO R_OIR
	VALUES (2327,
	2326,
	2330,
	0);
INSERT INTO R_SUBSUP
	VALUES (2331);
INSERT INTO R_REL
	VALUES (2331,
	664,
	'',
	2317);
INSERT INTO R_SUPER
	VALUES (2332,
	2331,
	2333);
INSERT INTO O_RTIDA
	VALUES (2334,
	2332,
	0,
	2331,
	2333);
INSERT INTO R_RTO
	VALUES (2332,
	2331,
	2333,
	0);
INSERT INTO R_OIR
	VALUES (2332,
	2331,
	2333,
	0);
INSERT INTO R_SUB
	VALUES (2335,
	2331,
	2336);
INSERT INTO R_RGO
	VALUES (2335,
	2331,
	2336);
INSERT INTO R_OIR
	VALUES (2335,
	2331,
	2336,
	0);
INSERT INTO R_SUB
	VALUES (2337,
	2331,
	2338);
INSERT INTO R_RGO
	VALUES (2337,
	2331,
	2338);
INSERT INTO R_OIR
	VALUES (2337,
	2331,
	2338,
	0);
INSERT INTO R_SIMP
	VALUES (2339);
INSERT INTO R_REL
	VALUES (2339,
	610,
	'',
	2317);
INSERT INTO R_FORM
	VALUES (2340,
	2339,
	2341,
	0,
	1,
	'');
INSERT INTO R_RGO
	VALUES (2340,
	2339,
	2341);
INSERT INTO R_OIR
	VALUES (2340,
	2339,
	2341,
	0);
INSERT INTO R_PART
	VALUES (70,
	2339,
	2342,
	0,
	0,
	'where clause');
INSERT INTO O_RTIDA
	VALUES (72,
	70,
	0,
	2339,
	2342);
INSERT INTO R_RTO
	VALUES (70,
	2339,
	2342,
	0);
INSERT INTO R_OIR
	VALUES (70,
	2339,
	2342,
	2319);
INSERT INTO R_SIMP
	VALUES (2343);
INSERT INTO R_REL
	VALUES (2343,
	611,
	'',
	2317);
INSERT INTO R_FORM
	VALUES (2335,
	2343,
	2344,
	0,
	1,
	'');
INSERT INTO R_RGO
	VALUES (2335,
	2343,
	2344);
INSERT INTO R_OIR
	VALUES (2335,
	2343,
	2344,
	0);
INSERT INTO R_PART
	VALUES (70,
	2343,
	2345,
	0,
	0,
	'where clause');
INSERT INTO O_RTIDA
	VALUES (72,
	70,
	0,
	2343,
	2345);
INSERT INTO R_RTO
	VALUES (70,
	2343,
	2345,
	0);
INSERT INTO R_OIR
	VALUES (70,
	2343,
	2345,
	2319);
INSERT INTO R_SIMP
	VALUES (2346);
INSERT INTO R_REL
	VALUES (2346,
	665,
	'',
	2317);
INSERT INTO R_FORM
	VALUES (2340,
	2346,
	2347,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (2340,
	2346,
	2347);
INSERT INTO R_OIR
	VALUES (2340,
	2346,
	2347,
	0);
INSERT INTO R_PART
	VALUES (129,
	2346,
	2348,
	0,
	0,
	'result');
INSERT INTO O_RTIDA
	VALUES (131,
	129,
	0,
	2346,
	2348);
INSERT INTO R_RTO
	VALUES (129,
	2346,
	2348,
	0);
INSERT INTO R_OIR
	VALUES (129,
	2346,
	2348,
	2320);
INSERT INTO R_SIMP
	VALUES (2349);
INSERT INTO R_REL
	VALUES (2349,
	639,
	'',
	2317);
INSERT INTO R_FORM
	VALUES (2350,
	2349,
	2351,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (2350,
	2349,
	2351);
INSERT INTO R_OIR
	VALUES (2350,
	2349,
	2351,
	0);
INSERT INTO R_PART
	VALUES (129,
	2349,
	2352,
	0,
	0,
	'selection');
INSERT INTO O_RTIDA
	VALUES (131,
	129,
	0,
	2349,
	2352);
INSERT INTO R_RTO
	VALUES (129,
	2349,
	2352,
	0);
INSERT INTO R_OIR
	VALUES (129,
	2349,
	2352,
	2320);
INSERT INTO R_SIMP
	VALUES (2353);
INSERT INTO R_REL
	VALUES (2353,
	638,
	'',
	2317);
INSERT INTO R_FORM
	VALUES (2332,
	2353,
	2354,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (2332,
	2353,
	2354);
INSERT INTO R_OIR
	VALUES (2332,
	2353,
	2354,
	0);
INSERT INTO R_PART
	VALUES (129,
	2353,
	2355,
	0,
	0,
	'selection');
INSERT INTO O_RTIDA
	VALUES (131,
	129,
	0,
	2353,
	2355);
INSERT INTO R_RTO
	VALUES (129,
	2353,
	2355,
	0);
INSERT INTO R_OIR
	VALUES (129,
	2353,
	2355,
	2320);
INSERT INTO R_SIMP
	VALUES (2356);
INSERT INTO R_REL
	VALUES (2356,
	676,
	'',
	2317);
INSERT INTO R_FORM
	VALUES (2340,
	2356,
	2357,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (2340,
	2356,
	2357);
INSERT INTO R_OIR
	VALUES (2340,
	2356,
	2357,
	0);
INSERT INTO R_PART
	VALUES (30,
	2356,
	2358,
	0,
	1,
	'from extent of');
INSERT INTO O_RTIDA
	VALUES (150,
	30,
	0,
	2356,
	2358);
INSERT INTO R_RTO
	VALUES (30,
	2356,
	2358,
	0);
INSERT INTO R_OIR
	VALUES (30,
	2356,
	2358,
	2323);
INSERT INTO R_SIMP
	VALUES (2359);
INSERT INTO R_REL
	VALUES (2359,
	677,
	'',
	2317);
INSERT INTO R_FORM
	VALUES (2350,
	2359,
	2360,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (2350,
	2359,
	2360);
INSERT INTO R_OIR
	VALUES (2350,
	2359,
	2360,
	0);
INSERT INTO R_PART
	VALUES (30,
	2359,
	2361,
	0,
	1,
	'from extent of');
INSERT INTO O_RTIDA
	VALUES (150,
	30,
	0,
	2359,
	2361);
INSERT INTO R_RTO
	VALUES (30,
	2359,
	2361,
	0);
INSERT INTO R_OIR
	VALUES (30,
	2359,
	2361,
	2323);
INSERT INTO R_SIMP
	VALUES (2362);
INSERT INTO R_REL
	VALUES (2362,
	678,
	'',
	2317);
INSERT INTO R_FORM
	VALUES (2327,
	2362,
	2363,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (2327,
	2362,
	2363);
INSERT INTO R_OIR
	VALUES (2327,
	2362,
	2363,
	0);
INSERT INTO R_PART
	VALUES (30,
	2362,
	2364,
	0,
	0,
	'specifies instances of');
INSERT INTO O_RTIDA
	VALUES (150,
	30,
	0,
	2362,
	2364);
INSERT INTO R_RTO
	VALUES (30,
	2362,
	2364,
	0);
INSERT INTO R_OIR
	VALUES (30,
	2362,
	2364,
	2324);
INSERT INTO R_SIMP
	VALUES (2365);
INSERT INTO R_REL
	VALUES (2365,
	681,
	'',
	2317);
INSERT INTO R_FORM
	VALUES (2327,
	2365,
	2366,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (2327,
	2365,
	2366);
INSERT INTO R_OIR
	VALUES (2327,
	2365,
	2366,
	0);
INSERT INTO R_PART
	VALUES (2322,
	2365,
	2367,
	0,
	0,
	'specifies traversal of');
INSERT INTO O_RTIDA
	VALUES (2368,
	2322,
	0,
	2365,
	2367);
INSERT INTO R_RTO
	VALUES (2322,
	2365,
	2367,
	0);
INSERT INTO R_OIR
	VALUES (2322,
	2365,
	2367,
	2321);
INSERT INTO R_SIMP
	VALUES (2369);
INSERT INTO R_REL
	VALUES (2369,
	637,
	'',
	2317);
INSERT INTO R_PART
	VALUES (2332,
	2369,
	2370,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (2334,
	2332,
	0,
	2369,
	2370);
INSERT INTO R_RTO
	VALUES (2332,
	2369,
	2370,
	0);
INSERT INTO R_OIR
	VALUES (2332,
	2369,
	2370,
	0);
INSERT INTO R_FORM
	VALUES (2327,
	2369,
	2371,
	0,
	0,
	'starts with');
INSERT INTO R_RGO
	VALUES (2327,
	2369,
	2371);
INSERT INTO R_OIR
	VALUES (2327,
	2369,
	2371,
	0);
INSERT INTO R_SIMP
	VALUES (2372);
INSERT INTO R_REL
	VALUES (2372,
	613,
	'This association captures the variable used to start the navigation chain.
Note that the Value we are related to always has a subtype of either 
Instance Reference or Instance Set Reference, which will point to the variable 
that starts the navigation change.',
	2317);
INSERT INTO R_FORM
	VALUES (2332,
	2372,
	2373,
	0,
	1,
	'');
INSERT INTO R_RGO
	VALUES (2332,
	2372,
	2373);
INSERT INTO R_OIR
	VALUES (2332,
	2372,
	2373,
	0);
INSERT INTO R_PART
	VALUES (70,
	2372,
	2374,
	0,
	0,
	'starting point');
INSERT INTO O_RTIDA
	VALUES (72,
	70,
	0,
	2372,
	2374);
INSERT INTO R_RTO
	VALUES (70,
	2372,
	2374,
	0);
INSERT INTO R_OIR
	VALUES (70,
	2372,
	2374,
	2325);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2335,
	'Select Related Where',
	604,
	'ACT_SRW',
	'This class represents a statement that selects a set of instances related across one or more associations with the support of a where clause.  The where clause consists of a boolean expression containing the special instance handle ''selected''. If the expression evaluates to true, the instance represented by ''selected '' is added to the result set of the statement.
',
	2317);
INSERT INTO O_TFR
	VALUES (2375,
	2335,
	'execute',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (2376,
	2375,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (2335,
	2332,
	0,
	2334,
	2331,
	2336,
	2333,
	2377,
	2378,
	0,
	0,
	'',
	'Select',
	'Statement_ID',
	'R664');
INSERT INTO O_RATTR
	VALUES (2377,
	2335,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (2377,
	2335,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2335,
	70,
	0,
	72,
	2343,
	2344,
	2345,
	2379,
	2380,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R611.''where clause''');
INSERT INTO O_RATTR
	VALUES (2379,
	2335,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (2379,
	2335,
	2377,
	'Where_Clause_Value_ID',
	'',
	'Where_Clause_',
	'Value_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2335);
INSERT INTO O_OIDA
	VALUES (2377,
	2335,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	2335);
INSERT INTO O_ID
	VALUES (2,
	2335);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2337,
	'Select Related By',
	623,
	'ACT_SR',
	'This class represents a statement that selects a set of instances related across one or more associations.',
	2317);
INSERT INTO O_REF
	VALUES (2337,
	2332,
	0,
	2334,
	2331,
	2338,
	2333,
	2381,
	2382,
	0,
	0,
	'',
	'Select',
	'Statement_ID',
	'R664');
INSERT INTO O_RATTR
	VALUES (2381,
	2337,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (2381,
	2337,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2337);
INSERT INTO O_OIDA
	VALUES (2381,
	2337,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	2337);
INSERT INTO O_ID
	VALUES (2,
	2337);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2340,
	'Select From Instances Where',
	611,
	'ACT_FIW',
	'This class represents a statement that selects a set of  instances from a class extent with the support of a where clause.  The where clause consists of a boolean expression containing the special instance handle ''selected''. If the expression evaluates to true, the instance represented by ''selected '' is added to the result set of the statement.
',
	2317);
INSERT INTO O_TFR
	VALUES (2383,
	2340,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'select one obj related by self->O_OBJ[R676];
if ( not_empty obj )
  unrelate self from obj across R676;
end if;

select one var related by self->V_VAR[R665];
if ( not_empty var )
  unrelate self from var across R665;
  if ( not var.Declared )
    var.dispose();
  end if;
end if;

select one val related by self->V_VAL[R610];
if ( not_empty val )
  unrelate self from val across R610;
  val.dispose();
end if;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (2384,
	2340,
	'execute',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	2383);
INSERT INTO O_TPARM
	VALUES (2385,
	2384,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (2340,
	686,
	0,
	685,
	2386,
	2387,
	2388,
	2389,
	2390,
	0,
	0,
	'',
	'Statement',
	'Statement_ID',
	'R603');
INSERT INTO O_RATTR
	VALUES (2389,
	2340,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (2389,
	2340,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2340,
	129,
	0,
	131,
	2346,
	2347,
	2348,
	2391,
	2392,
	0,
	0,
	'',
	'Variable',
	'Var_ID',
	'R665.''result''');
INSERT INTO O_RATTR
	VALUES (2391,
	2340,
	131,
	129,
	1,
	'Var_ID');
INSERT INTO O_ATTR
	VALUES (2391,
	2340,
	2389,
	'Var_ID',
	'

',
	'',
	'Var_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2393,
	2340);
INSERT INTO O_BATTR
	VALUES (2393,
	2340);
INSERT INTO O_ATTR
	VALUES (2393,
	2340,
	2391,
	'is_implicit',
	'Full Name: Is Implicit
Specifies whether the resulting instance handle found is being used for the first time in this scope or not.',
	'',
	'is_implicit',
	0,
	316,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2394,
	2340);
INSERT INTO O_BATTR
	VALUES (2394,
	2340);
INSERT INTO O_ATTR
	VALUES (2394,
	2340,
	2393,
	'cardinality',
	'Full Name: Selection Cardinality
Specifies whether the selection produces a set or an instance as a result.    The cardinality value can be one of the following: one, any, or many. ',
	'',
	'cardinality',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (2340,
	70,
	0,
	72,
	2339,
	2341,
	2342,
	2395,
	2396,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R610.''where clause''');
INSERT INTO O_RATTR
	VALUES (2395,
	2340,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (2395,
	2340,
	2394,
	'Where_Clause_Value_ID',
	'

',
	'Where_Clause_',
	'Value_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2397,
	2340);
INSERT INTO O_BATTR
	VALUES (2397,
	2340);
INSERT INTO O_ATTR
	VALUES (2397,
	2340,
	2398,
	'extentLineNumber',
	'',
	'',
	'extentLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2399,
	2340);
INSERT INTO O_BATTR
	VALUES (2399,
	2340);
INSERT INTO O_ATTR
	VALUES (2399,
	2340,
	2397,
	'extentColumn',
	'',
	'',
	'extentColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_REF
	VALUES (2340,
	30,
	0,
	150,
	2356,
	2357,
	2358,
	2398,
	2400,
	0,
	0,
	'',
	'Model Class',
	'Obj_ID',
	'R676.''from extent of''');
INSERT INTO O_RATTR
	VALUES (2398,
	2340,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (2398,
	2340,
	2395,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2340);
INSERT INTO O_OIDA
	VALUES (2389,
	2340,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	2340);
INSERT INTO O_ID
	VALUES (2,
	2340);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2350,
	'Select From Instances',
	612,
	'ACT_FIO',
	'This class represents a statement that selects a set of  instances from a class extent.',
	2317);
INSERT INTO O_TFR
	VALUES (2401,
	2350,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'select one obj related by self->O_OBJ[R677];
if ( not_empty obj )
  unrelate self from obj across R677;
end if;

select one var related by self->V_VAR[R639];
if ( not_empty var )
  unrelate self from var across R639;
  if ( not var.Declared )
    var.dispose();
  end if;
end if;
delete object instance self;

',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (2402,
	2350,
	'execute',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	2401);
INSERT INTO O_TPARM
	VALUES (2403,
	2402,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (2350,
	686,
	0,
	685,
	2386,
	2404,
	2388,
	2405,
	2406,
	0,
	0,
	'',
	'Statement',
	'Statement_ID',
	'R603');
INSERT INTO O_RATTR
	VALUES (2405,
	2350,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (2405,
	2350,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2350,
	129,
	0,
	131,
	2349,
	2351,
	2352,
	2407,
	2408,
	0,
	0,
	'',
	'Variable',
	'Var_ID',
	'R639.''selection''');
INSERT INTO O_RATTR
	VALUES (2407,
	2350,
	131,
	129,
	1,
	'Var_ID');
INSERT INTO O_ATTR
	VALUES (2407,
	2350,
	2405,
	'Var_ID',
	'

',
	'',
	'Var_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2409,
	2350);
INSERT INTO O_BATTR
	VALUES (2409,
	2350);
INSERT INTO O_ATTR
	VALUES (2409,
	2350,
	2407,
	'is_implicit',
	'Full Name: Is Implicit
Specifies whether the resulting instance handle found is being used for the first time in this scope or not.',
	'',
	'is_implicit',
	0,
	316,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2410,
	2350);
INSERT INTO O_BATTR
	VALUES (2410,
	2350);
INSERT INTO O_ATTR
	VALUES (2410,
	2350,
	2409,
	'cardinality',
	'Full Name: Selection Cardinality
Specifies whether the selection produces a set or an instance as a result.    The cardinality value can be one of the following: one, any, or many.',
	'',
	'cardinality',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2411,
	2350);
INSERT INTO O_BATTR
	VALUES (2411,
	2350);
INSERT INTO O_ATTR
	VALUES (2411,
	2350,
	2412,
	'extentLineNumber',
	'',
	'',
	'extentLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2413,
	2350);
INSERT INTO O_BATTR
	VALUES (2413,
	2350);
INSERT INTO O_ATTR
	VALUES (2413,
	2350,
	2411,
	'extentColumn',
	'',
	'',
	'extentColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_REF
	VALUES (2350,
	30,
	0,
	150,
	2359,
	2360,
	2361,
	2412,
	2414,
	0,
	0,
	'',
	'Model Class',
	'Obj_ID',
	'R677.''from extent of''');
INSERT INTO O_RATTR
	VALUES (2412,
	2350,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (2412,
	2350,
	2410,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2350);
INSERT INTO O_OIDA
	VALUES (2405,
	2350,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	2350);
INSERT INTO O_ID
	VALUES (2,
	2350);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2332,
	'Select',
	605,
	'ACT_SEL',
	'This class represents a statement that selects a set of  instances.',
	2317);
INSERT INTO O_TFR
	VALUES (2415,
	2332,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'select one sr related by self->ACT_SR[R664];
if ( not_empty sr )
  unrelate self from sr across R664;
  delete object instance sr;
end if;

select one srw related by self->ACT_SRW[R664];
if ( not_empty srw )
  unrelate self from srw across R664;
  select one val related by srw->V_VAL[R611];
  if ( not_empty val )
    unrelate srw from val across R611;
    val.dispose();
  end if;
  delete object instance srw;
end if;

select one var related by self->V_VAR[R638];
if ( not_empty var )
  unrelate self from var across R638;
  if ( not var.Declared )
    var.dispose();
  end if;
end if;

select one val related by self->V_VAL[R613];
if ( not_empty val )
  unrelate self from val across R613;
  val.dispose();
end if;

select one link related by self->ACT_LNK[R637];
if ( not_empty link )
  unrelate self from link across R637;
  while ( not_empty link )
    this_link = link;
    select one link related by this_link->ACT_LNK[R604.''precedes''];
    this_link.dispose();
  end while;
end if;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (2416,
	2332,
	'execute',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	2415);
INSERT INTO O_TPARM
	VALUES (2417,
	2416,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (2332,
	686,
	0,
	685,
	2386,
	2418,
	2388,
	2334,
	2419,
	0,
	0,
	'',
	'Statement',
	'Statement_ID',
	'R603');
INSERT INTO O_RATTR
	VALUES (2334,
	2332,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (2334,
	2332,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2332,
	129,
	0,
	131,
	2353,
	2354,
	2355,
	2420,
	2421,
	0,
	0,
	'',
	'Variable',
	'Var_ID',
	'R638.''selection''');
INSERT INTO O_RATTR
	VALUES (2420,
	2332,
	131,
	129,
	1,
	'Var_ID');
INSERT INTO O_ATTR
	VALUES (2420,
	2332,
	2334,
	'Var_ID',
	'

',
	'',
	'Var_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2422,
	2332);
INSERT INTO O_BATTR
	VALUES (2422,
	2332);
INSERT INTO O_ATTR
	VALUES (2422,
	2332,
	2420,
	'is_implicit',
	'Full Name: Is Implicit
Specifies whether the resulting instance handle found by traversing
R638 is being used for the first time in this scope or not.',
	'',
	'is_implicit',
	0,
	316,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2423,
	2332);
INSERT INTO O_BATTR
	VALUES (2423,
	2332);
INSERT INTO O_ATTR
	VALUES (2423,
	2332,
	2422,
	'cardinality',
	'Full Name: Selection Cardinality
Specifies whether the selection produces a set or an instance as a result.  The cardinality value can be one of the following: one, any, or many.',
	'',
	'cardinality',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (2332,
	70,
	0,
	72,
	2372,
	2373,
	2374,
	2424,
	2425,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R613.''starting point''');
INSERT INTO O_RATTR
	VALUES (2424,
	2332,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (2424,
	2332,
	2423,
	'Value_ID',
	'

',
	'',
	'Value_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2332);
INSERT INTO O_OIDA
	VALUES (2334,
	2332,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	2332);
INSERT INTO O_ID
	VALUES (2,
	2332);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2327,
	'Chain Link',
	627,
	'ACT_LNK',
	'This class represents a link in an association chain. In the string "self->O_OND[R5]->D_D[R7]", there are two chain links, one from the current instance to an instance (or set) of the class with keyletters "D_OND" found by traversing association "R5" and from there to an instance or set of the class with keyletters "D_D", crossing "R7". Each link is captured as an instance of this meta-model class. The target class is captured for each link, as is the association used for the traversal. The order of traversal is significant and is also captured.',
	2317);
INSERT INTO O_TFR
	VALUES (2426,
	2327,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'select one obj related by self->O_OBJ[R678];
if ( not_empty obj )
  unrelate self from obj across R678;
end if;
select one rel related by self->R_REL[R681];
if ( not_empty rel )
  unrelate self from rel across R681;
end if;
select one selection related by self->ACT_SEL[R637];
if (not_empty selection)
  unrelate self from selection across R637;
end if;
select one next_link related by self->ACT_LNK[R604.''precedes''];
select one prior_link related by self->ACT_LNK[R604.''succeeds''];
if ( not_empty next_link and not_empty prior_link )
  // in the middle of the chain
  unrelate self from next_link across R604.''precedes'';
  unrelate prior_link from self across R604.''precedes'';
  relate prior_link to next_link across R604.''precedes'';
else
  if ( not_empty prior_link and empty next_link )
    // we''re last in list
    unrelate prior_link from self across R604.''precedes'';
  else
    // we''re first in list
    unrelate self from next_link across R604.''precedes'';
  end if;
end if;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_NBATTR
	VALUES (2329,
	2327);
INSERT INTO O_BATTR
	VALUES (2329,
	2327);
INSERT INTO O_ATTR
	VALUES (2329,
	2327,
	0,
	'Link_ID',
	'',
	'',
	'Link_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2427,
	2327);
INSERT INTO O_BATTR
	VALUES (2427,
	2327);
INSERT INTO O_ATTR
	VALUES (2427,
	2327,
	2329,
	'Rel_Phrase',
	'Full Name: Relationship Phrase
Specifies the relationship phrase at the target end of the association.
Essential for disambiguating the navigation direction across the link.',
	'',
	'Rel_Phrase',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (2327,
	2332,
	0,
	2334,
	2369,
	2371,
	2370,
	2428,
	2429,
	0,
	0,
	'',
	'Select',
	'Statement_ID',
	'R637');
INSERT INTO O_RATTR
	VALUES (2428,
	2327,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (2428,
	2327,
	2427,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2327,
	2327,
	0,
	2329,
	2326,
	2330,
	2328,
	2430,
	2431,
	0,
	0,
	'',
	'Chain Link',
	'Link_ID',
	'R604');
INSERT INTO O_RATTR
	VALUES (2430,
	2327,
	2329,
	2327,
	1,
	'Link_ID');
INSERT INTO O_ATTR
	VALUES (2430,
	2327,
	2432,
	'Next_Link_ID',
	'',
	'Next_',
	'Link_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2433,
	2327);
INSERT INTO O_BATTR
	VALUES (2433,
	2327);
INSERT INTO O_ATTR
	VALUES (2433,
	2327,
	2430,
	'Mult',
	'This attribute has the value "one" if following this link 
results in a single instance, or "many" if following this
link can result in multiple instances.

',
	'',
	'Mult',
	0,
	2434,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2435,
	2327);
INSERT INTO O_BATTR
	VALUES (2435,
	2327);
INSERT INTO O_ATTR
	VALUES (2435,
	2327,
	2436,
	'modelClassKeyLettersLineNumber',
	'',
	'',
	'modelClassKeyLettersLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2437,
	2327);
INSERT INTO O_BATTR
	VALUES (2437,
	2327);
INSERT INTO O_ATTR
	VALUES (2437,
	2327,
	2435,
	'modelClassKeyLettersColumn',
	'',
	'',
	'modelClassKeyLettersColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2438,
	2327);
INSERT INTO O_BATTR
	VALUES (2438,
	2327);
INSERT INTO O_ATTR
	VALUES (2438,
	2327,
	2437,
	'associationNumberLineNumber',
	'',
	'',
	'associationNumberLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2439,
	2327);
INSERT INTO O_BATTR
	VALUES (2439,
	2327);
INSERT INTO O_ATTR
	VALUES (2439,
	2327,
	2438,
	'associationNumberColumn',
	'',
	'',
	'associationNumberColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2440,
	2327);
INSERT INTO O_BATTR
	VALUES (2440,
	2327);
INSERT INTO O_ATTR
	VALUES (2440,
	2327,
	2439,
	'phraseLineNumber',
	'',
	'',
	'phraseLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2441,
	2327);
INSERT INTO O_BATTR
	VALUES (2441,
	2327);
INSERT INTO O_ATTR
	VALUES (2441,
	2327,
	2440,
	'phraseColumn',
	'',
	'',
	'phraseColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_REF
	VALUES (2327,
	30,
	0,
	150,
	2362,
	2363,
	2364,
	2436,
	2442,
	0,
	0,
	'',
	'Model Class',
	'Obj_ID',
	'R678');
INSERT INTO O_RATTR
	VALUES (2436,
	2327,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (2436,
	2327,
	2433,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2327,
	2322,
	0,
	2368,
	2365,
	2366,
	2367,
	2432,
	2443,
	0,
	0,
	'',
	'Association',
	'Rel_ID',
	'R681');
INSERT INTO O_RATTR
	VALUES (2432,
	2327,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (2432,
	2327,
	2428,
	'Rel_ID',
	'

',
	'',
	'Rel_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2327);
INSERT INTO O_OIDA
	VALUES (2329,
	2327,
	0,
	'Link_ID');
INSERT INTO O_ID
	VALUES (1,
	2327);
INSERT INTO O_ID
	VALUES (2,
	2327);
-- BP 7.1 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (2444,
	'Search',
	'',
	'SE',
	0,
	1,
	0);
INSERT INTO S_SID
	VALUES (1,
	2444);
-- BP 7.1 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (2445,
	'Result',
	'',
	'SR',
	9800,
	1,
	0);
INSERT INTO O_IOBJ
	VALUES (2446,
	2447,
	0,
	2445,
	'Search Participant',
	'SP_SP');
INSERT INTO R_SIMP
	VALUES (2448);
INSERT INTO R_REL
	VALUES (2448,
	9800,
	'',
	2445);
INSERT INTO R_PART
	VALUES (2449,
	2448,
	2450,
	0,
	0,
	'provides for');
INSERT INTO O_RTIDA
	VALUES (2451,
	2449,
	0,
	2448,
	2450);
INSERT INTO R_RTO
	VALUES (2449,
	2448,
	2450,
	0);
INSERT INTO R_OIR
	VALUES (2449,
	2448,
	2450,
	0);
INSERT INTO R_FORM
	VALUES (2452,
	2448,
	2453,
	1,
	1,
	'consists of');
INSERT INTO R_RGO
	VALUES (2452,
	2448,
	2453);
INSERT INTO R_OIR
	VALUES (2452,
	2448,
	2453,
	0);
INSERT INTO R_SUBSUP
	VALUES (2454);
INSERT INTO R_REL
	VALUES (2454,
	9801,
	'',
	2445);
INSERT INTO R_SUPER
	VALUES (2452,
	2454,
	2455);
INSERT INTO O_RTIDA
	VALUES (2456,
	2452,
	0,
	2454,
	2455);
INSERT INTO R_RTO
	VALUES (2452,
	2454,
	2455,
	0);
INSERT INTO R_OIR
	VALUES (2452,
	2454,
	2455,
	0);
INSERT INTO R_SUB
	VALUES (2457,
	2454,
	2458);
INSERT INTO R_RGO
	VALUES (2457,
	2454,
	2458);
INSERT INTO R_OIR
	VALUES (2457,
	2454,
	2458,
	0);
INSERT INTO R_SUB
	VALUES (2459,
	2454,
	2460);
INSERT INTO R_RGO
	VALUES (2459,
	2454,
	2460);
INSERT INTO R_OIR
	VALUES (2459,
	2454,
	2460,
	0);
INSERT INTO R_SIMP
	VALUES (2461);
INSERT INTO R_REL
	VALUES (2461,
	9802,
	'',
	2445);
INSERT INTO R_FORM
	VALUES (2449,
	2461,
	2462,
	0,
	1,
	'');
INSERT INTO R_RGO
	VALUES (2449,
	2461,
	2462);
INSERT INTO R_OIR
	VALUES (2449,
	2461,
	2462,
	0);
INSERT INTO R_PART
	VALUES (2447,
	2461,
	2463,
	0,
	0,
	'');
INSERT INTO O_RTIDA
	VALUES (2464,
	2447,
	0,
	2461,
	2463);
INSERT INTO R_RTO
	VALUES (2447,
	2461,
	2463,
	0);
INSERT INTO R_OIR
	VALUES (2447,
	2461,
	2463,
	2446);
INSERT INTO S_SIS
	VALUES (2444,
	2445);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2449,
	'Search Result',
	9800,
	'SR_SR',
	'',
	2445);
INSERT INTO O_TFR
	VALUES (2465,
	2449,
	'dispose',
	'',
	19,
	1,
	'select many matches related by self->SR_M[R9800];
for each match in matches
  match.dispose();
end for;
select one participant related by self->SP_SP[R9802];
if(not_empty participant)
  unrelate self from participant across R9802;
end if;
select one engine related by self->SEN_E[R9503];
if(not_empty engine)
  unrelate self from engine across R9503;
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_NBATTR
	VALUES (2451,
	2449);
INSERT INTO O_BATTR
	VALUES (2451,
	2449);
INSERT INTO O_ATTR
	VALUES (2451,
	2449,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	296,
	'',
	'');
INSERT INTO O_REF
	VALUES (2449,
	2466,
	0,
	2467,
	2468,
	2469,
	2470,
	2471,
	2472,
	0,
	0,
	'',
	'Search Engine',
	'Id',
	'R9503');
INSERT INTO O_RATTR
	VALUES (2471,
	2449,
	2467,
	2466,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (2471,
	2449,
	2451,
	'Engine_Id',
	'',
	'Engine_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2449,
	2447,
	0,
	2464,
	2461,
	2462,
	2463,
	2473,
	2474,
	0,
	0,
	'',
	'Search Participant',
	'Id',
	'R9802');
INSERT INTO O_RATTR
	VALUES (2473,
	2449,
	2464,
	2447,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (2473,
	2449,
	2471,
	'MatchedParticipant_Id',
	'',
	'MatchedParticipant_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2449);
INSERT INTO O_OIDA
	VALUES (2451,
	2449,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	2449);
INSERT INTO O_ID
	VALUES (2,
	2449);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2457,
	'Name Match',
	9803,
	'SR_NM',
	'',
	2445);
INSERT INTO O_NBATTR
	VALUES (2475,
	2457);
INSERT INTO O_BATTR
	VALUES (2475,
	2457);
INSERT INTO O_ATTR
	VALUES (2475,
	2457,
	2476,
	'Unnamed Attribute',
	'',
	'',
	'Unnamed Attribute',
	0,
	298,
	'',
	'');
INSERT INTO O_REF
	VALUES (2457,
	2452,
	0,
	2456,
	2454,
	2458,
	2455,
	2476,
	2477,
	0,
	0,
	'',
	'Match',
	'Id',
	'R9801');
INSERT INTO O_RATTR
	VALUES (2476,
	2457,
	2456,
	2452,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (2476,
	2457,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2457);
INSERT INTO O_OIDA
	VALUES (2476,
	2457,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	2457);
INSERT INTO O_ID
	VALUES (2,
	2457);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2452,
	'Match',
	9801,
	'SR_M',
	'',
	2445);
INSERT INTO O_TFR
	VALUES (2478,
	2452,
	'dispose',
	'',
	19,
	1,
	'select one contentMatch related by self->SR_CM[R9801];
if(not_empty contentMatch)
  unrelate self from contentMatch across R9801;
  delete object instance contentMatch;
end if;
select one nameMatch related by self->SR_NM[R9801];
if(not_empty nameMatch)
  unrelate self from nameMatch across R9801;
  delete object instance nameMatch;
end if;
select one result related by self->SR_SR[R9800];
if(not_empty result)
  unrelate self from result across R9800;
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (2479,
	2452,
	'convertToInstance',
	'Translate:native',
	317,
	1,
	'	return this;',
	0,
	'',
	2478);
INSERT INTO O_NBATTR
	VALUES (2456,
	2452);
INSERT INTO O_BATTR
	VALUES (2456,
	2452);
INSERT INTO O_ATTR
	VALUES (2456,
	2452,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	296,
	'',
	'');
INSERT INTO O_REF
	VALUES (2452,
	2449,
	0,
	2451,
	2448,
	2453,
	2450,
	2480,
	2481,
	0,
	0,
	'',
	'Search Result',
	'Id',
	'R9800');
INSERT INTO O_RATTR
	VALUES (2480,
	2452,
	2451,
	2449,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (2480,
	2452,
	2456,
	'Result_Id',
	'',
	'Result_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2452);
INSERT INTO O_OIDA
	VALUES (2456,
	2452,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	2452);
INSERT INTO O_ID
	VALUES (2,
	2452);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2482,
	'Content Match Result',
	9804,
	'SR_CMR',
	'',
	2445);
INSERT INTO O_NBATTR
	VALUES (2483,
	2482);
INSERT INTO O_BATTR
	VALUES (2483,
	2482);
INSERT INTO O_ATTR
	VALUES (2483,
	2482,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	296,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2484,
	2482);
INSERT INTO O_BATTR
	VALUES (2484,
	2482);
INSERT INTO O_ATTR
	VALUES (2484,
	2482,
	2483,
	'startPosition',
	'',
	'',
	'startPosition',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2485,
	2482);
INSERT INTO O_BATTR
	VALUES (2485,
	2482);
INSERT INTO O_ATTR
	VALUES (2485,
	2482,
	2484,
	'length',
	'',
	'',
	'length',
	0,
	298,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2482);
INSERT INTO O_OIDA
	VALUES (2483,
	2482,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	2482);
INSERT INTO O_ID
	VALUES (2,
	2482);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2459,
	'Content Match',
	9802,
	'SR_CM',
	'',
	2445);
INSERT INTO O_NBATTR
	VALUES (2486,
	2459);
INSERT INTO O_BATTR
	VALUES (2486,
	2459);
INSERT INTO O_ATTR
	VALUES (2486,
	2459,
	2487,
	'startPosition',
	'',
	'',
	'startPosition',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2488,
	2459);
INSERT INTO O_BATTR
	VALUES (2488,
	2459);
INSERT INTO O_ATTR
	VALUES (2488,
	2459,
	2486,
	'matchLength',
	'',
	'',
	'matchLength',
	0,
	298,
	'',
	'');
INSERT INTO O_REF
	VALUES (2459,
	2452,
	0,
	2456,
	2454,
	2460,
	2455,
	2487,
	2489,
	0,
	0,
	'',
	'Match',
	'Id',
	'R9801');
INSERT INTO O_RATTR
	VALUES (2487,
	2459,
	2456,
	2452,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (2487,
	2459,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2459);
INSERT INTO O_OIDA
	VALUES (2487,
	2459,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	2459);
INSERT INTO O_ID
	VALUES (2,
	2459);
-- BP 7.1 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (2490,
	'Query',
	'',
	'SQU',
	9600,
	1,
	0);
INSERT INTO R_SUBSUP
	VALUES (2491);
INSERT INTO R_REL
	VALUES (2491,
	9600,
	'',
	2490);
INSERT INTO R_SUPER
	VALUES (2492,
	2491,
	2493);
INSERT INTO O_RTIDA
	VALUES (2494,
	2492,
	0,
	2491,
	2493);
INSERT INTO R_RTO
	VALUES (2492,
	2491,
	2493,
	0);
INSERT INTO R_OIR
	VALUES (2492,
	2491,
	2493,
	0);
INSERT INTO R_SUB
	VALUES (2495,
	2491,
	2496);
INSERT INTO R_RGO
	VALUES (2495,
	2491,
	2496);
INSERT INTO R_OIR
	VALUES (2495,
	2491,
	2496,
	0);
INSERT INTO R_SUB
	VALUES (2497,
	2491,
	2498);
INSERT INTO R_RGO
	VALUES (2497,
	2491,
	2498);
INSERT INTO R_OIR
	VALUES (2497,
	2491,
	2498,
	0);
INSERT INTO R_SUB
	VALUES (2499,
	2491,
	2500);
INSERT INTO R_RGO
	VALUES (2499,
	2491,
	2500);
INSERT INTO R_OIR
	VALUES (2499,
	2491,
	2500,
	0);
INSERT INTO R_SUB
	VALUES (2501,
	2491,
	2502);
INSERT INTO R_RGO
	VALUES (2501,
	2491,
	2502);
INSERT INTO R_OIR
	VALUES (2501,
	2491,
	2502,
	0);
INSERT INTO S_SIS
	VALUES (2444,
	2490);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2497,
	'References Query',
	9602,
	'SQU_R',
	'',
	2490);
INSERT INTO O_REF
	VALUES (2497,
	2492,
	0,
	2494,
	2491,
	2498,
	2493,
	2503,
	2504,
	0,
	0,
	'',
	'Query',
	'Id',
	'R9600');
INSERT INTO O_RATTR
	VALUES (2503,
	2497,
	2494,
	2492,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (2503,
	2497,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2497);
INSERT INTO O_OIDA
	VALUES (2503,
	2497,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	2497);
INSERT INTO O_ID
	VALUES (2,
	2497);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2492,
	'Query',
	9600,
	'SQU_Q',
	'',
	2490);
INSERT INTO O_TFR
	VALUES (2505,
	2492,
	'run',
	'',
	316,
	1,
	'// get the engine associated and have it process this query
select one engine related by self->SEN_E[R9500];
engine.processQuery(queryId:self.Id, monitor:param.monitor);
select any result related by engine->SR_SR[R9503];
if(not_empty result)
  return true;
end if;
return false;
',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (2506,
	2505,
	'monitor',
	317,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2507,
	2492,
	'createDeclarationQuery',
	'',
	296,
	0,
	'// create a declaration query
create object instance query of SQU_Q;
create object instance declarationQuery of SQU_D;
relate query to declarationQuery across R9600;
// create an engine to process this query, note
// there is only one for all of the types associated
select any declarationEngine from instances of SEN_DCE;
if(empty declarationEngine)
  create object instance declarationEngine of SEN_DCE;
end if;
select one engine related by declarationEngine->SEN_E[R9501];
relate query to engine across R9500;
query.pattern = param.pattern;
query.regEx = param.regEx;
query.caseSensitive = param.caseSensitive;
query.scope = param.scope;
return query.Id;',
	1,
	'',
	2505);
INSERT INTO O_TPARM
	VALUES (2508,
	2507,
	'pattern',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (2509,
	2507,
	'regEx',
	316,
	0,
	'',
	2508,
	'');
INSERT INTO O_TPARM
	VALUES (2510,
	2507,
	'caseSensitive',
	316,
	0,
	'',
	2509,
	'');
INSERT INTO O_TPARM
	VALUES (2511,
	2507,
	'scope',
	2512,
	0,
	'',
	2510,
	'');
INSERT INTO O_TFR
	VALUES (2513,
	2492,
	'createReferencesQuery',
	'',
	296,
	0,
	'// create a declaration query
create object instance query of SQU_Q;
create object instance referencesQuery of SQU_R;
relate query to referencesQuery across R9600;
// create an engine to process this query, note
// there is only one for all of the types associated
select any referencesEngine from instances of SEN_RE;
if(empty referencesEngine)
  create object instance referencesEngine of SEN_RE;
end if;
select one engine related by referencesEngine->SEN_E[R9501];
relate query to engine across R9500;
query.pattern = param.pattern;
query.regEx = param.regEx;
query.caseSensitive = param.caseSensitive;
query.scope = param.scope;
return query.Id;',
	1,
	'',
	2507);
INSERT INTO O_TPARM
	VALUES (2514,
	2513,
	'pattern',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (2515,
	2513,
	'regEx',
	316,
	0,
	'',
	2514,
	'');
INSERT INTO O_TPARM
	VALUES (2516,
	2513,
	'caseSensitive',
	316,
	0,
	'',
	2515,
	'');
INSERT INTO O_TPARM
	VALUES (2517,
	2513,
	'scope',
	2512,
	0,
	'',
	2516,
	'');
INSERT INTO O_TFR
	VALUES (2518,
	2492,
	'createActionLanguageQuery',
	'',
	296,
	0,
	'// create a declaration query
create object instance query of SQU_Q;
create object instance actionLanguageQuery of SQU_A;
relate query to actionLanguageQuery across R9600;
// create an engine to process this query
create object instance actionLanguageEngine of SEN_ALE;
create object instance engine of SEN_E;
relate engine to actionLanguageEngine across R9501;
relate query to engine across R9500;
query.pattern = param.pattern;
query.regEx = param.regEx;
query.caseSensitive = param.caseSensitive;
query.scope = param.scope;
return query.Id;',
	1,
	'',
	2513);
INSERT INTO O_TPARM
	VALUES (2519,
	2518,
	'pattern',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (2520,
	2518,
	'regEx',
	316,
	0,
	'',
	2519,
	'');
INSERT INTO O_TPARM
	VALUES (2521,
	2518,
	'caseSensitive',
	316,
	0,
	'',
	2520,
	'');
INSERT INTO O_TPARM
	VALUES (2522,
	2518,
	'scope',
	2512,
	0,
	'',
	2521,
	'');
INSERT INTO O_TFR
	VALUES (2523,
	2492,
	'createDescriptionQuery',
	'',
	296,
	0,
	'// create a declaration query
create object instance query of SQU_Q;
create object instance descriptionQuery of SQU_DE;
relate query to descriptionQuery across R9600;
// create an engine to process this query
create object instance descriptionEngine of SEN_DE;
create object instance engine of SEN_E;
relate engine to descriptionEngine across R9501;
relate query to engine across R9500;
query.pattern = param.pattern;
query.regEx = param.regEx;
query.caseSensitive = param.caseSensitive;
query.scope = param.scope;
return query.Id;',
	1,
	'',
	2518);
INSERT INTO O_TPARM
	VALUES (2524,
	2523,
	'pattern',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (2525,
	2523,
	'regEx',
	316,
	0,
	'',
	2524,
	'');
INSERT INTO O_TPARM
	VALUES (2526,
	2523,
	'caseSensitive',
	316,
	0,
	'',
	2525,
	'');
INSERT INTO O_TPARM
	VALUES (2527,
	2523,
	'scope',
	2512,
	0,
	'',
	2526,
	'');
INSERT INTO O_TFR
	VALUES (2528,
	2492,
	'configureParticipants',
	'',
	19,
	1,
	'// pass the participant gathering to the subtypes
// as they will filter some of the participants available
select one actionLanguageQuery related by self->SQU_A[R9600];
if(not_empty actionLanguageQuery)
  actionLanguageQuery.configureParticipants(monitor:param.monitor);
end if;
select one descriptionQuery related by self->SQU_DE[R9600];
if(not_empty descriptionQuery)
  descriptionQuery.configureParticipants(monitor:param.monitor);
end if;',
	1,
	'',
	2523);
INSERT INTO O_TPARM
	VALUES (2529,
	2528,
	'monitor',
	317,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2530,
	2492,
	'dispose',
	'',
	19,
	1,
	'select one alq related by self->SQU_A[R9600];
select one decq related by self->SQU_D[R9600];
select one descq related by self->SQU_DE[R9600];
select one rq related by self->SQU_R[R9600];
if(not_empty alq)
  unrelate alq from self across R9600;
  delete object instance alq;
end if;
if(not_empty decq)
  unrelate decq from self across R9600;
  delete object instance decq;
end if;
if(not_empty descq)
  unrelate descq from self across R9600;
  delete object instance descq;
end if;
if(not_empty rq)
  unrelate rq from self across R9600;
  delete object instance rq;
end if;
select one engine related by self->SEN_E[R9500];
if(not_empty engine)
  unrelate self from engine across R9500;
end if;
delete object instance self;',
	1,
	'',
	2528);
INSERT INTO O_TFR
	VALUES (2531,
	2492,
	'createParticipant',
	'',
	19,
	1,
	'select one actionLanguageQuery related by self->SQU_A[R9600];
if(not_empty actionLanguageQuery)
  actionLanguageQuery.createParticipant(modelRootId:param.modelRootId,
                           elementId:param.elementId, className:param.className,
                                         searchableValue:param.searchableValue);
end if;
select one descriptionQuery related by self->SQU_DE[R9600];
if(not_empty descriptionQuery)
  descriptionQuery.createParticipant(modelRootId:param.modelRootId,
                           elementId:param.elementId, className:param.className,
                                         searchableValue:param.searchableValue);
end if;',
	1,
	'',
	2530);
INSERT INTO O_TPARM
	VALUES (2532,
	2531,
	'modelRootId',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (2533,
	2531,
	'elementId',
	317,
	0,
	'',
	2532,
	'');
INSERT INTO O_TPARM
	VALUES (2534,
	2531,
	'className',
	322,
	0,
	'',
	2533,
	'');
INSERT INTO O_TPARM
	VALUES (2535,
	2531,
	'searchableValue',
	322,
	0,
	'',
	2534,
	'');
INSERT INTO O_TFR
	VALUES (2536,
	2492,
	'configureScope',
	'',
	19,
	0,
	'// pass on to the Search bridge
Search::configureScope(scope:param.scope, monitor:param.monitor);',
	1,
	'',
	2531);
INSERT INTO O_TPARM
	VALUES (2537,
	2536,
	'scope',
	2512,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (2538,
	2536,
	'monitor',
	317,
	0,
	'',
	2537,
	'');
INSERT INTO O_NBATTR
	VALUES (2494,
	2492);
INSERT INTO O_BATTR
	VALUES (2494,
	2492);
INSERT INTO O_ATTR
	VALUES (2494,
	2492,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	296,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2539,
	2492);
INSERT INTO O_BATTR
	VALUES (2539,
	2492);
INSERT INTO O_ATTR
	VALUES (2539,
	2492,
	2540,
	'pattern',
	'',
	'',
	'pattern',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2541,
	2492);
INSERT INTO O_BATTR
	VALUES (2541,
	2492);
INSERT INTO O_ATTR
	VALUES (2541,
	2492,
	2539,
	'regEx',
	'',
	'',
	'regEx',
	0,
	316,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2542,
	2492);
INSERT INTO O_BATTR
	VALUES (2542,
	2492);
INSERT INTO O_ATTR
	VALUES (2542,
	2492,
	2541,
	'caseSensitive',
	'',
	'',
	'caseSensitive',
	0,
	316,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2543,
	2492);
INSERT INTO O_BATTR
	VALUES (2543,
	2492);
INSERT INTO O_ATTR
	VALUES (2543,
	2492,
	2542,
	'scope',
	'',
	'',
	'scope',
	0,
	2512,
	'',
	'');
INSERT INTO O_REF
	VALUES (2492,
	2466,
	0,
	2467,
	2544,
	2545,
	2546,
	2540,
	2547,
	0,
	0,
	'',
	'Search Engine',
	'Id',
	'R9500');
INSERT INTO O_RATTR
	VALUES (2540,
	2492,
	2467,
	2466,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (2540,
	2492,
	2494,
	'Engine_Id',
	'',
	'Engine_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2492);
INSERT INTO O_OIDA
	VALUES (2494,
	2492,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	2492);
INSERT INTO O_ID
	VALUES (2,
	2492);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2499,
	'Description Query',
	9603,
	'SQU_DE',
	'',
	2490);
INSERT INTO O_TFR
	VALUES (2548,
	2499,
	'configureParticipants',
	'',
	19,
	1,
	'// considering the configured parameters of this query
// locate the elements which participate
select one query related by self->SQU_Q[R9600];
Search::gatherParticipants(queryId:query.Id, monitor:param.monitor);',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (2549,
	2548,
	'monitor',
	317,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2550,
	2499,
	'createParticipant',
	'',
	19,
	1,
	'create object instance participant of SP_SP;
create object instance searchable of SP_SE;
create object instance descriptionParticipant of SP_DS;
relate searchable to participant across R9700;
searchable.modelRootId = param.modelRootId;
searchable.elementId = param.elementId;
searchable.className = param.className;
descriptionParticipant.searchableValue = param.searchableValue;
relate descriptionParticipant to searchable across R9702;
select one engine related by self->SQU_Q[R9600]->SEN_E[R9500];
relate engine to participant across R9502;',
	1,
	'',
	2548);
INSERT INTO O_TPARM
	VALUES (2551,
	2550,
	'modelRootId',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (2552,
	2550,
	'elementId',
	317,
	0,
	'',
	2551,
	'');
INSERT INTO O_TPARM
	VALUES (2553,
	2550,
	'className',
	322,
	0,
	'',
	2552,
	'');
INSERT INTO O_TPARM
	VALUES (2554,
	2550,
	'searchableValue',
	322,
	0,
	'',
	2553,
	'');
INSERT INTO O_REF
	VALUES (2499,
	2492,
	0,
	2494,
	2491,
	2500,
	2493,
	2555,
	2556,
	0,
	0,
	'',
	'Query',
	'Id',
	'R9600');
INSERT INTO O_RATTR
	VALUES (2555,
	2499,
	2494,
	2492,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (2555,
	2499,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2499);
INSERT INTO O_OIDA
	VALUES (2555,
	2499,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	2499);
INSERT INTO O_ID
	VALUES (2,
	2499);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2495,
	'Declaration Query',
	9601,
	'SQU_D',
	'',
	2490);
INSERT INTO O_REF
	VALUES (2495,
	2492,
	0,
	2494,
	2491,
	2496,
	2493,
	2557,
	2558,
	0,
	0,
	'',
	'Query',
	'Id',
	'R9600');
INSERT INTO O_RATTR
	VALUES (2557,
	2495,
	2494,
	2492,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (2557,
	2495,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2495);
INSERT INTO O_OIDA
	VALUES (2557,
	2495,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	2495);
INSERT INTO O_ID
	VALUES (2,
	2495);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2501,
	'Action Language Query',
	9604,
	'SQU_A',
	'',
	2490);
INSERT INTO O_TFR
	VALUES (2559,
	2501,
	'configureParticipants',
	'',
	19,
	1,
	'// considering the configured parameters of this query
// locate the elements which participate
select one query related by self->SQU_Q[R9600];
Search::gatherParticipants(queryId:query.Id, monitor:param.monitor);',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (2560,
	2559,
	'monitor',
	317,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2561,
	2501,
	'createParticipant',
	'',
	19,
	1,
	'create object instance participant of SP_SP;
create object instance searchable of SP_SE;
create object instance actionLanguageParticipant of SP_ALS;
relate searchable to participant across R9700;
searchable.modelRootId = param.modelRootId;
searchable.elementId = param.elementId;
searchable.className = param.className;
actionLanguageParticipant.searchableValue = param.searchableValue;
relate actionLanguageParticipant to searchable across R9702;
select one engine related by self->SQU_Q[R9600]->SEN_E[R9500];
relate engine to participant across R9502;',
	1,
	'',
	2559);
INSERT INTO O_TPARM
	VALUES (2562,
	2561,
	'modelRootId',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (2563,
	2561,
	'elementId',
	317,
	0,
	'',
	2562,
	'');
INSERT INTO O_TPARM
	VALUES (2564,
	2561,
	'className',
	322,
	0,
	'',
	2563,
	'');
INSERT INTO O_TPARM
	VALUES (2565,
	2561,
	'searchableValue',
	322,
	0,
	'',
	2564,
	'');
INSERT INTO O_REF
	VALUES (2501,
	2492,
	0,
	2494,
	2491,
	2502,
	2493,
	2566,
	2567,
	0,
	0,
	'',
	'Query',
	'Id',
	'R9600');
INSERT INTO O_RATTR
	VALUES (2566,
	2501,
	2494,
	2492,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (2566,
	2501,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2501);
INSERT INTO O_OIDA
	VALUES (2566,
	2501,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	2501);
INSERT INTO O_ID
	VALUES (2,
	2501);
-- BP 7.1 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (2568,
	'Participation',
	'',
	'SP',
	9700,
	1,
	0);
INSERT INTO R_SIMP
	VALUES (2569);
INSERT INTO R_REL
	VALUES (2569,
	9700,
	'',
	2568);
INSERT INTO R_PART
	VALUES (2447,
	2569,
	2570,
	0,
	0,
	'participates as');
INSERT INTO O_RTIDA
	VALUES (2464,
	2447,
	0,
	2569,
	2570);
INSERT INTO R_RTO
	VALUES (2447,
	2569,
	2570,
	0);
INSERT INTO R_OIR
	VALUES (2447,
	2569,
	2570,
	0);
INSERT INTO R_FORM
	VALUES (2571,
	2569,
	2572,
	0,
	0,
	'provides participation for');
INSERT INTO R_RGO
	VALUES (2571,
	2569,
	2572);
INSERT INTO R_OIR
	VALUES (2571,
	2569,
	2572,
	0);
INSERT INTO R_SUBSUP
	VALUES (2573);
INSERT INTO R_REL
	VALUES (2573,
	9702,
	'',
	2568);
INSERT INTO R_SUPER
	VALUES (2571,
	2573,
	2574);
INSERT INTO O_RTIDA
	VALUES (2575,
	2571,
	0,
	2573,
	2574);
INSERT INTO R_RTO
	VALUES (2571,
	2573,
	2574,
	0);
INSERT INTO R_OIR
	VALUES (2571,
	2573,
	2574,
	0);
INSERT INTO R_SUB
	VALUES (2576,
	2573,
	2577);
INSERT INTO R_RGO
	VALUES (2576,
	2573,
	2577);
INSERT INTO R_OIR
	VALUES (2576,
	2573,
	2577,
	0);
INSERT INTO R_SUB
	VALUES (2578,
	2573,
	2579);
INSERT INTO R_RGO
	VALUES (2578,
	2573,
	2579);
INSERT INTO R_OIR
	VALUES (2578,
	2573,
	2579,
	0);
INSERT INTO R_SUB
	VALUES (2580,
	2573,
	2581);
INSERT INTO R_RGO
	VALUES (2580,
	2573,
	2581);
INSERT INTO R_OIR
	VALUES (2580,
	2573,
	2581,
	0);
INSERT INTO S_SIS
	VALUES (2444,
	2568);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2571,
	'Searchable Element',
	9701,
	'SP_SE',
	'',
	2568);
INSERT INTO O_TFR
	VALUES (2582,
	2571,
	'dispose',
	'',
	19,
	1,
	'select one descriptionSearchable related by self->SP_DS[R9702];
if(not_empty descriptionSearchable)
  unrelate self from descriptionSearchable across R9702;
  delete object instance descriptionSearchable;
end if;
select one actionLanguageSearchable related by self->SP_ALS[R9702];
if(not_empty actionLanguageSearchable)
  unrelate self from actionLanguageSearchable across R9702;
  delete object instance actionLanguageSearchable;
end if;
select one namedSearchable related by self->SP_NS[R9702];
if(not_empty namedSearchable)
  unrelate self from namedSearchable across R9702;
  delete object instance namedSearchable;
end if;
select one searchParticipant related by self->SP_SP[R9700];
if(not_empty searchParticipant)
  unrelate self from searchParticipant across R9700;
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (2571,
	2447,
	0,
	2464,
	2569,
	2572,
	2570,
	2583,
	2584,
	0,
	0,
	'',
	'Search Participant',
	'Id',
	'R9700');
INSERT INTO O_RATTR
	VALUES (2583,
	2571,
	2464,
	2447,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (2583,
	2571,
	2575,
	'Participant_Id',
	'',
	'Participant_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2575,
	2571);
INSERT INTO O_BATTR
	VALUES (2575,
	2571);
INSERT INTO O_ATTR
	VALUES (2575,
	2571,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	296,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2585,
	2571);
INSERT INTO O_BATTR
	VALUES (2585,
	2571);
INSERT INTO O_ATTR
	VALUES (2585,
	2571,
	2583,
	'modelRootId',
	'',
	'',
	'modelRootId',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2586,
	2571);
INSERT INTO O_BATTR
	VALUES (2586,
	2571);
INSERT INTO O_ATTR
	VALUES (2586,
	2571,
	2585,
	'className',
	'',
	'',
	'className',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2587,
	2571);
INSERT INTO O_BATTR
	VALUES (2587,
	2571);
INSERT INTO O_ATTR
	VALUES (2587,
	2571,
	2586,
	'elementId',
	'',
	'',
	'elementId',
	0,
	317,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2571);
INSERT INTO O_OIDA
	VALUES (2575,
	2571,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	2571);
INSERT INTO O_ID
	VALUES (2,
	2571);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2447,
	'Search Participant',
	9700,
	'SP_SP',
	'',
	2568);
INSERT INTO O_TFR
	VALUES (2588,
	2447,
	'dispose',
	'',
	19,
	1,
	'select one searchableElement related by self->SP_SE[R9700];
if(not_empty searchableElement)
  unrelate self from searchableElement across R9700;
  searchableElement.dispose();
end if;
select one engine related by self->SEN_E[R9502];
if(not_empty engine)
  unrelate self from engine across R9502;
end if;
select one searchResult related by self->SR_SR[R9802];
if(not_empty searchResult)
  unrelate self from searchResult across R9802;
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_NBATTR
	VALUES (2464,
	2447);
INSERT INTO O_BATTR
	VALUES (2464,
	2447);
INSERT INTO O_ATTR
	VALUES (2464,
	2447,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	296,
	'',
	'');
INSERT INTO O_REF
	VALUES (2447,
	2466,
	0,
	2467,
	2589,
	2590,
	2591,
	2592,
	2593,
	0,
	0,
	'',
	'Search Engine',
	'Id',
	'R9502');
INSERT INTO O_RATTR
	VALUES (2592,
	2447,
	2467,
	2466,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (2592,
	2447,
	2464,
	'Engine_Id',
	'',
	'Engine_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2447);
INSERT INTO O_OIDA
	VALUES (2464,
	2447,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	2447);
INSERT INTO O_ID
	VALUES (2,
	2447);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2576,
	'Named Searchable',
	9702,
	'SP_NS',
	'',
	2568);
INSERT INTO O_TFR
	VALUES (2594,
	2576,
	'getSearchableValue',
	'',
	322,
	1,
	'return "";',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (2576,
	2571,
	0,
	2575,
	2573,
	2577,
	2574,
	2595,
	2596,
	0,
	0,
	'',
	'Searchable Element',
	'Id',
	'R9702');
INSERT INTO O_RATTR
	VALUES (2595,
	2576,
	2575,
	2571,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (2595,
	2576,
	0,
	'Id',
	'',
	'',
	'Element_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2597,
	2576);
INSERT INTO O_BATTR
	VALUES (2597,
	2576);
INSERT INTO O_ATTR
	VALUES (2597,
	2576,
	2595,
	'searchableValue',
	'',
	'',
	'searchableValue',
	0,
	322,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2576);
INSERT INTO O_OIDA
	VALUES (2595,
	2576,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	2576);
INSERT INTO O_ID
	VALUES (2,
	2576);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2580,
	'Description Searchable',
	9702,
	'SP_DS',
	'',
	2568);
INSERT INTO O_TFR
	VALUES (2598,
	2580,
	'getSearchableValue',
	'',
	322,
	1,
	'return "";',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (2580,
	2571,
	0,
	2575,
	2573,
	2581,
	2574,
	2599,
	2600,
	0,
	0,
	'',
	'Searchable Element',
	'Id',
	'R9702');
INSERT INTO O_RATTR
	VALUES (2599,
	2580,
	2575,
	2571,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (2599,
	2580,
	0,
	'Id',
	'',
	'',
	'Element_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2601,
	2580);
INSERT INTO O_BATTR
	VALUES (2601,
	2580);
INSERT INTO O_ATTR
	VALUES (2601,
	2580,
	2599,
	'searchableValue',
	'',
	'',
	'searchableValue',
	0,
	322,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2580);
INSERT INTO O_OIDA
	VALUES (2599,
	2580,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	2580);
INSERT INTO O_ID
	VALUES (2,
	2580);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2578,
	'Action Language Searchable',
	9702,
	'SP_ALS',
	'',
	2568);
INSERT INTO O_TFR
	VALUES (2602,
	2578,
	'getSearchableValue',
	'',
	322,
	1,
	'return "";',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (2578,
	2571,
	0,
	2575,
	2573,
	2579,
	2574,
	2603,
	2604,
	0,
	0,
	'',
	'Searchable Element',
	'Id',
	'R9702');
INSERT INTO O_RATTR
	VALUES (2603,
	2578,
	2575,
	2571,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (2603,
	2578,
	0,
	'Id',
	'',
	'',
	'Element_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2605,
	2578);
INSERT INTO O_BATTR
	VALUES (2605,
	2578);
INSERT INTO O_ATTR
	VALUES (2605,
	2578,
	2603,
	'searchableValue',
	'',
	'',
	'searchableValue',
	0,
	322,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2578);
INSERT INTO O_OIDA
	VALUES (2603,
	2578,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	2578);
INSERT INTO O_ID
	VALUES (2,
	2578);
-- BP 7.1 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (2606,
	'Engine',
	'',
	'SEN',
	9500,
	1,
	0);
INSERT INTO O_IOBJ
	VALUES (2607,
	2492,
	0,
	2606,
	'Query',
	'SQU_Q');
INSERT INTO O_IOBJ
	VALUES (2608,
	2447,
	0,
	2606,
	'Search Participant',
	'SP_SP');
INSERT INTO O_IOBJ
	VALUES (2609,
	2449,
	0,
	2606,
	'Search Result',
	'SR_SR');
INSERT INTO R_SIMP
	VALUES (2544);
INSERT INTO R_REL
	VALUES (2544,
	9500,
	'',
	2606);
INSERT INTO R_PART
	VALUES (2466,
	2544,
	2546,
	0,
	1,
	'processed by');
INSERT INTO O_RTIDA
	VALUES (2467,
	2466,
	0,
	2544,
	2546);
INSERT INTO R_RTO
	VALUES (2466,
	2544,
	2546,
	0);
INSERT INTO R_OIR
	VALUES (2466,
	2544,
	2546,
	0);
INSERT INTO R_FORM
	VALUES (2492,
	2544,
	2545,
	0,
	0,
	'processes');
INSERT INTO R_RGO
	VALUES (2492,
	2544,
	2545);
INSERT INTO R_OIR
	VALUES (2492,
	2544,
	2545,
	2607);
INSERT INTO R_SUBSUP
	VALUES (2610);
INSERT INTO R_REL
	VALUES (2610,
	9501,
	'',
	2606);
INSERT INTO R_SUPER
	VALUES (2466,
	2610,
	2611);
INSERT INTO O_RTIDA
	VALUES (2467,
	2466,
	0,
	2610,
	2611);
INSERT INTO R_RTO
	VALUES (2466,
	2610,
	2611,
	0);
INSERT INTO R_OIR
	VALUES (2466,
	2610,
	2611,
	0);
INSERT INTO R_SUB
	VALUES (2612,
	2610,
	2613);
INSERT INTO R_RGO
	VALUES (2612,
	2610,
	2613);
INSERT INTO R_OIR
	VALUES (2612,
	2610,
	2613,
	0);
INSERT INTO R_SUB
	VALUES (2614,
	2610,
	2615);
INSERT INTO R_RGO
	VALUES (2614,
	2610,
	2615);
INSERT INTO R_OIR
	VALUES (2614,
	2610,
	2615,
	0);
INSERT INTO R_SUB
	VALUES (2616,
	2610,
	2617);
INSERT INTO R_RGO
	VALUES (2616,
	2610,
	2617);
INSERT INTO R_OIR
	VALUES (2616,
	2610,
	2617,
	0);
INSERT INTO R_SUB
	VALUES (2618,
	2610,
	2619);
INSERT INTO R_RGO
	VALUES (2618,
	2610,
	2619);
INSERT INTO R_OIR
	VALUES (2618,
	2610,
	2619,
	0);
INSERT INTO R_SIMP
	VALUES (2589);
INSERT INTO R_REL
	VALUES (2589,
	9502,
	'',
	2606);
INSERT INTO R_FORM
	VALUES (2447,
	2589,
	2590,
	1,
	1,
	'searches against');
INSERT INTO R_RGO
	VALUES (2447,
	2589,
	2590);
INSERT INTO R_OIR
	VALUES (2447,
	2589,
	2590,
	2608);
INSERT INTO R_PART
	VALUES (2466,
	2589,
	2591,
	0,
	0,
	'searched for by');
INSERT INTO O_RTIDA
	VALUES (2467,
	2466,
	0,
	2589,
	2591);
INSERT INTO R_RTO
	VALUES (2466,
	2589,
	2591,
	0);
INSERT INTO R_OIR
	VALUES (2466,
	2589,
	2591,
	0);
INSERT INTO R_SIMP
	VALUES (2468);
INSERT INTO R_REL
	VALUES (2468,
	9503,
	'',
	2606);
INSERT INTO R_FORM
	VALUES (2449,
	2468,
	2469,
	1,
	1,
	'determines');
INSERT INTO R_RGO
	VALUES (2449,
	2468,
	2469);
INSERT INTO R_OIR
	VALUES (2449,
	2468,
	2469,
	2609);
INSERT INTO R_PART
	VALUES (2466,
	2468,
	2470,
	0,
	0,
	'is determined by');
INSERT INTO O_RTIDA
	VALUES (2467,
	2466,
	0,
	2468,
	2470);
INSERT INTO R_RTO
	VALUES (2466,
	2468,
	2470,
	0);
INSERT INTO R_OIR
	VALUES (2466,
	2468,
	2470,
	0);
INSERT INTO S_SIS
	VALUES (2444,
	2606);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2466,
	'Search Engine',
	9500,
	'SEN_E',
	'',
	2606);
INSERT INTO O_TFR
	VALUES (2620,
	2466,
	'processQuery',
	'',
	19,
	1,
	'// ask the subtype to process this query
select one actionLanguageEngine related by self->SEN_ALE[R9501];
if(not_empty actionLanguageEngine)
  actionLanguageEngine.processQuery(queryId:param.queryId, 
                                                         monitor:param.monitor);
end if;
select one descriptionEngine related by self->SEN_DE[R9501];
if(not_empty descriptionEngine)
  descriptionEngine.processQuery(queryId:param.queryId, monitor:param.monitor);
end if;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (2621,
	2620,
	'queryId',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (2622,
	2620,
	'monitor',
	317,
	0,
	'',
	2621,
	'');
INSERT INTO O_TFR
	VALUES (2623,
	2466,
	'dispose',
	'',
	19,
	1,
	'select one actionLanguageEngine related by self->SEN_ALE[R9501];
if(not_empty actionLanguageEngine)
  unrelate self from actionLanguageEngine across R9501;
  delete object instance actionLanguageEngine;
end if;
select one declarationsLanguageEngine related by self->SEN_DCE[R9501];
if(not_empty declarationsLanguageEngine)
  unrelate self from declarationsLanguageEngine across R9501;
  delete object instance declarationsLanguageEngine;
end if;
select one referencesLanguageEngine related by self->SEN_RE[R9501];
if(not_empty referencesLanguageEngine)
  unrelate self from referencesLanguageEngine across R9501;
  delete object instance referencesLanguageEngine;
end if;
select one descriptionEngine related by self->SEN_DE[R9501];
if(not_empty descriptionEngine)
  unrelate self from descriptionEngine across R9501;
  delete object instance descriptionEngine;
end if;
select many participants related by self->SP_SP[R9502];
for each participant in participants
  unrelate self from participant across R9502;
  participant.dispose();
end for;
select many results related by self->SR_SR[R9503];
for each result in results
 unrelate self from result across R9503;
 result.dispose();
end for;
select one query related by self->SQU_Q[R9500];
if(not_empty query)
  unrelate self from query across R9500;
end if;
delete object instance self;',
	1,
	'',
	2620);
INSERT INTO O_NBATTR
	VALUES (2467,
	2466);
INSERT INTO O_BATTR
	VALUES (2467,
	2466);
INSERT INTO O_ATTR
	VALUES (2467,
	2466,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	296,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2466);
INSERT INTO O_OIDA
	VALUES (2467,
	2466,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	2466);
INSERT INTO O_ID
	VALUES (2,
	2466);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2618,
	'References Engine',
	9504,
	'SEN_RE',
	'',
	2606);
INSERT INTO O_REF
	VALUES (2618,
	2466,
	0,
	2467,
	2610,
	2619,
	2611,
	2624,
	2625,
	0,
	0,
	'',
	'Search Engine',
	'Id',
	'R9501');
INSERT INTO O_RATTR
	VALUES (2624,
	2618,
	2467,
	2466,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (2624,
	2618,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2618);
INSERT INTO O_OIDA
	VALUES (2624,
	2618,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	2618);
INSERT INTO O_ID
	VALUES (2,
	2618);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2614,
	'Description Engine',
	9502,
	'SEN_DE',
	'',
	2606);
INSERT INTO O_TFR
	VALUES (2626,
	2614,
	'processQuery',
	'',
	19,
	1,
	'// for each participant associated we apply the given pattern
// for any matches we create the necessary results
select any query from instances of SQU_Q where (selected.Id == param.queryId);
select one engine related by self->SEN_E[R9501];
select many participants related by engine->SP_SP[R9502];
for each participant in participants
  select one descriptionParticipant related by participant->SP_SE[R9700]
                                                                 ->SP_DS[R9702];
  if(not_empty descriptionParticipant)
    // cache a variable for the singleton result
    // used for this participant
    select any searchResult from instances of SR_SR 
                                    where (selected.Id == GD::NULL_UNIQUE_ID());
    // should not be empty, but no harm in checking
    contents = descriptionParticipant.searchableValue;
    // process this call in a while loop, the call will return
    // a negative value when no more matches exist
    result = 0;
    while(result >= 0)
      matchResultId = Search::locateContentResults(pattern:query.pattern,
                        contents:contents, isCaseSensitive:query.caseSensitive);
      select any matchResult from instances of SR_CMR
                                           where (selected.Id == matchResultId);
      if(not_empty matchResult)
        result = matchResult.startPosition;
        if(result >= 0)
          // create a search result
          if(empty searchResult)
            create object instance searchResult of SR_SR;
            relate searchResult to engine across R9503;
            relate searchResult to participant across R9802;
          end if;
          // create a match
          create object instance match of SR_M;
          create object instance contentMatch of SR_CM;
          relate match to contentMatch across R9801;
          relate searchResult to match across R9800;
          contentMatch.startPosition = matchResult.startPosition;
          contentMatch.matchLength = matchResult.length;
          delete object instance matchResult;
          // send creation notification
          Search::matchCreated(match:match.convertToInstance());
        end if;
      else
        // no match found set result to -1
        result = -1;
      end if;
      // if the passed in progress monitor indicates
      // that the user has cancelled this search, then
      // end all processing
      if(Search::monitorCanceled(monitor:param.monitor))
        Search::clearQueryData();
        return;
      end if;
    end while;
    Search::clearQueryData();
  end if;
end for;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (2627,
	2626,
	'queryId',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (2628,
	2626,
	'monitor',
	317,
	0,
	'',
	2627,
	'');
INSERT INTO O_REF
	VALUES (2614,
	2466,
	0,
	2467,
	2610,
	2615,
	2611,
	2629,
	2630,
	0,
	0,
	'',
	'Search Engine',
	'Id',
	'R9501');
INSERT INTO O_RATTR
	VALUES (2629,
	2614,
	2467,
	2466,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (2629,
	2614,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2614);
INSERT INTO O_OIDA
	VALUES (2629,
	2614,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	2614);
INSERT INTO O_ID
	VALUES (2,
	2614);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2616,
	'Declarations Engine',
	9503,
	'SEN_DCE',
	'',
	2606);
INSERT INTO O_REF
	VALUES (2616,
	2466,
	0,
	2467,
	2610,
	2617,
	2611,
	2631,
	2632,
	0,
	0,
	'',
	'Search Engine',
	'Id',
	'R9501');
INSERT INTO O_RATTR
	VALUES (2631,
	2616,
	2467,
	2466,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (2631,
	2616,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2616);
INSERT INTO O_OIDA
	VALUES (2631,
	2616,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	2616);
INSERT INTO O_ID
	VALUES (2,
	2616);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2612,
	'Action Language Engine',
	9501,
	'SEN_ALE',
	'',
	2606);
INSERT INTO O_TFR
	VALUES (2633,
	2612,
	'processQuery',
	'',
	19,
	1,
	'// for each participant associated we apply the given pattern
// for any matches we create the necessary results
select any query from instances of SQU_Q where (selected.Id == param.queryId);
select one engine related by self->SEN_E[R9501];
select many participants related by engine->SP_SP[R9502];
for each participant in participants
  select one actionLanguageParticipant related by participant->SP_SE[R9700]
                                                                ->SP_ALS[R9702];
  if(not_empty actionLanguageParticipant)
    // cache a variable for the singleton result
    // used for this participant
    select any searchResult from instances of SR_SR 
                                    where (selected.Id == GD::NULL_UNIQUE_ID());
    // should not be empty, but no harm in checking
    contents = actionLanguageParticipant.searchableValue;
    // process this call in a while loop, the call will return
    // a negative value when no more matches exist
    result = 0;
    while(result >= 0)
      matchResultId = Search::locateContentResults(pattern:query.pattern,
                        contents:contents, isCaseSensitive:query.caseSensitive);
      select any matchResult from instances of SR_CMR
                                           where (selected.Id == matchResultId);
      if(not_empty matchResult)
        result = matchResult.startPosition;
        if(result >= 0)
          // create a search result
          if(empty searchResult)
            create object instance searchResult of SR_SR;
            relate searchResult to engine across R9503;
            relate searchResult to participant across R9802;
          end if;
          // create a match
          create object instance match of SR_M;
          create object instance contentMatch of SR_CM;
          relate match to contentMatch across R9801;
          relate searchResult to match across R9800;
          contentMatch.startPosition = matchResult.startPosition;
          contentMatch.matchLength = matchResult.length;
          delete object instance matchResult;
          // send creation notification
          Search::matchCreated(match:match.convertToInstance());
        end if;
      else
        // no match found, set result to -1
        result = -1;
      end if;
      // if the passed in progress monitor indicates
      // that the user has cancelled this search, then
      // end all processing
      if(Search::monitorCanceled(monitor:param.monitor))
        Search::clearQueryData();
        return;
      end if;
    end while;
    Search::clearQueryData();
  end if;
end for;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (2634,
	2633,
	'queryId',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (2635,
	2633,
	'monitor',
	317,
	0,
	'',
	2634,
	'');
INSERT INTO O_REF
	VALUES (2612,
	2466,
	0,
	2467,
	2610,
	2613,
	2611,
	2636,
	2637,
	0,
	0,
	'',
	'Search Engine',
	'Id',
	'R9501');
INSERT INTO O_RATTR
	VALUES (2636,
	2612,
	2467,
	2466,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (2636,
	2612,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2612);
INSERT INTO O_OIDA
	VALUES (2636,
	2612,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	2612);
INSERT INTO O_ID
	VALUES (2,
	2612);
-- BP 7.1 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (2638,
	'Relate And Unrelate',
	'Captures  the concepts of relating instances together. Also captures
unrelate and covers relations with link classes.
Notify_Changes:false
Persistent:false
// This is used by schema_gen to ignore this subsystem (for publication)
TRANSLATE_FOR_EXTERNAL_USE:FALSE
',
	'ACT',
	600,
	1,
	2639);
INSERT INTO S_SID
	VALUES (1,
	2638);
INSERT INTO O_IOBJ
	VALUES (2640,
	129,
	5,
	2638,
	'Variable',
	'V_VAR');
INSERT INTO O_IOBJ
	VALUES (2641,
	2322,
	5,
	2638,
	'Association',
	'R_REL');
INSERT INTO R_SIMP
	VALUES (2642);
INSERT INTO R_REL
	VALUES (2642,
	615,
	'',
	2638);
INSERT INTO R_FORM
	VALUES (2643,
	2642,
	2644,
	1,
	1,
	'is one variable');
INSERT INTO R_RGO
	VALUES (2643,
	2642,
	2644);
INSERT INTO R_OIR
	VALUES (2643,
	2642,
	2644,
	0);
INSERT INTO R_PART
	VALUES (129,
	2642,
	2645,
	0,
	0,
	'one');
INSERT INTO O_RTIDA
	VALUES (131,
	129,
	0,
	2642,
	2645);
INSERT INTO R_RTO
	VALUES (129,
	2642,
	2645,
	0);
INSERT INTO R_OIR
	VALUES (129,
	2642,
	2645,
	2640);
INSERT INTO R_SIMP
	VALUES (2646);
INSERT INTO R_REL
	VALUES (2646,
	616,
	'',
	2638);
INSERT INTO R_FORM
	VALUES (2643,
	2646,
	2647,
	1,
	1,
	'is other variable');
INSERT INTO R_RGO
	VALUES (2643,
	2646,
	2647);
INSERT INTO R_OIR
	VALUES (2643,
	2646,
	2647,
	0);
INSERT INTO R_PART
	VALUES (129,
	2646,
	2648,
	0,
	0,
	'other');
INSERT INTO O_RTIDA
	VALUES (131,
	129,
	0,
	2646,
	2648);
INSERT INTO R_RTO
	VALUES (129,
	2646,
	2648,
	0);
INSERT INTO R_OIR
	VALUES (129,
	2646,
	2648,
	2640);
INSERT INTO R_SIMP
	VALUES (2649);
INSERT INTO R_REL
	VALUES (2649,
	617,
	'',
	2638);
INSERT INTO R_FORM
	VALUES (2650,
	2649,
	2651,
	1,
	1,
	'is one variable');
INSERT INTO R_RGO
	VALUES (2650,
	2649,
	2651);
INSERT INTO R_OIR
	VALUES (2650,
	2649,
	2651,
	0);
INSERT INTO R_PART
	VALUES (129,
	2649,
	2652,
	0,
	0,
	'one');
INSERT INTO O_RTIDA
	VALUES (131,
	129,
	0,
	2649,
	2652);
INSERT INTO R_RTO
	VALUES (129,
	2649,
	2652,
	0);
INSERT INTO R_OIR
	VALUES (129,
	2649,
	2652,
	2640);
INSERT INTO R_SIMP
	VALUES (2653);
INSERT INTO R_REL
	VALUES (2653,
	618,
	'',
	2638);
INSERT INTO R_FORM
	VALUES (2650,
	2653,
	2654,
	1,
	1,
	'is other variable');
INSERT INTO R_RGO
	VALUES (2650,
	2653,
	2654);
INSERT INTO R_OIR
	VALUES (2650,
	2653,
	2654,
	0);
INSERT INTO R_PART
	VALUES (129,
	2653,
	2655,
	0,
	0,
	'other');
INSERT INTO O_RTIDA
	VALUES (131,
	129,
	0,
	2653,
	2655);
INSERT INTO R_RTO
	VALUES (129,
	2653,
	2655,
	0);
INSERT INTO R_OIR
	VALUES (129,
	2653,
	2655,
	2640);
INSERT INTO R_SIMP
	VALUES (2656);
INSERT INTO R_REL
	VALUES (2656,
	619,
	'',
	2638);
INSERT INTO R_FORM
	VALUES (2650,
	2656,
	2657,
	1,
	1,
	'is using variable');
INSERT INTO R_RGO
	VALUES (2650,
	2656,
	2657);
INSERT INTO R_OIR
	VALUES (2650,
	2656,
	2657,
	0);
INSERT INTO R_PART
	VALUES (129,
	2656,
	2658,
	0,
	0,
	'using');
INSERT INTO O_RTIDA
	VALUES (131,
	129,
	0,
	2656,
	2658);
INSERT INTO R_RTO
	VALUES (129,
	2656,
	2658,
	0);
INSERT INTO R_OIR
	VALUES (129,
	2656,
	2658,
	2640);
INSERT INTO R_SIMP
	VALUES (2659);
INSERT INTO R_REL
	VALUES (2659,
	620,
	'',
	2638);
INSERT INTO R_FORM
	VALUES (2660,
	2659,
	2661,
	1,
	1,
	'is one variable');
INSERT INTO R_RGO
	VALUES (2660,
	2659,
	2661);
INSERT INTO R_OIR
	VALUES (2660,
	2659,
	2661,
	0);
INSERT INTO R_PART
	VALUES (129,
	2659,
	2662,
	0,
	0,
	'one');
INSERT INTO O_RTIDA
	VALUES (131,
	129,
	0,
	2659,
	2662);
INSERT INTO R_RTO
	VALUES (129,
	2659,
	2662,
	0);
INSERT INTO R_OIR
	VALUES (129,
	2659,
	2662,
	2640);
INSERT INTO R_SIMP
	VALUES (2663);
INSERT INTO R_REL
	VALUES (2663,
	621,
	'',
	2638);
INSERT INTO R_FORM
	VALUES (2660,
	2663,
	2664,
	1,
	1,
	'is other variable');
INSERT INTO R_RGO
	VALUES (2660,
	2663,
	2664);
INSERT INTO R_OIR
	VALUES (2660,
	2663,
	2664,
	0);
INSERT INTO R_PART
	VALUES (129,
	2663,
	2665,
	0,
	0,
	'other');
INSERT INTO O_RTIDA
	VALUES (131,
	129,
	0,
	2663,
	2665);
INSERT INTO R_RTO
	VALUES (129,
	2663,
	2665,
	0);
INSERT INTO R_OIR
	VALUES (129,
	2663,
	2665,
	2640);
INSERT INTO R_SIMP
	VALUES (2666);
INSERT INTO R_REL
	VALUES (2666,
	622,
	'',
	2638);
INSERT INTO R_FORM
	VALUES (2667,
	2666,
	2668,
	1,
	1,
	'is one variable');
INSERT INTO R_RGO
	VALUES (2667,
	2666,
	2668);
INSERT INTO R_OIR
	VALUES (2667,
	2666,
	2668,
	0);
INSERT INTO R_PART
	VALUES (129,
	2666,
	2669,
	0,
	0,
	'one');
INSERT INTO O_RTIDA
	VALUES (131,
	129,
	0,
	2666,
	2669);
INSERT INTO R_RTO
	VALUES (129,
	2666,
	2669,
	0);
INSERT INTO R_OIR
	VALUES (129,
	2666,
	2669,
	2640);
INSERT INTO R_SIMP
	VALUES (2670);
INSERT INTO R_REL
	VALUES (2670,
	623,
	'',
	2638);
INSERT INTO R_FORM
	VALUES (2667,
	2670,
	2671,
	1,
	1,
	'is other variable');
INSERT INTO R_RGO
	VALUES (2667,
	2670,
	2671);
INSERT INTO R_OIR
	VALUES (2667,
	2670,
	2671,
	0);
INSERT INTO R_PART
	VALUES (129,
	2670,
	2672,
	0,
	0,
	'other');
INSERT INTO O_RTIDA
	VALUES (131,
	129,
	0,
	2670,
	2672);
INSERT INTO R_RTO
	VALUES (129,
	2670,
	2672,
	0);
INSERT INTO R_OIR
	VALUES (129,
	2670,
	2672,
	2640);
INSERT INTO R_SIMP
	VALUES (2673);
INSERT INTO R_REL
	VALUES (2673,
	624,
	'',
	2638);
INSERT INTO R_FORM
	VALUES (2667,
	2673,
	2674,
	1,
	1,
	'is using variable');
INSERT INTO R_RGO
	VALUES (2667,
	2673,
	2674);
INSERT INTO R_OIR
	VALUES (2667,
	2673,
	2674,
	0);
INSERT INTO R_PART
	VALUES (129,
	2673,
	2675,
	0,
	0,
	'using');
INSERT INTO O_RTIDA
	VALUES (131,
	129,
	0,
	2673,
	2675);
INSERT INTO R_RTO
	VALUES (129,
	2673,
	2675,
	0);
INSERT INTO R_OIR
	VALUES (129,
	2673,
	2675,
	2640);
INSERT INTO R_SIMP
	VALUES (2676);
INSERT INTO R_REL
	VALUES (2676,
	653,
	'',
	2638);
INSERT INTO R_PART
	VALUES (2322,
	2676,
	2677,
	0,
	0,
	'creates');
INSERT INTO O_RTIDA
	VALUES (2368,
	2322,
	0,
	2676,
	2677);
INSERT INTO R_RTO
	VALUES (2322,
	2676,
	2677,
	0);
INSERT INTO R_OIR
	VALUES (2322,
	2676,
	2677,
	2641);
INSERT INTO R_FORM
	VALUES (2643,
	2676,
	2678,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (2643,
	2676,
	2678);
INSERT INTO R_OIR
	VALUES (2643,
	2676,
	2678,
	0);
INSERT INTO R_SIMP
	VALUES (2679);
INSERT INTO R_REL
	VALUES (2679,
	654,
	'',
	2638);
INSERT INTO R_PART
	VALUES (2322,
	2679,
	2680,
	0,
	0,
	'creates');
INSERT INTO O_RTIDA
	VALUES (2368,
	2322,
	0,
	2679,
	2680);
INSERT INTO R_RTO
	VALUES (2322,
	2679,
	2680,
	0);
INSERT INTO R_OIR
	VALUES (2322,
	2679,
	2680,
	2641);
INSERT INTO R_FORM
	VALUES (2650,
	2679,
	2681,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (2650,
	2679,
	2681);
INSERT INTO R_OIR
	VALUES (2650,
	2679,
	2681,
	0);
INSERT INTO R_SIMP
	VALUES (2682);
INSERT INTO R_REL
	VALUES (2682,
	655,
	'',
	2638);
INSERT INTO R_PART
	VALUES (2322,
	2682,
	2683,
	0,
	0,
	'destroys');
INSERT INTO O_RTIDA
	VALUES (2368,
	2322,
	0,
	2682,
	2683);
INSERT INTO R_RTO
	VALUES (2322,
	2682,
	2683,
	0);
INSERT INTO R_OIR
	VALUES (2322,
	2682,
	2683,
	2641);
INSERT INTO R_FORM
	VALUES (2660,
	2682,
	2684,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (2660,
	2682,
	2684);
INSERT INTO R_OIR
	VALUES (2660,
	2682,
	2684,
	0);
INSERT INTO R_SIMP
	VALUES (2685);
INSERT INTO R_REL
	VALUES (2685,
	656,
	'',
	2638);
INSERT INTO R_PART
	VALUES (2322,
	2685,
	2686,
	0,
	0,
	'destroys');
INSERT INTO O_RTIDA
	VALUES (2368,
	2322,
	0,
	2685,
	2686);
INSERT INTO R_RTO
	VALUES (2322,
	2685,
	2686,
	0);
INSERT INTO R_OIR
	VALUES (2322,
	2685,
	2686,
	2641);
INSERT INTO R_FORM
	VALUES (2667,
	2685,
	2687,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (2667,
	2685,
	2687);
INSERT INTO R_OIR
	VALUES (2667,
	2685,
	2687,
	0);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2667,
	'Unrelate Using',
	616,
	'ACT_URU',
	'This class represents a statement that unrelates two instances that were related together, using a third as a link class instance.',
	2638);
INSERT INTO O_TFR
	VALUES (2688,
	2667,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'select one one_var related by self->V_VAR[R622];
if ( not_empty one_var )
  unrelate self from one_var across R622;
end if;
select one other_var related by self->V_VAR[R623];
if ( not_empty other_var )
  unrelate self from other_var across R623;
end if;
select one assoc_var related by self->V_VAR[R624];
if ( not_empty assoc_var )
  unrelate self from assoc_var across R624;
end if;
select one rel related by self->R_REL[R656];
if ( not_empty rel )
  unrelate self from rel across R656;
end if;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (2689,
	2667,
	'execute',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	2688);
INSERT INTO O_TPARM
	VALUES (2690,
	2689,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (2667,
	686,
	0,
	685,
	2386,
	2691,
	2388,
	2692,
	2693,
	0,
	0,
	'',
	'Statement',
	'Statement_ID',
	'R603');
INSERT INTO O_RATTR
	VALUES (2692,
	2667,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (2692,
	2667,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2667,
	129,
	0,
	131,
	2666,
	2668,
	2669,
	2694,
	2695,
	0,
	0,
	'',
	'Variable',
	'Var_ID',
	'R622.''one''');
INSERT INTO O_RATTR
	VALUES (2694,
	2667,
	131,
	129,
	1,
	'Var_ID');
INSERT INTO O_ATTR
	VALUES (2694,
	2667,
	2692,
	'One_Side_Var_ID',
	'

',
	'One_Side_',
	'Var_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2667,
	129,
	0,
	131,
	2670,
	2671,
	2672,
	2696,
	2697,
	0,
	0,
	'',
	'Variable',
	'Var_ID',
	'R623.''other''');
INSERT INTO O_RATTR
	VALUES (2696,
	2667,
	131,
	129,
	1,
	'Var_ID');
INSERT INTO O_ATTR
	VALUES (2696,
	2667,
	2694,
	'Other_Side_Var_ID',
	'

',
	'Other_Side_',
	'Var_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2667,
	129,
	0,
	131,
	2673,
	2674,
	2675,
	2698,
	2699,
	0,
	0,
	'',
	'Variable',
	'Var_ID',
	'R624.''using''');
INSERT INTO O_RATTR
	VALUES (2698,
	2667,
	131,
	129,
	1,
	'Var_ID');
INSERT INTO O_ATTR
	VALUES (2698,
	2667,
	2696,
	'Associative_Var_ID',
	'

',
	'Associative_',
	'Var_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2700,
	2667);
INSERT INTO O_BATTR
	VALUES (2700,
	2667);
INSERT INTO O_ATTR
	VALUES (2700,
	2667,
	2698,
	'relationship_phrase',
	'Full Name: Relationship Phrase
Specifies the relationship phrase at the target end of the association.
Essential for disambiguating the navigation direction of reflexive
associations.',
	'',
	'relationship_phrase',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2701,
	2667);
INSERT INTO O_BATTR
	VALUES (2701,
	2667);
INSERT INTO O_ATTR
	VALUES (2701,
	2667,
	2702,
	'associationNumberLineNumber',
	'',
	'',
	'associationNumberLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2703,
	2667);
INSERT INTO O_BATTR
	VALUES (2703,
	2667);
INSERT INTO O_ATTR
	VALUES (2703,
	2667,
	2701,
	'associationNumberColumn',
	'',
	'',
	'associationNumberColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2704,
	2667);
INSERT INTO O_BATTR
	VALUES (2704,
	2667);
INSERT INTO O_ATTR
	VALUES (2704,
	2667,
	2703,
	'associationPhraseLineNumber',
	'',
	'',
	'associationPhraseLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2705,
	2667);
INSERT INTO O_BATTR
	VALUES (2705,
	2667);
INSERT INTO O_ATTR
	VALUES (2705,
	2667,
	2704,
	'associationPhraseColumn',
	'',
	'',
	'associationPhraseColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_REF
	VALUES (2667,
	2322,
	0,
	2368,
	2685,
	2687,
	2686,
	2702,
	2706,
	0,
	0,
	'',
	'Association',
	'Rel_ID',
	'R656.''destroys''');
INSERT INTO O_RATTR
	VALUES (2702,
	2667,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (2702,
	2667,
	2700,
	'Rel_ID',
	'

',
	'',
	'Rel_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2667);
INSERT INTO O_OIDA
	VALUES (2692,
	2667,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	2667);
INSERT INTO O_ID
	VALUES (2,
	2667);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2660,
	'Unrelate',
	609,
	'ACT_UNR',
	'This class represents a statement that unrelates two instances that were related together.',
	2638);
INSERT INTO O_TFR
	VALUES (2707,
	2660,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'select one one_var related by self->V_VAR[R620];
if ( not_empty one_var )
  unrelate self from one_var across R620;
end if;
select one other_var related by self->V_VAR[R621];
if ( not_empty other_var )
  unrelate self from other_var across R621;
end if;
select one rel related by self->R_REL[R655];
if ( not_empty rel )
  unrelate self from rel across R655;
end if;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (2708,
	2660,
	'execute',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	2707);
INSERT INTO O_TPARM
	VALUES (2709,
	2708,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (2660,
	686,
	0,
	685,
	2386,
	2710,
	2388,
	2711,
	2712,
	0,
	0,
	'',
	'Statement',
	'Statement_ID',
	'R603');
INSERT INTO O_RATTR
	VALUES (2711,
	2660,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (2711,
	2660,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2660,
	129,
	0,
	131,
	2659,
	2661,
	2662,
	2713,
	2714,
	0,
	0,
	'',
	'Variable',
	'Var_ID',
	'R620.''one''');
INSERT INTO O_RATTR
	VALUES (2713,
	2660,
	131,
	129,
	1,
	'Var_ID');
INSERT INTO O_ATTR
	VALUES (2713,
	2660,
	2711,
	'One_Side_Var_ID',
	'

',
	'One_Side_',
	'Var_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2660,
	129,
	0,
	131,
	2663,
	2664,
	2665,
	2715,
	2716,
	0,
	0,
	'',
	'Variable',
	'Var_ID',
	'R621.''other''');
INSERT INTO O_RATTR
	VALUES (2715,
	2660,
	131,
	129,
	1,
	'Var_ID');
INSERT INTO O_ATTR
	VALUES (2715,
	2660,
	2713,
	'Other_Side_Var_ID',
	'

',
	'Other_Side_',
	'Var_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2717,
	2660);
INSERT INTO O_BATTR
	VALUES (2717,
	2660);
INSERT INTO O_ATTR
	VALUES (2717,
	2660,
	2715,
	'relationship_phrase',
	'Full Name: Relationship Phrase
Specifies the relationship phrase at the target end of the association.
Essential for disambiguating the navigation direction of reflexive
associations.',
	'',
	'relationship_phrase',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2718,
	2660);
INSERT INTO O_BATTR
	VALUES (2718,
	2660);
INSERT INTO O_ATTR
	VALUES (2718,
	2660,
	2719,
	'associationNumberLineNumber',
	'',
	'',
	'associationNumberLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2720,
	2660);
INSERT INTO O_BATTR
	VALUES (2720,
	2660);
INSERT INTO O_ATTR
	VALUES (2720,
	2660,
	2718,
	'associationNumberColumn',
	'',
	'',
	'associationNumberColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2721,
	2660);
INSERT INTO O_BATTR
	VALUES (2721,
	2660);
INSERT INTO O_ATTR
	VALUES (2721,
	2660,
	2720,
	'associationPhraseLineNumber',
	'',
	'',
	'associationPhraseLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2722,
	2660);
INSERT INTO O_BATTR
	VALUES (2722,
	2660);
INSERT INTO O_ATTR
	VALUES (2722,
	2660,
	2721,
	'associationPhraseColumn',
	'',
	'',
	'associationPhraseColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_REF
	VALUES (2660,
	2322,
	0,
	2368,
	2682,
	2684,
	2683,
	2719,
	2723,
	0,
	0,
	'',
	'Association',
	'Rel_ID',
	'R655.''destroys''');
INSERT INTO O_RATTR
	VALUES (2719,
	2660,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (2719,
	2660,
	2717,
	'Rel_ID',
	'

',
	'',
	'Rel_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2660);
INSERT INTO O_OIDA
	VALUES (2711,
	2660,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	2660);
INSERT INTO O_ID
	VALUES (2,
	2660);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2650,
	'Relate Using',
	615,
	'ACT_RU',
	'This class represents a statement that relates two instances together, using a third as a link class instance.',
	2638);
INSERT INTO O_TFR
	VALUES (2724,
	2650,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'select one one_var related by self->V_VAR[R617];
if ( not_empty one_var )
  unrelate self from one_var across R617;
end if;
select one other_var related by self->V_VAR[R618];
if ( not_empty other_var )
  unrelate self from other_var across R618;
end if;
select one assoc_var related by self->V_VAR[R619];
if ( not_empty assoc_var )
  unrelate self from assoc_var across R619;
end if;
select one rel related by self->R_REL[R654];
if ( not_empty rel )
  unrelate self from rel across R654;
end if;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (2725,
	2650,
	'execute',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	2724);
INSERT INTO O_TPARM
	VALUES (2726,
	2725,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (2650,
	686,
	0,
	685,
	2386,
	2727,
	2388,
	2728,
	2729,
	0,
	0,
	'',
	'Statement',
	'Statement_ID',
	'R603');
INSERT INTO O_RATTR
	VALUES (2728,
	2650,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (2728,
	2650,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2650,
	129,
	0,
	131,
	2649,
	2651,
	2652,
	2730,
	2731,
	0,
	0,
	'',
	'Variable',
	'Var_ID',
	'R617.''one''');
INSERT INTO O_RATTR
	VALUES (2730,
	2650,
	131,
	129,
	1,
	'Var_ID');
INSERT INTO O_ATTR
	VALUES (2730,
	2650,
	2728,
	'One_Side_Var_ID',
	'

',
	'One_Side_',
	'Var_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2650,
	129,
	0,
	131,
	2653,
	2654,
	2655,
	2732,
	2733,
	0,
	0,
	'',
	'Variable',
	'Var_ID',
	'R618.''other''');
INSERT INTO O_RATTR
	VALUES (2732,
	2650,
	131,
	129,
	1,
	'Var_ID');
INSERT INTO O_ATTR
	VALUES (2732,
	2650,
	2730,
	'Other_Side_Var_ID',
	'

',
	'Other_Side_',
	'Var_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2650,
	129,
	0,
	131,
	2656,
	2657,
	2658,
	2734,
	2735,
	0,
	0,
	'',
	'Variable',
	'Var_ID',
	'R619.''using''');
INSERT INTO O_RATTR
	VALUES (2734,
	2650,
	131,
	129,
	1,
	'Var_ID');
INSERT INTO O_ATTR
	VALUES (2734,
	2650,
	2732,
	'Associative_Var_ID',
	'

',
	'Associative_',
	'Var_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2736,
	2650);
INSERT INTO O_BATTR
	VALUES (2736,
	2650);
INSERT INTO O_ATTR
	VALUES (2736,
	2650,
	2734,
	'relationship_phrase',
	'Full Name: Relationship Phrase
Specifies the relationship phrase at the target end of the association.
Essential for disambiguating the navigation direction of reflexive
associations.',
	'',
	'relationship_phrase',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2737,
	2650);
INSERT INTO O_BATTR
	VALUES (2737,
	2650);
INSERT INTO O_ATTR
	VALUES (2737,
	2650,
	2738,
	'associationNumberLineNumber',
	'',
	'',
	'associationNumberLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2739,
	2650);
INSERT INTO O_BATTR
	VALUES (2739,
	2650);
INSERT INTO O_ATTR
	VALUES (2739,
	2650,
	2737,
	'associationNumberColumn',
	'',
	'',
	'associationNumberColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2740,
	2650);
INSERT INTO O_BATTR
	VALUES (2740,
	2650);
INSERT INTO O_ATTR
	VALUES (2740,
	2650,
	2739,
	'associationPhraseLineNumber',
	'',
	'',
	'associationPhraseLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2741,
	2650);
INSERT INTO O_BATTR
	VALUES (2741,
	2650);
INSERT INTO O_ATTR
	VALUES (2741,
	2650,
	2740,
	'associationPhraseColumn',
	'',
	'',
	'associationPhraseColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_REF
	VALUES (2650,
	2322,
	0,
	2368,
	2679,
	2681,
	2680,
	2738,
	2742,
	0,
	0,
	'',
	'Association',
	'Rel_ID',
	'R654.''creates''');
INSERT INTO O_RATTR
	VALUES (2738,
	2650,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (2738,
	2650,
	2736,
	'Rel_ID',
	'

',
	'',
	'Rel_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2650);
INSERT INTO O_OIDA
	VALUES (2728,
	2650,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	2650);
INSERT INTO O_ID
	VALUES (2,
	2650);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2643,
	'Relate',
	608,
	'ACT_REL',
	'This class represents a statement that relates two instances together.',
	2638);
INSERT INTO O_TFR
	VALUES (2743,
	2643,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'select one one_var related by self->V_VAR[R615];
if ( not_empty one_var )
  unrelate self from one_var across R615;
end if;
select one other_var related by self->V_VAR[R616];
if ( not_empty other_var )
  unrelate self from other_var across R616;
end if;
select one rel related by self->R_REL[R653];
if ( not_empty rel )
  unrelate self from rel across R653;
end if;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (2744,
	2643,
	'execute',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	2743);
INSERT INTO O_TPARM
	VALUES (2745,
	2744,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (2643,
	686,
	0,
	685,
	2386,
	2746,
	2388,
	2747,
	2748,
	0,
	0,
	'',
	'Statement',
	'Statement_ID',
	'R603');
INSERT INTO O_RATTR
	VALUES (2747,
	2643,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (2747,
	2643,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2643,
	129,
	0,
	131,
	2642,
	2644,
	2645,
	2749,
	2750,
	0,
	0,
	'',
	'Variable',
	'Var_ID',
	'R615.''one''');
INSERT INTO O_RATTR
	VALUES (2749,
	2643,
	131,
	129,
	1,
	'Var_ID');
INSERT INTO O_ATTR
	VALUES (2749,
	2643,
	2747,
	'One_Side_Var_ID',
	'

',
	'One_Side_',
	'Var_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2643,
	129,
	0,
	131,
	2646,
	2647,
	2648,
	2751,
	2752,
	0,
	0,
	'',
	'Variable',
	'Var_ID',
	'R616.''other''');
INSERT INTO O_RATTR
	VALUES (2751,
	2643,
	131,
	129,
	1,
	'Var_ID');
INSERT INTO O_ATTR
	VALUES (2751,
	2643,
	2749,
	'Other_Side_Var_ID',
	'

',
	'Other_Side_',
	'Var_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2753,
	2643);
INSERT INTO O_BATTR
	VALUES (2753,
	2643);
INSERT INTO O_ATTR
	VALUES (2753,
	2643,
	2751,
	'relationship_phrase',
	'Full Name: Relationship Phrase
Specifies the relationship phrase at the target end of the association.
Essential for disambiguating the navigation direction of reflexive
associations.',
	'',
	'relationship_phrase',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2754,
	2643);
INSERT INTO O_BATTR
	VALUES (2754,
	2643);
INSERT INTO O_ATTR
	VALUES (2754,
	2643,
	2755,
	'associationNumberLineNumber',
	'',
	'',
	'associationNumberLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2756,
	2643);
INSERT INTO O_BATTR
	VALUES (2756,
	2643);
INSERT INTO O_ATTR
	VALUES (2756,
	2643,
	2754,
	'associationNumberColumn',
	'',
	'',
	'associationNumberColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2757,
	2643);
INSERT INTO O_BATTR
	VALUES (2757,
	2643);
INSERT INTO O_ATTR
	VALUES (2757,
	2643,
	2756,
	'associationPhraseLineNumber',
	'',
	'',
	'associationPhraseLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2758,
	2643);
INSERT INTO O_BATTR
	VALUES (2758,
	2643);
INSERT INTO O_ATTR
	VALUES (2758,
	2643,
	2757,
	'associationPhraseColumn',
	'',
	'',
	'associationPhraseColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_REF
	VALUES (2643,
	2322,
	0,
	2368,
	2676,
	2678,
	2677,
	2755,
	2759,
	0,
	0,
	'',
	'Association',
	'Rel_ID',
	'R653.''creates''');
INSERT INTO O_RATTR
	VALUES (2755,
	2643,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (2755,
	2643,
	2753,
	'Rel_ID',
	'

',
	'',
	'Rel_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2643);
INSERT INTO O_OIDA
	VALUES (2747,
	2643,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	2643);
INSERT INTO O_ID
	VALUES (2,
	2643);
-- BP 7.1 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (2760,
	'Persistence Associations',
	'This subsystem contains associations required to allow correct persistence
locations.

Once the infrastructure is fixed to correctly allow multiple traversals between
export items, this subsystem shall be removed.

// This is used by schema_gen to ignore this subsystem (for publication)
TRANSLATE_FOR_EXTERNAL_USE:FALSE

Persistent:false',
	'',
	9000,
	1,
	0);
INSERT INTO S_SID
	VALUES (1,
	2760);
INSERT INTO O_IOBJ
	VALUES (2761,
	2762,
	0,
	2760,
	'Delegation',
	'C_DG');
INSERT INTO O_IOBJ
	VALUES (2763,
	707,
	0,
	2760,
	'Component Package',
	'CP_CP');
INSERT INTO O_IOBJ
	VALUES (2764,
	2765,
	0,
	2760,
	'Satisfaction',
	'C_SF');
INSERT INTO O_IOBJ
	VALUES (2766,
	709,
	0,
	2760,
	'Component',
	'C_C');
INSERT INTO R_ASSOC
	VALUES (2767);
INSERT INTO R_REL
	VALUES (2767,
	9002,
	'',
	2760);
INSERT INTO R_ASSR
	VALUES (2768,
	2767,
	2769,
	0);
INSERT INTO R_RGO
	VALUES (2768,
	2767,
	2769);
INSERT INTO R_OIR
	VALUES (2768,
	2767,
	2769,
	0);
INSERT INTO R_AOTH
	VALUES (2762,
	2767,
	2770,
	1,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (2771,
	2762,
	0,
	2767,
	2770);
INSERT INTO R_RTO
	VALUES (2762,
	2767,
	2770,
	0);
INSERT INTO R_OIR
	VALUES (2762,
	2767,
	2770,
	2761);
INSERT INTO R_AONE
	VALUES (709,
	2767,
	2772,
	0,
	0,
	'');
INSERT INTO O_RTIDA
	VALUES (762,
	709,
	0,
	2767,
	2772);
INSERT INTO R_RTO
	VALUES (709,
	2767,
	2772,
	0);
INSERT INTO R_OIR
	VALUES (709,
	2767,
	2772,
	2766);
INSERT INTO R_ASSOC
	VALUES (2773);
INSERT INTO R_REL
	VALUES (2773,
	9001,
	'',
	2760);
INSERT INTO R_ASSR
	VALUES (2774,
	2773,
	2775,
	0);
INSERT INTO R_RGO
	VALUES (2774,
	2773,
	2775);
INSERT INTO R_OIR
	VALUES (2774,
	2773,
	2775,
	0);
INSERT INTO R_AOTH
	VALUES (707,
	2773,
	2776,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (758,
	707,
	0,
	2773,
	2776);
INSERT INTO R_RTO
	VALUES (707,
	2773,
	2776,
	0);
INSERT INTO R_OIR
	VALUES (707,
	2773,
	2776,
	2763);
INSERT INTO R_AONE
	VALUES (2765,
	2773,
	2777,
	1,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (2778,
	2765,
	0,
	2773,
	2777);
INSERT INTO R_RTO
	VALUES (2765,
	2773,
	2777,
	0);
INSERT INTO R_OIR
	VALUES (2765,
	2773,
	2777,
	2764);
INSERT INTO R_ASSOC
	VALUES (2779);
INSERT INTO R_REL
	VALUES (2779,
	9000,
	'',
	2760);
INSERT INTO R_ASSR
	VALUES (2780,
	2779,
	2781,
	0);
INSERT INTO R_RGO
	VALUES (2780,
	2779,
	2781);
INSERT INTO R_OIR
	VALUES (2780,
	2779,
	2781,
	0);
INSERT INTO R_AOTH
	VALUES (2765,
	2779,
	2782,
	1,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (2778,
	2765,
	0,
	2779,
	2782);
INSERT INTO R_RTO
	VALUES (2765,
	2779,
	2782,
	0);
INSERT INTO R_OIR
	VALUES (2765,
	2779,
	2782,
	2764);
INSERT INTO R_AONE
	VALUES (709,
	2779,
	2783,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (762,
	709,
	0,
	2779,
	2783);
INSERT INTO R_RTO
	VALUES (709,
	2779,
	2783,
	0);
INSERT INTO R_OIR
	VALUES (709,
	2779,
	2783,
	2766);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2774,
	'Satisfaction In Component Package',
	9001,
	'PA_SICP',
	'User_Visible:false',
	2760);
INSERT INTO O_REF
	VALUES (2774,
	707,
	0,
	758,
	2773,
	2775,
	2776,
	2784,
	2785,
	0,
	0,
	'',
	'Component Package',
	'Package_ID',
	'R9001');
INSERT INTO O_RATTR
	VALUES (2784,
	2774,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (2784,
	2774,
	0,
	'ComponentPackage_ID',
	'',
	'Component',
	'Package_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2774,
	2765,
	0,
	2778,
	2773,
	2775,
	2777,
	2786,
	2787,
	0,
	0,
	'',
	'Satisfaction',
	'Id',
	'R9001');
INSERT INTO O_RATTR
	VALUES (2786,
	2774,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (2786,
	2774,
	2784,
	'Satisfaction_Id',
	'',
	'Satisfaction_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (2,
	2774);
INSERT INTO O_ID
	VALUES (1,
	2774);
INSERT INTO O_ID
	VALUES (0,
	2774);
INSERT INTO O_OIDA
	VALUES (2784,
	2774,
	0,
	'ComponentPackage_ID');
INSERT INTO O_OIDA
	VALUES (2786,
	2774,
	0,
	'Satisfaction_Id');
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2780,
	'Satisfaction In Component',
	9000,
	'PA_SIC',
	'User_Visible:false',
	2760);
INSERT INTO O_REF
	VALUES (2780,
	709,
	0,
	762,
	2779,
	2781,
	2783,
	2788,
	2789,
	0,
	0,
	'',
	'Component',
	'Id',
	'R9000');
INSERT INTO O_RATTR
	VALUES (2788,
	2780,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (2788,
	2780,
	0,
	'Component_Id',
	'',
	'Component_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2780,
	2765,
	0,
	2778,
	2779,
	2781,
	2782,
	2790,
	2791,
	0,
	0,
	'',
	'Satisfaction',
	'Id',
	'R9000');
INSERT INTO O_RATTR
	VALUES (2790,
	2780,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (2790,
	2780,
	2788,
	'Satisfaction_Id',
	'',
	'Satisfaction_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (2,
	2780);
INSERT INTO O_ID
	VALUES (1,
	2780);
INSERT INTO O_ID
	VALUES (0,
	2780);
INSERT INTO O_OIDA
	VALUES (2788,
	2780,
	0,
	'Component_Id');
INSERT INTO O_OIDA
	VALUES (2790,
	2780,
	0,
	'Satisfaction_Id');
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2768,
	'Delegation In Component',
	9002,
	'PA_DIC',
	'User_Visible:false',
	2760);
INSERT INTO O_REF
	VALUES (2768,
	709,
	0,
	762,
	2767,
	2769,
	2772,
	2792,
	2793,
	0,
	0,
	'',
	'Component',
	'Id',
	'R9002');
INSERT INTO O_RATTR
	VALUES (2792,
	2768,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (2792,
	2768,
	0,
	'Component_Id',
	'',
	'Component_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2768,
	2762,
	0,
	2771,
	2767,
	2769,
	2770,
	2794,
	2795,
	0,
	0,
	'',
	'Delegation',
	'Id',
	'R9002');
INSERT INTO O_RATTR
	VALUES (2794,
	2768,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (2794,
	2768,
	2792,
	'Delegation_Id',
	'',
	'Delegation_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (2,
	2768);
INSERT INTO O_ID
	VALUES (1,
	2768);
INSERT INTO O_ID
	VALUES (0,
	2768);
INSERT INTO O_OIDA
	VALUES (2792,
	2768,
	0,
	'Component_Id');
INSERT INTO O_OIDA
	VALUES (2794,
	2768,
	0,
	'Delegation_Id');
-- BP 7.1 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (2796,
	'Packageable Element',
	'',
	'PE',
	8000,
	1,
	0);
INSERT INTO S_SID
	VALUES (1,
	2796);
INSERT INTO O_IOBJ
	VALUES (2797,
	2798,
	0,
	2796,
	'Package',
	'EP_PKG');
INSERT INTO O_IOBJ
	VALUES (2799,
	32,
	0,
	2796,
	'Data Type',
	'S_DT');
INSERT INTO O_IOBJ
	VALUES (2800,
	703,
	0,
	2796,
	'Interaction Participant',
	'SQ_P');
INSERT INTO O_IOBJ
	VALUES (2801,
	729,
	0,
	2796,
	'Use Case Association',
	'UC_UCA');
INSERT INTO O_IOBJ
	VALUES (2802,
	2803,
	0,
	2796,
	'Activity Node',
	'A_N');
INSERT INTO O_IOBJ
	VALUES (2804,
	30,
	0,
	2796,
	'Model Class',
	'O_OBJ');
INSERT INTO O_IOBJ
	VALUES (2805,
	709,
	0,
	2796,
	'Component',
	'C_C');
INSERT INTO O_IOBJ
	VALUES (2806,
	2807,
	0,
	2796,
	'Component Reference',
	'CL_IC');
INSERT INTO O_IOBJ
	VALUES (2808,
	2809,
	0,
	2796,
	'Interface',
	'C_I');
INSERT INTO O_IOBJ
	VALUES (2810,
	939,
	0,
	2796,
	'Constant Specification',
	'CNST_CSP');
INSERT INTO O_IOBJ
	VALUES (2811,
	2812,
	0,
	2796,
	'Activity Partition',
	'A_AP');
INSERT INTO O_IOBJ
	VALUES (2813,
	2814,
	0,
	2796,
	'Activity Edge',
	'A_E');
INSERT INTO O_IOBJ
	VALUES (2815,
	2141,
	0,
	2796,
	'Message',
	'MSG_M');
INSERT INTO O_IOBJ
	VALUES (2816,
	1050,
	0,
	2796,
	'Imported Class',
	'O_IOBJ');
INSERT INTO O_IOBJ
	VALUES (2817,
	2322,
	0,
	2796,
	'Association',
	'R_REL');
INSERT INTO O_IOBJ
	VALUES (2818,
	8,
	0,
	2796,
	'Function',
	'S_SYNC');
INSERT INTO O_IOBJ
	VALUES (2819,
	2820,
	0,
	2796,
	'External Entity',
	'S_EE');
INSERT INTO O_IOBJ
	VALUES (2821,
	2765,
	0,
	2796,
	'Satisfaction',
	'C_SF');
INSERT INTO O_IOBJ
	VALUES (2822,
	2762,
	0,
	2796,
	'Delegation',
	'C_DG');
INSERT INTO R_SIMP
	VALUES (2823);
INSERT INTO R_REL
	VALUES (2823,
	8000,
	'',
	2796);
INSERT INTO R_PART
	VALUES (2798,
	2823,
	2824,
	0,
	1,
	'contained by');
INSERT INTO O_RTIDA
	VALUES (2825,
	2798,
	0,
	2823,
	2824);
INSERT INTO R_RTO
	VALUES (2798,
	2823,
	2824,
	0);
INSERT INTO R_OIR
	VALUES (2798,
	2823,
	2824,
	2797);
INSERT INTO R_FORM
	VALUES (26,
	2823,
	2826,
	1,
	1,
	'contains');
INSERT INTO R_RGO
	VALUES (26,
	2823,
	2826);
INSERT INTO R_OIR
	VALUES (26,
	2823,
	2826,
	0);
INSERT INTO R_SUBSUP
	VALUES (868);
INSERT INTO R_REL
	VALUES (868,
	8001,
	'CrossComponent:true
Optional:true',
	2796);
INSERT INTO R_SUPER
	VALUES (26,
	868,
	870);
INSERT INTO O_RTIDA
	VALUES (25,
	26,
	0,
	868,
	870);
INSERT INTO R_RTO
	VALUES (26,
	868,
	870,
	0);
INSERT INTO R_OIR
	VALUES (26,
	868,
	870,
	0);
INSERT INTO R_SUB
	VALUES (32,
	868,
	2827);
INSERT INTO R_RGO
	VALUES (32,
	868,
	2827);
INSERT INTO R_OIR
	VALUES (32,
	868,
	2827,
	2799);
INSERT INTO R_SUB
	VALUES (703,
	868,
	2828);
INSERT INTO R_RGO
	VALUES (703,
	868,
	2828);
INSERT INTO R_OIR
	VALUES (703,
	868,
	2828,
	2800);
INSERT INTO R_SUB
	VALUES (729,
	868,
	869);
INSERT INTO R_RGO
	VALUES (729,
	868,
	869);
INSERT INTO R_OIR
	VALUES (729,
	868,
	869,
	2801);
INSERT INTO R_SUB
	VALUES (2803,
	868,
	2829);
INSERT INTO R_RGO
	VALUES (2803,
	868,
	2829);
INSERT INTO R_OIR
	VALUES (2803,
	868,
	2829,
	2802);
INSERT INTO R_SUB
	VALUES (30,
	868,
	1320);
INSERT INTO R_RGO
	VALUES (30,
	868,
	1320);
INSERT INTO R_OIR
	VALUES (30,
	868,
	1320,
	2804);
INSERT INTO R_SUB
	VALUES (709,
	868,
	2830);
INSERT INTO R_RGO
	VALUES (709,
	868,
	2830);
INSERT INTO R_OIR
	VALUES (709,
	868,
	2830,
	2805);
INSERT INTO R_SUB
	VALUES (2807,
	868,
	2831);
INSERT INTO R_RGO
	VALUES (2807,
	868,
	2831);
INSERT INTO R_OIR
	VALUES (2807,
	868,
	2831,
	2806);
INSERT INTO R_SUB
	VALUES (2809,
	868,
	2832);
INSERT INTO R_RGO
	VALUES (2809,
	868,
	2832);
INSERT INTO R_OIR
	VALUES (2809,
	868,
	2832,
	2808);
INSERT INTO R_SUB
	VALUES (2798,
	868,
	2833);
INSERT INTO R_RGO
	VALUES (2798,
	868,
	2833);
INSERT INTO R_OIR
	VALUES (2798,
	868,
	2833,
	2797);
INSERT INTO R_SUB
	VALUES (939,
	868,
	2834);
INSERT INTO R_RGO
	VALUES (939,
	868,
	2834);
INSERT INTO R_OIR
	VALUES (939,
	868,
	2834,
	2810);
INSERT INTO R_SUB
	VALUES (2812,
	868,
	2835);
INSERT INTO R_RGO
	VALUES (2812,
	868,
	2835);
INSERT INTO R_OIR
	VALUES (2812,
	868,
	2835,
	2811);
INSERT INTO R_SUB
	VALUES (2814,
	868,
	2836);
INSERT INTO R_RGO
	VALUES (2814,
	868,
	2836);
INSERT INTO R_OIR
	VALUES (2814,
	868,
	2836,
	2813);
INSERT INTO R_SUB
	VALUES (2141,
	868,
	2837);
INSERT INTO R_RGO
	VALUES (2141,
	868,
	2837);
INSERT INTO R_OIR
	VALUES (2141,
	868,
	2837,
	2815);
INSERT INTO R_SUB
	VALUES (1050,
	868,
	1361);
INSERT INTO R_RGO
	VALUES (1050,
	868,
	1361);
INSERT INTO R_OIR
	VALUES (1050,
	868,
	1361,
	2816);
INSERT INTO R_SUB
	VALUES (2322,
	868,
	2838);
INSERT INTO R_RGO
	VALUES (2322,
	868,
	2838);
INSERT INTO R_OIR
	VALUES (2322,
	868,
	2838,
	2817);
INSERT INTO R_SUB
	VALUES (2820,
	868,
	2839);
INSERT INTO R_RGO
	VALUES (2820,
	868,
	2839);
INSERT INTO R_OIR
	VALUES (2820,
	868,
	2839,
	2819);
INSERT INTO R_SUB
	VALUES (8,
	868,
	2840);
INSERT INTO R_RGO
	VALUES (8,
	868,
	2840);
INSERT INTO R_OIR
	VALUES (8,
	868,
	2840,
	2818);
INSERT INTO R_SUB
	VALUES (2765,
	868,
	2841);
INSERT INTO R_RGO
	VALUES (2765,
	868,
	2841);
INSERT INTO R_OIR
	VALUES (2765,
	868,
	2841,
	2821);
INSERT INTO R_SUB
	VALUES (2762,
	868,
	2842);
INSERT INTO R_RGO
	VALUES (2762,
	868,
	2842);
INSERT INTO R_OIR
	VALUES (2762,
	868,
	2842,
	2822);
INSERT INTO R_ASSOC
	VALUES (2843);
INSERT INTO R_REL
	VALUES (2843,
	8002,
	'',
	2796);
INSERT INTO R_AONE
	VALUES (26,
	2843,
	2844,
	1,
	1,
	'has visibility of');
INSERT INTO O_RTIDA
	VALUES (25,
	26,
	0,
	2843,
	2844);
INSERT INTO R_RTO
	VALUES (26,
	2843,
	2844,
	0);
INSERT INTO R_OIR
	VALUES (26,
	2843,
	2844,
	0);
INSERT INTO R_AOTH
	VALUES (2798,
	2843,
	2845,
	1,
	1,
	'is visible to elements in');
INSERT INTO O_RTIDA
	VALUES (2825,
	2798,
	0,
	2843,
	2845);
INSERT INTO R_RTO
	VALUES (2798,
	2843,
	2845,
	0);
INSERT INTO R_OIR
	VALUES (2798,
	2843,
	2845,
	2797);
INSERT INTO R_ASSR
	VALUES (2846,
	2843,
	2847,
	1);
INSERT INTO R_RGO
	VALUES (2846,
	2843,
	2847);
INSERT INTO R_OIR
	VALUES (2846,
	2843,
	2847,
	0);
INSERT INTO R_SIMP
	VALUES (2848);
INSERT INTO R_REL
	VALUES (2848,
	8003,
	'',
	2796);
INSERT INTO R_PART
	VALUES (709,
	2848,
	2849,
	0,
	1,
	'contained in');
INSERT INTO O_RTIDA
	VALUES (762,
	709,
	0,
	2848,
	2849);
INSERT INTO R_RTO
	VALUES (709,
	2848,
	2849,
	0);
INSERT INTO R_OIR
	VALUES (709,
	2848,
	2849,
	2805);
INSERT INTO R_FORM
	VALUES (26,
	2848,
	2850,
	1,
	1,
	'contains');
INSERT INTO R_RGO
	VALUES (26,
	2848,
	2850);
INSERT INTO R_OIR
	VALUES (26,
	2848,
	2850,
	0);
INSERT INTO R_ASSOC
	VALUES (2851);
INSERT INTO R_REL
	VALUES (2851,
	8004,
	'',
	2796);
INSERT INTO R_AONE
	VALUES (709,
	2851,
	2852,
	1,
	1,
	'is visible to');
INSERT INTO O_RTIDA
	VALUES (762,
	709,
	0,
	2851,
	2852);
INSERT INTO R_RTO
	VALUES (709,
	2851,
	2852,
	0);
INSERT INTO R_OIR
	VALUES (709,
	2851,
	2852,
	2805);
INSERT INTO R_AOTH
	VALUES (26,
	2851,
	2853,
	1,
	1,
	'has visibility of');
INSERT INTO O_RTIDA
	VALUES (25,
	26,
	0,
	2851,
	2853);
INSERT INTO R_RTO
	VALUES (26,
	2851,
	2853,
	0);
INSERT INTO R_OIR
	VALUES (26,
	2851,
	2853,
	0);
INSERT INTO R_ASSR
	VALUES (2854,
	2851,
	2855,
	1);
INSERT INTO R_RGO
	VALUES (2854,
	2851,
	2855);
INSERT INTO R_OIR
	VALUES (2854,
	2851,
	2855,
	0);
INSERT INTO R_SIMP
	VALUES (2856);
INSERT INTO R_REL
	VALUES (2856,
	8005,
	'',
	2796);
INSERT INTO R_PART
	VALUES (2798,
	2856,
	2857,
	0,
	0,
	'held by');
INSERT INTO O_RTIDA
	VALUES (2825,
	2798,
	0,
	2856,
	2857);
INSERT INTO R_RTO
	VALUES (2798,
	2856,
	2857,
	0);
INSERT INTO R_OIR
	VALUES (2798,
	2856,
	2857,
	2797);
INSERT INTO R_FORM
	VALUES (2858,
	2856,
	2859,
	1,
	1,
	'holds');
INSERT INTO R_RGO
	VALUES (2858,
	2856,
	2859);
INSERT INTO R_OIR
	VALUES (2858,
	2856,
	2859,
	0);
INSERT INTO R_SIMP
	VALUES (2860);
INSERT INTO R_REL
	VALUES (2860,
	8006,
	'',
	2796);
INSERT INTO R_PART
	VALUES (2858,
	2860,
	2861,
	0,
	0,
	'');
INSERT INTO O_RTIDA
	VALUES (2862,
	2858,
	0,
	2860,
	2861);
INSERT INTO O_RTIDA
	VALUES (2863,
	2858,
	0,
	2860,
	2861);
INSERT INTO O_RTIDA
	VALUES (2864,
	2858,
	0,
	2860,
	2861);
INSERT INTO R_RTO
	VALUES (2858,
	2860,
	2861,
	0);
INSERT INTO R_OIR
	VALUES (2858,
	2860,
	2861,
	0);
INSERT INTO R_FORM
	VALUES (2846,
	2860,
	2865,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (2846,
	2860,
	2865);
INSERT INTO R_OIR
	VALUES (2846,
	2860,
	2865,
	0);
INSERT INTO R_SIMP
	VALUES (2866);
INSERT INTO R_REL
	VALUES (2866,
	8007,
	'',
	2796);
INSERT INTO R_PART
	VALUES (709,
	2866,
	2867,
	0,
	0,
	'held by');
INSERT INTO O_RTIDA
	VALUES (762,
	709,
	0,
	2866,
	2867);
INSERT INTO R_RTO
	VALUES (709,
	2866,
	2867,
	0);
INSERT INTO R_OIR
	VALUES (709,
	2866,
	2867,
	2805);
INSERT INTO R_FORM
	VALUES (2868,
	2866,
	2869,
	1,
	1,
	'holds');
INSERT INTO R_RGO
	VALUES (2868,
	2866,
	2869);
INSERT INTO R_OIR
	VALUES (2868,
	2866,
	2869,
	0);
INSERT INTO R_SIMP
	VALUES (2870);
INSERT INTO R_REL
	VALUES (2870,
	8008,
	'',
	2796);
INSERT INTO R_PART
	VALUES (2868,
	2870,
	2871,
	0,
	0,
	'makes up a');
INSERT INTO O_RTIDA
	VALUES (2872,
	2868,
	0,
	2870,
	2871);
INSERT INTO O_RTIDA
	VALUES (2873,
	2868,
	0,
	2870,
	2871);
INSERT INTO O_RTIDA
	VALUES (2874,
	2868,
	0,
	2870,
	2871);
INSERT INTO R_RTO
	VALUES (2868,
	2870,
	2871,
	0);
INSERT INTO R_OIR
	VALUES (2868,
	2870,
	2871,
	0);
INSERT INTO R_FORM
	VALUES (2854,
	2870,
	2875,
	1,
	1,
	'made up of');
INSERT INTO R_RGO
	VALUES (2854,
	2870,
	2875);
INSERT INTO R_OIR
	VALUES (2854,
	2870,
	2875,
	0);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2858,
	'Search Result Set',
	8003,
	'PE_SRS',
	'This class captures set of element instances that are visible to a
given package for a given search criterion.
----
Persistent:false',
	2796);
INSERT INTO O_TFR
	VALUES (2876,
	2858,
	'dispose',
	'',
	19,
	1,
	'// Search Result Set.dispose()
select one package related by self->EP_PKG[R8005];
select many elemVis related by self->PE_VIS[R8006];
for each elemV in elemVis
  select one pe related by elemV->PE_PE[R8002];
  unrelate package from pe across R8002 using elemV;
  unrelate self from elemV across R8006;
  delete object instance elemV;
end for;
unrelate self from package across R8005;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (2858,
	2798,
	0,
	2825,
	2856,
	2859,
	2857,
	2864,
	2877,
	0,
	0,
	'',
	'Package',
	'Package_ID',
	'R8005');
INSERT INTO O_RATTR
	VALUES (2864,
	2858,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (2864,
	2858,
	0,
	'Package_ID',
	'',
	'',
	'Package_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2862,
	2858);
INSERT INTO O_BATTR
	VALUES (2862,
	2858);
INSERT INTO O_ATTR
	VALUES (2862,
	2858,
	2864,
	'Name',
	'',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2863,
	2858);
INSERT INTO O_BATTR
	VALUES (2863,
	2858);
INSERT INTO O_ATTR
	VALUES (2863,
	2858,
	2862,
	'Type',
	'',
	'',
	'Type',
	0,
	2878,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2858);
INSERT INTO O_OIDA
	VALUES (2862,
	2858,
	0,
	'Name');
INSERT INTO O_OIDA
	VALUES (2863,
	2858,
	0,
	'Type');
INSERT INTO O_OIDA
	VALUES (2864,
	2858,
	0,
	'Package_ID');
INSERT INTO O_ID
	VALUES (1,
	2858);
INSERT INTO O_ID
	VALUES (2,
	2858);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (26,
	'Packageable Element',
	8000,
	'PE_PE',
	'',
	2796);
INSERT INTO O_TFR
	VALUES (2879,
	26,
	'dispose',
	'',
	19,
	1,
	'// Packageable Element.dispose()
 
select many ele_vis_links related by self->PE_VIS[R8002];
for each ele_vis_link in ele_vis_links
  select one pkg related by ele_vis_link->EP_PKG[R8002];
  unrelate self from pkg across R8002 using ele_vis_link;
  select one searchResultset related by ele_vis_link->PE_SRS[R8006];
  unrelate ele_vis_link from searchResultset across R8006;  
  delete object instance ele_vis_link;
end for;
select many com_vis_links related by self->PE_CVS[R8004];
for each com_vis_link in com_vis_links
  select one component related by com_vis_link->C_C[R8004];
  unrelate self from component across R8004 using com_vis_link;
  delete object instance com_vis_link;
end for;
select one modelClass related by self->O_OBJ[R8001];
if not_empty modelClass
  unrelate modelClass from self across R8001;
  modelClass.dispose();
end if;
select one dt related by self->S_DT[R8001];
if not_empty dt
  // note we do not tear down this association
  // as the S_DT.dispose() call requires it to
  // be setup, it will tear it down
  dt.dispose();
end if;
select one intPart related by self->SQ_P[R8001];
if not_empty intPart
  unrelate intPart from self across R8001;
  intPart.dispose();
end if;
select one ucAssoc related by self->UC_UCA[R8001];
if not_empty ucAssoc
  unrelate ucAssoc from self across R8001;
  ucAssoc.dispose();
end if;
select one actNode related by self->A_N[R8001];
if not_empty actNode
  unrelate actNode from self across R8001;
  actNode.dispose();
end if;
select one comp related by self->C_C[R8001];
if not_empty comp
  unrelate comp from self across R8001;
  comp.dispose();
end if;
select one ic related by self->CL_IC[R8001];
if not_empty ic
  unrelate ic from self across R8001;
  ic.dispose();
end if;
select one interface related by self->C_I[R8001];
if not_empty interface
  unrelate interface from self across R8001;
  interface.dispose();
end if;
select one pkg related by self->EP_PKG[R8001];
if not_empty pkg
  unrelate pkg from self across R8001;
  pkg.dispose();
end if;
select one csp related by self->CNST_CSP[R8001];
if not_empty csp
  unrelate csp from self across R8001;
  csp.dispose();
end if;
select one ap related by self->A_AP[R8001];
if not_empty ap
  unrelate ap from self across R8001;
  ap.dispose();
end if;
select one edge related by self->A_E[R8001];
if not_empty edge
  unrelate edge from self across R8001;
  edge.dispose();
end if;
select one msg related by self->MSG_M[R8001];
if not_empty msg
  unrelate msg from self across R8001;
  msg.dispose();
end if;
select one rel related by self->R_REL[R8001];
if not_empty rel
  unrelate rel from self across R8001;
  rel.dispose();
end if;
select one icomp related by self->O_IOBJ[R8001];
if not_empty icomp
  unrelate icomp from self across R8001;
  icomp.dispose();
end if;
select one sync related by self->S_SYNC[R8001];
if not_empty sync
  unrelate sync from self across R8001;
  sync.dispose();
end if;
select one ee related by self->S_EE[R8001];
if not_empty ee
  unrelate ee from self across R8001;
  ee.dispose();
end if;
select one sat related by self->C_SF[R8001];
if not_empty sat
  unrelate sat from self across R8001;
  sat.dispose();
end if;
select one delg related by self->C_DG[R8001];
if not_empty delg
  unrelate delg from self across R8001;
  delg.dispose();
end if;
select many bodyInElements related by self->ACT_BIE[R640];
for each bie in bodyInElements
  select one body related by bie->ACT_ACT[R640];
  unrelate self from body across R640 using bie;
  delete object instance bie;
end for;

select one package related by self->EP_PKG[R8000];
if not_empty package
  unrelate self from package across R8000 ;
end if;

select one component related by self->C_C[R8003];
if(not_empty component)
  unrelate self from component across R8003;
end if;

select many elemInSystems related by self->G_EIS[R9100];
for each elemInSystem in elemInSystems
  select one system related by elemInSystem->S_SYS[R9100];
  unrelate self from system across R9100 using elemInSystem;
  delete object instance elemInSystem;
end for;

delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (2880,
	26,
	'collectVisibleElementsForName',
	'',
	19,
	1,
	'// Packageable Element::collectVisibleElementsForName()
if param.type == self.type
  visible = false;
  if param.type == ElementTypeConstants::DATATYPE
    select one dt related by self->S_DT[R8001];
    if not_empty dt and (param.name == "" or dt.Name == param.name)
      visible = true;
    end if;
  elif param.type == ElementTypeConstants::CONSTANT
    select one cnst related by self->CNST_CSP[R8001];
    if not_empty cnst
      visible = true;
    end if;    
  elif param.type == ElementTypeConstants::CLASS
    select one clazz related by self->O_OBJ[R8001];
    if not_empty clazz and (param.name == "" or clazz.Key_Lett == param.name)
      visible = true;
    end if;
  elif param.type == ElementTypeConstants::INTERFACE
    select one ifc related by self->C_I[R8001];
    if not_empty ifc and (param.name == "" or ifc.Name == param.name)
      visible = true;
    end if;
  elif param.type == ElementTypeConstants::FUNCTION
    select one fn related by self->S_SYNC[R8001];
    if not_empty fn and (param.name == "" or fn.Name == param.name)
      visible = true;
    end if;
  elif param.type == ElementTypeConstants::COMPONENT
    select one comp related by self->C_C[R8001];
    if not_empty comp and (param.name == "" or comp.Name == param.name)
      visible = true;
    end if;
  elif param.type == ElementTypeConstants::EE
    select one ee related by self->S_EE[R8001];
    if not_empty ee and (param.name == "" or ee.Key_Lett == param.name)
      visible = true;
    end if;
  elif param.type == ElementTypeConstants::ASSOCIATION
    select one rel related by self->R_REL[R8001];
    if not_empty rel and (param.name == "" or
                   rel.Numb == OS::convert_relationship_string(rel:param.name));
      visible = true;
    end if;
  elif param.type == ElementTypeConstants::PACKAGE
    select one package related by self->EP_PKG[R8001];
    if not_empty package and (param.name == "" or package.Name == param.name)
      visible = true;
    end if;
  end if;
  if visible
    select any package from instances of EP_PKG
                    where (selected.Package_ID == param.originatingContainerID);
    select one packageableElement related by package->PE_PE[R8001];
    if(empty package)
      // force the architecture to look globally for the package
      select any packageableElement from instances of PE_PE
                    where (selected.Element_ID == param.originatingContainerID);
      select one package related by packageableElement->EP_PKG[R8001];
    end if;
    if not_empty package
      select any resultSet related by package->PE_SRS[R8005] where
                    selected.Name == param.name and selected.Type == param.type;
      create object instance visibility of PE_VIS;
      relate self to package across R8002 using visibility;
      relate visibility to resultSet across R8006;
    else
      select one originatingComp related by packageableElement->C_C[R8001];
      if not_empty originatingComp
        select any resultSet related by originatingComp->PE_CRS[R8007] where
                    selected.Name == param.name and selected.Type == param.type;
        create object instance visibility of PE_CVS;
        relate self to originatingComp across R8004 using visibility;
        relate visibility to resultSet across R8008;
      end if;
    end if;
  end if;
end if;
if self.type == ElementTypeConstants::PACKAGE
  select one package related by self->EP_PKG[R8001];
  if not_empty package and self.Element_ID != param.delegatingPkgID
    package.collectVisibleElementsForName(name:param.name,
                         type:param.type, descending:param.descending,
                         originatingContainerID: param.originatingContainerID,
                                         delegatingPkgID:GD::NULL_UNIQUE_ID(),
                                         collectGlobally:param.collectGlobally);
  end if;
end if;',
	1,
	'',
	2879);
INSERT INTO O_TPARM
	VALUES (2881,
	2880,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (2882,
	2880,
	'type',
	2878,
	0,
	'',
	2881,
	'');
INSERT INTO O_TPARM
	VALUES (2883,
	2880,
	'descending',
	316,
	0,
	'',
	2882,
	'');
INSERT INTO O_TPARM
	VALUES (2884,
	2880,
	'originatingContainerID',
	296,
	0,
	'',
	2883,
	'');
INSERT INTO O_TPARM
	VALUES (2885,
	2880,
	'delegatingPkgID',
	296,
	0,
	'',
	2884,
	'');
INSERT INTO O_TPARM
	VALUES (2886,
	2880,
	'collectGlobally',
	316,
	0,
	'',
	2885,
	'');
INSERT INTO O_TFR
	VALUES (2887,
	26,
	'initialize',
	'',
	19,
	1,
	'// PackageableElement.initialize()
self.Visibility = Visibility::Public;',
	1,
	'',
	2880);
INSERT INTO O_TFR
	VALUES (2888,
	26,
	'getQualifiedName',
	'',
	322,
	1,
	'//PackageableElement::getQualifiedName()
result = "";
select one package related by self->EP_PKG[R8000];
if not_empty package
  result = package.getQualifiedName();
else
  select one comp related by self->C_C[R8003];
  if not_empty comp
    result = comp.getQualifiedName();
  end if;
end if;
if result != ""
  result = result + "::";
end if;
result = result + self.getLocalName();
return result;',
	1,
	'',
	2887);
INSERT INTO O_TFR
	VALUES (2889,
	26,
	'getLocalName',
	'',
	322,
	1,
	'//PackageableElement::getLocalName()
// put these three first because these will be called much more than others.
select one dt related by self->S_DT[R8001];
if not_empty dt
  return dt.Name;
end if;
select one clazz related by self->O_OBJ[R8001];
if not_empty clazz
  return clazz.Name;
end if;
select one package related by self->EP_PKG[R8001];
if not_empty package
  return package.Name;
end if;
select one interface related by self->C_I[R8001];
if not_empty interface
  return interface.Name;
end if;
select one component related by self->C_C[R8001];
if not_empty component
  return component.Name;
end if;
select one assoc related by self->R_REL[R8001];
if not_empty assoc
  return GD::int_to_string(value:assoc.Numb);
end if;
select one func related by self->S_SYNC[R8001];
if not_empty func
  return func.Name;
end if;
select one iComp related by self->CL_IC[R8001];
if not_empty iComp
  return iComp.Name;
end if;
select one ee related by self->S_EE[R8001];
if not_empty ee
  return ee.Name;
end if;
return "";',
	1,
	'',
	2888);
INSERT INTO O_TFR
	VALUES (2890,
	26,
	'isAllowedType',
	'',
	316,
	1,
	'// PackageableElement.isAllowedType()
select one package related by self->EP_PKG[R8000];
select any resultSet related by package->PE_SRS[R8005] where
        selected.Name == "" and selected.Type == ElementTypeConstants::DATATYPE;
select any dt related by resultSet->
                             PE_VIS[R8006]->PE_PE[R8002]->S_DT[R8001] where
                                                selected.Name == param.typeName;
if empty package
  select one component related by self->C_C[R8003];
  select any compResultSet related by component->PE_CRS[R8007] where
        selected.Name == "" and selected.Type == ElementTypeConstants::DATATYPE;
  select any dt related by compResultSet->
                             PE_CVS[R8008]->PE_PE[R8004]->S_DT[R8001] where
                                                selected.Name == param.typeName;
end if;
if not_empty dt
  if param.isReturnType and param.typeName == "void"
    return true;
  else
    return dt.isCommonAllowedType();
  end if;
end if;
return false;',
	1,
	'',
	2889);
INSERT INTO O_TPARM
	VALUES (2891,
	2890,
	'isReturnType',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (2892,
	2890,
	'typeName',
	322,
	0,
	'',
	2891,
	'');
INSERT INTO O_TFR
	VALUES (2893,
	26,
	'resolveDataTypeRelativeToSelf',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one package related by self->EP_PKG[R8000];
select one component related by self->C_C[R8003];
if not_empty component
  component.clearScope();
  component.collectVisibleElementsForName(name:param.expected_name,
           type:ElementTypeConstants::DATATYPE,
                       originatingContainerID:component.Id,
                              delegatingContainerID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:true);
else
  package.clearScope();
  package.collectVisibleElementsForName(name:param.expected_name,
           type:ElementTypeConstants::DATATYPE, descending:false,
                       originatingContainerID:package.Package_ID,
                                      delegatingPkgID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:true);
end if;
select any resultSet related by component->PE_CRS[R8007] where
                                         selected.Name == param.expected_name and 
                            selected.Type == ElementTypeConstants::DATATYPE; 
select many results related by resultSet->PE_CVS[R8008]->PE_PE[R8004];
if not_empty package
  select any pkgResultSet related by package->PE_SRS[R8005] where
                                         selected.Name == param.expected_name and 
                            selected.Type == ElementTypeConstants::DATATYPE; 
  select many results related by pkgResultSet->PE_VIS[R8006]->PE_PE[R8002];
end if;
select any resolvedDt related by results->S_DT[R8001];
if cardinality results == 0
  if not_empty component
    component.clearScope();
    component.collectVisibleElementsForName(name:param.default_name,
          type:ElementTypeConstants::DATATYPE,
                      originatingContainerID:component.Id,
                             delegatingContainerID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:true);
  else
    package.clearScope();
    package.collectVisibleElementsForName(name:param.default_name,
          type:ElementTypeConstants::DATATYPE, descending:false,
                      originatingContainerID:package.Package_ID,
                                      delegatingPkgID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:true);
  end if;
  select any resultSet related by component->PE_CRS[R8007] where
                                               selected.Name == param.default_name and 
                            selected.Type == ElementTypeConstants::DATATYPE; 
  select many results related by resultSet->PE_CVS[R8008]->PE_PE[R8004];
  if not_empty package
    select any pkgResultSet related by package->PE_SRS[R8005] where
                                               selected.Name == param.default_name and 
                            selected.Type == ElementTypeConstants::DATATYPE; 
    select many results related by
                                  pkgResultSet->PE_VIS[R8006]->PE_PE[R8002];
  end if;
  select any resolvedDt related by results->S_DT[R8001];
end if;
if(not_empty resolvedDt)
  return resolvedDt.DT_ID;
end if;
// no dt was found, this is definitely an issue
// log an error and return a null id
USER::logError(msg:"Unable to resolve any data type.",path:"");
return GD::NULL_UNIQUE_ID();
',
	1,
	'',
	2890);
INSERT INTO O_TPARM
	VALUES (2894,
	2893,
	'expected_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (2895,
	2893,
	'default_name',
	322,
	0,
	'',
	2894,
	'');
INSERT INTO O_TFR
	VALUES (2896,
	26,
	'canReferToDataType',
	'',
	316,
	1,
	'select one package related by self->EP_PKG[R8000];
select one component related by self->C_C[R8003];
if not_empty component
  component.clearScope();
  component.collectVisibleElementsForName(name:param.dtName,
         type:ElementTypeConstants::DATATYPE,
                          originatingContainerID:component.Id,
                                   delegatingContainerID:GD::NULL_UNIQUE_ID(),
                                                          collectGlobally:true);
else
  package.clearScope();
  package.collectVisibleElementsForName(name:param.dtName,
         type:ElementTypeConstants::DATATYPE, descending:false,
                           originatingContainerID:package.Package_ID,
                                          delegatingPkgID:GD::NULL_UNIQUE_ID(),
                                                          collectGlobally:true);
end if;
// Find the previously created visibility list
select any resultSet related by package->PE_SRS[R8005] where
      selected.Name == param.dtName and selected.Type == ElementTypeConstants::DATATYPE;
select any dt related by resultSet->PE_VIS[R8006]->
                 PE_PE[R8002]->S_DT[R8001] where selected.DT_ID == param.dtID;
if not_empty component
  // Find the previously created visibility list
  select any compResultSet related by component->PE_CRS[R8007] where
      selected.Name == param.dtName and selected.Type == ElementTypeConstants::DATATYPE;
  select any dt related by compResultSet->PE_CVS[R8008]->
                   PE_PE[R8004]->S_DT[R8001] where selected.DT_ID == dt.DT_ID;
end if;
if(not_empty dt)
  return true;
end if;
return false;
',
	1,
	'',
	2893);
INSERT INTO O_TPARM
	VALUES (2897,
	2896,
	'dtID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (2898,
	2896,
	'dtName',
	322,
	0,
	'',
	2897,
	'');
INSERT INTO O_TFR
	VALUES (2899,
	26,
	'getVisibilityAdornment',
	'',
	322,
	1,
	'// Packageable Element.getVisibilityAdornment()
select one package related by self->EP_PKG[R8000];
select one component related by self->C_C[R8003];
select one sys related by self->EP_PKG[R8001]->S_SYS[R1401];
result = "";
if ((not_empty package or not_empty component) or 
    (not_empty sys and sys.useGlobals == true))
  if self.Visibility == Visibility::Public
    result = "+";
  elif self.Visibility == Visibility::Protected
    result = "#";
  elif self.Visibility == Visibility::Private
    result = "-";
  end if;
end if;
return result;',
	1,
	'',
	2896);
INSERT INTO O_TFR
	VALUES (2900,
	26,
	'getVisibilityValue',
	'',
	2901,
	1,
	'select one irdt related by self->S_DT[R8001]->S_IRDT[R17];
if(not_empty irdt)
  select one classPE related by irdt->O_OBJ[R123]->PE_PE[R8001];
  return classPE.Visibility;
end if;
return self.Visibility;',
	1,
	'',
	2899);
INSERT INTO O_TFR
	VALUES (2902,
	26,
	'resolveComponentRelativeToSelf',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one package related by self->EP_PKG[R8000];
select one component related by self->C_C[R8003];
if not_empty component
  component.clearScope();
  component.collectVisibleElementsForName(name:param.expected_name,
           type:ElementTypeConstants::COMPONENT,
                       originatingContainerID:component.Id,
                              delegatingContainerID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:true);
else
  package.clearScope();
  package.collectVisibleElementsForName(name:param.expected_name,
           type:ElementTypeConstants::COMPONENT, descending:false,
                       originatingContainerID:package.Package_ID,
                                      delegatingPkgID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:true);
end if;',
	1,
	'',
	2900);
INSERT INTO O_TPARM
	VALUES (2903,
	2902,
	'expected_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2904,
	26,
	'resolveInterfaceRelativeToSelf',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one package related by self->EP_PKG[R8000];
select one component related by self->C_C[R8003];
if not_empty component
  component.clearScope();
  component.collectVisibleElementsForName(name:param.expected_name,
           type:ElementTypeConstants::INTERFACE,
                       originatingContainerID:component.Id,
                              delegatingContainerID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:true);
else
  package.clearScope();
  package.collectVisibleElementsForName(name:param.expected_name,
           type:ElementTypeConstants::INTERFACE, descending:false,
                       originatingContainerID:package.Package_ID,
                                      delegatingPkgID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:true);
end if;',
	1,
	'',
	2902);
INSERT INTO O_TPARM
	VALUES (2905,
	2904,
	'expected_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2906,
	26,
	'resolvePackageRelativeToSelf',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one package related by self->EP_PKG[R8000];
select one component related by self->C_C[R8003];
if not_empty component
  component.clearScope();
  component.collectVisibleElementsForName(name:param.expected_name,
           type:ElementTypeConstants::PACKAGE,
                       originatingContainerID:component.Id,
                              delegatingContainerID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:true);
else
  package.clearScope();
  package.collectVisibleElementsForName(name:param.expected_name,
           type:ElementTypeConstants::PACKAGE, descending:false,
                       originatingContainerID:package.Package_ID,
                                      delegatingPkgID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:true);
end if;
select any resultSet related by component->PE_CRS[R8007] where
                                         selected.Name == param.expected_name and 
                            selected.Type == ElementTypeConstants::PACKAGE; 
select many results related by resultSet->PE_CVS[R8008]->PE_PE[R8004];
if not_empty package
  select any pkgResultSet related by package->PE_SRS[R8005] where
                                         selected.Name == param.expected_name and 
                            selected.Type == ElementTypeConstants::PACKAGE; 
  select many results related by pkgResultSet->PE_VIS[R8006]->PE_PE[R8002];
end if;
select any resolvedPkg related by results->EP_PKG[R8001];
if(not_empty resolvedPkg)
  return resolvedPkg.Package_ID;
end if; 
return GD::NULL_UNIQUE_ID();
',
	1,
	'',
	2904);
INSERT INTO O_TPARM
	VALUES (2907,
	2906,
	'expected_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2908,
	26,
	'resolveClassRelativeToSelf',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one package related by self->EP_PKG[R8000];
select one component related by self->C_C[R8003];
if not_empty component
  component.clearScope();
  component.collectVisibleElementsForName(name:param.expected_name,
           type:ElementTypeConstants::CLASS,
                       originatingContainerID:component.Id,
                              delegatingContainerID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:true);
else
  package.clearScope();
  package.collectVisibleElementsForName(name:param.expected_name,
           type:ElementTypeConstants::CLASS, descending:false,
                       originatingContainerID:package.Package_ID,
                                      delegatingPkgID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:true);
end if;',
	1,
	'',
	2906);
INSERT INTO O_TPARM
	VALUES (2909,
	2908,
	'expected_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2910,
	26,
	'resolveEERelativeToSelf',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one package related by self->EP_PKG[R8000];
select one component related by self->C_C[R8003];
if not_empty component
  component.clearScope();
  component.collectVisibleElementsForName(name:param.expected_name,
           type:ElementTypeConstants::EE,
                       originatingContainerID:component.Id,
                              delegatingContainerID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:true);
else
  package.clearScope();
  package.collectVisibleElementsForName(name:param.expected_name,
           type:ElementTypeConstants::EE, descending:false,
                       originatingContainerID:package.Package_ID,
                                      delegatingPkgID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:true);
end if;',
	1,
	'',
	2908);
INSERT INTO O_TPARM
	VALUES (2911,
	2910,
	'expected_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (2912,
	26,
	'isElementVisibleToSelf',
	'',
	316,
	1,
	'select one package related by self->EP_PKG[R8000];
select one component related by self->C_C[R8003];
if not_empty component
  component.clearScope();
  component.collectVisibleElementsForName(name:"",
           type:param.type,
                       originatingContainerID:component.Id,
                              delegatingContainerID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:true);
else
  package.clearScope();
  package.collectVisibleElementsForName(name:"",
           type:param.type, descending:false,
                       originatingContainerID:package.Package_ID,
                                      delegatingPkgID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:true);
end if;
select any resultSet related by component->PE_CRS[R8007] where
                                                    selected.Type == param.type;
select many results related by resultSet->PE_CVS[R8008]->PE_PE[R8004];
if not_empty package
  select any pkgResultSet related by package->PE_SRS[R8005] where 
                                                    selected.Type == param.type; 
  select many results related by pkgResultSet->PE_VIS[R8006]->PE_PE[R8002];
end if;
for each result in results
  if(result.Element_ID == param.elementId)
    return true;
  end if;
end for;
return false;',
	1,
	'',
	2910);
INSERT INTO O_TPARM
	VALUES (2913,
	2912,
	'type',
	2878,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (2914,
	2912,
	'elementId',
	296,
	0,
	'',
	2913,
	'');
INSERT INTO O_NBATTR
	VALUES (25,
	26);
INSERT INTO O_BATTR
	VALUES (25,
	26);
INSERT INTO O_ATTR
	VALUES (25,
	26,
	0,
	'Element_ID',
	'',
	'',
	'Element_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2915,
	26);
INSERT INTO O_BATTR
	VALUES (2915,
	26);
INSERT INTO O_ATTR
	VALUES (2915,
	26,
	25,
	'Visibility',
	'Full Name: Visibility',
	'',
	'Visibility',
	0,
	2901,
	'',
	'');
INSERT INTO O_REF
	VALUES (26,
	2798,
	0,
	2825,
	2823,
	2826,
	2824,
	2916,
	2917,
	0,
	0,
	'',
	'Package',
	'Package_ID',
	'R8000');
INSERT INTO O_RATTR
	VALUES (2916,
	26,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (2916,
	26,
	2915,
	'Package_ID',
	'',
	'',
	'Package_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (26,
	709,
	0,
	762,
	2848,
	2850,
	2849,
	2918,
	2919,
	0,
	0,
	'',
	'Component',
	'Id',
	'R8003');
INSERT INTO O_RATTR
	VALUES (2918,
	26,
	25,
	26,
	0,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (2918,
	26,
	2916,
	'Component_ID',
	'',
	'',
	'Component_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2920,
	26);
INSERT INTO O_BATTR
	VALUES (2920,
	26);
INSERT INTO O_ATTR
	VALUES (2920,
	26,
	2918,
	'type',
	'readonly:true',
	'',
	'type',
	0,
	2878,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	26);
INSERT INTO O_OIDA
	VALUES (25,
	26,
	0,
	'Element_ID');
INSERT INTO O_ID
	VALUES (1,
	26);
INSERT INTO O_ID
	VALUES (2,
	26);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2846,
	'Element Visibility',
	8001,
	'PE_VIS',
	'This link class captures the list of element instances that are visible to a
given package. The association R8002 is populated by the operations
collectVisibleElementsForName() on the Package and PackageableElement classes.
Persistent:false',
	2796);
INSERT INTO O_REF
	VALUES (2846,
	26,
	0,
	25,
	2843,
	2847,
	2844,
	2921,
	2922,
	0,
	0,
	'',
	'Packageable Element',
	'Element_ID',
	'R8002');
INSERT INTO O_RATTR
	VALUES (2921,
	2846,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (2921,
	2846,
	2923,
	'Element_ID',
	'',
	'',
	'Element_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2846,
	2798,
	0,
	2825,
	2843,
	2847,
	2845,
	2924,
	2925,
	0,
	0,
	'',
	'Package',
	'Package_ID',
	'R8002');
INSERT INTO O_REF
	VALUES (2846,
	2858,
	0,
	2864,
	2860,
	2865,
	2861,
	2924,
	2926,
	2925,
	0,
	'',
	'Search Result Set',
	'Package_ID',
	'R8006');
INSERT INTO O_RATTR
	VALUES (2924,
	2846,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (2924,
	2846,
	2921,
	'Package_ID',
	'',
	'',
	'Package_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2846,
	2858,
	0,
	2862,
	2860,
	2865,
	2861,
	2927,
	2928,
	0,
	0,
	'',
	'Search Result Set',
	'Name',
	'R8006');
INSERT INTO O_RATTR
	VALUES (2927,
	2846,
	2862,
	2858,
	1,
	'Name');
INSERT INTO O_ATTR
	VALUES (2927,
	2846,
	2924,
	'Name',
	'',
	'',
	'Name',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2846,
	2858,
	0,
	2863,
	2860,
	2865,
	2861,
	2929,
	2930,
	0,
	0,
	'',
	'Search Result Set',
	'Type',
	'R8006');
INSERT INTO O_RATTR
	VALUES (2929,
	2846,
	2863,
	2858,
	1,
	'Type');
INSERT INTO O_ATTR
	VALUES (2929,
	2846,
	2927,
	'Type',
	'',
	'',
	'Type',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2923,
	2846);
INSERT INTO O_BATTR
	VALUES (2923,
	2846);
INSERT INTO O_ATTR
	VALUES (2923,
	2846,
	0,
	'Visibility_ID',
	'',
	'',
	'Visibility_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2846);
INSERT INTO O_OIDA
	VALUES (2921,
	2846,
	0,
	'Element_ID');
INSERT INTO O_OIDA
	VALUES (2924,
	2846,
	0,
	'Package_ID');
INSERT INTO O_OIDA
	VALUES (2923,
	2846,
	0,
	'Visibility_ID');
INSERT INTO O_ID
	VALUES (1,
	2846);
INSERT INTO O_ID
	VALUES (2,
	2846);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2854,
	'Component Visibility',
	8002,
	'PE_CVS',
	'This link class captures the list of element instances that are visible to a
given component. The association R8004 is populated by the operations
collectVisibleElementsForName() on the Component and PackageableElement classes.
Persistent:false',
	2796);
INSERT INTO O_REF
	VALUES (2854,
	709,
	0,
	762,
	2851,
	2855,
	2852,
	2931,
	2932,
	0,
	0,
	'',
	'Component',
	'Id',
	'R8004');
INSERT INTO O_REF
	VALUES (2854,
	2868,
	0,
	2874,
	2870,
	2875,
	2871,
	2931,
	2933,
	2932,
	0,
	'',
	'Component Result Set',
	'Id',
	'R8008');
INSERT INTO O_RATTR
	VALUES (2931,
	2854,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (2931,
	2854,
	2934,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2854,
	26,
	0,
	25,
	2851,
	2855,
	2853,
	2934,
	2935,
	0,
	0,
	'',
	'Packageable Element',
	'Element_ID',
	'R8004');
INSERT INTO O_RATTR
	VALUES (2934,
	2854,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (2934,
	2854,
	2936,
	'Element_ID',
	'',
	'',
	'Element_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2854,
	2868,
	0,
	2872,
	2870,
	2875,
	2871,
	2937,
	2938,
	0,
	0,
	'',
	'Component Result Set',
	'Name',
	'R8008');
INSERT INTO O_RATTR
	VALUES (2937,
	2854,
	2872,
	2868,
	1,
	'Name');
INSERT INTO O_ATTR
	VALUES (2937,
	2854,
	2931,
	'Name',
	'',
	'',
	'Name',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2854,
	2868,
	0,
	2873,
	2870,
	2875,
	2871,
	2939,
	2940,
	0,
	0,
	'',
	'Component Result Set',
	'Type',
	'R8008');
INSERT INTO O_RATTR
	VALUES (2939,
	2854,
	2873,
	2868,
	1,
	'Type');
INSERT INTO O_ATTR
	VALUES (2939,
	2854,
	2937,
	'Type',
	'',
	'',
	'Type',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2936,
	2854);
INSERT INTO O_BATTR
	VALUES (2936,
	2854);
INSERT INTO O_ATTR
	VALUES (2936,
	2854,
	0,
	'Visibility_ID',
	'',
	'',
	'Visibility_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2854);
INSERT INTO O_OIDA
	VALUES (2931,
	2854,
	0,
	'Id');
INSERT INTO O_OIDA
	VALUES (2934,
	2854,
	0,
	'Element_ID');
INSERT INTO O_OIDA
	VALUES (2936,
	2854,
	0,
	'Visibility_ID');
INSERT INTO O_ID
	VALUES (1,
	2854);
INSERT INTO O_ID
	VALUES (2,
	2854);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2868,
	'Component Result Set',
	8004,
	'PE_CRS',
	'This class captures set of element instances that are visible to a
given component for a given search criterion.
----
Persistent:false',
	2796);
INSERT INTO O_TFR
	VALUES (2941,
	2868,
	'dispose',
	'',
	19,
	1,
	'// Component Result Set.dispose()
select one component related by self->C_C[R8007];
select many elemVis related by self->PE_CVS[R8008];
for each elemV in elemVis
  select one pe related by elemV->PE_PE[R8004];
  unrelate component from pe across R8004 using elemV;
  unrelate self from elemV across R8008;
  delete object instance elemV;
end for;
unrelate self from component across R8007;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_NBATTR
	VALUES (2872,
	2868);
INSERT INTO O_BATTR
	VALUES (2872,
	2868);
INSERT INTO O_ATTR
	VALUES (2872,
	2868,
	2874,
	'Name',
	'',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2873,
	2868);
INSERT INTO O_BATTR
	VALUES (2873,
	2868);
INSERT INTO O_ATTR
	VALUES (2873,
	2868,
	2872,
	'Type',
	'',
	'',
	'Type',
	0,
	2878,
	'',
	'');
INSERT INTO O_REF
	VALUES (2868,
	709,
	0,
	762,
	2866,
	2869,
	2867,
	2874,
	2942,
	0,
	0,
	'',
	'Component',
	'Id',
	'R8007');
INSERT INTO O_RATTR
	VALUES (2874,
	2868,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (2874,
	2868,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2868);
INSERT INTO O_OIDA
	VALUES (2872,
	2868,
	0,
	'Name');
INSERT INTO O_OIDA
	VALUES (2873,
	2868,
	0,
	'Type');
INSERT INTO O_OIDA
	VALUES (2874,
	2868,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	2868);
INSERT INTO O_ID
	VALUES (2,
	2868);
-- BP 7.1.6 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (2943,
	'Model Integrity',
	'',
	'MI',
	1300,
	1,
	0);
INSERT INTO S_SID
	VALUES (1,
	2943);
INSERT INTO O_IOBJ
	VALUES (2944,
	705,
	0,
	2943,
	'System Model',
	'S_SYS');
INSERT INTO R_SIMP
	VALUES (2945);
INSERT INTO R_REL
	VALUES (2945,
	1300,
	'',
	2943);
INSERT INTO R_PART
	VALUES (2946,
	2945,
	2947,
	0,
	0,
	'managed by');
INSERT INTO O_RTIDA
	VALUES (2948,
	2946,
	0,
	2945,
	2947);
INSERT INTO R_RTO
	VALUES (2946,
	2945,
	2947,
	0);
INSERT INTO R_OIR
	VALUES (2946,
	2945,
	2947,
	0);
INSERT INTO R_FORM
	VALUES (2949,
	2945,
	2950,
	1,
	1,
	'manages');
INSERT INTO R_RGO
	VALUES (2949,
	2945,
	2950);
INSERT INTO R_OIR
	VALUES (2949,
	2945,
	2950,
	0);
INSERT INTO R_SIMP
	VALUES (2951);
INSERT INTO R_REL
	VALUES (2951,
	1301,
	'',
	2943);
INSERT INTO R_PART
	VALUES (705,
	2951,
	2952,
	0,
	0,
	'contained within');
INSERT INTO O_RTIDA
	VALUES (754,
	705,
	0,
	2951,
	2952);
INSERT INTO R_RTO
	VALUES (705,
	2951,
	2952,
	0);
INSERT INTO R_OIR
	VALUES (705,
	2951,
	2952,
	2944);
INSERT INTO R_FORM
	VALUES (2946,
	2951,
	2953,
	0,
	1,
	'contains');
INSERT INTO R_RGO
	VALUES (2946,
	2951,
	2953);
INSERT INTO R_OIR
	VALUES (2946,
	2951,
	2953,
	0);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2946,
	'Integrity Manager',
	1300,
	'MI_IM',
	'Persistent:false',
	2943);
INSERT INTO O_TFR
	VALUES (2954,
	2946,
	'createIssue',
	'',
	19,
	0,
	'// Selecting the system here from instances is safe as all systems are stored
// on the default model root
select any system from instances of S_SYS
                                        where (selected.Sys_ID == param.sys_id);
select one manager related by system->MI_IM[R1301];
if(not_empty manager)
  create object instance issue of MI_II;
  relate issue to manager across R1300;
  issue.Description = param.description;
  issue.Severity = param.severity;
  issue.ElementName = param.name;
  issue.ElementPath = param.path;
  issue.ElementID = param.id;
  issue.Element = param.element;
end if;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (2955,
	2954,
	'sys_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (2956,
	2954,
	'description',
	322,
	0,
	'',
	2955,
	'');
INSERT INTO O_TPARM
	VALUES (2957,
	2954,
	'severity',
	2958,
	0,
	'',
	2956,
	'');
INSERT INTO O_TPARM
	VALUES (2959,
	2954,
	'name',
	322,
	0,
	'',
	2957,
	'');
INSERT INTO O_TPARM
	VALUES (2960,
	2954,
	'path',
	322,
	0,
	'',
	2959,
	'');
INSERT INTO O_TPARM
	VALUES (2961,
	2954,
	'id',
	296,
	0,
	'',
	2960,
	'');
INSERT INTO O_TPARM
	VALUES (2962,
	2954,
	'element',
	317,
	0,
	'',
	2961,
	'');
INSERT INTO O_NBATTR
	VALUES (2963,
	2946);
INSERT INTO O_BATTR
	VALUES (2963,
	2946);
INSERT INTO O_ATTR
	VALUES (2963,
	2946,
	2964,
	'RootElement',
	'',
	'',
	'RootElement',
	0,
	317,
	'',
	'');
INSERT INTO O_REF
	VALUES (2946,
	705,
	0,
	754,
	2951,
	2953,
	2952,
	2964,
	2965,
	0,
	0,
	'',
	'System Model',
	'Sys_ID',
	'R1301');
INSERT INTO O_RATTR
	VALUES (2964,
	2946,
	754,
	705,
	1,
	'Sys_ID');
INSERT INTO O_ATTR
	VALUES (2964,
	2946,
	2948,
	'Sys_ID',
	'',
	'',
	'Sys_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2948,
	2946);
INSERT INTO O_BATTR
	VALUES (2948,
	2946);
INSERT INTO O_ATTR
	VALUES (2948,
	2946,
	0,
	'IM_ID',
	'',
	'',
	'IM_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2946);
INSERT INTO O_OIDA
	VALUES (2948,
	2946,
	0,
	'IM_ID');
INSERT INTO O_ID
	VALUES (1,
	2946);
INSERT INTO O_ID
	VALUES (2,
	2946);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2949,
	'Integrity Issue',
	1301,
	'MI_II',
	'Persistent:false',
	2943);
INSERT INTO O_TFR
	VALUES (2966,
	2949,
	'recheckIntegrity',
	'',
	19,
	1,
	'self.dispose();',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (2967,
	2949,
	'dispose',
	'',
	19,
	1,
	'select one manager related by self->MI_IM[R1300];
unrelate self from manager across R1300;
delete object instance self;',
	1,
	'',
	2966);
INSERT INTO O_REF
	VALUES (2949,
	2946,
	0,
	2948,
	2945,
	2950,
	2947,
	2968,
	2969,
	0,
	0,
	'',
	'Integrity Manager',
	'IM_ID',
	'R1300');
INSERT INTO O_RATTR
	VALUES (2968,
	2949,
	2948,
	2946,
	1,
	'IM_ID');
INSERT INTO O_ATTR
	VALUES (2968,
	2949,
	2970,
	'IM_ID',
	'',
	'',
	'IM_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2971,
	2949);
INSERT INTO O_BATTR
	VALUES (2971,
	2949);
INSERT INTO O_ATTR
	VALUES (2971,
	2949,
	2968,
	'Description',
	'',
	'',
	'Description',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2972,
	2949);
INSERT INTO O_BATTR
	VALUES (2972,
	2949);
INSERT INTO O_ATTR
	VALUES (2972,
	2949,
	2971,
	'Severity',
	'',
	'',
	'Severity',
	0,
	2958,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2973,
	2949);
INSERT INTO O_BATTR
	VALUES (2973,
	2949);
INSERT INTO O_ATTR
	VALUES (2973,
	2949,
	2972,
	'ElementName',
	'',
	'',
	'ElementName',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2974,
	2949);
INSERT INTO O_BATTR
	VALUES (2974,
	2949);
INSERT INTO O_ATTR
	VALUES (2974,
	2949,
	2973,
	'ElementPath',
	'',
	'',
	'ElementPath',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2975,
	2949);
INSERT INTO O_BATTR
	VALUES (2975,
	2949);
INSERT INTO O_ATTR
	VALUES (2975,
	2949,
	2974,
	'ElementID',
	'',
	'',
	'ElementID',
	0,
	296,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2976,
	2949);
INSERT INTO O_BATTR
	VALUES (2976,
	2949);
INSERT INTO O_ATTR
	VALUES (2976,
	2949,
	2975,
	'Element',
	'',
	'',
	'Element',
	0,
	317,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2970,
	2949);
INSERT INTO O_BATTR
	VALUES (2970,
	2949);
INSERT INTO O_ATTR
	VALUES (2970,
	2949,
	0,
	'II_ID',
	'',
	'',
	'II_ID',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (2977,
	2949);
INSERT INTO O_BATTR
	VALUES (2977,
	2949);
INSERT INTO O_ATTR
	VALUES (2977,
	2949,
	2976,
	'markerID',
	'',
	'',
	'markerID',
	0,
	2978,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2949);
INSERT INTO O_OIDA
	VALUES (2970,
	2949,
	0,
	'II_ID');
INSERT INTO O_ID
	VALUES (1,
	2949);
INSERT INTO O_ID
	VALUES (2,
	2949);
-- BP 7.1 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (2979,
	'Message',
	'// This is used by schema_gen to ignore this subsystem (for publication)
TRANSLATE_FOR_EXTERNAL_USE:FALSE',
	'MSG',
	1000,
	1,
	0);
INSERT INTO S_SID
	VALUES (1,
	2979);
INSERT INTO O_IOBJ
	VALUES (2980,
	50,
	0,
	2979,
	'Operation Parameter',
	'O_TPARM');
INSERT INTO O_IOBJ
	VALUES (2981,
	48,
	0,
	2979,
	'Function Parameter',
	'S_SPARM');
INSERT INTO O_IOBJ
	VALUES (2982,
	52,
	0,
	2979,
	'State Machine Event Data Item',
	'SM_EVTDI');
INSERT INTO O_IOBJ
	VALUES (2983,
	46,
	0,
	2979,
	'Bridge Parameter',
	'S_BPARM');
INSERT INTO O_IOBJ
	VALUES (2984,
	703,
	0,
	2979,
	'Interaction Participant',
	'SQ_P');
INSERT INTO O_IOBJ
	VALUES (2985,
	1488,
	0,
	2979,
	'State Machine Event',
	'SM_EVT');
INSERT INTO O_IOBJ
	VALUES (2986,
	8,
	0,
	2979,
	'Function',
	'S_SYNC');
INSERT INTO O_IOBJ
	VALUES (2987,
	43,
	0,
	2979,
	'Operation',
	'O_TFR');
INSERT INTO O_IOBJ
	VALUES (2988,
	6,
	0,
	2979,
	'Bridge',
	'S_BRG');
INSERT INTO O_IOBJ
	VALUES (2989,
	2990,
	0,
	2979,
	'Interface Signal',
	'C_AS');
INSERT INTO O_IOBJ
	VALUES (2991,
	2992,
	0,
	2979,
	'Interface Operation',
	'C_IO');
INSERT INTO O_IOBJ
	VALUES (2993,
	57,
	0,
	2979,
	'Property Parameter',
	'C_PP');
INSERT INTO R_SIMP
	VALUES (2994);
INSERT INTO R_REL
	VALUES (2994,
	1000,
	'',
	2979);
INSERT INTO R_FORM
	VALUES (2995,
	2994,
	2996,
	1,
	1,
	'has an informal');
INSERT INTO R_RGO
	VALUES (2995,
	2994,
	2996);
INSERT INTO R_OIR
	VALUES (2995,
	2994,
	2996,
	0);
INSERT INTO R_PART
	VALUES (2141,
	2994,
	2997,
	0,
	1,
	'belongs to informal');
INSERT INTO O_RTIDA
	VALUES (2177,
	2141,
	0,
	2994,
	2997);
INSERT INTO R_RTO
	VALUES (2141,
	2994,
	2997,
	0);
INSERT INTO R_OIR
	VALUES (2141,
	2994,
	2997,
	0);
INSERT INTO R_SIMP
	VALUES (2998);
INSERT INTO R_REL
	VALUES (2998,
	1001,
	'',
	2979);
INSERT INTO R_FORM
	VALUES (2995,
	2998,
	2999,
	1,
	1,
	'has a formal');
INSERT INTO R_RGO
	VALUES (2995,
	2998,
	2999);
INSERT INTO R_OIR
	VALUES (2995,
	2998,
	2999,
	0);
INSERT INTO R_PART
	VALUES (2141,
	2998,
	3000,
	0,
	1,
	'belongs to formal');
INSERT INTO O_RTIDA
	VALUES (2177,
	2141,
	0,
	2998,
	3000);
INSERT INTO R_RTO
	VALUES (2141,
	2998,
	3000,
	0);
INSERT INTO R_OIR
	VALUES (2141,
	2998,
	3000,
	0);
INSERT INTO R_SIMP
	VALUES (3001);
INSERT INTO R_REL
	VALUES (3001,
	1007,
	'',
	2979);
INSERT INTO R_FORM
	VALUES (2141,
	3001,
	3002,
	1,
	1,
	'receives');
INSERT INTO R_RGO
	VALUES (2141,
	3001,
	3002);
INSERT INTO R_OIR
	VALUES (2141,
	3001,
	3002,
	0);
INSERT INTO R_PART
	VALUES (703,
	3001,
	3003,
	0,
	1,
	'has destination');
INSERT INTO O_RTIDA
	VALUES (743,
	703,
	0,
	3001,
	3003);
INSERT INTO R_RTO
	VALUES (703,
	3001,
	3003,
	0);
INSERT INTO R_OIR
	VALUES (703,
	3001,
	3003,
	2984);
INSERT INTO R_SIMP
	VALUES (3004);
INSERT INTO R_REL
	VALUES (3004,
	1008,
	'',
	2979);
INSERT INTO R_FORM
	VALUES (2141,
	3004,
	3005,
	1,
	1,
	'sends');
INSERT INTO R_RGO
	VALUES (2141,
	3004,
	3005);
INSERT INTO R_OIR
	VALUES (2141,
	3004,
	3005,
	0);
INSERT INTO R_PART
	VALUES (703,
	3004,
	3006,
	0,
	1,
	'has source');
INSERT INTO O_RTIDA
	VALUES (743,
	703,
	0,
	3004,
	3006);
INSERT INTO R_RTO
	VALUES (703,
	3004,
	3006,
	0);
INSERT INTO R_OIR
	VALUES (703,
	3004,
	3006,
	2984);
INSERT INTO R_SIMP
	VALUES (3007);
INSERT INTO R_REL
	VALUES (3007,
	1009,
	'CrossComponent:true',
	2979);
INSERT INTO R_FORM
	VALUES (3008,
	3007,
	3009,
	1,
	1,
	'is generated by');
INSERT INTO R_RGO
	VALUES (3008,
	3007,
	3009);
INSERT INTO R_OIR
	VALUES (3008,
	3007,
	3009,
	0);
INSERT INTO R_PART
	VALUES (1488,
	3007,
	3010,
	0,
	1,
	'generates');
INSERT INTO O_RTIDA
	VALUES (1604,
	1488,
	0,
	3007,
	3010);
INSERT INTO R_RTO
	VALUES (1488,
	3007,
	3010,
	0);
INSERT INTO R_OIR
	VALUES (1488,
	3007,
	3010,
	2985);
INSERT INTO R_SIMP
	VALUES (3011);
INSERT INTO R_REL
	VALUES (3011,
	1010,
	'CrossComponent:true',
	2979);
INSERT INTO R_FORM
	VALUES (3012,
	3011,
	3013,
	1,
	1,
	'is invoked by');
INSERT INTO R_RGO
	VALUES (3012,
	3011,
	3013);
INSERT INTO R_OIR
	VALUES (3012,
	3011,
	3013,
	0);
INSERT INTO R_PART
	VALUES (8,
	3011,
	3014,
	0,
	1,
	'is invocation of');
INSERT INTO O_RTIDA
	VALUES (11,
	8,
	0,
	3011,
	3014);
INSERT INTO R_RTO
	VALUES (8,
	3011,
	3014,
	0);
INSERT INTO R_OIR
	VALUES (8,
	3011,
	3014,
	2986);
INSERT INTO R_SIMP
	VALUES (3015);
INSERT INTO R_REL
	VALUES (3015,
	1011,
	'CrossComponent:true',
	2979);
INSERT INTO R_FORM
	VALUES (3016,
	3015,
	3017,
	1,
	1,
	'is invoked by');
INSERT INTO R_RGO
	VALUES (3016,
	3015,
	3017);
INSERT INTO R_OIR
	VALUES (3016,
	3015,
	3017,
	0);
INSERT INTO R_PART
	VALUES (43,
	3015,
	3018,
	0,
	1,
	'is invocation of');
INSERT INTO O_RTIDA
	VALUES (201,
	43,
	0,
	3015,
	3018);
INSERT INTO R_RTO
	VALUES (43,
	3015,
	3018,
	0);
INSERT INTO R_OIR
	VALUES (43,
	3015,
	3018,
	2987);
INSERT INTO R_SIMP
	VALUES (3019);
INSERT INTO R_REL
	VALUES (3019,
	1012,
	'CrossComponent:true',
	2979);
INSERT INTO R_FORM
	VALUES (3020,
	3019,
	3021,
	1,
	1,
	'is invoked by');
INSERT INTO R_RGO
	VALUES (3020,
	3019,
	3021);
INSERT INTO R_OIR
	VALUES (3020,
	3019,
	3021,
	0);
INSERT INTO R_PART
	VALUES (6,
	3019,
	3022,
	0,
	1,
	'is invocation of');
INSERT INTO O_RTIDA
	VALUES (16,
	6,
	0,
	3019,
	3022);
INSERT INTO R_RTO
	VALUES (6,
	3019,
	3022,
	0);
INSERT INTO R_OIR
	VALUES (6,
	3019,
	3022,
	2988);
INSERT INTO R_SUBSUP
	VALUES (3023);
INSERT INTO R_REL
	VALUES (3023,
	1013,
	'',
	2979);
INSERT INTO R_SUPER
	VALUES (2995,
	3023,
	3024);
INSERT INTO O_RTIDA
	VALUES (3025,
	2995,
	0,
	3023,
	3024);
INSERT INTO R_RTO
	VALUES (2995,
	3023,
	3024,
	0);
INSERT INTO R_OIR
	VALUES (2995,
	3023,
	3024,
	0);
INSERT INTO R_SUB
	VALUES (3026,
	3023,
	3027);
INSERT INTO R_RGO
	VALUES (3026,
	3023,
	3027);
INSERT INTO R_OIR
	VALUES (3026,
	3023,
	3027,
	0);
INSERT INTO R_SUB
	VALUES (3028,
	3023,
	3029);
INSERT INTO R_RGO
	VALUES (3028,
	3023,
	3029);
INSERT INTO R_OIR
	VALUES (3028,
	3023,
	3029,
	0);
INSERT INTO R_SUB
	VALUES (3030,
	3023,
	3031);
INSERT INTO R_RGO
	VALUES (3030,
	3023,
	3031);
INSERT INTO R_OIR
	VALUES (3030,
	3023,
	3031,
	0);
INSERT INTO R_SUB
	VALUES (3032,
	3023,
	3033);
INSERT INTO R_RGO
	VALUES (3032,
	3023,
	3033);
INSERT INTO R_OIR
	VALUES (3032,
	3023,
	3033,
	0);
INSERT INTO R_SUB
	VALUES (3034,
	3023,
	3035);
INSERT INTO R_RGO
	VALUES (3034,
	3023,
	3035);
INSERT INTO R_OIR
	VALUES (3034,
	3023,
	3035,
	0);
INSERT INTO R_SUB
	VALUES (3036,
	3023,
	3037);
INSERT INTO R_RGO
	VALUES (3036,
	3023,
	3037);
INSERT INTO R_OIR
	VALUES (3036,
	3023,
	3037,
	0);
INSERT INTO R_SIMP
	VALUES (3038);
INSERT INTO R_REL
	VALUES (3038,
	1014,
	'CrossComponent:true',
	2979);
INSERT INTO R_FORM
	VALUES (3026,
	3038,
	3039,
	1,
	1,
	'represents');
INSERT INTO R_RGO
	VALUES (3026,
	3038,
	3039);
INSERT INTO R_OIR
	VALUES (3026,
	3038,
	3039,
	0);
INSERT INTO R_PART
	VALUES (46,
	3038,
	3040,
	0,
	1,
	'is represented by');
INSERT INTO O_RTIDA
	VALUES (211,
	46,
	0,
	3038,
	3040);
INSERT INTO R_RTO
	VALUES (46,
	3038,
	3040,
	0);
INSERT INTO R_OIR
	VALUES (46,
	3038,
	3040,
	2983);
INSERT INTO R_SIMP
	VALUES (3041);
INSERT INTO R_REL
	VALUES (3041,
	1015,
	'CrossComponent:true',
	2979);
INSERT INTO R_FORM
	VALUES (3028,
	3041,
	3042,
	1,
	1,
	'represents');
INSERT INTO R_RGO
	VALUES (3028,
	3041,
	3042);
INSERT INTO R_OIR
	VALUES (3028,
	3041,
	3042,
	0);
INSERT INTO R_PART
	VALUES (50,
	3041,
	3043,
	0,
	1,
	'is represented by');
INSERT INTO O_RTIDA
	VALUES (219,
	50,
	0,
	3041,
	3043);
INSERT INTO R_RTO
	VALUES (50,
	3041,
	3043,
	0);
INSERT INTO R_OIR
	VALUES (50,
	3041,
	3043,
	2980);
INSERT INTO R_SIMP
	VALUES (3044);
INSERT INTO R_REL
	VALUES (3044,
	1016,
	'CrossComponent:true',
	2979);
INSERT INTO R_FORM
	VALUES (3030,
	3044,
	3045,
	1,
	1,
	'represents');
INSERT INTO R_RGO
	VALUES (3030,
	3044,
	3045);
INSERT INTO R_OIR
	VALUES (3030,
	3044,
	3045,
	0);
INSERT INTO R_PART
	VALUES (48,
	3044,
	3046,
	0,
	1,
	'is represented by');
INSERT INTO O_RTIDA
	VALUES (215,
	48,
	0,
	3044,
	3046);
INSERT INTO R_RTO
	VALUES (48,
	3044,
	3046,
	0);
INSERT INTO R_OIR
	VALUES (48,
	3044,
	3046,
	2981);
INSERT INTO R_SIMP
	VALUES (3047);
INSERT INTO R_REL
	VALUES (3047,
	1017,
	'CrossComponent:true',
	2979);
INSERT INTO R_FORM
	VALUES (3032,
	3047,
	3048,
	1,
	1,
	'represents');
INSERT INTO R_RGO
	VALUES (3032,
	3047,
	3048);
INSERT INTO R_OIR
	VALUES (3032,
	3047,
	3048,
	0);
INSERT INTO R_PART
	VALUES (52,
	3047,
	3049,
	0,
	1,
	'is represented by');
INSERT INTO O_RTIDA
	VALUES (276,
	52,
	0,
	3047,
	3049);
INSERT INTO O_RTIDA
	VALUES (277,
	52,
	0,
	3047,
	3049);
INSERT INTO R_RTO
	VALUES (52,
	3047,
	3049,
	0);
INSERT INTO R_OIR
	VALUES (52,
	3047,
	3049,
	2982);
INSERT INTO R_SUBSUP
	VALUES (3050);
INSERT INTO R_REL
	VALUES (3050,
	1018,
	'',
	2979);
INSERT INTO R_SUPER
	VALUES (2141,
	3050,
	3051);
INSERT INTO O_RTIDA
	VALUES (2177,
	2141,
	0,
	3050,
	3051);
INSERT INTO R_RTO
	VALUES (2141,
	3050,
	3051,
	0);
INSERT INTO R_OIR
	VALUES (2141,
	3050,
	3051,
	0);
INSERT INTO R_SUB
	VALUES (3052,
	3050,
	3053);
INSERT INTO R_RGO
	VALUES (3052,
	3050,
	3053);
INSERT INTO R_OIR
	VALUES (3052,
	3050,
	3053,
	0);
INSERT INTO R_SUB
	VALUES (3054,
	3050,
	3055);
INSERT INTO R_RGO
	VALUES (3054,
	3050,
	3055);
INSERT INTO R_OIR
	VALUES (3054,
	3050,
	3055,
	0);
INSERT INTO R_SUB
	VALUES (3056,
	3050,
	3057);
INSERT INTO R_RGO
	VALUES (3056,
	3050,
	3057);
INSERT INTO R_OIR
	VALUES (3056,
	3050,
	3057,
	0);
INSERT INTO R_SUBSUP
	VALUES (3058);
INSERT INTO R_REL
	VALUES (3058,
	1019,
	'',
	2979);
INSERT INTO R_SUPER
	VALUES (3052,
	3058,
	3059);
INSERT INTO O_RTIDA
	VALUES (3060,
	3052,
	0,
	3058,
	3059);
INSERT INTO R_RTO
	VALUES (3052,
	3058,
	3059,
	0);
INSERT INTO R_OIR
	VALUES (3052,
	3058,
	3059,
	0);
INSERT INTO R_SUB
	VALUES (3008,
	3058,
	3061);
INSERT INTO R_RGO
	VALUES (3008,
	3058,
	3061);
INSERT INTO R_OIR
	VALUES (3008,
	3058,
	3061,
	0);
INSERT INTO R_SUB
	VALUES (3062,
	3058,
	3063);
INSERT INTO R_RGO
	VALUES (3062,
	3058,
	3063);
INSERT INTO R_OIR
	VALUES (3062,
	3058,
	3063,
	0);
INSERT INTO R_SUB
	VALUES (3064,
	3058,
	3065);
INSERT INTO R_RGO
	VALUES (3064,
	3058,
	3065);
INSERT INTO R_OIR
	VALUES (3064,
	3058,
	3065,
	0);
INSERT INTO R_SUBSUP
	VALUES (3066);
INSERT INTO R_REL
	VALUES (3066,
	1020,
	'',
	2979);
INSERT INTO R_SUPER
	VALUES (3054,
	3066,
	3067);
INSERT INTO O_RTIDA
	VALUES (3068,
	3054,
	0,
	3066,
	3067);
INSERT INTO R_RTO
	VALUES (3054,
	3066,
	3067,
	0);
INSERT INTO R_OIR
	VALUES (3054,
	3066,
	3067,
	0);
INSERT INTO R_SUB
	VALUES (3012,
	3066,
	3069);
INSERT INTO R_RGO
	VALUES (3012,
	3066,
	3069);
INSERT INTO R_OIR
	VALUES (3012,
	3066,
	3069,
	0);
INSERT INTO R_SUB
	VALUES (3016,
	3066,
	3070);
INSERT INTO R_RGO
	VALUES (3016,
	3066,
	3070);
INSERT INTO R_OIR
	VALUES (3016,
	3066,
	3070,
	0);
INSERT INTO R_SUB
	VALUES (3020,
	3066,
	3071);
INSERT INTO R_RGO
	VALUES (3020,
	3066,
	3071);
INSERT INTO R_OIR
	VALUES (3020,
	3066,
	3071,
	0);
INSERT INTO R_SUB
	VALUES (3072,
	3066,
	3073);
INSERT INTO R_RGO
	VALUES (3072,
	3066,
	3073);
INSERT INTO R_OIR
	VALUES (3072,
	3066,
	3073,
	0);
INSERT INTO R_SUB
	VALUES (3074,
	3066,
	3075);
INSERT INTO R_RGO
	VALUES (3074,
	3066,
	3075);
INSERT INTO R_OIR
	VALUES (3074,
	3066,
	3075,
	0);
INSERT INTO R_SIMP
	VALUES (3076);
INSERT INTO R_REL
	VALUES (3076,
	1021,
	'CrossComponent:true',
	2979);
INSERT INTO R_FORM
	VALUES (3064,
	3076,
	3077,
	1,
	1,
	'sent by');
INSERT INTO R_RGO
	VALUES (3064,
	3076,
	3077);
INSERT INTO R_OIR
	VALUES (3064,
	3076,
	3077,
	0);
INSERT INTO R_PART
	VALUES (2990,
	3076,
	3078,
	0,
	1,
	'sends');
INSERT INTO O_RTIDA
	VALUES (3079,
	2990,
	0,
	3076,
	3078);
INSERT INTO R_RTO
	VALUES (2990,
	3076,
	3078,
	0);
INSERT INTO R_OIR
	VALUES (2990,
	3076,
	3078,
	2989);
INSERT INTO R_SIMP
	VALUES (3080);
INSERT INTO R_REL
	VALUES (3080,
	1022,
	'CrossComponent:true',
	2979);
INSERT INTO R_FORM
	VALUES (3074,
	3080,
	3081,
	1,
	1,
	'sent by');
INSERT INTO R_RGO
	VALUES (3074,
	3080,
	3081);
INSERT INTO R_OIR
	VALUES (3074,
	3080,
	3081,
	0);
INSERT INTO R_PART
	VALUES (2992,
	3080,
	3082,
	0,
	1,
	'sends');
INSERT INTO O_RTIDA
	VALUES (3083,
	2992,
	0,
	3080,
	3082);
INSERT INTO R_RTO
	VALUES (2992,
	3080,
	3082,
	0);
INSERT INTO R_OIR
	VALUES (2992,
	3080,
	3082,
	2991);
INSERT INTO R_SIMP
	VALUES (3084);
INSERT INTO R_REL
	VALUES (3084,
	1023,
	'CrossComponent:true',
	2979);
INSERT INTO R_PART
	VALUES (57,
	3084,
	3085,
	0,
	1,
	'is represented by');
INSERT INTO O_RTIDA
	VALUES (254,
	57,
	0,
	3084,
	3085);
INSERT INTO R_RTO
	VALUES (57,
	3084,
	3085,
	0);
INSERT INTO R_OIR
	VALUES (57,
	3084,
	3085,
	2993);
INSERT INTO R_FORM
	VALUES (3036,
	3084,
	3086,
	1,
	1,
	'represents');
INSERT INTO R_RGO
	VALUES (3036,
	3084,
	3086);
INSERT INTO R_OIR
	VALUES (3036,
	3084,
	3086,
	0);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3054,
	'Synchronous Message',
	1012,
	'MSG_SM',
	'This subclass represents, and holds its unique data, a synchronous message.  The
types of synchronous messages are:

Informal Synchronous Message
Bridge Message
Operation Message
Function Message',
	2979);
INSERT INTO O_TFR
	VALUES (3087,
	3054,
	'dispose',
	'',
	19,
	1,
	'select one om related by self->MSG_O[R1020];
select one fm related by self->MSG_F[R1020];
select one bm related by self->MSG_B[R1020];
select one im related by self->MSG_ISM[R1020];
select one iOp related by self->MSG_IOP[R1020];
// dispose formal messages
if(not_empty om)
  unrelate self from om across R1020;
  om.dispose();
end if;
if(not_empty fm)
  unrelate self from fm across R1020;
  fm.dispose();
end if;
if(not_empty bm)
  unrelate self from bm across R1020;
  bm.dispose();
end if;
// dispose informal messages
if(not_empty im)
  unrelate self from im across R1020;
  im.dispose();
end if;
if not_empty iOp
  unrelate self from iOp across R1020;
  iOp.dispose();
end if;
// delete supertype, and unrelate
select one msg related by self->MSG_M[R1018];
if(not_empty msg)
  unrelate self from msg across R1018;
  msg.dispose();
end if;
delete object instance self;',
	1,
	'',
	3088);
INSERT INTO O_TFR
	VALUES (3089,
	3054,
	'unformalize',
	'',
	19,
	1,
	'// dispose the formal message
select one om related by self->MSG_O[R1020];
select one fm related by self->MSG_F[R1020];
select one bm related by self->MSG_B[R1020];
select one iOp related by self->MSG_IOP[R1020];
if(not_empty om)
  om.dispose();
elif(not_empty fm)
  fm.dispose();
elif(not_empty bm)
  bm.dispose();
elif not_empty iOp
  iOp.dispose();
end if;
// unrelate from target element if under a communication
select one message related by self->MSG_M[R1018];
message.deassociateFromTarget();
self.disposeFormalArguments();
// create an informal synch message
create object instance im of MSG_ISM;
relate im to self across R1020;',
	1,
	'',
	3090);
INSERT INTO O_TFR
	VALUES (3091,
	3054,
	'initialize',
	'',
	19,
	1,
	'self.InformalName = "Informal Message";
// create informal subtype
create object instance im of MSG_ISM;
relate im to self across R1020;',
	1,
	'',
	3092);
INSERT INTO O_TFR
	VALUES (3093,
	3054,
	'newArgument',
	'',
	19,
	1,
	'// have the supertype create the argument
select one msg related by self->MSG_M[R1018];
if(not_empty msg)
  msg.newArgument();
end if;',
	1,
	'',
	3091);
INSERT INTO O_TFR
	VALUES (3088,
	3054,
	'canRename',
	'',
	316,
	1,
	'// only informal messages can be renamed
select one im related by self->MSG_ISM[R1020];
if(not_empty im)
  return true;
else
  return false;
end if;',
	1,
	'',
	3094);
INSERT INTO O_TFR
	VALUES (3095,
	3054,
	'get_name',
	'',
	322,
	1,
	'return self.Label;',
	1,
	'',
	3096);
INSERT INTO O_TFR
	VALUES (3092,
	3054,
	'get_style',
	'',
	784,
	1,
	'if(param.at == End::End)
  return Style::FilledArrow;
else
  return Style::Solid;
end if;',
	1,
	'',
	3097);
INSERT INTO O_TPARM
	VALUES (3098,
	3092,
	'at',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3096,
	3054,
	'get_connector_text',
	'',
	322,
	1,
	'if(param.at == End::Middle)
  result = self.Label;
  if(self.ResultTarget != "")
    if(result == "")
      result = self.ResultTarget;
    else
      result = self.ResultTarget + " = " + result;
    end if;
  end if;
  select many args related by self->MSG_M[R1018]->MSG_A[R1001];
  if(not self.isFormal)
    select many args related by self->MSG_M[R1018]->MSG_A[R1000];
  end if;
  if(not_empty args)
    result = result + " (";
    count = 0;
    for each arg in args
      count = count + 1;
      result = result + arg.Label;
      if(count != cardinality args)
        result = result + ", ";
      end if;
    end for;  
    result = result + ")";
  end if;
  if(self.ReturnValue != "")
    if(result == "")
      result = self.ReturnValue;
    else
      result = result + ":" + self.ReturnValue;
    end if;
  end if;
  if(self.SequenceNumb != "")
    if(result != "")
      result = ": " + result;
    end if;
    result = self.SequenceNumb + result;
  end if;
  return result;
elif(param.at == End::Start)
  if(self.GuardCondition != "")
    return "[" + self.GuardCondition + "]";
  end if;
  return "";
else
  return "";
end if;',
	1,
	'',
	3099);
INSERT INTO O_TPARM
	VALUES (3100,
	3096,
	'Obj_ID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (3101,
	3096,
	'Obj_TypeIsImported',
	316,
	0,
	'',
	3100,
	'');
INSERT INTO O_TPARM
	VALUES (3102,
	3096,
	'at',
	880,
	0,
	'',
	3101,
	'');
INSERT INTO O_TPARM
	VALUES (3103,
	3096,
	'parent_ID',
	296,
	0,
	'',
	3102,
	'');
INSERT INTO O_TFR
	VALUES (3094,
	3054,
	'actionFilter',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one packageableElem related by self->MSG_M[R1018]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one message related by self->MSG_M[R1018];
if(empty message)
  // This can be null during unit testing, just return false
  // if this is the case
  return false;
end if;
if(empty package and message.participatesInCommunication)
  select one package related by self->MSG_M[R1018]->SQ_P[R1007]->PE_PE[R8001]
                                                                ->EP_PKG[R8000];
end if;
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;

if(param.name == "can")
  if(param.value == "addArg")
    return not self.isFormal;
  elif(param.value == "unform")
    return self.isFormal;
  elif(param.value == "formBrg")
    select one eep related by self->MSG_M[R1018]->SQ_P[R1007]->SQ_EEP[R930];
    if(empty eep)
      // try the communication line
      select one eep related by self->MSG_M[R1018]->SQ_P[R1007]->SQ_LS[R930]
                                                     ->SQ_P[R940]->SQ_EEP[R930];
    end if;
    if(not_empty eep)
      select one communication related by eep->SQ_P[R930]->COMM_PIC[R1126]
                                                             ->COMM_COMM[R1126];
      // another filter will be used for communication
      // diagrams
      if(not_empty communication or message.participatesInCommunication)
        return false;
      end if;
      // if there is only one possible operation, and we are formal
      // do not allow
      if(self.isFormal)
        if(eep.getBridgeOperationCount() == 1)
          return false;
        end if;
      end if;
      return eep.formalEEHasBridgeOperations();
    end if;
  elif(param.value == "formFunc")
    select one fpp related by self->MSG_M[R1018]->SQ_P[R1007]->SQ_FPP[R930];
    if(empty fpp)
      // try the communication line
      select one fpp related by self->MSG_M[R1018]->SQ_P[R1007]->SQ_LS[R930]
                                                     ->SQ_P[R940]->SQ_FPP[R930];
    end if;
    if(not_empty fpp)
      select one communication related by fpp->SQ_P[R930]->COMM_PIC[R1126]
                                                             ->COMM_COMM[R1126];
      // another filter will be used for communication
      // diagrams
      if(not_empty communication)
        return false;
      end if; 
      // if there is only one possible function, and we are formal
      // do not allow
      if(self.isFormal)
        if(fpp.getFunctionCount() == 1)
          return false;
        end if;
      end if;
      return fpp.formalFPKHasFunctions();
    end if;
  elif(param.value == "formPkgFunc")
    if(message.participatesInCommunication)
      // another filter will handle
      return false;
    end if;
    select one pp related by self->MSG_M[R1018]->SQ_P[R1007]->SQ_PP[R930];
    if(empty pp)
      // try the communication line
      select one pp related by self->MSG_M[R1018]->SQ_P[R1007]->SQ_LS[R930]
                                                      ->SQ_P[R940]->SQ_PP[R930];
    end if;
    if(not_empty pp)
      if(self.isFormal)
        // if formal and only one possibility do not allow
        if(pp.getFunctionCount() == 1)
          return false;
        end if;
      end if;
      return pp.getFunctionCount() != 0;
    end if;
  elif(param.value == "formClassOp")
    select one cip related by self->MSG_M[R1018]->SQ_P[R1007]->SQ_CIP[R930];
    select one cp related by self->MSG_M[R1018]->SQ_P[R1007]->SQ_CP[R930];
    if(empty cp)
      // try the communication line
      select one cp related by self->MSG_M[R1018]->SQ_P[R1007]->SQ_LS[R930]
                                                      ->SQ_P[R940]->SQ_CP[R930];
    end if;
    if(not_empty cip)
      // if the instance is shown on a communication
      // do not allow
      if (isInGenericPackage)
        if(message.participatesInCommunication)
          return false;
        else
          // if there is only one possible operation, and we are formal
          // do not allow
          if(self.isFormal)
            if(cip.getClassOperationCount() == 1)
              return false;
            end if;
          end if;
          return cip.formalClassHasCBOperations();
        end if;
      else      
        select one communication related by cip->SQ_P[R930]->COMM_PIC[R1126]->COMM_COMM[R1126];
        if(not_empty communication)
          return false;
        else
          // if there is only one possible operation, and we are formal
          // do not allow
          if(self.isFormal)
            if(cip.getClassOperationCount() == 1)
              return false;
            end if;
          end if;
          return cip.formalClassHasCBOperations();
        end if;
      end if;
    elif(not_empty cp)
      select one communication related by cp->SQ_P[R930]->COMM_PIC[R1126]
                                                             ->COMM_COMM[R1126];
      if(not_empty communication)
        return false;
      end if;
      if (isInGenericPackage)
        if(message.participatesInCommunication)
          return false;
        end if;
      end if;
      // if there is only one possible operation, and we are formal
      // do not allow
      if(self.isFormal)
        if(cp.getClassOperationCount() == 1)
          return false;
        end if;
      end if;
      return cp.formalClassHasCBOperations();
    end if;
  elif(param.value == "formInstOp")  
    select one ls related by self->MSG_M[R1018]->SQ_P[R1007]->SQ_LS[R930];
    if(not_empty ls)
      select one cip related by ls->SQ_P[R940]->SQ_CIP[R930];
      select one communication related by cip->SQ_P[R930]->COMM_PIC[R1126]
                                                             ->COMM_COMM[R1126];
      if(not_empty communication or message.participatesInCommunication)
        // another filter will handle the communication case
        return false;
      end if;
      if(not_empty cip)
        // if there is only one possible operation, and we are formal
        // do not allow
        if(self.isFormal)
          if(cip.getInstanceOperationCount() == 1)
            return false;
          end if;
        end if;
        return cip.formalClassHasIBOperations();
      end if;
    end if;
  elif(param.value == "formIOp")
    // if there is only one interface operation and we are already
    // formalized with it, then do not allow
    select one operation related by self->MSG_IOP[R1020]->C_IO[R1022];
    if(not_empty operation)
      select one cop related by self->MSG_M[R1018]->SQ_P[R1007]->SQ_COP[R930];
      if(empty cop)
        select one cop related by self->MSG_M[R1018]->SQ_P[R1007]->SQ_LS[R930]
                                                     ->SQ_P[R940]->SQ_COP[R930];
      end if;
      if(not_empty cop)
        if(cop.getInterfaceOperationCount() == 1)
          return false;
        end if;
      end if;
    end if;
  
    select one cop related by self->MSG_M[R1018]->SQ_P[R1007]->SQ_COP[R930];
    if(empty cop)
      select one cop related by self->MSG_M[R1018]->SQ_P[R1007]->SQ_LS[R930]
                                                     ->SQ_P[R940]->SQ_COP[R930];
    end if;
    if(not_empty cop)
      // do not allow if on a communication diagram, other
      // filters will handle this
      select one communication related by cop->SQ_P[R930]->COMM_PIC[R1126]
                                                             ->COMM_COMM[R1126];
      if(not_empty communication or message.participatesInCommunication)
        return false;
      end if;
      return cop.isFormalAndHasIFOperations();
    end if;
  // the following filtering is for communication diagrams
  elif(param.value == "formCommClassOp") or (param.value == "formCommInstOp")
  		 or (param.value == "formCommFunc") or (param.value == "formCommMsgIOp")
  		 or (param.value == "formCommBrg") or (param.value == "formCommPackageFunc")
    
    // if this message is not shown on a communication diagram
    // do not allow
    select one communication related by self->MSG_M[R1018]->COMM_MIC[R1135]
                                                             ->COMM_COMM[R1135];
    if(empty communication)
      // if the above association is not setup, the message is associated with
      // a participant already, get the communication through this participant
      select one communication related by self->MSG_M[R1018]->SQ_P[R1007]->COMM_PIC[R1126]->COMM_COMM[R1126];
      if(empty communication and not message.participatesInCommunication)
        return false;
      end if;
    end if;
    pkgID = GD::NULL_UNIQUE_ID();
    if (not_empty communication)
      pkgID = communication.Package_ID;
    else
      pkgID = package.Package_ID;
    end if;
      
    // if the selection count does not equal two return false, this
    // prevents the menu entries from existing while only one of the
    // elements is selected
    if(Sel::getCurrentSelectionCount() != 2)
      return false;
    end if;
    // if the selection does not contain a participant
    // do not allow
    if(not Util::selectionContainsValidParticipant(from:Util::getCommunicationInstance(id:pkgID)))
      return false;
    end if;
    // additionally check if this message is already formalized
    // to the only available operation
    if(self.isFormal)
      select one participant related by self->MSG_M[R1018]->SQ_P[R1007];
      if(param.value == "formCommClassOp")
        select one cp related by participant->SQ_CP[R930];
        if(not_empty cp)
          if(cp.getClassOperationCount() == 1)
            return false;
          end if;
        end if;
      elif(param.value == "formCommInstOp")
        select one cip related by participant->SQ_CIP[R930];
        if(not_empty cip)
          if(cip.getInstanceOperationCount() == 1)
            return false;
          end if;
        end if;
      elif(param.value == "formCommMsgIOp")
        select one cop related by participant->SQ_COP[R930];
        if(not_empty cop)
          if(cop.getInterfaceOperationCount() == 1)
            return false;
          end if;
        end if;
      elif(param.value == "formCommFunc")
        select one fpp related by participant->SQ_FPP[R930];
        if(not_empty fpp)
          if(fpp.getFunctionCount() == 1)
            return false;
          end if;
        else
          // will be a package participant
          select one pp related by participant->SQ_PP[R930];
          if(not_empty pp)
            if(pp.getFunctionCount() == 1)
              return false;
            end if;
          end if;
        end if;
      elif(param.value == "formCommBrg")
        select one eep related by participant->SQ_EEP[R930];
        if(not_empty eep)
          if(eep.getBridgeOperationCount() == 1)
            return false;
          end if;
        end if;
      end if;
    end if;
    return true;
  end if;
elif(param.name == "show")
  if(param.value == "noTargetMessage")
    if(Sel::getCurrentSelectionCount() != 1)
      return false;
    end if;
    select one target related by self->MSG_M[R1018]->SQ_P[R1007];
    return empty target;
  end if;
end if;
return false;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (3104,
	3094,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (3105,
	3094,
	'value',
	322,
	0,
	'',
	3104,
	'');
INSERT INTO O_TFR
	VALUES (3097,
	3054,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Msg_ID;',
	1,
	'',
	3095);
INSERT INTO O_TFR
	VALUES (3106,
	3054,
	'disposeFormalArguments',
	'',
	19,
	1,
	'select one parent related by self->MSG_M[R1018];
parent.disposeFormalArguments();',
	1,
	'',
	3087);
INSERT INTO O_TFR
	VALUES (3107,
	3054,
	'formalizeWithClassOperation',
	'',
	19,
	1,
	'select any operation from instances of O_TFR where (selected.Tfr_ID == param.operationId);
self.prepareForFormalization();
create object instance om of MSG_O;
relate om to self across R1020;
if (not_empty operation)
  relate operation to om across R1011;
end if;
select one message related by self->MSG_M[R1018];
select many oparms related by operation->O_TPARM[R117];
// create message arguments for each parameter
for each oparm in oparms
  create object instance arg of MSG_A;
  create object instance oarg of MSG_OA;
  relate arg to message across R1001;
  relate oarg to arg across R1013;
  relate oarg to oparm across R1015;
  arg.Value = "";
end for;      
',
	1,
	'',
	3108);
INSERT INTO O_TPARM
	VALUES (3109,
	3107,
	'operationId',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3090,
	3054,
	'prepareForFormalization',
	'',
	19,
	1,
	'select one im related by self->MSG_ISM[R1020];
select one om related by self->MSG_O[R1020];
select one fm related by self->MSG_F[R1020];
select one bm related by self->MSG_B[R1020];
select one iOp related by self->MSG_IOP[R1020];
select one message related by self->MSG_M[R1018];
if(not_empty im)
  unrelate im from self across R1020;
  im.dispose();
elif(not_empty om)
  unrelate om from self across R1020;
  om.dispose();
  message.disposeFormalArguments();
elif(not_empty fm)
  unrelate fm from self across R1020;
  fm.dispose();
  message.disposeFormalArguments();
elif(not_empty bm)
  unrelate bm from self across R1020;
  bm.dispose();
  message.disposeFormalArguments();
elif not_empty iOp
  unrelate iOp from self across R1020;
  iOp.dispose();
  message.disposeFormalArguments();
end if;',
	1,
	'',
	3093);
INSERT INTO O_TFR
	VALUES (3108,
	3054,
	'formalizeWithBridgeOperation',
	'',
	19,
	1,
	'select any brg from instances of S_BRG where (selected.Brg_ID == param.bridgeId);
select one message related by self->MSG_M[R1018];
self.prepareForFormalization();
create object instance bm of MSG_B;
relate bm to self across R1020;
relate bm to brg across R1012;
select many bparms related by brg->S_BPARM[R21];
for each bparm in bparms
  create object instance arg of MSG_A;
  create object instance barg of MSG_BA;
  relate arg to message across R1001;
  relate barg to arg across R1013;
  relate bparm to barg across R1014;
  arg.Value = "";
end for;',
	1,
	'',
	3106);
INSERT INTO O_TPARM
	VALUES (3110,
	3108,
	'bridgeId',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3099,
	3054,
	'formalizeWithFunction',
	'',
	19,
	1,
	'select any function from instances of S_SYNC where (selected.Sync_ID == param.functionId);
select one message related by self->MSG_M[R1018];
self.prepareForFormalization();
create object instance fm of MSG_F;
relate fm to self across R1020;
relate function to fm across R1010;
select many fparms related by function->S_SPARM[R24];
for each fparm in fparms
  create object instance arg of MSG_A;
  create object instance farg of MSG_FA;
  relate arg to message across R1001;
  relate farg to arg across R1013;
  relate fparm to farg across R1016;
  arg.Value = "";
end for;    ',
	1,
	'',
	3107);
INSERT INTO O_TPARM
	VALUES (3111,
	3099,
	'functionId',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3112,
	3054,
	'formalizeWithInterfaceOperation',
	'',
	19,
	1,
	'select any iOpProp from instances of C_EP where selected.Id == param.iOpId;
if not_empty iOpProp
  select one iOp related by iOpProp->C_IO[R4004];
  if not_empty iOp
    self.prepareForFormalization();
    create object instance ioM of MSG_IOP;
    relate ioM to self across R1020;
    relate ioM to iOp across R1022;
    select one message related by self->MSG_M[R1018];
    // create a message argument for every parameter
    // assigned to this signal
    select many parms related by iOpProp->C_PP[R4006];
    for each parm in parms
      create object instance arg of MSG_A;
      create object instance eparg of MSG_EPA;
      relate arg to message across R1001;
      relate eparg to arg across R1013;
      relate eparg to parm across R1023;
      arg.Value = "";
    end for;
  end if;
end if;
',
	1,
	'',
	3089);
INSERT INTO O_TPARM
	VALUES (3113,
	3112,
	'iOpId',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3114,
	3054,
	'canFormalizeUsingInterfaceOperation',
	'',
	316,
	1,
	'/**
 *  Filter operation when choosing which interface operation can be used
 *  to formalize this synchronous message
 */

// Check that we are not already formalized to the given interface
// operation
select one currentOperation related by self->MSG_IOP[R1020]->C_IO[R1022];
if(not_empty currentOperation and param.id == currentOperation.Id)
  return false;
end if;
return true;',
	1,
	'',
	3112);
INSERT INTO O_TPARM
	VALUES (3115,
	3114,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3116,
	3054,
	'pasteMessageArgument',
	'',
	19,
	1,
	'select one message related by self->MSG_M[R1018];
message.pasteMessageArgument(id:param.id);',
	1,
	'',
	3114);
INSERT INTO O_TPARM
	VALUES (3117,
	3116,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3118,
	3054,
	'canCopyMessageArgument',
	'',
	316,
	1,
	'select one message related by self->MSG_M[R1018];
return message.canCopyMessageArgument(id:param.id);',
	1,
	'',
	3116);
INSERT INTO O_TPARM
	VALUES (3119,
	3118,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3120,
	3054,
	'canPasteMessageArgument',
	'',
	316,
	1,
	'return not self.isFormal;',
	1,
	'',
	3118);
INSERT INTO O_NBATTR
	VALUES (3121,
	3054);
INSERT INTO O_BATTR
	VALUES (3121,
	3054);
INSERT INTO O_ATTR
	VALUES (3121,
	3054,
	3122,
	'ResultTarget',
	'Full Name: Result Target',
	'',
	'ResultTarget',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3123,
	3054);
INSERT INTO O_BATTR
	VALUES (3123,
	3054);
INSERT INTO O_ATTR
	VALUES (3123,
	3054,
	3121,
	'ReturnValue',
	'Full Name: Return Value',
	'',
	'ReturnValue',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3122,
	3054);
INSERT INTO O_BATTR
	VALUES (3122,
	3054);
INSERT INTO O_ATTR
	VALUES (3122,
	3054,
	3124,
	'GuardCondition',
	'Full Name: Guard Condition',
	'',
	'GuardCondition',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3124,
	3054);
INSERT INTO O_BATTR
	VALUES (3124,
	3054);
INSERT INTO O_ATTR
	VALUES (3124,
	3054,
	3125,
	'Descrip',
	'Full Name: Message Description',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (3126,
	3054,
	'select one ism related by self->MSG_ISM[R1020];
if(not_empty ism)
  self.isFormal = false;
else
  self.isFormal = true;
end if;',
	1);
INSERT INTO O_BATTR
	VALUES (3126,
	3054);
INSERT INTO O_ATTR
	VALUES (3126,
	3054,
	3123,
	'isFormal',
	'Full Name: Is Formal',
	'',
	'isFormal',
	0,
	316,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (3127,
	3054,
	'result = "";
select one fm related by self->MSG_F[R1020];
select one om related by self->MSG_O[R1020];
select one bm related by self->MSG_B[R1020];
select one iOp related by self->MSG_IOP[R1020];
if(not_empty fm)
  select one func related by fm->S_SYNC[R1010];
  result = func.Name;
elif(not_empty om)
  select one op related by om->O_TFR[R1011];
  result = op.Name;
elif(not_empty bm)
  select one brg related by bm->S_BRG[R1012];
  result = brg.Name;
elif not_empty iOp
  select one interfaceOp related by iOp->C_IO[R1022];
  result = interfaceOp.Name;
else
  result = self.InformalName;
end if;
self.Label = result;',
	1);
INSERT INTO O_BATTR
	VALUES (3127,
	3054);
INSERT INTO O_ATTR
	VALUES (3127,
	3054,
	3126,
	'Label',
	'User_Visible: false',
	'',
	'Label',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3125,
	3054);
INSERT INTO O_BATTR
	VALUES (3125,
	3054);
INSERT INTO O_ATTR
	VALUES (3125,
	3054,
	3068,
	'InformalName',
	'Full Name: Informal Name',
	'',
	'InformalName',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3128,
	3054);
INSERT INTO O_BATTR
	VALUES (3128,
	3054);
INSERT INTO O_ATTR
	VALUES (3128,
	3054,
	3127,
	'SequenceNumb',
	'Full Name: Sequence Number',
	'',
	'SequenceNumb',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (3054,
	2141,
	0,
	2177,
	3050,
	3055,
	3051,
	3068,
	3129,
	0,
	0,
	'',
	'Message',
	'Msg_ID',
	'R1018');
INSERT INTO O_RATTR
	VALUES (3068,
	3054,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (3068,
	3054,
	0,
	'Msg_ID',
	'',
	'',
	'Msg_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3054);
INSERT INTO O_OIDA
	VALUES (3068,
	3054,
	0,
	'Msg_ID');
INSERT INTO O_ID
	VALUES (1,
	3054);
INSERT INTO O_ID
	VALUES (2,
	3054);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3064,
	'Signal Message',
	1017,
	'MSG_SIG',
	'',
	2979);
INSERT INTO O_TFR
	VALUES (3130,
	3064,
	'dispose',
	'',
	19,
	1,
	'select one em related by self->MSG_AM[R1019];
if(not_empty em)
  unrelate self from em across R1019;
end if;
select one sig related by self->C_AS[R1021];
if not_empty sig
  unrelate self from sig across R1021;
end if;
select one asyncMessage related by self->MSG_AM[R1019];
if(not_empty asyncMessage)
  unrelate self from asyncMessage across R1019;
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (3131,
	3064,
	'get_name',
	'',
	322,
	1,
	'select one signal related by self->C_AS[R1021];
return signal.Name;',
	1,
	'',
	3130);
INSERT INTO O_REF
	VALUES (3064,
	3052,
	0,
	3060,
	3058,
	3065,
	3059,
	3132,
	3133,
	0,
	0,
	'',
	'Asynchronous Message',
	'Msg_ID',
	'R1019');
INSERT INTO O_RATTR
	VALUES (3132,
	3064,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (3132,
	3064,
	0,
	'Msg_ID',
	'',
	'',
	'Msg_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (3064,
	2990,
	0,
	3079,
	3076,
	3077,
	3078,
	3134,
	3135,
	0,
	0,
	'',
	'Interface Signal',
	'Id',
	'R1021');
INSERT INTO O_RATTR
	VALUES (3134,
	3064,
	3136,
	3137,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (3134,
	3064,
	3132,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3064);
INSERT INTO O_OIDA
	VALUES (3132,
	3064,
	0,
	'Msg_ID');
INSERT INTO O_ID
	VALUES (1,
	3064);
INSERT INTO O_ID
	VALUES (2,
	3064);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3056,
	'Return Message',
	1011,
	'MSG_R',
	'This class is used to represent a return message.  The return message is never
formal.',
	2979);
INSERT INTO O_TFR
	VALUES (3138,
	3056,
	'dispose',
	'',
	19,
	1,
	'// dispose supertype
select one msg related by self->MSG_M[R1018];
if(not_empty msg)
  unrelate self from msg across R1018;
  msg.dispose();
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (3139,
	3056,
	'initialize',
	'',
	19,
	1,
	'self.Name = "Unnamed Return";',
	1,
	'',
	3140);
INSERT INTO O_TFR
	VALUES (3141,
	3056,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Msg_ID;',
	1,
	'',
	3142);
INSERT INTO O_TFR
	VALUES (3140,
	3056,
	'get_style',
	'',
	784,
	1,
	'if(param.at == End::End)
  return Style::OpenArrow;
else
  return Style::Broken;
end if;',
	1,
	'',
	3141);
INSERT INTO O_TPARM
	VALUES (3143,
	3140,
	'at',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3142,
	3056,
	'get_connector_text',
	'',
	322,
	1,
	'if(param.at == End::Middle)
  result = self.Name;
  if(self.ResultTarget != "")
    if(result == "")
      result = self.ResultTarget;
    else
      result = self.ResultTarget + " = " + result;
    end if;
  end if;
  if(self.SequenceNumb != "")
    if(result == "")
      result = self.SequenceNumb;
    else
      result = self.SequenceNumb + ": " + result;
    end if;
  end if;
  select many args related by self->MSG_M[R1018]->MSG_A[R1001];
  if(empty args)
    select many args related by self->MSG_M[R1018]->MSG_A[R1000];
  end if;
  if(not_empty args)
    result = result + " (";
    count = 0;
    for each arg in args
      count = count + 1;
      result = result + arg.Label;
      if(count != cardinality args)
        result = result + ", ";
      end if;
    end for;  
    result = result + ")";
  end if;
  if(self.ReturnValue != "")
    if(result == "")
      result = self.ReturnValue;
    else
      result = result + ":" + self.ReturnValue;
    end if;
  end if;
  return result;
elif(param.at == End::Start)
  if(self.GuardCondition != "")
    return "[" + self.GuardCondition + "]";
  end if;
  return "";
else
  return "";
end if;',
	1,
	'',
	3138);
INSERT INTO O_TPARM
	VALUES (3144,
	3142,
	'Obj_ID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (3145,
	3142,
	'Obj_TypeIsImported',
	316,
	0,
	'',
	3144,
	'');
INSERT INTO O_TPARM
	VALUES (3146,
	3142,
	'at',
	880,
	0,
	'',
	3145,
	'');
INSERT INTO O_TPARM
	VALUES (3147,
	3142,
	'parent_ID',
	296,
	0,
	'',
	3146,
	'');
INSERT INTO O_TFR
	VALUES (3148,
	3056,
	'newArgument',
	'',
	19,
	1,
	'// have the supertype create the argument
select one msg related by self->MSG_M[R1018];
if(not_empty msg)
  msg.newArgument();
end if;',
	1,
	'',
	3139);
INSERT INTO O_NBATTR
	VALUES (3149,
	3056);
INSERT INTO O_BATTR
	VALUES (3149,
	3056);
INSERT INTO O_ATTR
	VALUES (3149,
	3056,
	3150,
	'ReturnValue',
	'Full Name: Return Value',
	'',
	'ReturnValue',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3150,
	3056);
INSERT INTO O_BATTR
	VALUES (3150,
	3056);
INSERT INTO O_ATTR
	VALUES (3150,
	3056,
	3151,
	'ResultTarget',
	'Full Name: Result Target',
	'',
	'ResultTarget',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3151,
	3056);
INSERT INTO O_BATTR
	VALUES (3151,
	3056);
INSERT INTO O_ATTR
	VALUES (3151,
	3056,
	3152,
	'GuardCondition',
	'Full Name: Guard Condition',
	'',
	'GuardCondition',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3152,
	3056);
INSERT INTO O_BATTR
	VALUES (3152,
	3056);
INSERT INTO O_ATTR
	VALUES (3152,
	3056,
	3153,
	'Descrip',
	'Full Name: Message Description
Description: A textual description of this message.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3153,
	3056);
INSERT INTO O_BATTR
	VALUES (3153,
	3056);
INSERT INTO O_ATTR
	VALUES (3153,
	3056,
	3154,
	'Name',
	'Full Name: Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3155,
	3056);
INSERT INTO O_BATTR
	VALUES (3155,
	3056);
INSERT INTO O_ATTR
	VALUES (3155,
	3056,
	3149,
	'SequenceNumb',
	'Full Name: Sequence Number',
	'',
	'SequenceNumb',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (3056,
	2141,
	0,
	2177,
	3050,
	3057,
	3051,
	3154,
	3156,
	0,
	0,
	'',
	'Message',
	'Msg_ID',
	'R1018');
INSERT INTO O_RATTR
	VALUES (3154,
	3056,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (3154,
	3056,
	0,
	'Msg_ID',
	'',
	'',
	'Msg_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3056);
INSERT INTO O_OIDA
	VALUES (3154,
	3056,
	0,
	'Msg_ID');
INSERT INTO O_ID
	VALUES (1,
	3056);
INSERT INTO O_ID
	VALUES (2,
	3056);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3016,
	'Operation Message',
	1002,
	'MSG_O',
	'This class manages the formality between a message and its formal couterpart
model element.',
	2979);
INSERT INTO O_TFR
	VALUES (3157,
	3016,
	'dispose',
	'',
	19,
	1,
	'select one op related by self->O_TFR[R1011];
if(not_empty op)
  unrelate self from op across R1011;
end if;
select one sm related by self->MSG_SM[R1020];
if(not_empty sm)
  unrelate self from sm across R1020;
end if;
// dispose any formal arguments if still
// existant
select many arguments related by self->MSG_SM[R1020]->MSG_M[R1018]->MSG_A[R1001];
for each argument in arguments
  argument.dispose();
end for;
select one syncMessage related by self->MSG_SM[R1020];
if(not_empty syncMessage)
  unrelate self from syncMessage across R1020;
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (3158,
	3016,
	'get_name',
	'',
	322,
	1,
	'select one operation related by self->O_TFR[R1011];
return operation.Name;',
	1,
	'',
	3157);
INSERT INTO O_REF
	VALUES (3016,
	43,
	0,
	201,
	3015,
	3017,
	3018,
	3159,
	3160,
	0,
	0,
	'',
	'Operation',
	'Tfr_ID',
	'R1011');
INSERT INTO O_RATTR
	VALUES (3159,
	3016,
	201,
	43,
	1,
	'Tfr_ID');
INSERT INTO O_ATTR
	VALUES (3159,
	3016,
	3161,
	'Tfr_ID',
	'',
	'',
	'Tfr_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (3016,
	3054,
	0,
	3068,
	3066,
	3070,
	3067,
	3161,
	3162,
	0,
	0,
	'',
	'Synchronous Message',
	'Msg_ID',
	'R1020');
INSERT INTO O_RATTR
	VALUES (3161,
	3016,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (3161,
	3016,
	0,
	'Msg_ID',
	'',
	'',
	'Msg_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3016);
INSERT INTO O_OIDA
	VALUES (3161,
	3016,
	0,
	'Msg_ID');
INSERT INTO O_ID
	VALUES (1,
	3016);
INSERT INTO O_ID
	VALUES (2,
	3016);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3028,
	'Operation Argument',
	1008,
	'MSG_OA',
	'This class manages the formality between a message argument and its formal
couterpart model element.',
	2979);
INSERT INTO O_TFR
	VALUES (3163,
	3028,
	'dispose',
	'',
	19,
	1,
	'select one oparm related by self->O_TPARM[R1015];
if(not_empty oparm)
  unrelate self from oparm across R1015;
end if;
select one ma related by self->MSG_A[R1013];
if(not_empty ma)
  ma.dispose();
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (3028,
	2995,
	0,
	3025,
	3023,
	3029,
	3024,
	3164,
	3165,
	0,
	0,
	'',
	'Message Argument',
	'Arg_ID',
	'R1013');
INSERT INTO O_RATTR
	VALUES (3164,
	3028,
	3025,
	2995,
	1,
	'Arg_ID');
INSERT INTO O_ATTR
	VALUES (3164,
	3028,
	0,
	'Arg_ID',
	'',
	'',
	'Arg_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (3028,
	50,
	0,
	219,
	3041,
	3042,
	3043,
	3166,
	3167,
	0,
	0,
	'',
	'Operation Parameter',
	'TParm_ID',
	'R1015');
INSERT INTO O_RATTR
	VALUES (3166,
	3028,
	219,
	50,
	1,
	'TParm_ID');
INSERT INTO O_ATTR
	VALUES (3166,
	3028,
	3164,
	'TParm_ID',
	'',
	'',
	'TParm_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3028);
INSERT INTO O_OIDA
	VALUES (3164,
	3028,
	0,
	'Arg_ID');
INSERT INTO O_ID
	VALUES (1,
	3028);
INSERT INTO O_ID
	VALUES (2,
	3028);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2995,
	'Message Argument',
	1001,
	'MSG_A',
	'This class represents a message''s argument.  A message argument can be
formalized against any of the following elements:

S_BPARM
O_TPARM
S_SPARM
SM_EVTDI',
	2979);
INSERT INTO O_TFR
	VALUES (3168,
	2995,
	'dispose',
	'',
	19,
	1,
	'// dispose all formal arguments
select one ba related by self->MSG_BA[R1013];
select one oa related by self->MSG_OA[R1013];
select one fa related by self->MSG_FA[R1013];
select one ea related by self->MSG_EA[R1013];
select one ia related by self->MSG_IA[R1013];
select one epa related by self->MSG_EPA[R1013];
if(not_empty ba)
  unrelate self from ba across R1013;
  ba.dispose();
end if;
if(not_empty oa)
  unrelate self from oa across R1013;
  oa.dispose();
end if;
if(not_empty fa)
  unrelate self from fa across R1013;
  fa.dispose();
end if;
if(not_empty ea)
  unrelate self from ea across R1013;
  ea.dispose();
end if;
if(not_empty ia)
  unrelate self from ia across R1013;
  delete object instance ia;
end if;
if not_empty epa
  unrelate self from epa across R1013;
  epa.dispose();
end if;
// unrelate self from message
select one fmessage related by self->MSG_M[R1001];
select one imessage related by self->MSG_M[R1000];
if(not_empty fmessage)
  unrelate self from fmessage across R1001;
elif(not_empty imessage)
  unrelate self from imessage across R1000;
end if;
delete object instance self;',
	1,
	'',
	3169);
INSERT INTO O_TFR
	VALUES (3170,
	2995,
	'initialize',
	'',
	19,
	1,
	'name = "Informal Argument";
success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:false);    
if ( success!="") 
 self.InformalName =success;
else 
 self.dispose();
end if;      ',
	1,
	'',
	3171);
INSERT INTO O_TFR
	VALUES (3171,
	2995,
	'get_name',
	'',
	322,
	1,
	'return self.Label;',
	1,
	'',
	3168);
INSERT INTO O_TFR
	VALUES (3169,
	2995,
	'canRename',
	'',
	316,
	1,
	'return not self.isFormal;',
	1,
	'',
	3172);
INSERT INTO O_TFR
	VALUES (3172,
	2995,
	'canDelete',
	'',
	316,
	1,
	'return not self.isFormal;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (3173,
	2995,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.
Translate: native
',
	317,
	1,
	'return this;',
	0,
	'',
	3170);
INSERT INTO O_NBATTR
	VALUES (3025,
	2995);
INSERT INTO O_BATTR
	VALUES (3025,
	2995);
INSERT INTO O_ATTR
	VALUES (3025,
	2995,
	0,
	'Arg_ID',
	'',
	'',
	'Arg_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (3174,
	2995,
	'select one ba related by self->MSG_BA[R1013];
select one oa related by self->MSG_OA[R1013];
select one fa related by self->MSG_FA[R1013];
select one ea related by self->MSG_EA[R1013];
select one epa related by self->MSG_EPA[R1013];
label = "";
if(not_empty ba)
  select one bparm related by ba->S_BPARM[R1014];
  label = bparm.Name;
elif(not_empty oa)
  select one oparm related by oa->O_TPARM[R1015];
  label = oparm.Name;
elif(not_empty fa)
  select one fparm related by fa->S_SPARM[R1016];
  label = fparm.Name;
elif(not_empty ea)
  select one evtdi related by ea->SM_EVTDI[R1017];
  label = evtdi.Name;
elif(not_empty epa)
  select one epp related by epa->C_PP[R1023];
  label = epp.Name;
else
  label = self.InformalName;
end if;
if(self.Value != "")
  self.Label = label + " = " + self.Value;
else
  self.Label = label;
end if;',
	1);
INSERT INTO O_BATTR
	VALUES (3174,
	2995);
INSERT INTO O_ATTR
	VALUES (3174,
	2995,
	3175,
	'Label',
	'User_Visible:false',
	'',
	'Label',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3176,
	2995);
INSERT INTO O_BATTR
	VALUES (3176,
	2995);
INSERT INTO O_ATTR
	VALUES (3176,
	2995,
	3174,
	'Value',
	'Full Name: Argument Value',
	'',
	'Value',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3177,
	2995);
INSERT INTO O_BATTR
	VALUES (3177,
	2995);
INSERT INTO O_ATTR
	VALUES (3177,
	2995,
	3176,
	'InformalName',
	'Full Name: Informal Argument Name',
	'',
	'InformalName',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3178,
	2995);
INSERT INTO O_BATTR
	VALUES (3178,
	2995);
INSERT INTO O_ATTR
	VALUES (3178,
	2995,
	3177,
	'Descrip',
	'Full Name: Message Argument Description
Description: A textual description of this argument.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (3179,
	2995,
	'select one message related by self->MSG_M[R1001];
self.isFormal = not_empty message;',
	1);
INSERT INTO O_BATTR
	VALUES (3179,
	2995);
INSERT INTO O_ATTR
	VALUES (3179,
	2995,
	3178,
	'isFormal',
	'Full Name: Is Formal',
	'',
	'isFormal',
	0,
	316,
	'',
	'');
INSERT INTO O_REF
	VALUES (2995,
	2141,
	0,
	2177,
	2994,
	2996,
	2997,
	3180,
	3181,
	0,
	0,
	'',
	'Message',
	'Msg_ID',
	'R1000');
INSERT INTO O_RATTR
	VALUES (3180,
	2995,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (3180,
	2995,
	3025,
	'Informal_Msg_ID',
	'',
	'Informal_',
	'MSG_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2995,
	2141,
	0,
	2177,
	2998,
	2999,
	3000,
	3175,
	3182,
	0,
	0,
	'',
	'Message',
	'Msg_ID',
	'R1001');
INSERT INTO O_RATTR
	VALUES (3175,
	2995,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (3175,
	2995,
	3180,
	'Formal_Msg_ID',
	'',
	'Formal_',
	'MSG_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2995);
INSERT INTO O_OIDA
	VALUES (3025,
	2995,
	0,
	'Arg_ID');
INSERT INTO O_ID
	VALUES (1,
	2995);
INSERT INTO O_ID
	VALUES (2,
	2995);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2141,
	'Message',
	1000,
	'MSG_M',
	'This class represents a message which participates in a sequence.  A message
represents an invocation of some operation, function, or event.  Messages can be
formalized with any of the following elements:

S_BRG
S_SYNC
O_TFR
SM_EVT',
	2979);
INSERT INTO O_TFR
	VALUES (3183,
	2141,
	'dispose',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// dispose all message arguments
select one pe related by self->PE_PE[R8001];
if(not_empty pe)
  // PE_PE.dispose() will call back into this function at which time the
  // rest of the activity will execute.
  pe.dispose();
  return;
end if;
select many iargs related by self->MSG_A[R1000];
select many fargs related by self->MSG_A[R1001];
for each farg in fargs
  unrelate self from farg across R1001;
  farg.dispose();
end for;
for each iarg in iargs
  unrelate self from iarg across R1000;
  iarg.dispose();
end for;
// unrelate self from source/destination participants
select one participant related by self->SQ_P[R1007];
if(not_empty participant)
  unrelate self from participant across R1007;
end if;
select one participant related by self->SQ_P[R1008];
if(not_empty participant)
  unrelate self from participant across R1008;
end if;
// now dispose the subtype messages
select one sm related by self->MSG_SM[R1018];
select one am related by self->MSG_AM[R1018];
select one rm related by self->MSG_R[R1018];
if(not_empty sm)
  unrelate self from sm across R1018;
  sm.dispose();
end if;
if(not_empty am)
  unrelate self from am across R1018;
  am.dispose();
end if;
if(not_empty rm)
  unrelate self from rm across R1018;
  rm.dispose();
end if;
// unrelate self from communication if
// necessary
select one mic related by self->COMM_MIC[R1135];
if(not_empty mic)
  select one comm related by mic->COMM_COMM[R1135];
  if (not_empty comm)
    unrelate self from comm across R1135 using mic;
  end if;
end if;
select one mis related by self->SQ_MIS[R954];
if(not_empty mis)
  select one sequence related by mis->SQ_S[R953];
  unrelate mis from sequence across R953;
  unrelate mis from self across R954;
  delete object instance mis;
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (3184,
	2141,
	'newArgument',
	'',
	19,
	1,
	'create object instance argument of MSG_A;
create object instance informalArg of MSG_IA;
relate argument to self across R1000;
relate argument to informalArg across R1013;
argument.initialize();',
	1,
	'',
	3185);
INSERT INTO O_TFR
	VALUES (3185,
	2141,
	'getName',
	'',
	322,
	1,
	'select one rm related by self->MSG_R[R1018];
select one sm related by self->MSG_SM[R1018];
select one am related by self->MSG_AM[R1018];
if(not_empty rm)
  return rm.Name;
elif(not_empty sm)
  return sm.Label;
elif(not_empty am)
  return am.Label;
else
  return "";
end if;',
	1,
	'',
	3186);
INSERT INTO O_TFR
	VALUES (3187,
	2141,
	'unformalize',
	'',
	19,
	1,
	'select one sm related by self->MSG_SM[R1018];
select one am related by self->MSG_AM[R1018];
if(not_empty sm)
  if(sm.isFormal)
    sm.unformalize();
  end if;
elif(not_empty am)
  if(am.isFormal)
    am.unformalize();
  end if;
end if;',
	1,
	'',
	3184);
INSERT INTO O_TFR
	VALUES (3186,
	2141,
	'disposeFormalArguments',
	'',
	19,
	1,
	'/**
*
*  This operation is called when a previously formal
*  message has been re-formalized
*
*/
select many arguments related by self->MSG_A[R1001];
for each argument in arguments
  argument.dispose();
end for;',
	1,
	'',
	3183);
INSERT INTO O_TFR
	VALUES (3188,
	2141,
	'pasteMessageArgument',
	'',
	19,
	1,
	'select any argument from instances of MSG_A where (selected.Arg_ID == param.id);
if(not_empty argument)
  select one existingMsg related by argument->MSG_M[R1000];
  if(not_empty existingMsg)
    unrelate existingMsg from argument across R1000;
  end if;
  relate argument to self across R1000;
end if;',
	1,
	'',
	3187);
INSERT INTO O_TPARM
	VALUES (3189,
	3188,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3190,
	2141,
	'canCopyMessageArgument',
	'',
	316,
	1,
	'select any argument from instances of MSG_A where (selected.Arg_ID == param.id);
if(not_empty argument)
  select one informal related by argument->MSG_IA[R1013];
  if(empty informal)
    return false;
  end if;
else
  return false;
end if;
return true;',
	1,
	'',
	3188);
INSERT INTO O_TPARM
	VALUES (3191,
	3190,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3192,
	2141,
	'deassociateFromTarget',
	'',
	19,
	1,
	'select one destPart related by self->SQ_P[R1007];
if(not_empty destPart)
  select one packageableElem related by destPart->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = not_empty package or not_empty component;
  if (isInGenericPackage)
    select one sync related by self->MSG_SM[R1018];
    select one async related by self->MSG_AM[R1018];
    if(not_empty sync)
      if(not self.participatesInCommunication)
        // no need to relate with communication
        return;
      end if;
    end if;
    if(not_empty async)
      if(not self.participatesInCommunication)
        // no need to relate with communication
        return;
      end if;
    end if;
    select one pkg related by destPart->PE_PE[R8001]->EP_PKG[R8000];
    if(empty pkg and not_empty component)
      rootCompIdInPkg = component.getRootComponentId();
      select any rootComponent from instances of C_C where (selected.Id == rootCompIdInPkg);
      select one pkg related by rootComponent->PE_PE[R8001]->EP_PKG[R8000];    
    end if;
    if(not_empty pkg)
      unrelate self from destPart across R1007;
    end if;
  else
    select one comm related by destPart->COMM_PIC[R1126]->COMM_COMM[R1126];
    if(not_empty comm)
      unrelate self from destPart across R1007;
    end if;
  end if;
end if;',
	1,
	'',
	3190);
INSERT INTO O_REF
	VALUES (2141,
	703,
	0,
	743,
	3001,
	3002,
	3003,
	3193,
	3194,
	0,
	0,
	'',
	'Interaction Participant',
	'Part_ID',
	'R1007');
INSERT INTO O_RATTR
	VALUES (3193,
	2141,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (3193,
	2141,
	3195,
	'Sender_Part_ID',
	'',
	'Sender_',
	'Part_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2141,
	703,
	0,
	743,
	3004,
	3005,
	3006,
	3195,
	3196,
	0,
	0,
	'',
	'Interaction Participant',
	'Part_ID',
	'R1008');
INSERT INTO O_RATTR
	VALUES (3195,
	2141,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (3195,
	2141,
	2177,
	'Receiver_Part_ID',
	'',
	'Receiver_',
	'Part_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2141,
	26,
	0,
	25,
	868,
	2837,
	870,
	2177,
	3197,
	0,
	0,
	'',
	'Packageable Element',
	'Element_ID',
	'R8001');
INSERT INTO O_RATTR
	VALUES (2177,
	2141,
	25,
	26,
	0,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (2177,
	2141,
	0,
	'Msg_ID',
	'',
	'',
	'Msg_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3198,
	2141);
INSERT INTO O_BATTR
	VALUES (3198,
	2141);
INSERT INTO O_ATTR
	VALUES (3198,
	2141,
	3193,
	'participatesInCommunication',
	'This attribute is set at load time to indicate whether or not this message is
participating in a communication.

persistent:false',
	'',
	'participatesInCommunication',
	0,
	316,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2141);
INSERT INTO O_OIDA
	VALUES (2177,
	2141,
	0,
	'Msg_ID');
INSERT INTO O_ID
	VALUES (1,
	2141);
INSERT INTO O_ID
	VALUES (2,
	2141);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3074,
	'Interface Operation Message',
	1018,
	'MSG_IOP',
	'',
	2979);
INSERT INTO O_TFR
	VALUES (3199,
	3074,
	'dispose',
	'',
	19,
	1,
	'select one sm related by self->MSG_SM[R1020];
if(not_empty sm)
  unrelate self from sm across R1020;
end if;
select one iOp related by self->C_IO[R1022];
if not_empty iOp
  unrelate self from iOp across R1022;
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (3200,
	3074,
	'get_name',
	'',
	322,
	1,
	'select one iop related by self->C_IO[R1022];
return iop.Name;',
	1,
	'',
	3199);
INSERT INTO O_REF
	VALUES (3074,
	3054,
	0,
	3068,
	3066,
	3075,
	3067,
	3201,
	3202,
	0,
	0,
	'',
	'Synchronous Message',
	'Msg_ID',
	'R1020');
INSERT INTO O_RATTR
	VALUES (3201,
	3074,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (3201,
	3074,
	0,
	'Msg_ID',
	'',
	'',
	'Msg_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (3074,
	2992,
	0,
	3083,
	3080,
	3081,
	3082,
	3203,
	3204,
	0,
	0,
	'',
	'Interface Operation',
	'Id',
	'R1022');
INSERT INTO O_RATTR
	VALUES (3203,
	3074,
	3136,
	3137,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (3203,
	3074,
	3201,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3074);
INSERT INTO O_OIDA
	VALUES (3201,
	3074,
	0,
	'Msg_ID');
INSERT INTO O_ID
	VALUES (1,
	3074);
INSERT INTO O_ID
	VALUES (2,
	3074);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3072,
	'Informal Synchronous Message',
	1014,
	'MSG_ISM',
	'This class is responsible for representing the fact that a message is informal.',
	2979);
INSERT INTO O_TFR
	VALUES (3205,
	3072,
	'dispose',
	'',
	19,
	1,
	'select one syncMessage related by self->MSG_SM[R1020];
if(not_empty syncMessage)
  unrelate self from syncMessage across R1020;
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (3206,
	3072,
	'get_name',
	'',
	322,
	1,
	'return "Informal Message";',
	1,
	'',
	3205);
INSERT INTO O_REF
	VALUES (3072,
	3054,
	0,
	3068,
	3066,
	3073,
	3067,
	3207,
	3208,
	0,
	0,
	'',
	'Synchronous Message',
	'Msg_ID',
	'R1020');
INSERT INTO O_RATTR
	VALUES (3207,
	3072,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (3207,
	3072,
	0,
	'Msg_ID',
	'',
	'',
	'Msg_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3072);
INSERT INTO O_OIDA
	VALUES (3207,
	3072,
	0,
	'Msg_ID');
INSERT INTO O_ID
	VALUES (1,
	3072);
INSERT INTO O_ID
	VALUES (2,
	3072);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3062,
	'Informal Asynchronous Message',
	1015,
	'MSG_IAM',
	'This class is responsible for representing the fact that a message is informal.',
	2979);
INSERT INTO O_TFR
	VALUES (3209,
	3062,
	'dispose',
	'',
	19,
	1,
	'select one asyncMessage related by self->MSG_AM[R1019];
if(not_empty asyncMessage)
  unrelate self from asyncMessage across R1019;
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (3210,
	3062,
	'get_name',
	'',
	322,
	1,
	'return "Informal Message";',
	1,
	'',
	3209);
INSERT INTO O_REF
	VALUES (3062,
	3052,
	0,
	3060,
	3058,
	3063,
	3059,
	3211,
	3212,
	0,
	0,
	'',
	'Asynchronous Message',
	'Msg_ID',
	'R1019');
INSERT INTO O_RATTR
	VALUES (3211,
	3062,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (3211,
	3062,
	0,
	'Msg_ID',
	'',
	'',
	'Msg_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3062);
INSERT INTO O_OIDA
	VALUES (3211,
	3062,
	0,
	'Msg_ID');
INSERT INTO O_ID
	VALUES (1,
	3062);
INSERT INTO O_ID
	VALUES (2,
	3062);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3034,
	'Informal Argument',
	1016,
	'MSG_IA',
	'This class is responsible for representing the fact that a message argument
is informal.',
	2979);
INSERT INTO O_TFR
	VALUES (3213,
	3034,
	'get_name',
	'',
	322,
	1,
	'select one arg related by self->MSG_A[R1013];
return arg.Label;',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (3034,
	2995,
	0,
	3025,
	3023,
	3035,
	3024,
	3214,
	3215,
	0,
	0,
	'',
	'Message Argument',
	'Arg_ID',
	'R1013');
INSERT INTO O_RATTR
	VALUES (3214,
	3034,
	3025,
	2995,
	1,
	'Arg_ID');
INSERT INTO O_ATTR
	VALUES (3214,
	3034,
	0,
	'Arg_ID',
	'',
	'',
	'Arg_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3034);
INSERT INTO O_OIDA
	VALUES (3214,
	3034,
	0,
	'Arg_ID');
INSERT INTO O_ID
	VALUES (1,
	3034);
INSERT INTO O_ID
	VALUES (2,
	3034);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3012,
	'Function Message',
	1005,
	'MSG_F',
	'This class manages the formality between a message and its formal couterpart
model element.',
	2979);
INSERT INTO O_TFR
	VALUES (3216,
	3012,
	'dispose',
	'',
	19,
	1,
	'select one func related by self->S_SYNC[R1010];
if(not_empty func)
  unrelate self from func across R1010;
end if;
select one sm related by self->MSG_SM[R1020];
if(not_empty sm)
  unrelate self from sm across R1020;
end if;
// dispose any formal arguments if still
// existant
select many arguments related by self->MSG_SM[R1020]->MSG_M[R1018]->MSG_A[R1001];
for each argument in arguments
  argument.dispose();
end for;
select one syncMessage related by self->MSG_SM[R1020];
if(not_empty syncMessage)
  unrelate self from syncMessage across R1020;
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (3217,
	3012,
	'get_name',
	'',
	322,
	1,
	'select one func related by self->S_SYNC[R1010];
return func.Name;',
	1,
	'',
	3216);
INSERT INTO O_REF
	VALUES (3012,
	3054,
	0,
	3068,
	3066,
	3069,
	3067,
	3218,
	3219,
	0,
	0,
	'',
	'Synchronous Message',
	'Msg_ID',
	'R1020');
INSERT INTO O_RATTR
	VALUES (3218,
	3012,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (3218,
	3012,
	0,
	'Msg_ID',
	'',
	'',
	'Msg_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (3012,
	8,
	0,
	11,
	3011,
	3013,
	3014,
	3220,
	3221,
	0,
	0,
	'',
	'Function',
	'Sync_ID',
	'R1010');
INSERT INTO O_RATTR
	VALUES (3220,
	3012,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (3220,
	3012,
	3218,
	'Sync_ID',
	'',
	'',
	'Sync_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3012);
INSERT INTO O_OIDA
	VALUES (3218,
	3012,
	0,
	'Msg_ID');
INSERT INTO O_ID
	VALUES (1,
	3012);
INSERT INTO O_ID
	VALUES (2,
	3012);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3030,
	'Function Argument',
	1009,
	'MSG_FA',
	'This class manages the formality between a message argument and its formal
couterpart model element.',
	2979);
INSERT INTO O_TFR
	VALUES (3222,
	3030,
	'dispose',
	'',
	19,
	1,
	'select one fparm related by self->S_SPARM[R1016];
if(not_empty fparm)
  unrelate self from fparm across R1016;
end if;
select one ma related by self->MSG_A[R1013];
if(not_empty ma)
  ma.dispose();
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (3030,
	2995,
	0,
	3025,
	3023,
	3031,
	3024,
	3223,
	3224,
	0,
	0,
	'',
	'Message Argument',
	'Arg_ID',
	'R1013');
INSERT INTO O_RATTR
	VALUES (3223,
	3030,
	3025,
	2995,
	1,
	'Arg_ID');
INSERT INTO O_ATTR
	VALUES (3223,
	3030,
	0,
	'Arg_ID',
	'',
	'',
	'Arg_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (3030,
	48,
	0,
	215,
	3044,
	3045,
	3046,
	3225,
	3226,
	0,
	0,
	'',
	'Function Parameter',
	'SParm_ID',
	'R1016');
INSERT INTO O_RATTR
	VALUES (3225,
	3030,
	215,
	48,
	1,
	'SParm_ID');
INSERT INTO O_ATTR
	VALUES (3225,
	3030,
	3223,
	'SParm_ID',
	'',
	'',
	'SParm_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3030);
INSERT INTO O_OIDA
	VALUES (3223,
	3030,
	0,
	'Arg_ID');
INSERT INTO O_ID
	VALUES (1,
	3030);
INSERT INTO O_ID
	VALUES (2,
	3030);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3036,
	'Executable Property Argument',
	1019,
	'MSG_EPA',
	'',
	2979);
INSERT INTO O_TFR
	VALUES (3227,
	3036,
	'dispose',
	'',
	19,
	1,
	'select one pp related by self->C_PP[R1023];
if not_empty pp
  unrelate self from pp across R1023;
end if;
select one ma related by self->MSG_A[R1013];
if(not_empty ma)
  ma.dispose();
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (3036,
	2995,
	0,
	3025,
	3023,
	3037,
	3024,
	3228,
	3229,
	0,
	0,
	'',
	'Message Argument',
	'Arg_ID',
	'R1013');
INSERT INTO O_RATTR
	VALUES (3228,
	3036,
	3025,
	2995,
	1,
	'Arg_ID');
INSERT INTO O_ATTR
	VALUES (3228,
	3036,
	0,
	'Arg_ID',
	'',
	'',
	'Arg_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (3036,
	57,
	0,
	254,
	3084,
	3086,
	3085,
	3230,
	3231,
	0,
	0,
	'',
	'Property Parameter',
	'PP_Id',
	'R1023');
INSERT INTO O_RATTR
	VALUES (3230,
	3036,
	254,
	57,
	1,
	'PP_Id');
INSERT INTO O_ATTR
	VALUES (3230,
	3036,
	3228,
	'PP_Id',
	'',
	'',
	'PP_Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3036);
INSERT INTO O_OIDA
	VALUES (3228,
	3036,
	0,
	'Arg_ID');
INSERT INTO O_ID
	VALUES (1,
	3036);
INSERT INTO O_ID
	VALUES (2,
	3036);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3008,
	'Event Message',
	1004,
	'MSG_E',
	'This class manages the formality between a message and its formal couterpart
model element.',
	2979);
INSERT INTO O_TFR
	VALUES (3232,
	3008,
	'dispose',
	'',
	19,
	1,
	'select one evt related by self->SM_EVT[R1009];
if(not_empty evt)
  unrelate self from evt across R1009;
end if;
select one em related by self->MSG_AM[R1019];
if(not_empty em)
  unrelate self from em across R1019;
end if;
// dispose any formal arguments if still
// existant
select many arguments related by self->MSG_AM[R1019]->MSG_M[R1018]->MSG_A[R1001];
for each argument in arguments
  argument.dispose();
end for;
select one asyncMessage related by self->MSG_AM[R1019];
if(not_empty asyncMessage)
  unrelate self from asyncMessage across R1019;
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (3233,
	3008,
	'get_name',
	'',
	322,
	1,
	'select one evt related by self->SM_EVT[R1009];
return evt.Mning;',
	1,
	'',
	3232);
INSERT INTO O_REF
	VALUES (3008,
	1488,
	0,
	1604,
	3007,
	3009,
	3010,
	3234,
	3235,
	0,
	0,
	'',
	'State Machine Event',
	'SMevt_ID',
	'R1009');
INSERT INTO O_RATTR
	VALUES (3234,
	3008,
	1604,
	1488,
	1,
	'SMevt_ID');
INSERT INTO O_ATTR
	VALUES (3234,
	3008,
	3236,
	'SMevt_ID',
	'',
	'',
	'SMevt_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (3008,
	3052,
	0,
	3060,
	3058,
	3061,
	3059,
	3236,
	3237,
	0,
	0,
	'',
	'Asynchronous Message',
	'Msg_ID',
	'R1019');
INSERT INTO O_RATTR
	VALUES (3236,
	3008,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (3236,
	3008,
	0,
	'Msg_ID',
	'',
	'',
	'Msg_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3008);
INSERT INTO O_OIDA
	VALUES (3236,
	3008,
	0,
	'Msg_ID');
INSERT INTO O_ID
	VALUES (1,
	3008);
INSERT INTO O_ID
	VALUES (2,
	3008);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3032,
	'Event Argument',
	1010,
	'MSG_EA',
	'This class manages the formality between a message argument and its formal
couterpart model element.',
	2979);
INSERT INTO O_TFR
	VALUES (3238,
	3032,
	'dispose',
	'',
	19,
	1,
	'select one evtdi related by self->SM_EVTDI[R1017];
if(not_empty evtdi)
  unrelate self from evtdi across R1017;
end if;
select one ma related by self->MSG_A[R1013];
if(not_empty ma)
  ma.dispose();
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (3032,
	2995,
	0,
	3025,
	3023,
	3033,
	3024,
	3239,
	3240,
	0,
	0,
	'',
	'Message Argument',
	'Arg_ID',
	'R1013');
INSERT INTO O_RATTR
	VALUES (3239,
	3032,
	3025,
	2995,
	1,
	'Arg_ID');
INSERT INTO O_ATTR
	VALUES (3239,
	3032,
	0,
	'Arg_ID',
	'',
	'',
	'Arg_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (3032,
	52,
	0,
	276,
	3047,
	3048,
	3049,
	3241,
	3242,
	0,
	0,
	'',
	'State Machine Event Data Item',
	'SM_ID',
	'R1017');
INSERT INTO O_RATTR
	VALUES (3241,
	3032,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (3241,
	3032,
	3239,
	'SM_ID',
	'',
	'',
	'SM_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (3032,
	52,
	0,
	277,
	3047,
	3048,
	3049,
	3243,
	3244,
	0,
	0,
	'',
	'State Machine Event Data Item',
	'SMedi_ID',
	'R1017');
INSERT INTO O_RATTR
	VALUES (3243,
	3032,
	277,
	52,
	1,
	'SMedi_ID');
INSERT INTO O_ATTR
	VALUES (3243,
	3032,
	3241,
	'SMedi_ID',
	'',
	'',
	'SMedi_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3032);
INSERT INTO O_OIDA
	VALUES (3239,
	3032,
	0,
	'Arg_ID');
INSERT INTO O_ID
	VALUES (1,
	3032);
INSERT INTO O_ID
	VALUES (2,
	3032);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3020,
	'Bridge Message',
	1003,
	'MSG_B',
	'This class manages the formality between a message and its formal couterpart
model element.',
	2979);
INSERT INTO O_TFR
	VALUES (3245,
	3020,
	'dispose',
	'',
	19,
	1,
	'select one brg related by self->S_BRG[R1012];
if(not_empty brg)
  unrelate self from brg across R1012;
end if;
select one sm related by self->MSG_SM[R1020];
if(not_empty sm)
  unrelate self from sm across R1020;
end if;
// dispose any formal arguments if still
// existant
select many arguments related by self->MSG_SM[R1020]->MSG_M[R1018]->MSG_A[R1001];
for each argument in arguments
  argument.dispose();
end for;
select one syncMessage related by self->MSG_SM[R1020];
if(not_empty syncMessage)
  unrelate self from syncMessage across R1020;
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (3246,
	3020,
	'get_name',
	'',
	322,
	1,
	'select one brg related by self->S_BRG[R1012];
return brg.Name;',
	1,
	'',
	3245);
INSERT INTO O_REF
	VALUES (3020,
	6,
	0,
	16,
	3019,
	3021,
	3022,
	3247,
	3248,
	0,
	0,
	'',
	'Bridge',
	'Brg_ID',
	'R1012');
INSERT INTO O_RATTR
	VALUES (3247,
	3020,
	16,
	6,
	1,
	'Brg_ID');
INSERT INTO O_ATTR
	VALUES (3247,
	3020,
	3249,
	'Brg_ID',
	'',
	'',
	'Brg_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (3020,
	3054,
	0,
	3068,
	3066,
	3071,
	3067,
	3249,
	3250,
	0,
	0,
	'',
	'Synchronous Message',
	'Msg_ID',
	'R1020');
INSERT INTO O_RATTR
	VALUES (3249,
	3020,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (3249,
	3020,
	0,
	'Msg_ID',
	'',
	'',
	'Msg_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3020);
INSERT INTO O_OIDA
	VALUES (3249,
	3020,
	0,
	'Msg_ID');
INSERT INTO O_ID
	VALUES (1,
	3020);
INSERT INTO O_ID
	VALUES (2,
	3020);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3026,
	'Bridge Argument',
	1007,
	'MSG_BA',
	'This class manages the formality between a message argument and its formal
couterpart model element.',
	2979);
INSERT INTO O_TFR
	VALUES (3251,
	3026,
	'dispose',
	'',
	19,
	1,
	'select one bparm related by self->S_BPARM[R1014];
if(not_empty bparm)
  unrelate self from bparm across R1014;
end if;
select one ma related by self->MSG_A[R1013];
if(not_empty ma)
  ma.dispose();
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (3026,
	2995,
	0,
	3025,
	3023,
	3027,
	3024,
	3252,
	3253,
	0,
	0,
	'',
	'Message Argument',
	'Arg_ID',
	'R1013');
INSERT INTO O_RATTR
	VALUES (3252,
	3026,
	3025,
	2995,
	1,
	'Arg_ID');
INSERT INTO O_ATTR
	VALUES (3252,
	3026,
	0,
	'Arg_ID',
	'',
	'',
	'Arg_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (3026,
	46,
	0,
	211,
	3038,
	3039,
	3040,
	3254,
	3255,
	0,
	0,
	'',
	'Bridge Parameter',
	'BParm_ID',
	'R1014');
INSERT INTO O_RATTR
	VALUES (3254,
	3026,
	211,
	46,
	1,
	'BParm_ID');
INSERT INTO O_ATTR
	VALUES (3254,
	3026,
	3252,
	'BParm_ID',
	'',
	'',
	'BParm_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3026);
INSERT INTO O_OIDA
	VALUES (3252,
	3026,
	0,
	'Arg_ID');
INSERT INTO O_ID
	VALUES (1,
	3026);
INSERT INTO O_ID
	VALUES (2,
	3026);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3052,
	'Asynchronous Message',
	1013,
	'MSG_AM',
	'This subclass represents, and holds its unique data, an asynchronous message.
The types of asynchronous messages are:

Informal Asynchronous Message
Event Message',
	2979);
INSERT INTO O_TFR
	VALUES (3256,
	3052,
	'dispose',
	'',
	19,
	1,
	'// dispose any formal asych messages
select one em related by self->MSG_E[R1019];
if(not_empty em)
  unrelate self from em across R1019;
  em.dispose();
end if;
// dispose any informal asynch messages
select one im related by self->MSG_IAM[R1019];
if(not_empty im)
  unrelate self from im across R1019;
  im.dispose();
end if;
select one sigMsg related by self->MSG_SIG[R1019];
if not_empty sigMsg
  unrelate self from sigMsg across R1019;
  sigMsg.dispose();
end if;
// delete supertype, and unrelate
select one msg related by self->MSG_M[R1018];
if(not_empty msg)
  unrelate self from msg across R1018;
  msg.dispose();
end if;
delete object instance self;',
	1,
	'',
	3257);
INSERT INTO O_TFR
	VALUES (3258,
	3052,
	'unformalize',
	'',
	19,
	1,
	'// dispose the associated event message
select one em related by self->MSG_E[R1019];
select one sigMsg related by self->MSG_SIG[R1019];
if(not_empty em)
  em.dispose();
elif not_empty sigMsg
  sigMsg.dispose();
end if;
// unrelate from target element if under a communication
select one message related by self->MSG_M[R1018];
message.deassociateFromTarget();
self.disposeFormalArguments();
// create an informal asych message
create object instance im of MSG_IAM;
relate im to self across R1019;',
	1,
	'',
	3259);
INSERT INTO O_TFR
	VALUES (3260,
	3052,
	'initialize',
	'',
	19,
	1,
	'self.InformalName = "Informal Message";
// create informal subtype
create object instance im of MSG_IAM;
relate im to self across R1019;',
	1,
	'',
	3261);
INSERT INTO O_TFR
	VALUES (3262,
	3052,
	'newArgument',
	'',
	19,
	1,
	'// have the supertype create the argument
select one msg related by self->MSG_M[R1018];
if(not_empty msg)
  msg.newArgument();
end if;',
	1,
	'',
	3260);
INSERT INTO O_TFR
	VALUES (3257,
	3052,
	'canRename',
	'',
	316,
	1,
	'// only informal messages can be renamed
select one im related by self->MSG_IAM[R1019];
if(not_empty im)
  return true;
else
  return false;
end if;',
	1,
	'',
	3263);
INSERT INTO O_TFR
	VALUES (3264,
	3052,
	'get_name',
	'',
	322,
	1,
	'return self.Label;',
	1,
	'',
	3265);
INSERT INTO O_TFR
	VALUES (3261,
	3052,
	'get_style',
	'',
	784,
	1,
	'if(param.at == End::End)
  return Style::OpenArrow;
else
  return Style::Solid;
end if;',
	1,
	'',
	3266);
INSERT INTO O_TPARM
	VALUES (3267,
	3261,
	'at',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3265,
	3052,
	'get_connector_text',
	'',
	322,
	1,
	'if(param.at == End::Middle)
  result = self.Label;
  select many args related by self->MSG_M[R1018]->MSG_A[R1001];
  if(not self.isFormal)
    select many args related by self->MSG_M[R1018]->MSG_A[R1000];
  end if;
  if(not_empty args)
    result = result + " (";
    count = 0;
    for each arg in args
      count = count + 1;
      result = result + arg.Label;
      if(count != cardinality args)
        result = result + ", ";
      end if;
    end for;  
    result = result + ")";
  end if;
  if(self.DurationObservation != "")
    result = result  + "  " + self.DurationObservation;
  end if;
  if(self.SequenceNumb != "")
    if(result != "")
      result = ": " + result;
    end if;
    result = self.SequenceNumb + result;
  end if;
  return result;
elif(param.at == End::Start)
  if(self.GuardCondition != "")
    return "[" + self.GuardCondition + "]";
  end if;
  return "";
elif(param.at == End::End)
  if(self.DurationConstraint != "")
    return "{" + self.DurationConstraint + "}";
  else
    return "";
  end if;
else
  return "";
end if;',
	1,
	'',
	3268);
INSERT INTO O_TPARM
	VALUES (3269,
	3265,
	'Obj_ID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (3270,
	3265,
	'Obj_TypeIsImported',
	316,
	0,
	'',
	3269,
	'');
INSERT INTO O_TPARM
	VALUES (3271,
	3265,
	'at',
	880,
	0,
	'',
	3270,
	'');
INSERT INTO O_TPARM
	VALUES (3272,
	3265,
	'parent_ID',
	296,
	0,
	'',
	3271,
	'');
INSERT INTO O_TFR
	VALUES (3263,
	3052,
	'actionFilter',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.

if(param.name == "can")
  select one packageableElem related by self->MSG_M[R1018]->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one message related by self->MSG_M[R1018];
  if(empty package and message.participatesInCommunication)
    select one package related by self->MSG_M[R1018]->SQ_P[R1007]->PE_PE[R8001]
                                                                ->EP_PKG[R8000];
  end if;
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = not_empty package or not_empty component;
  
  if(param.value == "addArg")
    return not self.isFormal;
  elif(param.value == "unform")
    return self.isFormal;
  elif(param.value == "formInstClassEvent")
    select one cip related by self->MSG_M[R1018]->SQ_P[R1007]->SQ_CIP[R930];
    if(not_empty cip)
      // do not allow if on a communication
      select one communication related by cip->SQ_P[R930]->COMM_PIC[R1126]->COMM_COMM[R1126];
      if(not_empty communication or message.participatesInCommunication)
        return false;
      else
        // if there is only one possible event, and we are formal
        // do not allow
        if(self.isFormal)
          if(cip.getClassEventCount() == 1)
            return false;
          end if;
        end if;
        return cip.formalClassHasCBEvents(checkForCreationEvents:true);
      end if;
    end if;
  elif(param.value == "formClassEvent")
    select one cp related by self->MSG_M[R1018]->SQ_P[R1007]->SQ_CP[R930];
    if(empty cp)
      // try the communication line
      select one cp related by self->MSG_M[R1018]->SQ_P[R1007]->SQ_LS[R930]
                                                      ->SQ_P[R940]->SQ_CP[R930];
    end if;
    if(not_empty cp)
      select one communication related by cp->SQ_P[R930]->COMM_PIC[R1126]
                                                             ->COMM_COMM[R1126];
      if(not_empty communication or message.participatesInCommunication)
        return false;
      end if;
      // if there is only one possible event, and we are formal
      // do not allow
      if(self.isFormal)
        if(cp.getClassEventCount() == 1)
          return false;
        end if;
      end if;
      return cp.formalClassHasCBEvents();
    end if;
  elif(param.value == "formInstEvent")
    select one ls related by self->MSG_M[R1018]->SQ_P[R1007]->SQ_LS[R930];
    if (not_empty ls)
      select one cip related by ls->SQ_P[R940]->SQ_CIP[R930];
      if(not_empty cip)
        // if there is only one possible event, and we are formal
        // do not allow
        if(self.isFormal)
          if(cip.getInstanceEventCount() == 1)
            return false;
          end if;
        end if;
        return cip.formalClassHasIBEvents();
      end if;  // not_empty cip
    end if; // not_empty ls
  elif(param.value == "formSig")  
    // if there is only one possible interface operation and we are
    // already using it then do not show the menu
    select one signal related by self->MSG_SIG[R1019]->C_AS[R1021];
    if(not_empty signal)
      select one cop related by self->MSG_M[R1018]->SQ_P[R1007]->SQ_COP[R930];
      if(empty cop)
        select one cop related by self->MSG_M[R1018]->SQ_P[R1007]->SQ_LS[R930]
                                                     ->SQ_P[R940]->SQ_COP[R930];
      end if;
      if(not_empty cop)
        if(cop.getInterfaceSignalCount() == 1)
          return false;
        end if;
      end if;
    end if;
  
    select one cop related by self->MSG_M[R1018]->SQ_P[R1007]->SQ_COP[R930];
    if(empty cop)
      select one cop related by self->MSG_M[R1018]->SQ_P[R1007]->SQ_LS[R930]
                                                     ->SQ_P[R940]->SQ_COP[R930];
    end if;
    if(not_empty cop)
      select one communication related by cop->SQ_P[R930]->COMM_PIC[R1126]
                                                             ->COMM_COMM[R1126];
      // if on communication do not allow, other filters will handle
      // this
      if(not_empty communication or message.participatesInCommunication)
        return false;
      end if;
      return cop.isFormalAndHasSignals();
    end if;
  // the following filtering is used for the communication diagram
  elif(param.value == "formCommClassEvent") or (param.value == "formCommMsgSig")
                                         or (param.value == "formCommInstEvent") 
    pkgID = GD::NULL_UNIQUE_ID();
    // if this message is not shown on a communication diagram
    // do not allow
    select one communication related by self->MSG_M[R1018]->COMM_MIC[R1135]->COMM_COMM[R1135];
    if(empty communication)
      // if the above association is not setup, the message is associated with
      // a participant already, get the communication through this participant
      select one communication related by self->MSG_M[R1018]->SQ_P[R1007]->COMM_PIC[R1126]->COMM_COMM[R1126];
      if (empty communication and not message.participatesInCommunication)
        return false;
      end if;
    end if;
    if (not_empty communication)
      pkgID = communication.Package_ID;
    else
      pkgID = package.Package_ID;
    end if;
    // if the selection count does not equal two return false, this
    // prevents the menu entries from existing while only one of the
    // elements is selected
    if(Sel::getCurrentSelectionCount() != 2)
      return false;
    end if;
    // if the selection does not contain a participant
    // do not allow
    if(not Util::selectionContainsValidParticipant(from:Util::getCommunicationInstance(id:pkgID)))
      return false;
    end if;
    // additionally check if this message is already formalized
    // to the only available operation
    if(self.isFormal)
      select one participant related by self->MSG_M[R1018]->SQ_P[R1007];
      if(param.value == "formCommClassEvent")
        select one cp related by participant->SQ_CP[R930];
        if(not_empty cp)
          if(cp.getClassEventCount() == 1)
            return false;
          end if;
        end if;
      elif(param.value == "formCommInstEvent")
        select one cip related by participant->SQ_CIP[R930];
        if(not_empty cip)
          if(cip.getInstanceEventCount() == 1)
            return false;
          end if;
        end if;
      elif(param.value == "formCommMsgSig")
        select one cop related by participant->SQ_COP[R930];
        if(not_empty cop)
          if(cop.getInterfaceSignalCount() == 1)
            return false;
          end if;
        end if;
      end if;
    end if;
    return true;
  end if;
elif(param.name == "show")
  if(param.value == "noTargetMessage")
    if(Sel::getCurrentSelectionCount() != 1)
      return false;
    end if;
    select one target related by self->MSG_M[R1018]->SQ_P[R1007];
    return empty target;
  end if;
end if;
return false;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (3273,
	3263,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (3274,
	3263,
	'value',
	322,
	0,
	'',
	3273,
	'');
INSERT INTO O_TFR
	VALUES (3266,
	3052,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Msg_ID;',
	1,
	'',
	3264);
INSERT INTO O_TFR
	VALUES (3275,
	3052,
	'disposeFormalArguments',
	'',
	19,
	1,
	'select one parent related by self->MSG_M[R1018];
parent.disposeFormalArguments();',
	1,
	'',
	3256);
INSERT INTO O_TFR
	VALUES (3268,
	3052,
	'formalizeWithEvent',
	'',
	19,
	1,
	'select any event from instances of SM_EVT where (selected.SMevt_ID == param.eventId);
self.prepareForFormalization();
create object instance em of MSG_E;
relate em to self across R1019;
relate em to event across R1009;
select one message related by self->MSG_M[R1018];
// create a message argument for every data item
// assigned to this event
select many evtdis related by event->SM_EVTDI[R532];
for each evtdi in evtdis
  create object instance arg of MSG_A;
  create object instance earg of MSG_EA;
  relate arg to message across R1001;
  relate earg to arg across R1013;
  relate earg to evtdi across R1017;
  arg.Value = "";
end for;  
',
	1,
	'',
	3275);
INSERT INTO O_TPARM
	VALUES (3276,
	3268,
	'eventId',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3259,
	3052,
	'prepareForFormalization',
	'',
	19,
	1,
	'select one eem related by self->MSG_E[R1019];
select one im related by self->MSG_IAM[R1019];
select one sig related by self->MSG_SIG[R1019];
select one message related by self->MSG_M[R1018];
if(not_empty im)
  unrelate im from self across R1019;
  im.dispose();
elif(not_empty eem)
  unrelate eem from self across R1019;
  eem.dispose();
  message.disposeFormalArguments();
elif not_empty sig
  unrelate self from sig across R1019;
  sig.dispose();
  message.disposeFormalArguments();
end if;

',
	1,
	'',
	3262);
INSERT INTO O_TFR
	VALUES (3277,
	3052,
	'formalizeWithSignal',
	'',
	19,
	1,
	'select any sigProp from instances of C_EP where selected.Id == param.signalId;
if not_empty sigProp
  select one sig related by sigProp->C_AS[R4004];
  if not_empty sig
    self.prepareForFormalization();
    create object instance sigM of MSG_SIG;
    relate sigM to self across R1019;
    relate sigM to sig across R1021;
    select one message related by self->MSG_M[R1018];
    // create a message argument for every parameter
    // assigned to this signal
    select many parms related by sigProp->C_PP[R4006];
    for each parm in parms
      create object instance arg of MSG_A;
      create object instance eparg of MSG_EPA;
      relate arg to message across R1001;
      relate eparg to arg across R1013;
      relate eparg to parm across R1023;
      arg.Value = "";
    end for;
  end if;
end if;
',
	1,
	'',
	3258);
INSERT INTO O_TPARM
	VALUES (3278,
	3277,
	'signalId',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3279,
	3052,
	'canFormalizeUsingInterfaceSignal',
	'',
	316,
	1,
	'/**
 *  Filter operation when choosing which interface signal can be used
 *  to formalize this asynchronous message
 */

// Check that we are not already formalized to the given interface
// signal
select one currentSignal related by self->MSG_SIG[R1019]->C_AS[R1021];
if(not_empty currentSignal and param.id == currentSignal.Id)
  return false;
end if;
return true;',
	1,
	'',
	3277);
INSERT INTO O_TPARM
	VALUES (3280,
	3279,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3281,
	3052,
	'pasteMessageArgument',
	'',
	19,
	1,
	'select one message related by self->MSG_M[R1018];
message.pasteMessageArgument(id:param.id);',
	1,
	'',
	3279);
INSERT INTO O_TPARM
	VALUES (3282,
	3281,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3283,
	3052,
	'canCopyMessageArgument',
	'',
	316,
	1,
	'select one message related by self->MSG_M[R1018];
return message.canCopyMessageArgument(id:param.id);',
	1,
	'',
	3281);
INSERT INTO O_TPARM
	VALUES (3284,
	3283,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3285,
	3052,
	'canPasteMessageArgument',
	'',
	316,
	1,
	'return not self.isFormal;',
	1,
	'',
	3283);
INSERT INTO O_NBATTR
	VALUES (3286,
	3052);
INSERT INTO O_BATTR
	VALUES (3286,
	3052);
INSERT INTO O_ATTR
	VALUES (3286,
	3052,
	3287,
	'GuardCondition',
	'Full Name: Guard Condition',
	'',
	'GuardCondition',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3287,
	3052);
INSERT INTO O_BATTR
	VALUES (3287,
	3052);
INSERT INTO O_ATTR
	VALUES (3287,
	3052,
	3288,
	'Descrip',
	'Full Name: Message Description',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (3289,
	3052,
	'select one iam related by self->MSG_IAM[R1019];
if(not_empty iam)
  self.isFormal = false;
else
  self.isFormal = true;
end if;',
	1);
INSERT INTO O_BATTR
	VALUES (3289,
	3052);
INSERT INTO O_ATTR
	VALUES (3289,
	3052,
	3290,
	'isFormal',
	'Full Name: Is Formal',
	'',
	'isFormal',
	0,
	316,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3290,
	3052);
INSERT INTO O_BATTR
	VALUES (3290,
	3052);
INSERT INTO O_ATTR
	VALUES (3290,
	3052,
	3291,
	'DurationConstraint',
	'Full Name: Duration Constraint',
	'',
	'DurationConstraint',
	0,
	322,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (3292,
	3052,
	'result = "";
select one em related by self->MSG_E[R1019];
select one sigMsg related by self->MSG_SIG[R1019];
if(not_empty em)
  select one evt related by em->SM_EVT[R1009];
  result = evt.Drv_Lbl + ": " + evt.Mning;
elif not_empty sigMsg
  select one signal related by sigMsg->C_AS[R1021];
  result = signal.Name;
else
  result = self.InformalName;
end if;
self.Label = result;',
	1);
INSERT INTO O_BATTR
	VALUES (3292,
	3052);
INSERT INTO O_ATTR
	VALUES (3292,
	3052,
	3289,
	'Label',
	'User_Visible: false',
	'',
	'Label',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3291,
	3052);
INSERT INTO O_BATTR
	VALUES (3291,
	3052);
INSERT INTO O_ATTR
	VALUES (3291,
	3052,
	3286,
	'DurationObservation',
	'Full Name: Duration Observation',
	'',
	'DurationObservation',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3288,
	3052);
INSERT INTO O_BATTR
	VALUES (3288,
	3052);
INSERT INTO O_ATTR
	VALUES (3288,
	3052,
	3060,
	'InformalName',
	'Full Name: Informal Name',
	'',
	'InformalName',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3293,
	3052);
INSERT INTO O_BATTR
	VALUES (3293,
	3052);
INSERT INTO O_ATTR
	VALUES (3293,
	3052,
	3292,
	'SequenceNumb',
	'Full Name: Sequence Number',
	'',
	'SequenceNumb',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (3052,
	2141,
	0,
	2177,
	3050,
	3053,
	3051,
	3060,
	3294,
	0,
	0,
	'',
	'Message',
	'Msg_ID',
	'R1018');
INSERT INTO O_RATTR
	VALUES (3060,
	3052,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (3060,
	3052,
	0,
	'Msg_ID',
	'',
	'',
	'Msg_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3052);
INSERT INTO O_OIDA
	VALUES (3060,
	3052,
	0,
	'Msg_ID');
INSERT INTO O_ID
	VALUES (1,
	3052);
INSERT INTO O_ID
	VALUES (2,
	3052);
-- BP 7.1 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (3295,
	'Invocation',
	'This subsystem captures the concepts of call and return. It covers
calls to operations, bridges and functions and includes the return
statement.
Notify_Changes:false
Persistent:false
// This is used by schema_gen to ignore this subsystem (for publication)
TRANSLATE_FOR_EXTERNAL_USE:FALSE
',
	'ACT',
	600,
	1,
	3296);
INSERT INTO S_SID
	VALUES (1,
	3295);
INSERT INTO O_IOBJ
	VALUES (3297,
	129,
	5,
	3295,
	'Variable',
	'V_VAR');
INSERT INTO O_IOBJ
	VALUES (3298,
	68,
	5,
	3295,
	'Actual Parameter',
	'V_PAR');
INSERT INTO O_IOBJ
	VALUES (3299,
	70,
	5,
	3295,
	'Value',
	'V_VAL');
INSERT INTO O_IOBJ
	VALUES (3300,
	43,
	5,
	3295,
	'Operation',
	'O_TFR');
INSERT INTO O_IOBJ
	VALUES (3301,
	6,
	5,
	3295,
	'Bridge',
	'S_BRG');
INSERT INTO O_IOBJ
	VALUES (3302,
	8,
	5,
	3295,
	'Function',
	'S_SYNC');
INSERT INTO O_IOBJ
	VALUES (3303,
	1483,
	0,
	3295,
	'Provided Signal',
	'SPR_PS');
INSERT INTO O_IOBJ
	VALUES (3304,
	1485,
	0,
	3295,
	'Required Signal',
	'SPR_RS');
INSERT INTO O_IOBJ
	VALUES (3305,
	3306,
	0,
	3295,
	'Provided Operation',
	'SPR_PO');
INSERT INTO O_IOBJ
	VALUES (3307,
	3308,
	0,
	3295,
	'Required Operation',
	'SPR_RO');
INSERT INTO R_SIMP
	VALUES (3309);
INSERT INTO R_REL
	VALUES (3309,
	668,
	'',
	3295);
INSERT INTO R_FORM
	VALUES (3310,
	3309,
	3311,
	0,
	1,
	'returned by');
INSERT INTO R_RGO
	VALUES (3310,
	3309,
	3311);
INSERT INTO R_OIR
	VALUES (3310,
	3309,
	3311,
	0);
INSERT INTO R_PART
	VALUES (70,
	3309,
	3312,
	0,
	1,
	'has');
INSERT INTO O_RTIDA
	VALUES (72,
	70,
	0,
	3309,
	3312);
INSERT INTO R_RTO
	VALUES (70,
	3309,
	3312,
	0);
INSERT INTO R_OIR
	VALUES (70,
	3309,
	3312,
	3299);
INSERT INTO R_SIMP
	VALUES (663);
INSERT INTO R_REL
	VALUES (663,
	669,
	'',
	3295);
INSERT INTO R_PART
	VALUES (661,
	663,
	665,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (662,
	661,
	0,
	663,
	665);
INSERT INTO R_RTO
	VALUES (661,
	663,
	665,
	0);
INSERT INTO R_OIR
	VALUES (661,
	663,
	665,
	0);
INSERT INTO R_FORM
	VALUES (68,
	663,
	664,
	1,
	1,
	'takes');
INSERT INTO R_RGO
	VALUES (68,
	663,
	664);
INSERT INTO R_OIR
	VALUES (68,
	663,
	664,
	3298);
INSERT INTO R_SIMP
	VALUES (657);
INSERT INTO R_REL
	VALUES (657,
	628,
	'',
	3295);
INSERT INTO R_PART
	VALUES (655,
	657,
	659,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (656,
	655,
	0,
	657,
	659);
INSERT INTO R_RTO
	VALUES (655,
	657,
	659,
	0);
INSERT INTO R_OIR
	VALUES (655,
	657,
	659,
	0);
INSERT INTO R_FORM
	VALUES (68,
	657,
	658,
	1,
	1,
	'takes');
INSERT INTO R_RGO
	VALUES (68,
	657,
	658);
INSERT INTO R_OIR
	VALUES (68,
	657,
	658,
	3298);
INSERT INTO R_SIMP
	VALUES (650);
INSERT INTO R_REL
	VALUES (650,
	627,
	'',
	3295);
INSERT INTO R_PART
	VALUES (648,
	650,
	652,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (649,
	648,
	0,
	650,
	652);
INSERT INTO R_RTO
	VALUES (648,
	650,
	652,
	0);
INSERT INTO R_OIR
	VALUES (648,
	650,
	652,
	0);
INSERT INTO R_FORM
	VALUES (68,
	650,
	651,
	1,
	1,
	'takes');
INSERT INTO R_RGO
	VALUES (68,
	650,
	651);
INSERT INTO R_OIR
	VALUES (68,
	650,
	651,
	3298);
INSERT INTO R_SIMP
	VALUES (3313);
INSERT INTO R_REL
	VALUES (3313,
	667,
	'',
	3295);
INSERT INTO R_FORM
	VALUES (648,
	3313,
	3314,
	1,
	1,
	'is target of');
INSERT INTO R_RGO
	VALUES (648,
	3313,
	3314);
INSERT INTO R_OIR
	VALUES (648,
	3313,
	3314,
	0);
INSERT INTO R_PART
	VALUES (129,
	3313,
	3315,
	0,
	1,
	'has target');
INSERT INTO O_RTIDA
	VALUES (131,
	129,
	0,
	3313,
	3315);
INSERT INTO R_RTO
	VALUES (129,
	3313,
	3315,
	0);
INSERT INTO R_OIR
	VALUES (129,
	3313,
	3315,
	3297);
INSERT INTO R_SIMP
	VALUES (3316);
INSERT INTO R_REL
	VALUES (3316,
	673,
	'',
	3295);
INSERT INTO R_FORM
	VALUES (648,
	3316,
	3317,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (648,
	3316,
	3317);
INSERT INTO R_OIR
	VALUES (648,
	3316,
	3317,
	0);
INSERT INTO R_PART
	VALUES (43,
	3316,
	3318,
	0,
	1,
	'is an invocation of');
INSERT INTO O_RTIDA
	VALUES (201,
	43,
	0,
	3316,
	3318);
INSERT INTO R_RTO
	VALUES (43,
	3316,
	3318,
	0);
INSERT INTO R_OIR
	VALUES (43,
	3316,
	3318,
	3300);
INSERT INTO R_SIMP
	VALUES (3319);
INSERT INTO R_REL
	VALUES (3319,
	674,
	'',
	3295);
INSERT INTO R_FORM
	VALUES (655,
	3319,
	3320,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (655,
	3319,
	3320);
INSERT INTO R_OIR
	VALUES (655,
	3319,
	3320,
	0);
INSERT INTO R_PART
	VALUES (6,
	3319,
	3321,
	0,
	1,
	'is an invocation of');
INSERT INTO O_RTIDA
	VALUES (16,
	6,
	0,
	3319,
	3321);
INSERT INTO R_RTO
	VALUES (6,
	3319,
	3321,
	0);
INSERT INTO R_OIR
	VALUES (6,
	3319,
	3321,
	3301);
INSERT INTO R_SIMP
	VALUES (3322);
INSERT INTO R_REL
	VALUES (3322,
	675,
	'',
	3295);
INSERT INTO R_FORM
	VALUES (661,
	3322,
	3323,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (661,
	3322,
	3323);
INSERT INTO R_OIR
	VALUES (661,
	3322,
	3323,
	0);
INSERT INTO R_PART
	VALUES (8,
	3322,
	3324,
	0,
	1,
	'is an invocation of');
INSERT INTO O_RTIDA
	VALUES (11,
	8,
	0,
	3322,
	3324);
INSERT INTO R_RTO
	VALUES (8,
	3322,
	3324,
	0);
INSERT INTO R_OIR
	VALUES (8,
	3322,
	3324,
	3302);
INSERT INTO R_SIMP
	VALUES (675);
INSERT INTO R_REL
	VALUES (675,
	679,
	'',
	3295);
INSERT INTO R_FORM
	VALUES (68,
	675,
	676,
	1,
	1,
	'takes');
INSERT INTO R_RGO
	VALUES (68,
	675,
	676);
INSERT INTO R_OIR
	VALUES (68,
	675,
	676,
	3298);
INSERT INTO R_PART
	VALUES (673,
	675,
	677,
	0,
	1,
	'taken by');
INSERT INTO O_RTIDA
	VALUES (674,
	673,
	0,
	675,
	677);
INSERT INTO R_RTO
	VALUES (673,
	675,
	677,
	0);
INSERT INTO R_OIR
	VALUES (673,
	675,
	677,
	0);
INSERT INTO R_SIMP
	VALUES (681);
INSERT INTO R_REL
	VALUES (681,
	662,
	'',
	3295);
INSERT INTO R_FORM
	VALUES (68,
	681,
	682,
	1,
	1,
	'takes');
INSERT INTO R_RGO
	VALUES (68,
	681,
	682);
INSERT INTO R_OIR
	VALUES (68,
	681,
	682,
	3298);
INSERT INTO R_PART
	VALUES (679,
	681,
	683,
	0,
	1,
	'taken by');
INSERT INTO O_RTIDA
	VALUES (680,
	679,
	0,
	681,
	683);
INSERT INTO R_RTO
	VALUES (679,
	681,
	683,
	0);
INSERT INTO R_OIR
	VALUES (679,
	681,
	683,
	0);
INSERT INTO R_SIMP
	VALUES (3325);
INSERT INTO R_REL
	VALUES (3325,
	663,
	'',
	3295);
INSERT INTO R_FORM
	VALUES (679,
	3325,
	3326,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (679,
	3325,
	3326);
INSERT INTO R_OIR
	VALUES (679,
	3325,
	3326,
	0);
INSERT INTO R_PART
	VALUES (1483,
	3325,
	3327,
	0,
	1,
	'is invocation of');
INSERT INTO O_RTIDA
	VALUES (1637,
	1483,
	0,
	3325,
	3327);
INSERT INTO R_RTO
	VALUES (1483,
	3325,
	3327,
	0);
INSERT INTO R_OIR
	VALUES (1483,
	3325,
	3327,
	3303);
INSERT INTO R_SIMP
	VALUES (3328);
INSERT INTO R_REL
	VALUES (3328,
	660,
	'',
	3295);
INSERT INTO R_FORM
	VALUES (679,
	3328,
	3329,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (679,
	3328,
	3329);
INSERT INTO R_OIR
	VALUES (679,
	3328,
	3329,
	0);
INSERT INTO R_PART
	VALUES (1485,
	3328,
	3330,
	0,
	1,
	'is invocation of');
INSERT INTO O_RTIDA
	VALUES (1641,
	1485,
	0,
	3328,
	3330);
INSERT INTO R_RTO
	VALUES (1485,
	3328,
	3330,
	0);
INSERT INTO R_OIR
	VALUES (1485,
	3328,
	3330,
	3304);
INSERT INTO R_SIMP
	VALUES (3331);
INSERT INTO R_REL
	VALUES (3331,
	680,
	'',
	3295);
INSERT INTO R_FORM
	VALUES (673,
	3331,
	3332,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (673,
	3331,
	3332);
INSERT INTO R_OIR
	VALUES (673,
	3331,
	3332,
	0);
INSERT INTO R_PART
	VALUES (3306,
	3331,
	3333,
	0,
	1,
	'is invocation of');
INSERT INTO O_RTIDA
	VALUES (3334,
	3306,
	0,
	3331,
	3333);
INSERT INTO R_RTO
	VALUES (3306,
	3331,
	3333,
	0);
INSERT INTO R_OIR
	VALUES (3306,
	3331,
	3333,
	3305);
INSERT INTO R_SIMP
	VALUES (3335);
INSERT INTO R_REL
	VALUES (3335,
	657,
	'',
	3295);
INSERT INTO R_PART
	VALUES (3308,
	3335,
	3336,
	0,
	1,
	'is invocation of');
INSERT INTO O_RTIDA
	VALUES (3337,
	3308,
	0,
	3335,
	3336);
INSERT INTO R_RTO
	VALUES (3308,
	3335,
	3336,
	0);
INSERT INTO R_OIR
	VALUES (3308,
	3335,
	3336,
	3307);
INSERT INTO R_FORM
	VALUES (673,
	3335,
	3338,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (673,
	3335,
	3338);
INSERT INTO R_OIR
	VALUES (673,
	3335,
	3338,
	0);
INSERT INTO R_SIMP
	VALUES (3339);
INSERT INTO R_REL
	VALUES (3339,
	630,
	'',
	3295);
INSERT INTO R_FORM
	VALUES (679,
	3339,
	3340,
	1,
	1,
	'is target of');
INSERT INTO R_RGO
	VALUES (679,
	3339,
	3340);
INSERT INTO R_OIR
	VALUES (679,
	3339,
	3340,
	0);
INSERT INTO R_PART
	VALUES (70,
	3339,
	3341,
	0,
	1,
	'has target');
INSERT INTO O_RTIDA
	VALUES (72,
	70,
	0,
	3339,
	3341);
INSERT INTO R_RTO
	VALUES (70,
	3339,
	3341,
	0);
INSERT INTO R_OIR
	VALUES (70,
	3339,
	3341,
	3299);
INSERT INTO R_SIMP
	VALUES (3342);
INSERT INTO R_REL
	VALUES (3342,
	629,
	'',
	3295);
INSERT INTO R_FORM
	VALUES (673,
	3342,
	3343,
	1,
	1,
	'is target of');
INSERT INTO R_RGO
	VALUES (673,
	3342,
	3343);
INSERT INTO R_OIR
	VALUES (673,
	3342,
	3343,
	0);
INSERT INTO R_PART
	VALUES (70,
	3342,
	3344,
	0,
	1,
	'has target');
INSERT INTO O_RTIDA
	VALUES (72,
	70,
	0,
	3342,
	3344);
INSERT INTO R_RTO
	VALUES (70,
	3342,
	3344,
	0);
INSERT INTO R_OIR
	VALUES (70,
	3342,
	3344,
	3299);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (679,
	'Signal Invocation',
	627,
	'ACT_SGN',
	'',
	3295);
INSERT INTO O_TFR
	VALUES (3345,
	679,
	'dispose',
	'',
	19,
	1,
	'// Signal Invocation.dispose()
select one reqSig related by self->SPR_RS[R660];
if not_empty reqSig
  unrelate self from reqSig across R660;
end if;
select one proSig related by self->SPR_PS[R663];
if(not_empty proSig)
  unrelate self from proSig across R663;
end if;
select many parm_set related by self->V_PAR[R662];
for each parm in parm_set 
  unrelate self from parm across R662;
  parm.dispose();
end for;
select one targetVal related by self->V_VAL[R630];
if not_empty targetVal
  unrelate self from targetVal across R630;
  targetVal.dispose();
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (3346,
	679,
	'execute',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	3345);
INSERT INTO O_TPARM
	VALUES (3347,
	3346,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3348,
	679,
	'setupParameterValues',
	'',
	316,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return false;',
	1,
	'',
	3346);
INSERT INTO O_TPARM
	VALUES (3349,
	3348,
	'stack_frame_id',
	296,
	0,
	'',
	3350,
	'');
INSERT INTO O_TPARM
	VALUES (3351,
	3348,
	'ee_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (3350,
	3348,
	'event_inst_id',
	296,
	0,
	'',
	3351,
	'');
INSERT INTO O_TPARM
	VALUES (3352,
	3348,
	'executeRemotely',
	316,
	0,
	'',
	3349,
	'');
INSERT INTO O_TPARM
	VALUES (3353,
	3348,
	'channel_id',
	296,
	0,
	'',
	3352,
	'');
INSERT INTO O_REF
	VALUES (679,
	686,
	0,
	685,
	2386,
	3354,
	2388,
	680,
	3355,
	0,
	0,
	'',
	'Statement',
	'Statement_ID',
	'R603');
INSERT INTO O_RATTR
	VALUES (680,
	679,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (680,
	679,
	0,
	'Statement_ID',
	'',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3356,
	679);
INSERT INTO O_BATTR
	VALUES (3356,
	679);
INSERT INTO O_ATTR
	VALUES (3356,
	679,
	680,
	'sigNameLineNumber',
	'',
	'',
	'sigNameLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3357,
	679);
INSERT INTO O_BATTR
	VALUES (3357,
	679);
INSERT INTO O_ATTR
	VALUES (3357,
	679,
	3356,
	'sigNameColumn',
	'',
	'',
	'sigNameColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3358,
	679);
INSERT INTO O_BATTR
	VALUES (3358,
	679);
INSERT INTO O_ATTR
	VALUES (3358,
	679,
	3357,
	'ownerNameLineNumber',
	'',
	'',
	'ownerNameLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3359,
	679);
INSERT INTO O_BATTR
	VALUES (3359,
	679);
INSERT INTO O_ATTR
	VALUES (3359,
	679,
	3358,
	'ownerNameColumn',
	'',
	'',
	'ownerNameColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_REF
	VALUES (679,
	1483,
	0,
	1637,
	3325,
	3326,
	3327,
	3360,
	3361,
	0,
	0,
	'',
	'Provided Signal',
	'Id',
	'R663.''is invocation of''');
INSERT INTO O_RATTR
	VALUES (3360,
	679,
	263,
	61,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (3360,
	679,
	3359,
	'ProvidedSig_Id',
	'',
	'ProvidedSig_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (679,
	1485,
	0,
	1641,
	3328,
	3329,
	3330,
	3362,
	3363,
	0,
	0,
	'',
	'Required Signal',
	'Id',
	'R660.''is invocation of''');
INSERT INTO O_RATTR
	VALUES (3362,
	679,
	267,
	63,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (3362,
	679,
	3360,
	'RequiredSig_Id',
	'',
	'RequiredSig_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (679,
	70,
	0,
	72,
	3339,
	3340,
	3341,
	3364,
	3365,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R630.''has target''');
INSERT INTO O_RATTR
	VALUES (3364,
	679,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (3364,
	679,
	3362,
	'Value_ID',
	'',
	'',
	'Value_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	679);
INSERT INTO O_OIDA
	VALUES (680,
	679,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	679);
INSERT INTO O_ID
	VALUES (2,
	679);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3310,
	'Return Stmt',
	624,
	'ACT_RET',
	'Represents a return statement. It has an optional relationship with a value
because returns may bear a value depending on whether the callee
returns void or not.',
	3295);
INSERT INTO O_TFR
	VALUES (3366,
	3310,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'select one val related by self->V_VAL[R668];
if ( not_empty val )
  unrelate self from val across R668;
  val.dispose();
end if;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (3367,
	3310,
	'execute',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	3366);
INSERT INTO O_TPARM
	VALUES (3368,
	3367,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (3310,
	686,
	0,
	685,
	2386,
	3369,
	2388,
	3370,
	3371,
	0,
	0,
	'',
	'Statement',
	'Statement_ID',
	'R603');
INSERT INTO O_RATTR
	VALUES (3370,
	3310,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (3370,
	3310,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (3310,
	70,
	0,
	72,
	3309,
	3311,
	3312,
	3372,
	3373,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R668.''has''');
INSERT INTO O_RATTR
	VALUES (3372,
	3310,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (3372,
	3310,
	3370,
	'Value_ID',
	'

',
	'',
	'Value_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3310);
INSERT INTO O_OIDA
	VALUES (3370,
	3310,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	3310);
INSERT INTO O_ID
	VALUES (2,
	3310);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (648,
	'Operation Invocation',
	618,
	'ACT_TFM',
	'This class represents the invocation of an operation.',
	3295);
INSERT INTO O_TFR
	VALUES (3374,
	648,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'select one tfr related by self->O_TFR[R673];
if ( not empty tfr )
  unrelate self from tfr across R673;
end if;

select one var related by self->V_VAR[R667];
if ( not_empty var )
  unrelate self from var across R667;
end if;

select many parm_set related by self->V_PAR[R627];
for each parm in parm_set 
  unrelate self from parm across R627;
  parm.dispose();
end for;

delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (3375,
	648,
	'execute',
	'',
	19,
	1,
	'//Invocation:Operation Invocation.execute()

// Execute the operation
select one body related by self->O_TFR[R673]->ACT_OPB[R696]->ACT_ACT[R698];
select any statement related by body->ACT_BLK[R601]->ACT_SMT[R602];
if (not_empty statement)
  // Setup the parameter values within the newly created stack frame
  discard = self.setupParameterValues(stack_frame_id: param.stack_frame_id);
end if;
',
	1,
	'',
	3374);
INSERT INTO O_TPARM
	VALUES (3376,
	3375,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3377,
	648,
	'setupParameterValues',
	'Initializes the parameters passing to an Operation Invocation',
	316,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return false;',
	1,
	'',
	3375);
INSERT INTO O_TPARM
	VALUES (3378,
	3377,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (648,
	686,
	0,
	685,
	2386,
	3379,
	2388,
	649,
	3380,
	0,
	0,
	'',
	'Statement',
	'Statement_ID',
	'R603');
INSERT INTO O_RATTR
	VALUES (649,
	648,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (649,
	648,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (648,
	43,
	0,
	201,
	3316,
	3317,
	3318,
	3381,
	3382,
	0,
	0,
	'',
	'Operation',
	'Tfr_ID',
	'R673.''is an invocation of''');
INSERT INTO O_RATTR
	VALUES (3381,
	648,
	201,
	43,
	1,
	'Tfr_ID');
INSERT INTO O_ATTR
	VALUES (3381,
	648,
	649,
	'Tfr_ID',
	'

',
	'',
	'Tfr_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (648,
	129,
	0,
	131,
	3313,
	3314,
	3315,
	3383,
	3384,
	0,
	0,
	'',
	'Variable',
	'Var_ID',
	'R667.''has target''');
INSERT INTO O_RATTR
	VALUES (3383,
	648,
	131,
	129,
	1,
	'Var_ID');
INSERT INTO O_ATTR
	VALUES (3383,
	648,
	3381,
	'Var_ID',
	'

',
	'',
	'Var_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3385,
	648);
INSERT INTO O_BATTR
	VALUES (3385,
	648);
INSERT INTO O_ATTR
	VALUES (3385,
	648,
	3383,
	'operationNameLineNumber',
	'',
	'',
	'operationNameLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3386,
	648);
INSERT INTO O_BATTR
	VALUES (3386,
	648);
INSERT INTO O_ATTR
	VALUES (3386,
	648,
	3385,
	'operationNameColumn',
	'',
	'',
	'operationNameColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3387,
	648);
INSERT INTO O_BATTR
	VALUES (3387,
	648);
INSERT INTO O_ATTR
	VALUES (3387,
	648,
	3386,
	'modelClassKeyLettersLineNumber',
	'',
	'',
	'modelClassKeyLettersLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3388,
	648);
INSERT INTO O_BATTR
	VALUES (3388,
	648);
INSERT INTO O_ATTR
	VALUES (3388,
	648,
	3387,
	'modelClassKeyLettersColumn',
	'',
	'',
	'modelClassKeyLettersColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	648);
INSERT INTO O_OIDA
	VALUES (649,
	648,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	648);
INSERT INTO O_ID
	VALUES (2,
	648);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (673,
	'Interface Operation Invocation',
	626,
	'ACT_IOP',
	'',
	3295);
INSERT INTO O_TFR
	VALUES (3389,
	673,
	'dispose',
	'',
	19,
	1,
	'// Interface Operation Invocation.dispose()
select one rop related by self->SPR_RO[R657];
if not_empty rop
  unrelate self from rop across R657;
end if;
select one pop related by self->SPR_PO[R680];
if(not_empty pop)
  unrelate self from pop across R680;
end if;
select many parm_set related by self->V_PAR[R679];
for each parm in parm_set 
  unrelate self from parm across R679;
  parm.dispose();
end for;
select one targetVal related by self->V_VAL[R629];
if not_empty targetVal
  unrelate self from targetVal across R629;
  targetVal.dispose();
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (3390,
	673,
	'execute',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	3389);
INSERT INTO O_TPARM
	VALUES (3391,
	3390,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3392,
	673,
	'setupParameterValues',
	'',
	316,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return false;',
	1,
	'',
	3390);
INSERT INTO O_TPARM
	VALUES (3393,
	3392,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (673,
	686,
	0,
	685,
	2386,
	3394,
	2388,
	674,
	3395,
	0,
	0,
	'',
	'Statement',
	'Statement_ID',
	'R603');
INSERT INTO O_RATTR
	VALUES (674,
	673,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (674,
	673,
	0,
	'Statement_ID',
	'',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3396,
	673);
INSERT INTO O_BATTR
	VALUES (3396,
	673);
INSERT INTO O_ATTR
	VALUES (3396,
	673,
	674,
	'opNameLineNumber',
	'',
	'',
	'opNameLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3397,
	673);
INSERT INTO O_BATTR
	VALUES (3397,
	673);
INSERT INTO O_ATTR
	VALUES (3397,
	673,
	3396,
	'opNameColumn',
	'',
	'',
	'opNameColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3398,
	673);
INSERT INTO O_BATTR
	VALUES (3398,
	673);
INSERT INTO O_ATTR
	VALUES (3398,
	673,
	3397,
	'ownerNameLineNumber',
	'',
	'',
	'ownerNameLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3399,
	673);
INSERT INTO O_BATTR
	VALUES (3399,
	673);
INSERT INTO O_ATTR
	VALUES (3399,
	673,
	3398,
	'ownerNameColumn',
	'',
	'',
	'ownerNameColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_REF
	VALUES (673,
	3306,
	0,
	3334,
	3331,
	3332,
	3333,
	3400,
	3401,
	0,
	0,
	'',
	'Provided Operation',
	'Id',
	'R680.''is invocation of''');
INSERT INTO O_RATTR
	VALUES (3400,
	673,
	263,
	61,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (3400,
	673,
	3399,
	'ProvidedOp_Id',
	'',
	'ProvidedOp_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (673,
	3308,
	0,
	3337,
	3335,
	3338,
	3336,
	3402,
	3403,
	0,
	0,
	'',
	'Required Operation',
	'Id',
	'R657.''is invocation of''');
INSERT INTO O_RATTR
	VALUES (3402,
	673,
	267,
	63,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (3402,
	673,
	3400,
	'RequiredOp_Id',
	'',
	'RequiredOp_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (673,
	70,
	0,
	72,
	3342,
	3343,
	3344,
	3404,
	3405,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R629.''has target''');
INSERT INTO O_RATTR
	VALUES (3404,
	673,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (3404,
	673,
	3402,
	'Value_ID',
	'',
	'',
	'Value_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	673);
INSERT INTO O_OIDA
	VALUES (674,
	673,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	673);
INSERT INTO O_ID
	VALUES (2,
	673);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (661,
	'Function Invocation',
	625,
	'ACT_FNC',
	'This class represents the invocation of a function.',
	3295);
INSERT INTO O_TFR
	VALUES (3406,
	661,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'select one sync related by self->S_SYNC[R675];
if ( not empty sync )
  unrelate self from sync across R675;
end if;

select many parm_set related by self->V_PAR[R669];
for each parm in parm_set 
  unrelate self from parm across R669;
  parm.dispose();
end for;

delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (3407,
	661,
	'execute',
	'',
	19,
	1,
	'//Invocation:Function Invocation.execute()
// Execute the function
select one body related by self->S_SYNC[R675]->ACT_FNB[R695]->ACT_ACT[R698];
select any statement related by body->ACT_BLK[R601]->ACT_SMT[R602];
if (not_empty statement)
  // Setup the parameter values within the newly created stack frame
  discard = self.setupParameterValues(stack_frame_id: param.stack_frame_id);
end if;
',
	1,
	'',
	3406);
INSERT INTO O_TPARM
	VALUES (3408,
	3407,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3409,
	661,
	'setupParameterValues',
	'SetupParameterValues is responsible for taking all of the actual parameter
values supplied to a function call and creating accessible local values within the
new executing stack frame.',
	316,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return false;',
	1,
	'',
	3407);
INSERT INTO O_TPARM
	VALUES (3410,
	3409,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (661,
	686,
	0,
	685,
	2386,
	3411,
	2388,
	662,
	3412,
	0,
	0,
	'',
	'Statement',
	'Statement_ID',
	'R603');
INSERT INTO O_RATTR
	VALUES (662,
	661,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (662,
	661,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3413,
	661);
INSERT INTO O_BATTR
	VALUES (3413,
	661);
INSERT INTO O_ATTR
	VALUES (3413,
	661,
	3414,
	'functionNameLineNumber',
	'',
	'',
	'functionNameLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3415,
	661);
INSERT INTO O_BATTR
	VALUES (3415,
	661);
INSERT INTO O_ATTR
	VALUES (3415,
	661,
	3413,
	'functionNameColumn',
	'',
	'',
	'functionNameColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_REF
	VALUES (661,
	8,
	0,
	11,
	3322,
	3323,
	3324,
	3414,
	3416,
	0,
	0,
	'',
	'Function',
	'Sync_ID',
	'R675.''is an invocation of''');
INSERT INTO O_RATTR
	VALUES (3414,
	661,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (3414,
	661,
	662,
	'Sync_ID',
	'',
	'',
	'Sync_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	661);
INSERT INTO O_OIDA
	VALUES (662,
	661,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	661);
INSERT INTO O_ID
	VALUES (2,
	661);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (655,
	'Bridge Invocation',
	620,
	'ACT_BRG',
	'This class represents the invocation of an External Entity Bridge.',
	3295);
INSERT INTO O_TFR
	VALUES (3417,
	655,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'select one brg related by self->S_BRG[R674];
if ( not empty brg )
  unrelate self from brg across R674;
end if;

select many parm_set related by self->V_PAR[R628];
for each parm in parm_set 
  unrelate self from parm across R628;
  parm.dispose();
end for;

delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (3418,
	655,
	'execute',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	3417);
INSERT INTO O_TPARM
	VALUES (3419,
	3418,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3420,
	655,
	'setupParameterValues',
	'Initializes the parameters passing to a bridge invocation.',
	316,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return false;',
	1,
	'',
	3418);
INSERT INTO O_TPARM
	VALUES (3421,
	3420,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (3422,
	3420,
	'target_stack_frame_id',
	296,
	0,
	'',
	3421,
	'');
INSERT INTO O_REF
	VALUES (655,
	686,
	0,
	685,
	2386,
	3423,
	2388,
	656,
	3424,
	0,
	0,
	'',
	'Statement',
	'Statement_ID',
	'R603');
INSERT INTO O_RATTR
	VALUES (656,
	655,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (656,
	655,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (655,
	6,
	0,
	16,
	3319,
	3320,
	3321,
	3425,
	3426,
	0,
	0,
	'',
	'Bridge',
	'Brg_ID',
	'R674.''is an invocation of''');
INSERT INTO O_RATTR
	VALUES (3425,
	655,
	16,
	6,
	1,
	'Brg_ID');
INSERT INTO O_ATTR
	VALUES (3425,
	655,
	656,
	'Brg_ID',
	'

',
	'',
	'Brg_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3427,
	655);
INSERT INTO O_BATTR
	VALUES (3427,
	655);
INSERT INTO O_ATTR
	VALUES (3427,
	655,
	3425,
	'bridgeNameLineNumber',
	'',
	'',
	'bridgeNameLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3428,
	655);
INSERT INTO O_BATTR
	VALUES (3428,
	655);
INSERT INTO O_ATTR
	VALUES (3428,
	655,
	3427,
	'bridgeNameColumn',
	'',
	'',
	'bridgeNameColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3429,
	655);
INSERT INTO O_BATTR
	VALUES (3429,
	655);
INSERT INTO O_ATTR
	VALUES (3429,
	655,
	3428,
	'externalEntityKeyLettersLineNumber',
	'',
	'',
	'externalEntityKeyLettersLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3430,
	655);
INSERT INTO O_BATTR
	VALUES (3430,
	655);
INSERT INTO O_ATTR
	VALUES (3430,
	655,
	3429,
	'externalEntityKeyLettersColumn',
	'',
	'',
	'externalEntityKeyLettersColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	655);
INSERT INTO O_OIDA
	VALUES (656,
	655,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	655);
INSERT INTO O_ID
	VALUES (2,
	655);
-- BP 7.1 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (3431,
	'Interface Package',
	'// This is used by schema_gen to ignore this subsystem (for publication)
TRANSLATE_FOR_EXTERNAL_USE:FALSE

The Interface Diagram subsystem captures data specific to the graphical
implementation of interfaces.',
	'IP',
	4300,
	1,
	0);
INSERT INTO S_SID
	VALUES (1,
	3431);
INSERT INTO O_IOBJ
	VALUES (3432,
	705,
	0,
	3431,
	'System Model',
	'S_SYS');
INSERT INTO O_IOBJ
	VALUES (3433,
	2809,
	0,
	3431,
	'Interface',
	'C_I');
INSERT INTO R_SIMP
	VALUES (3434);
INSERT INTO R_REL
	VALUES (3434,
	4300,
	'',
	3431);
INSERT INTO R_PART
	VALUES (3435,
	3434,
	3436,
	0,
	0,
	'can be shown in');
INSERT INTO O_RTIDA
	VALUES (3437,
	3435,
	0,
	3434,
	3436);
INSERT INTO R_RTO
	VALUES (3435,
	3434,
	3436,
	0);
INSERT INTO R_OIR
	VALUES (3435,
	3434,
	3436,
	0);
INSERT INTO R_FORM
	VALUES (3438,
	3434,
	3439,
	0,
	1,
	'may contain');
INSERT INTO R_RGO
	VALUES (3438,
	3434,
	3439);
INSERT INTO R_OIR
	VALUES (3438,
	3434,
	3439,
	0);
INSERT INTO R_SIMP
	VALUES (3440);
INSERT INTO R_REL
	VALUES (3440,
	4301,
	'',
	3431);
INSERT INTO R_PART
	VALUES (3438,
	3440,
	3441,
	0,
	1,
	'may be shown in');
INSERT INTO O_RTIDA
	VALUES (3442,
	3438,
	0,
	3440,
	3441);
INSERT INTO R_RTO
	VALUES (3438,
	3440,
	3441,
	0);
INSERT INTO R_OIR
	VALUES (3438,
	3440,
	3441,
	0);
INSERT INTO R_FORM
	VALUES (3435,
	3440,
	3443,
	1,
	1,
	'has children');
INSERT INTO R_RGO
	VALUES (3435,
	3440,
	3443);
INSERT INTO R_OIR
	VALUES (3435,
	3440,
	3443,
	0);
INSERT INTO R_SIMP
	VALUES (3444);
INSERT INTO R_REL
	VALUES (3444,
	4302,
	'',
	3431);
INSERT INTO R_PART
	VALUES (705,
	3444,
	3445,
	0,
	1,
	'may be shown in');
INSERT INTO O_RTIDA
	VALUES (754,
	705,
	0,
	3444,
	3445);
INSERT INTO R_RTO
	VALUES (705,
	3444,
	3445,
	0);
INSERT INTO R_OIR
	VALUES (705,
	3444,
	3445,
	3432);
INSERT INTO R_FORM
	VALUES (3435,
	3444,
	3446,
	1,
	1,
	'can show');
INSERT INTO R_RGO
	VALUES (3435,
	3444,
	3446);
INSERT INTO R_OIR
	VALUES (3435,
	3444,
	3446,
	0);
INSERT INTO R_SIMP
	VALUES (3447);
INSERT INTO R_REL
	VALUES (3447,
	4303,
	'',
	3431);
INSERT INTO R_PART
	VALUES (3435,
	3447,
	3448,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (3437,
	3435,
	0,
	3447,
	3448);
INSERT INTO R_RTO
	VALUES (3435,
	3447,
	3448,
	0);
INSERT INTO R_OIR
	VALUES (3435,
	3447,
	3448,
	0);
INSERT INTO R_FORM
	VALUES (2809,
	3447,
	3449,
	1,
	1,
	'contains');
INSERT INTO R_RGO
	VALUES (2809,
	3447,
	3449);
INSERT INTO R_OIR
	VALUES (2809,
	3447,
	3449,
	3433);
INSERT INTO R_SIMP
	VALUES (3450);
INSERT INTO R_REL
	VALUES (3450,
	4304,
	'CrossComponent:true',
	3431);
INSERT INTO R_PART
	VALUES (705,
	3450,
	3451,
	0,
	0,
	'');
INSERT INTO O_RTIDA
	VALUES (754,
	705,
	0,
	3450,
	3451);
INSERT INTO R_RTO
	VALUES (705,
	3450,
	3451,
	0);
INSERT INTO R_OIR
	VALUES (705,
	3450,
	3451,
	3432);
INSERT INTO R_FORM
	VALUES (3435,
	3450,
	3452,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (3435,
	3450,
	3452);
INSERT INTO R_OIR
	VALUES (3435,
	3450,
	3452,
	0);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3438,
	'Interface Package in Interface Package',
	4301,
	'IP_IPINIP',
	'',
	3431);
INSERT INTO O_REF
	VALUES (3438,
	3435,
	0,
	3437,
	3434,
	3439,
	3436,
	3442,
	3453,
	0,
	0,
	'',
	'Interface Package',
	'Package_ID',
	'R4300');
INSERT INTO O_RATTR
	VALUES (3442,
	3438,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (3442,
	3438,
	0,
	'Package_ID',
	'',
	'',
	'Package_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3438);
INSERT INTO O_OIDA
	VALUES (3442,
	3438,
	0,
	'Package_ID');
INSERT INTO O_ID
	VALUES (1,
	3438);
INSERT INTO O_ID
	VALUES (2,
	3438);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3435,
	'Interface Package',
	4300,
	'IP_IP',
	'',
	3431);
INSERT INTO O_TFR
	VALUES (3454,
	3435,
	'initialize',
	'',
	19,
	1,
	'self.Name = ::getUniqueInitialName( 
    instance: self.convertToInstance(), 
    candidateName: "Unnamed Interface Package" );',
	1,
	'',
	3455);
INSERT INTO O_TFR
	VALUES (3456,
	3435,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'return this;',
	0,
	'',
	3457);
INSERT INTO O_TFR
	VALUES (3458,
	3435,
	'get_compartment_text',
	'',
	322,
	1,
	'// The component package symbol only contains its name
// appended by the interface stereotype
result = "";
if (param.at == Justification::Center_in_X)
  result = "interface";
elif (param.at == Justification::Center)
  result = self.Name;
end if;
return result;',
	1,
	'',
	3459);
INSERT INTO O_TPARM
	VALUES (3460,
	3458,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (3461,
	3458,
	'ent_num',
	298,
	0,
	'',
	3462,
	'');
INSERT INTO O_TPARM
	VALUES (3462,
	3458,
	'comp_num',
	298,
	0,
	'',
	3460,
	'');
INSERT INTO O_TFR
	VALUES (3463,
	3435,
	'get_compartments',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	3458);
INSERT INTO O_TFR
	VALUES (3464,
	3435,
	'get_style',
	'',
	784,
	1,
	'return Style::Folder;',
	1,
	'',
	3465);
INSERT INTO O_TFR
	VALUES (3455,
	3435,
	'get_text_style',
	'',
	784,
	1,
	'return Style::None;',
	1,
	'',
	3464);
INSERT INTO O_TPARM
	VALUES (3466,
	3455,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (3467,
	3455,
	'ent_num',
	298,
	0,
	'',
	3468,
	'');
INSERT INTO O_TPARM
	VALUES (3468,
	3455,
	'comp_num',
	298,
	0,
	'',
	3466,
	'');
INSERT INTO O_TFR
	VALUES (3469,
	3435,
	'get_entries',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	3463);
INSERT INTO O_TPARM
	VALUES (3470,
	3469,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3471,
	3435,
	'newInterface',
	'',
	19,
	1,
	'create object instance interface of C_I;
relate interface to self across R4303;
interface.initialize();',
	1,
	'',
	3472);
INSERT INTO O_TFR
	VALUES (3473,
	3435,
	'newInterfacePackage',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one idiid related by self->IP_IPINIP[R4300];
if(empty idiid)
  create object instance idiid of IP_IPINIP;
  relate self to idiid across R4300;
end if;
create object instance interfaceDiagram of IP_IP;
create object instance sp of EP_SPKG;
relate interfaceDiagram to sp across R1402;
relate idiid to interfaceDiagram across R4301;
interfaceDiagram.initialize();
select one system related by self->S_SYS[R4304];
if(empty system)
  select one system related by self->S_SYS[R4302];
end if;
if(not_empty system)
  relate interfaceDiagram to system across R4304;
end if;',
	1,
	'',
	3471);
INSERT INTO O_TFR
	VALUES (3459,
	3435,
	'dispose',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one system related by self->S_SYS[R4302];
if(not_empty system)
  unrelate self from system across R4302;
end if;

// unrelate from parent
select one did related by self->IP_IPINIP[R4301];
if(not_empty did)
  unrelate self from did across R4301;
  // are there any other children?
  select any other_child related by did->IP_IP[R4301];
  if empty other_child
    // no, dispose the interface package in interface package placeholder
    select one parent related by did->IP_IP[R4300];
    if not_empty parent
      unrelate did from parent across R4300;
    end if;
    delete object instance did;
  end if;
end if;

// delete child Interface diagrams
select one did related by self->IP_IPINIP[R4300];
select many diagrams related by did->IP_IP[R4301];
for each diagram in diagrams
  diagram.dispose();
end for;
// last child will delete the did instance

select many interfaces related by self->C_I[R4303];
for each i in interfaces
  unrelate i from self across R4303;
  i.dispose();
end for;
select one system related by self->S_SYS[R4304];
if(not_empty system)
  unrelate self from system across R4304;
end if;
select one component related by self->C_C[R4206];
if(not_empty component)
  unrelate self from component across R4206;
end if;
select one componentPackage related by self->CP_CP[R4607];
if(not_empty componentPackage)
  unrelate self from componentPackage across R4607;
end if;
select one specPkg related by self->EP_SPKG[R1402];
delete object instance self;
// we must dispose the supertype after the
// subtype to allow access to the id through
// the supertype
if(not_empty specPkg)
  unrelate self from specPkg across R1402;
  specPkg.dispose();
end if;',
	1,
	'',
	3474);
INSERT INTO O_TFR
	VALUES (3472,
	3435,
	'isChildPackageOf',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
/*
 * Check the child tree to see if the given package exists
 *
 */
select many childPkgs related by self->IP_IPINIP[R4300]->IP_IP[R4301];
for each childPkg in childPkgs
  if(childPkg.Package_ID == param.Id)
    return true;
  else
    result = childPkg.isChildPackageOf(Id:param.Id);
    if(result)
      return result;
    end if;
  end if;
end for;
return false;',
	1,
	'',
	3454);
INSERT INTO O_TPARM
	VALUES (3475,
	3472,
	'Id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3476,
	3435,
	'associatePackageWithSystem',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any system from instances of S_SYS where (selected.Sys_ID == param.sysID);
if (not_empty system)
  shouldRelate = true;
  select one existSystem related by self->S_SYS[R4304];
  if(not_empty existSystem)
    if(system == existSystem)
      shouldRelate = false;
    end if;
  end if;
  if(shouldRelate)
    if(not_empty existSystem)
      unrelate self from existSystem across R4304;
    end if;
    relate self to system across R4304;
  end if;

  select many childPkgs related by self->IP_IPINIP[R4300]->IP_IP[R4301];
  for each childPkg in childPkgs
    childPkg.associatePackageWithSystem(sysID:system.Sys_ID);
  end for;
end if;
  ',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (3477,
	3476,
	'sysID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3465,
	3435,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Package_ID;',
	1,
	'',
	3469);
INSERT INTO O_TFR
	VALUES (3457,
	3435,
	'associateWithSystem',
	'',
	19,
	1,
	'// unhook from current parent
self.deassociateFromParent();
// hook up with system
select any system from instances of S_SYS
                                     where (selected.Sys_ID == param.sysID);
relate self to system across R4302;',
	1,
	'',
	3478);
INSERT INTO O_TPARM
	VALUES (3479,
	3457,
	'sysID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3474,
	3435,
	'deassociateFromParent',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one system related by self->S_SYS[R4302];
if(not_empty system)
  unrelate self from system across R4302;
end if;
select one specPkg related by self->EP_SPKG[R1402];
select one pkg related by specPkg->EP_PKG[R1400];
if(not_empty pkg)
  unrelate specPkg from pkg across R1400;
end if;
select one ipinip related by self->IP_IPINIP[R4301];
if(not_empty ipinip)
  select one parent related by ipinip->IP_IP[R4300];
  unrelate ipinip from self across R4301;
  select many otherIps related by ipinip->IP_IP[R4301];
  if(empty otherIps)
    unrelate ipinip from parent across R4300;
    delete object instance ipinip;
  end if;
end if;
select one componentPackage related by self->CP_CP[R4607];
if(not_empty componentPackage)
  unrelate self from componentPackage across R4607;
end if;
select one component related by self->C_C[R4206];
if(not_empty component)
  unrelate self from component across R4206;
end if;',
	1,
	'',
	3456);
INSERT INTO O_TFR
	VALUES (3478,
	3435,
	'associateWithPackage',
	'',
	19,
	1,
	'// unhook from current parent
self.deassociateFromParent();
// hook up with package
select any package from instances of EP_PKG
                                     where (selected.Package_ID == param.pkgID);
select one specPkg related by self->EP_SPKG[R1402];
relate specPkg to package across R1400;',
	1,
	'',
	3480);
INSERT INTO O_TPARM
	VALUES (3481,
	3478,
	'pkgID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3482,
	3435,
	'associateWithComponentPackage',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// unhook from current parent
self.deassociateFromParent();
// hook up with component package
select any cp from instances of CP_CP where (selected.Package_ID == param.cpID);
relate cp to self across R4607;',
	1,
	'',
	3483);
INSERT INTO O_TPARM
	VALUES (3484,
	3482,
	'cpID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3483,
	3435,
	'associateWithComponent',
	'',
	19,
	1,
	'// unhook from current parent
self.deassociateFromParent();
// hook up with component
select any component from instances of C_C
                                    where (selected.Id == param.compID);
relate self to component across R4206;',
	1,
	'',
	3476);
INSERT INTO O_TPARM
	VALUES (3485,
	3483,
	'compID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3480,
	3435,
	'associateWithInterfacePackage',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// unhook from current parent
self.deassociateFromParent();
// hook up with interface package
select any ifacePkg from instances of IP_IP
                                     where (selected.Package_ID == param.ipID);
select one ipinip related by ifacePkg->IP_IPINIP[R4300];
if(empty ipinip)
  create object instance ipinip of IP_IPINIP;
  relate ipinip to ifacePkg across R4300;
end if;
relate ipinip to self across R4301;',
	1,
	'',
	3482);
INSERT INTO O_TPARM
	VALUES (3486,
	3480,
	'ipID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3487,
	3435,
	'pasteInterfacePackage',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any ifacePkg from instances of IP_IP where (selected.Package_ID == param.id);
if(not_empty ifacePkg)
  // guarantee a unique name for the pasted dt package
  ifacePkg.Name = ::getUniqueInitialNameInParent(instance:ifacePkg.convertToInstance(),
  						name:ifacePkg.Name, parent:self.convertToInstance());
  ifacePkg.associateWithInterfacePackage(ipID:self.Package_ID);  
  select one system related by self->S_SYS[R4304];
  ifacePkg.associatePackageWithSystem(sysID:system.Sys_ID);
end if;',
	1,
	'',
	3473);
INSERT INTO O_TPARM
	VALUES (3488,
	3487,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3489,
	3435,
	'getInterfacePckgCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many interfacePckgs related by self->IP_IPINIP[R4300]->IP_IP[R4301];
return cardinality interfacePckgs;',
	1,
	'',
	3487);
INSERT INTO O_TFR
	VALUES (3490,
	3435,
	'getInterfacePckgId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many interfacePckgs related by self->IP_IPINIP[R4300]->IP_IP[R4301];
// We''re preincrementing the index
count = -1;
for each interfacePckg in interfacePckgs
  if (not_empty interfacePckg)
      count = count+1;
  end if;
  if (count == param.index)
      return interfacePckg.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	3489);
INSERT INTO O_TPARM
	VALUES (3491,
	3490,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3492,
	3435,
	'getInterfaceCount',
	'',
	298,
	1,
	'select many interfaces related by self->C_I[R4303];
return cardinality interfaces;',
	1,
	'',
	3490);
INSERT INTO O_TFR
	VALUES (3493,
	3435,
	'getInterfaceId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many interfaces related by self->C_I[R4303];
// We''re preincrementing the index
count = -1;
for each interface in interfaces
  if (not_empty interface)
      count = count+1;
  end if;
  if (count == param.index)
      return interface.Id;  
  end if;
end for;
return id;',
	1,
	'',
	3492);
INSERT INTO O_TPARM
	VALUES (3494,
	3493,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3495,
	3435,
	'pasteInterface',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any iface from instances of C_I where (selected.Id == param.id);
if(not_empty iface)
  // guarantee a unique name for the pasted dt package
  iface.Name = ::getUniqueInitialNameInParent(instance:iface.convertToInstance(),
  						name:iface.Name, parent:self.convertToInstance());
  relate iface to self across R4303;
end if;',
	1,
	'',
	3493);
INSERT INTO O_TPARM
	VALUES (3496,
	3495,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3497,
	3435,
	'collectReferencesForSynchronization',
	'',
	19,
	1,
	'/**
 *  Call on all interfaces to gather required elements for
 *  synchronization
 */
select many interfaces related by self->C_I[R4303];
for each interface in interfaces
  interface.collectReferencesForSynchronization(
                   referenceList:param.referenceList, syncType: param.syncType);
end for;
select many interfacePkgs related by self->IP_IPINIP[R4300]->IP_IP[R4301];
for each interfacePkg in interfacePkgs
  interfacePkg.collectReferencesForSynchronization(
                   referenceList:param.referenceList, syncType: param.syncType);
end for;',
	1,
	'',
	3495);
INSERT INTO O_TPARM
	VALUES (3498,
	3497,
	'referenceList',
	317,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (3499,
	3497,
	'syncType',
	3500,
	0,
	'',
	3498,
	'');
INSERT INTO O_NBATTR
	VALUES (3501,
	3435);
INSERT INTO O_BATTR
	VALUES (3501,
	3435);
INSERT INTO O_ATTR
	VALUES (3501,
	3435,
	3502,
	'Name',
	'Full Name: Interface Diagram Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3503,
	3435);
INSERT INTO O_BATTR
	VALUES (3503,
	3435);
INSERT INTO O_ATTR
	VALUES (3503,
	3435,
	3501,
	'Descrip',
	'Full Name: Interface Diagram Description
Description: A textual description of this diagram.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (3435,
	705,
	0,
	754,
	3444,
	3446,
	3445,
	3504,
	3505,
	0,
	0,
	'',
	'System Model',
	'Sys_ID',
	'R4302');
INSERT INTO O_RATTR
	VALUES (3504,
	3435,
	754,
	705,
	1,
	'Sys_ID');
INSERT INTO O_ATTR
	VALUES (3504,
	3435,
	3506,
	'Direct_Sys_ID',
	'',
	'Direct_',
	'Sys_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (3435,
	705,
	0,
	754,
	3450,
	3452,
	3451,
	3507,
	3508,
	0,
	0,
	'',
	'System Model',
	'Sys_ID',
	'R4304');
INSERT INTO O_RATTR
	VALUES (3507,
	3435,
	754,
	705,
	1,
	'Sys_ID');
INSERT INTO O_ATTR
	VALUES (3507,
	3435,
	3504,
	'Sys_ID',
	'',
	'',
	'Sys_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (3435,
	773,
	0,
	772,
	854,
	3509,
	856,
	3437,
	3510,
	0,
	0,
	'',
	'Specification Package',
	'Package_ID',
	'R1402');
INSERT INTO O_RATTR
	VALUES (3437,
	3435,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (3437,
	3435,
	0,
	'Package_ID',
	'',
	'',
	'Package_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (3435,
	707,
	0,
	758,
	3511,
	3512,
	3513,
	3502,
	3514,
	0,
	0,
	'',
	'Component Package',
	'Package_ID',
	'R4607');
INSERT INTO O_RATTR
	VALUES (3502,
	3435,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (3502,
	3435,
	3515,
	'Component_Package_ID',
	'',
	'Component_',
	'Package_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (3435,
	3438,
	0,
	3442,
	3440,
	3443,
	3441,
	3506,
	3516,
	0,
	0,
	'',
	'Interface Package in Interface Package',
	'Package_ID',
	'R4301');
INSERT INTO O_RATTR
	VALUES (3506,
	3435,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (3506,
	3435,
	3437,
	'Parent_Package_ID',
	'',
	'Parent_',
	'Package_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (3435,
	709,
	0,
	762,
	3517,
	3518,
	3519,
	3515,
	3520,
	0,
	0,
	'',
	'Component',
	'Id',
	'R4206');
INSERT INTO O_RATTR
	VALUES (3515,
	3435,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (3515,
	3435,
	3507,
	'Component_Id',
	'',
	'Component_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3435);
INSERT INTO O_OIDA
	VALUES (3437,
	3435,
	0,
	'Package_ID');
INSERT INTO O_ID
	VALUES (1,
	3435);
INSERT INTO O_ID
	VALUES (2,
	3435);
-- BP 7.1 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (3521,
	'Interaction',
	'// This is used by schema_gen to ignore this subsystem (for publication)
TRANSLATE_FOR_EXTERNAL_USE:FALSE',
	'IA',
	930,
	1,
	0);
INSERT INTO S_SID
	VALUES (1,
	3521);
INSERT INTO O_IOBJ
	VALUES (3522,
	3523,
	0,
	3521,
	'Function Package',
	'S_FPK');
INSERT INTO O_IOBJ
	VALUES (3524,
	2820,
	0,
	3521,
	'External Entity',
	'S_EE');
INSERT INTO O_IOBJ
	VALUES (3525,
	30,
	0,
	3521,
	'Model Class',
	'O_OBJ');
INSERT INTO O_IOBJ
	VALUES (3526,
	37,
	0,
	3521,
	'Attribute',
	'O_ATTR');
INSERT INTO O_IOBJ
	VALUES (3527,
	30,
	0,
	3521,
	'Model Class',
	'O_OBJ');
INSERT INTO O_IOBJ
	VALUES (3528,
	709,
	0,
	3521,
	'Component',
	'C_C');
INSERT INTO O_IOBJ
	VALUES (3529,
	2798,
	0,
	3521,
	'Package',
	'EP_PKG');
INSERT INTO R_SIMP
	VALUES (3530);
INSERT INTO R_REL
	VALUES (3530,
	941,
	'',
	3521);
INSERT INTO R_PART
	VALUES (3531,
	3530,
	3532,
	0,
	0,
	'span begins at');
INSERT INTO O_RTIDA
	VALUES (3533,
	3531,
	0,
	3530,
	3532);
INSERT INTO R_RTO
	VALUES (3531,
	3530,
	3532,
	0);
INSERT INTO R_OIR
	VALUES (3531,
	3530,
	3532,
	0);
INSERT INTO R_FORM
	VALUES (3534,
	3530,
	3535,
	1,
	1,
	'defines start of');
INSERT INTO R_RGO
	VALUES (3534,
	3530,
	3535);
INSERT INTO R_OIR
	VALUES (3534,
	3530,
	3535,
	0);
INSERT INTO R_SIMP
	VALUES (3536);
INSERT INTO R_REL
	VALUES (3536,
	931,
	'',
	3521);
INSERT INTO R_FORM
	VALUES (3531,
	3536,
	3537,
	1,
	1,
	'has a point in time referenced by');
INSERT INTO R_RGO
	VALUES (3531,
	3536,
	3537);
INSERT INTO R_OIR
	VALUES (3531,
	3536,
	3537,
	0);
INSERT INTO R_PART
	VALUES (3538,
	3536,
	3539,
	0,
	0,
	'marks a point in time');
INSERT INTO O_RTIDA
	VALUES (3540,
	3538,
	0,
	3536,
	3539);
INSERT INTO R_RTO
	VALUES (3538,
	3536,
	3539,
	0);
INSERT INTO R_OIR
	VALUES (3538,
	3536,
	3539,
	0);
INSERT INTO R_SIMP
	VALUES (3541);
INSERT INTO R_REL
	VALUES (3541,
	942,
	'',
	3521);
INSERT INTO R_PART
	VALUES (3531,
	3541,
	3542,
	0,
	0,
	'span ends at');
INSERT INTO O_RTIDA
	VALUES (3533,
	3531,
	0,
	3541,
	3542);
INSERT INTO R_RTO
	VALUES (3531,
	3541,
	3542,
	0);
INSERT INTO R_OIR
	VALUES (3531,
	3541,
	3542,
	0);
INSERT INTO R_FORM
	VALUES (3534,
	3541,
	3543,
	1,
	1,
	'defines end of');
INSERT INTO R_RGO
	VALUES (3534,
	3541,
	3543);
INSERT INTO R_OIR
	VALUES (3534,
	3541,
	3543,
	0);
INSERT INTO R_SUBSUP
	VALUES (3544);
INSERT INTO R_REL
	VALUES (3544,
	930,
	'',
	3521);
INSERT INTO R_SUPER
	VALUES (703,
	3544,
	3545);
INSERT INTO O_RTIDA
	VALUES (743,
	703,
	0,
	3544,
	3545);
INSERT INTO R_RTO
	VALUES (703,
	3544,
	3545,
	0);
INSERT INTO R_OIR
	VALUES (703,
	3544,
	3545,
	0);
INSERT INTO R_SUB
	VALUES (3546,
	3544,
	3547);
INSERT INTO R_RGO
	VALUES (3546,
	3544,
	3547);
INSERT INTO R_OIR
	VALUES (3546,
	3544,
	3547,
	0);
INSERT INTO R_SUB
	VALUES (3548,
	3544,
	3549);
INSERT INTO R_RGO
	VALUES (3548,
	3544,
	3549);
INSERT INTO R_OIR
	VALUES (3548,
	3544,
	3549,
	0);
INSERT INTO R_SUB
	VALUES (3550,
	3544,
	3551);
INSERT INTO R_RGO
	VALUES (3550,
	3544,
	3551);
INSERT INTO R_OIR
	VALUES (3550,
	3544,
	3551,
	0);
INSERT INTO R_SUB
	VALUES (3552,
	3544,
	3553);
INSERT INTO R_RGO
	VALUES (3552,
	3544,
	3553);
INSERT INTO R_OIR
	VALUES (3552,
	3544,
	3553,
	0);
INSERT INTO R_SUB
	VALUES (3554,
	3544,
	3555);
INSERT INTO R_RGO
	VALUES (3554,
	3544,
	3555);
INSERT INTO R_OIR
	VALUES (3554,
	3544,
	3555,
	0);
INSERT INTO R_SUB
	VALUES (3538,
	3544,
	3556);
INSERT INTO R_RGO
	VALUES (3538,
	3544,
	3556);
INSERT INTO R_OIR
	VALUES (3538,
	3544,
	3556,
	0);
INSERT INTO R_SUB
	VALUES (3557,
	3544,
	3558);
INSERT INTO R_RGO
	VALUES (3557,
	3544,
	3558);
INSERT INTO R_OIR
	VALUES (3557,
	3544,
	3558,
	0);
INSERT INTO R_SUB
	VALUES (3559,
	3544,
	3560);
INSERT INTO R_RGO
	VALUES (3559,
	3544,
	3560);
INSERT INTO R_OIR
	VALUES (3559,
	3544,
	3560,
	0);
INSERT INTO R_SUB
	VALUES (3561,
	3544,
	3562);
INSERT INTO R_RGO
	VALUES (3561,
	3544,
	3562);
INSERT INTO R_OIR
	VALUES (3561,
	3544,
	3562,
	0);
INSERT INTO R_SIMP
	VALUES (3563);
INSERT INTO R_REL
	VALUES (3563,
	932,
	'CrossComponent:true',
	3521);
INSERT INTO R_FORM
	VALUES (3550,
	3563,
	3564,
	1,
	1,
	'represents participant of');
INSERT INTO R_RGO
	VALUES (3550,
	3563,
	3564);
INSERT INTO R_OIR
	VALUES (3550,
	3563,
	3564,
	0);
INSERT INTO R_PART
	VALUES (3523,
	3563,
	3565,
	0,
	1,
	'represents');
INSERT INTO O_RTIDA
	VALUES (3566,
	3523,
	0,
	3563,
	3565);
INSERT INTO R_RTO
	VALUES (3523,
	3563,
	3565,
	0);
INSERT INTO R_OIR
	VALUES (3523,
	3563,
	3565,
	3522);
INSERT INTO R_SIMP
	VALUES (3567);
INSERT INTO R_REL
	VALUES (3567,
	933,
	'CrossComponent:true',
	3521);
INSERT INTO R_FORM
	VALUES (3548,
	3567,
	3568,
	1,
	1,
	'represents participant of');
INSERT INTO R_RGO
	VALUES (3548,
	3567,
	3568);
INSERT INTO R_OIR
	VALUES (3548,
	3567,
	3568,
	0);
INSERT INTO R_PART
	VALUES (2820,
	3567,
	3569,
	0,
	1,
	'represents');
INSERT INTO O_RTIDA
	VALUES (3570,
	2820,
	0,
	3567,
	3569);
INSERT INTO R_RTO
	VALUES (2820,
	3567,
	3569,
	0);
INSERT INTO R_OIR
	VALUES (2820,
	3567,
	3569,
	3524);
INSERT INTO R_SIMP
	VALUES (3571);
INSERT INTO R_REL
	VALUES (3571,
	934,
	'CrossComponent:true',
	3521);
INSERT INTO R_FORM
	VALUES (3546,
	3571,
	3572,
	1,
	1,
	'represents participant of');
INSERT INTO R_RGO
	VALUES (3546,
	3571,
	3572);
INSERT INTO R_OIR
	VALUES (3546,
	3571,
	3572,
	0);
INSERT INTO R_PART
	VALUES (30,
	3571,
	3573,
	0,
	1,
	'represents');
INSERT INTO O_RTIDA
	VALUES (150,
	30,
	0,
	3571,
	3573);
INSERT INTO R_RTO
	VALUES (30,
	3571,
	3573,
	0);
INSERT INTO R_OIR
	VALUES (30,
	3571,
	3573,
	3525);
INSERT INTO R_SIMP
	VALUES (3574);
INSERT INTO R_REL
	VALUES (3574,
	935,
	'',
	3521);
INSERT INTO R_PART
	VALUES (3552,
	3574,
	3575,
	0,
	0,
	'belongs to');
INSERT INTO O_RTIDA
	VALUES (3576,
	3552,
	0,
	3574,
	3575);
INSERT INTO R_RTO
	VALUES (3552,
	3574,
	3575,
	0);
INSERT INTO R_OIR
	VALUES (3552,
	3574,
	3575,
	0);
INSERT INTO R_FORM
	VALUES (3577,
	3574,
	3578,
	1,
	1,
	'may have');
INSERT INTO R_RGO
	VALUES (3577,
	3574,
	3578);
INSERT INTO R_OIR
	VALUES (3577,
	3574,
	3578,
	0);
INSERT INTO R_SIMP
	VALUES (3579);
INSERT INTO R_REL
	VALUES (3579,
	936,
	'',
	3521);
INSERT INTO R_FORM
	VALUES (3580,
	3579,
	3581,
	1,
	1,
	'contains informal');
INSERT INTO R_RGO
	VALUES (3580,
	3579,
	3581);
INSERT INTO R_OIR
	VALUES (3580,
	3579,
	3581,
	0);
INSERT INTO R_PART
	VALUES (3546,
	3579,
	3582,
	0,
	1,
	'owns informal');
INSERT INTO O_RTIDA
	VALUES (3583,
	3546,
	0,
	3579,
	3582);
INSERT INTO R_RTO
	VALUES (3546,
	3579,
	3582,
	0);
INSERT INTO R_OIR
	VALUES (3546,
	3579,
	3582,
	0);
INSERT INTO R_SIMP
	VALUES (3584);
INSERT INTO R_REL
	VALUES (3584,
	937,
	'',
	3521);
INSERT INTO R_FORM
	VALUES (3580,
	3584,
	3585,
	1,
	1,
	'contains formal');
INSERT INTO R_RGO
	VALUES (3580,
	3584,
	3585);
INSERT INTO R_OIR
	VALUES (3580,
	3584,
	3585,
	0);
INSERT INTO R_PART
	VALUES (3546,
	3584,
	3586,
	0,
	1,
	'owns formal');
INSERT INTO O_RTIDA
	VALUES (3583,
	3546,
	0,
	3584,
	3586);
INSERT INTO R_RTO
	VALUES (3546,
	3584,
	3586,
	0);
INSERT INTO R_OIR
	VALUES (3546,
	3584,
	3586,
	0);
INSERT INTO R_SIMP
	VALUES (3587);
INSERT INTO R_REL
	VALUES (3587,
	938,
	'CrossComponent:true',
	3521);
INSERT INTO R_FORM
	VALUES (3580,
	3587,
	3588,
	1,
	1,
	'defines');
INSERT INTO R_RGO
	VALUES (3580,
	3587,
	3588);
INSERT INTO R_OIR
	VALUES (3580,
	3587,
	3588,
	0);
INSERT INTO R_PART
	VALUES (37,
	3587,
	3589,
	0,
	1,
	'references');
INSERT INTO O_RTIDA
	VALUES (168,
	37,
	0,
	3587,
	3589);
INSERT INTO O_RTIDA
	VALUES (169,
	37,
	0,
	3587,
	3589);
INSERT INTO R_RTO
	VALUES (37,
	3587,
	3589,
	0);
INSERT INTO R_OIR
	VALUES (37,
	3587,
	3589,
	3526);
INSERT INTO R_SIMP
	VALUES (3590);
INSERT INTO R_REL
	VALUES (3590,
	939,
	'CrossComponent:true',
	3521);
INSERT INTO R_FORM
	VALUES (3552,
	3590,
	3591,
	1,
	1,
	'represents participant of');
INSERT INTO R_RGO
	VALUES (3552,
	3590,
	3591);
INSERT INTO R_OIR
	VALUES (3552,
	3590,
	3591,
	0);
INSERT INTO R_PART
	VALUES (30,
	3590,
	3592,
	0,
	1,
	'represents');
INSERT INTO O_RTIDA
	VALUES (150,
	30,
	0,
	3590,
	3592);
INSERT INTO R_RTO
	VALUES (30,
	3590,
	3592,
	0);
INSERT INTO R_OIR
	VALUES (30,
	3590,
	3592,
	3527);
INSERT INTO R_SUBSUP
	VALUES (3593);
INSERT INTO R_REL
	VALUES (3593,
	947,
	'',
	3521);
INSERT INTO R_SUPER
	VALUES (3577,
	3593,
	3594);
INSERT INTO O_RTIDA
	VALUES (3595,
	3577,
	0,
	3593,
	3594);
INSERT INTO R_RTO
	VALUES (3577,
	3593,
	3594,
	0);
INSERT INTO R_OIR
	VALUES (3577,
	3593,
	3594,
	0);
INSERT INTO R_SUB
	VALUES (3596,
	3593,
	3597);
INSERT INTO R_RGO
	VALUES (3596,
	3593,
	3597);
INSERT INTO R_OIR
	VALUES (3596,
	3593,
	3597,
	0);
INSERT INTO R_SUB
	VALUES (3598,
	3593,
	3599);
INSERT INTO R_RGO
	VALUES (3598,
	3593,
	3599);
INSERT INTO R_OIR
	VALUES (3598,
	3593,
	3599,
	0);
INSERT INTO R_SUBSUP
	VALUES (3600);
INSERT INTO R_REL
	VALUES (3600,
	948,
	'',
	3521);
INSERT INTO R_SUPER
	VALUES (3580,
	3600,
	3601);
INSERT INTO O_RTIDA
	VALUES (3602,
	3580,
	0,
	3600,
	3601);
INSERT INTO R_RTO
	VALUES (3580,
	3600,
	3601,
	0);
INSERT INTO R_OIR
	VALUES (3580,
	3600,
	3601,
	0);
INSERT INTO R_SUB
	VALUES (3603,
	3600,
	3604);
INSERT INTO R_RGO
	VALUES (3603,
	3600,
	3604);
INSERT INTO R_OIR
	VALUES (3603,
	3600,
	3604,
	0);
INSERT INTO R_SUB
	VALUES (3605,
	3600,
	3606);
INSERT INTO R_RGO
	VALUES (3605,
	3600,
	3606);
INSERT INTO R_OIR
	VALUES (3605,
	3600,
	3606,
	0);
INSERT INTO R_SIMP
	VALUES (3607);
INSERT INTO R_REL
	VALUES (3607,
	940,
	'',
	3521);
INSERT INTO R_PART
	VALUES (703,
	3607,
	3608,
	0,
	0,
	'extends from');
INSERT INTO O_RTIDA
	VALUES (743,
	703,
	0,
	3607,
	3608);
INSERT INTO R_RTO
	VALUES (703,
	3607,
	3608,
	0);
INSERT INTO R_OIR
	VALUES (703,
	3607,
	3608,
	0);
INSERT INTO R_FORM
	VALUES (3538,
	3607,
	3609,
	0,
	1,
	'is source of span');
INSERT INTO R_RGO
	VALUES (3538,
	3607,
	3609);
INSERT INTO R_OIR
	VALUES (3538,
	3607,
	3609,
	0);
INSERT INTO R_SIMP
	VALUES (3610);
INSERT INTO R_REL
	VALUES (3610,
	955,
	'CrossComponent:true',
	3521);
INSERT INTO R_FORM
	VALUES (3559,
	3610,
	3611,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (3559,
	3610,
	3611);
INSERT INTO R_OIR
	VALUES (3559,
	3610,
	3611,
	0);
INSERT INTO R_PART
	VALUES (709,
	3610,
	3612,
	0,
	1,
	'represents');
INSERT INTO O_RTIDA
	VALUES (762,
	709,
	0,
	3610,
	3612);
INSERT INTO R_RTO
	VALUES (709,
	3610,
	3612,
	0);
INSERT INTO R_OIR
	VALUES (709,
	3610,
	3612,
	3528);
INSERT INTO R_SIMP
	VALUES (3613);
INSERT INTO R_REL
	VALUES (3613,
	949,
	'',
	3521);
INSERT INTO R_PART
	VALUES (3538,
	3613,
	3614,
	0,
	1,
	'life is bounded by');
INSERT INTO O_RTIDA
	VALUES (3540,
	3538,
	0,
	3613,
	3614);
INSERT INTO R_RTO
	VALUES (3538,
	3613,
	3614,
	0);
INSERT INTO R_OIR
	VALUES (3538,
	3613,
	3614,
	0);
INSERT INTO R_FORM
	VALUES (3554,
	3613,
	3615,
	0,
	1,
	'defines bounds of existence');
INSERT INTO R_RGO
	VALUES (3554,
	3613,
	3615);
INSERT INTO R_OIR
	VALUES (3554,
	3613,
	3615,
	0);
INSERT INTO R_SIMP
	VALUES (3616);
INSERT INTO R_REL
	VALUES (3616,
	956,
	'',
	3521);
INSERT INTO R_FORM
	VALUES (3561,
	3616,
	3617,
	1,
	1,
	'represents participant of');
INSERT INTO R_RGO
	VALUES (3561,
	3616,
	3617);
INSERT INTO R_OIR
	VALUES (3561,
	3616,
	3617,
	0);
INSERT INTO R_PART
	VALUES (2798,
	3616,
	3618,
	0,
	1,
	'represents');
INSERT INTO O_RTIDA
	VALUES (2825,
	2798,
	0,
	3616,
	3618);
INSERT INTO R_RTO
	VALUES (2798,
	3616,
	3618,
	0);
INSERT INTO R_OIR
	VALUES (2798,
	3616,
	3618,
	3529);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3557,
	'Use Case Participant',
	930,
	'IA_UCP',
	'',
	3521);
INSERT INTO O_TFR
	VALUES (3619,
	3557,
	'initialize',
	'',
	19,
	1,
	'name = "Unnamed Use Case";
success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:false);     
if ( success!="") 
self.Name =success;
else 
 self.dispose();
end if;  ',
	1,
	'',
	3620);
INSERT INTO O_TFR
	VALUES (3621,
	3557,
	'get_compartments',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	3622);
INSERT INTO O_TFR
	VALUES (3623,
	3557,
	'get_entries',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	3621);
INSERT INTO O_TPARM
	VALUES (3624,
	3623,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3622,
	3557,
	'get_compartment_text',
	'',
	322,
	1,
	'if(param.at == Justification::Center)
  return self.Name;
end if;
return "";',
	1,
	'',
	3625);
INSERT INTO O_TPARM
	VALUES (3626,
	3622,
	'comp_num',
	298,
	0,
	'',
	3627,
	'');
INSERT INTO O_TPARM
	VALUES (3628,
	3622,
	'ent_num',
	298,
	0,
	'',
	3626,
	'');
INSERT INTO O_TPARM
	VALUES (3627,
	3622,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3620,
	3557,
	'get_text_style',
	'',
	784,
	1,
	'return Style::None;',
	1,
	'',
	3629);
INSERT INTO O_TPARM
	VALUES (3630,
	3620,
	'comp_num',
	298,
	0,
	'',
	3631,
	'');
INSERT INTO O_TPARM
	VALUES (3632,
	3620,
	'ent_num',
	298,
	0,
	'',
	3630,
	'');
INSERT INTO O_TPARM
	VALUES (3631,
	3620,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3629,
	3557,
	'get_style',
	'',
	784,
	1,
	'return Style::Ellipse;',
	1,
	'',
	3633);
INSERT INTO O_TFR
	VALUES (3625,
	3557,
	'dispose',
	'',
	19,
	1,
	'select one participant related by self->SQ_P[R930];
if(not_empty participant)
  participant.dispose();
else
  delete object instance self;
end if;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (3633,
	3557,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Part_ID;',
	1,
	'',
	3623);
INSERT INTO O_TFR
	VALUES (3634,
	3557,
	'convertToInstance',
	'Translate:native',
	317,
	1,
	'return this;',
	0,
	'',
	3619);
INSERT INTO O_NBATTR
	VALUES (3635,
	3557);
INSERT INTO O_BATTR
	VALUES (3635,
	3557);
INSERT INTO O_ATTR
	VALUES (3635,
	3557,
	3636,
	'Name',
	'Full Name: Use Case Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3637,
	3557);
INSERT INTO O_BATTR
	VALUES (3637,
	3557);
INSERT INTO O_ATTR
	VALUES (3637,
	3557,
	3635,
	'Descrip',
	'Full Name: Use Case Description',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (3557,
	703,
	0,
	743,
	3544,
	3558,
	3545,
	3636,
	3638,
	0,
	0,
	'',
	'Interaction Participant',
	'Part_ID',
	'R930');
INSERT INTO O_RATTR
	VALUES (3636,
	3557,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (3636,
	3557,
	0,
	'Part_ID',
	'',
	'',
	'Part_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3557);
INSERT INTO O_OIDA
	VALUES (3636,
	3557,
	0,
	'Part_ID');
INSERT INTO O_ID
	VALUES (1,
	3557);
INSERT INTO O_ID
	VALUES (2,
	3557);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3531,
	'Timing Mark',
	904,
	'SQ_TM',
	'This class represents a mark somewhere on a lifespan.  They are used to capture
a point in time during an instance''s life.',
	3521);
INSERT INTO O_TFR
	VALUES (3639,
	3531,
	'get_style',
	'',
	784,
	1,
	'return Style::None;',
	1,
	'',
	3640);
INSERT INTO O_TPARM
	VALUES (3641,
	3639,
	'at',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3642,
	3531,
	'get_connector_text',
	'',
	322,
	1,
	'if(param.at == End::End)
  return self.Name;
end if;
return "";',
	1,
	'',
	3643);
INSERT INTO O_TPARM
	VALUES (3644,
	3642,
	'Obj_ID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (3645,
	3642,
	'Obj_TypeIsImported',
	316,
	0,
	'',
	3644,
	'');
INSERT INTO O_TPARM
	VALUES (3646,
	3642,
	'at',
	880,
	0,
	'',
	3645,
	'');
INSERT INTO O_TPARM
	VALUES (3647,
	3642,
	'parent_ID',
	296,
	0,
	'',
	3646,
	'');
INSERT INTO O_TFR
	VALUES (3643,
	3531,
	'dispose',
	'',
	19,
	1,
	'select many spans related by self->SQ_TS[R941];
for each span in spans
  unrelate self from span across R941;
  span.dispose();
end for;
select many spans related by self->SQ_TS[R942];
for each span in spans
  unrelate self from span across R942;
  span.dispose();
end for;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (3640,
	3531,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Mark_ID;',
	1,
	'',
	3642);
INSERT INTO O_NBATTR
	VALUES (3648,
	3531);
INSERT INTO O_BATTR
	VALUES (3648,
	3531);
INSERT INTO O_ATTR
	VALUES (3648,
	3531,
	3533,
	'Name',
	'Full Name: Timing Mark Label',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3649,
	3531);
INSERT INTO O_BATTR
	VALUES (3649,
	3531);
INSERT INTO O_ATTR
	VALUES (3649,
	3531,
	3650,
	'Descrip',
	'Full Name: Timing Mark Description
Description: A textual description of this timing mark.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (3531,
	3538,
	0,
	3540,
	3536,
	3537,
	3539,
	3650,
	3651,
	0,
	0,
	'',
	'Lifespan',
	'Part_ID',
	'R931');
INSERT INTO O_RATTR
	VALUES (3650,
	3531,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (3650,
	3531,
	3648,
	'Part_ID',
	'',
	'',
	'Part_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3533,
	3531);
INSERT INTO O_BATTR
	VALUES (3533,
	3531);
INSERT INTO O_ATTR
	VALUES (3533,
	3531,
	0,
	'Mark_ID',
	'',
	'',
	'Mark_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3531);
INSERT INTO O_OIDA
	VALUES (3533,
	3531,
	0,
	'Mark_ID');
INSERT INTO O_ID
	VALUES (1,
	3531);
INSERT INTO O_ID
	VALUES (2,
	3531);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3534,
	'Time Span',
	905,
	'SQ_TS',
	'This class represents a span of time between two timing marks.',
	3521);
INSERT INTO O_TFR
	VALUES (3652,
	3534,
	'get_style',
	'',
	784,
	1,
	'if((param.at == End::End ) or (param.at == End::Start))
  return Style::OpenArrow;
else
  return Style::Solid;
end if;',
	1,
	'',
	3653);
INSERT INTO O_TPARM
	VALUES (3654,
	3652,
	'at',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3655,
	3534,
	'get_connector_text',
	'',
	322,
	1,
	'if(param.at == End::Middle)
  if(self.Name != "")
    return "{" + self.Name + "}";
  end if;
  return "";
else
  return "";
end if;',
	1,
	'',
	3656);
INSERT INTO O_TPARM
	VALUES (3657,
	3655,
	'Obj_ID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (3658,
	3655,
	'Obj_TypeIsImported',
	316,
	0,
	'',
	3657,
	'');
INSERT INTO O_TPARM
	VALUES (3659,
	3655,
	'at',
	880,
	0,
	'',
	3658,
	'');
INSERT INTO O_TPARM
	VALUES (3660,
	3655,
	'parent_ID',
	296,
	0,
	'',
	3659,
	'');
INSERT INTO O_TFR
	VALUES (3656,
	3534,
	'dispose',
	'',
	19,
	1,
	'select one endMark related by self->SQ_TM[R942];
select one startMark related by self->SQ_TM[R941];
if(not_empty endMark)
  unrelate self from endMark across R942;
end if;
if(not_empty startMark)
  unrelate self from startMark across R941;
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (3653,
	3534,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Span_ID;',
	1,
	'',
	3655);
INSERT INTO O_NBATTR
	VALUES (3661,
	3534);
INSERT INTO O_BATTR
	VALUES (3661,
	3534);
INSERT INTO O_ATTR
	VALUES (3661,
	3534,
	3662,
	'Name',
	'Full Name: Time Span Label',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3663,
	3534);
INSERT INTO O_BATTR
	VALUES (3663,
	3534);
INSERT INTO O_ATTR
	VALUES (3663,
	3534,
	3661,
	'Descrip',
	'Full Name: Time Span Description
Description: A textual description of this time span.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (3534,
	3531,
	0,
	3533,
	3530,
	3535,
	3532,
	3662,
	3664,
	0,
	0,
	'',
	'Timing Mark',
	'Mark_ID',
	'R941');
INSERT INTO O_RATTR
	VALUES (3662,
	3534,
	3533,
	3531,
	1,
	'Mark_ID');
INSERT INTO O_ATTR
	VALUES (3662,
	3534,
	3665,
	'Prev_Mark_ID',
	'',
	'Prev_',
	'Mark_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (3534,
	3531,
	0,
	3533,
	3541,
	3543,
	3542,
	3665,
	3666,
	0,
	0,
	'',
	'Timing Mark',
	'Mark_ID',
	'R942');
INSERT INTO O_RATTR
	VALUES (3665,
	3534,
	3533,
	3531,
	1,
	'Mark_ID');
INSERT INTO O_ATTR
	VALUES (3665,
	3534,
	3667,
	'Mark_ID',
	'',
	'',
	'Mark_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3667,
	3534);
INSERT INTO O_BATTR
	VALUES (3667,
	3534);
INSERT INTO O_ATTR
	VALUES (3667,
	3534,
	0,
	'Span_ID',
	'',
	'',
	'Span_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3534);
INSERT INTO O_OIDA
	VALUES (3667,
	3534,
	0,
	'Span_ID');
INSERT INTO O_ID
	VALUES (1,
	3534);
INSERT INTO O_ID
	VALUES (2,
	3534);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3561,
	'Package Participant',
	931,
	'SQ_PP',
	'',
	3521);
INSERT INTO O_TFR
	VALUES (3668,
	3561,
	'actionFilter',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
if(param.name == "can")
  // if the current action is one which requires
  // this element to be selected along with a
  // synchronous message
  if(param.value == "formCommPackageFunc")
    // no formalization support yet at system level
    if(self.definedAtSystemLevel())
      return false;
    end if;
    // if the selection count is not equal two return false, this
    // prevents the menu entries from existing while only one of the
    // elements is selected
    if(Sel::getCurrentSelectionCount() != 2)
      return false;
    end if;
    // return true if this participant represents
    // a function package which contains at least
    // one function
    return self.formalPKGHasFunctions();
  end if;
  if(param.value == "formPkg")
    count = Util::getElementCountInSystem(
                                      elementType:ElementTypeConstants::PACKAGE,
                                        askingElement:self.convertToInstance());
    if(count == 1 and self.isFormal)
      return false;
    end if;
    return count != 0;
  end if;
  if(param.value == "unform")
    return self.isFormal;
  end if;
end if;
return false;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (3669,
	3668,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (3670,
	3668,
	'value',
	322,
	0,
	'',
	3669,
	'');
INSERT INTO O_TFR
	VALUES (3671,
	3561,
	'canRename',
	'',
	316,
	1,
	'return not self.isFormal;',
	1,
	'',
	3668);
INSERT INTO O_TFR
	VALUES (3672,
	3561,
	'definedAtSystemLevel',
	'',
	316,
	1,
	'select one part related by self->SQ_P[R930];
return part.definedAtSystemLevel();',
	1,
	'',
	3671);
INSERT INTO O_TFR
	VALUES (3673,
	3561,
	'dispose',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one participant related by self->SQ_P[R930];
if(not_empty participant)
  participant.dispose();
else
  select one fp related by self->EP_PKG[R956];
  if(not_empty fp)
    unrelate fp from self across R956;
  end if;
  delete object instance self;
end if;',
	1,
	'',
	3672);
INSERT INTO O_TFR
	VALUES (3674,
	3561,
	'formalPKGHasFunctions',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one packageableElem related by self->SQ_P[R930]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;

if (isInGenericPackage)
  select one pkg related by self->EP_PKG[R956];
  if(not_empty pkg)
    select many funcs related by pkg->PE_PE[R8000]->S_SYNC[R8001];
    return not_empty funcs;
  end if;
  return false;
else
// select one fpk related by self->S_FPK[R932];
// if(not_empty fpk)
//   select many funcs related by fpk->S_FIP[R31]->S_SYNC[R31];
//  return not_empty funcs;
// end if;
  return false;
end if;
',
	1,
	'',
	3673);
INSERT INTO O_TFR
	VALUES (3675,
	3561,
	'formalize',
	'',
	19,
	1,
	'select any pe from instances of PE_PE where (selected.Element_ID == param.fpId);
select one pkg related by pe->EP_PKG[R8001];
if(self.isFormal)
  self.unformalize();
end if;
if (not_empty pkg)
  relate self to pkg across R956;
end if;',
	1,
	'',
	3674);
INSERT INTO O_TPARM
	VALUES (3676,
	3675,
	'fpId',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3677,
	3561,
	'get_compartment_text',
	'',
	322,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
result = "";
select one packageableElem related by self->SQ_P[R930]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;

if (isInGenericPackage)
  select one pkg related by self->EP_PKG[R956];
  result = "";
  if (param.at == Justification::Center_in_X)
      result = "function";
  end if;
  if(not_empty pkg)
    if(param.at == Justification::Center)
      result = pkg.getPath(path:"");
    end if;
  else
    if (param.at == Justification::Center)
      result = self.InformalName;
    end if;
  end if;
else
    result = "";
end if;
return result;',
	1,
	'',
	3675);
INSERT INTO O_TPARM
	VALUES (3678,
	3677,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (3679,
	3677,
	'comp_num',
	298,
	0,
	'',
	3678,
	'');
INSERT INTO O_TPARM
	VALUES (3680,
	3677,
	'ent_num',
	298,
	0,
	'',
	3679,
	'');
INSERT INTO O_TFR
	VALUES (3681,
	3561,
	'get_compartments',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	3677);
INSERT INTO O_TFR
	VALUES (3682,
	3561,
	'get_entries',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	3681);
INSERT INTO O_TPARM
	VALUES (3683,
	3682,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3684,
	3561,
	'get_name',
	'',
	322,
	1,
	'return self.Label;',
	1,
	'',
	3682);
INSERT INTO O_TFR
	VALUES (3685,
	3561,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Part_ID;',
	1,
	'',
	3684);
INSERT INTO O_TFR
	VALUES (3686,
	3561,
	'get_style',
	'',
	784,
	1,
	'return Style::Folder;',
	1,
	'',
	3685);
INSERT INTO O_TFR
	VALUES (3687,
	3561,
	'get_text_style',
	'',
	784,
	1,
	'return Style::None;',
	1,
	'',
	3686);
INSERT INTO O_TPARM
	VALUES (3688,
	3687,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (3689,
	3687,
	'comp_num',
	298,
	0,
	'',
	3688,
	'');
INSERT INTO O_TPARM
	VALUES (3690,
	3687,
	'ent_num',
	298,
	0,
	'',
	3689,
	'');
INSERT INTO O_TFR
	VALUES (3691,
	3561,
	'unformalize',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one part related by self->SQ_P[R930];

select one packageableElem related by self->SQ_P[R930]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;

if (isInGenericPackage)
  select one pkg related by self ->EP_PKG[R956];
  if(not_empty pkg)
    unrelate self from pkg across R956;
  end if;
end if;

select many messages related by part->MSG_M[R1007];
for each message in messages
  message.unformalize();
end for;
// unformalize any communication links connected
// to this instance
select many links related by part->COMM_LNK[R1133];
for each link in links
  link.unformalize();
end for;',
	1,
	'',
	3692);
INSERT INTO O_TFR
	VALUES (3692,
	3561,
	'initialize',
	'',
	19,
	1,
	'name = "Informal Package";
success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:false);     
if ( success!="") 
self.InformalName =success;
else 
 self.dispose();
end if;  ',
	1,
	'',
	3687);
INSERT INTO O_TFR
	VALUES (3693,
	3561,
	'getFunctionCount',
	'',
	298,
	1,
	'select many funcs related by self->EP_PKG[R956]->PE_PE[R8000]->S_SYNC[R8001];
return cardinality funcs;',
	1,
	'',
	3691);
INSERT INTO O_TFR
	VALUES (3694,
	3561,
	'resolvePackage',
	'',
	19,
	1,
	'select one proxyPkg related by self->EP_PKG[R956];
if(not_empty proxyPkg and not Util::isProxy(element:self.convertToInstance()))
  select one packageableElem related by self->SQ_P[R930]->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  if (empty package)
    select one package related by component->PE_PE[R8001]->EP_PKG[R8000]; 
  end if;
  // try to resolve the package by name
  id = packageableElem
                     .resolvePackageRelativeToSelf(expected_name:proxyPkg.Name);
  select any resolvedPe from instances of PE_PE
                                            where (selected.Element_ID == id);
  if(not_empty resolvedPe)
    select one pkg related by resolvedPe->EP_PKG[R8001];
    relate self to pkg across R956;
    self.resolveMessageFormalizations();
  else
    // unformalize this PP
    self.unformalize();
  end if;
end if;',
	1,
	'',
	3693);
INSERT INTO O_TFR
	VALUES (3695,
	3561,
	'convertToInstance',
	'Translate:native',
	317,
	1,
	'return this;',
	0,
	'',
	3694);
INSERT INTO O_TFR
	VALUES (3696,
	3561,
	'resolveMessageFormalizations',
	'',
	19,
	1,
	'// first resolve those messages drawn directly to
// self
select many messages related by self->SQ_P[R930]->MSG_M[R1007];
for each message in messages
  select one syncMessage related by message->MSG_SM[R1018];
  if(not_empty syncMessage)
    // skip if informal
    if(not syncMessage.isFormal)
      continue;
    end if;
    select one funcMsg related by syncMessage->MSG_F[R1020];
    select one funcProxy related by funcMsg->S_SYNC[R1010];
    // we match by name
    select any function related by self->EP_PKG[R956]->PE_PE[R8000]
                        ->S_SYNC[R8001] where (selected.Name == funcProxy.Name);
    if(not_empty function)
      syncMessage.formalizeWithFunction(functionId:function.Sync_ID);
    else
      // otherwise unformalize the message
      syncMessage.unformalize();
    end if;
  end if;
end for;
// now process all messages that go to our lifespan
select one ls related by self->SQ_P[R930]->SQ_LS[R940];
if(not_empty ls)
  select many messages related by ls->SQ_P[R930]->MSG_M[R1007];
  for each message in messages
    select one syncMessage related by message->MSG_SM[R1018];
    if(not_empty syncMessage)
      // skip if informal
      if(not syncMessage.isFormal)
        continue;
      end if;
      select one funcMsg related by syncMessage->MSG_F[R1020];
      select one funcProxy related by funcMsg->S_SYNC[R1010];
      // we match by name
      select any function related by self->EP_PKG[R956]->PE_PE[R8000]
                        ->S_SYNC[R8001] where (selected.Name == funcProxy.Name);
      if(not_empty function)
        syncMessage.formalizeWithFunction(functionId:function.Sync_ID);
      else
        // otherwise unformalize the message
        syncMessage.unformalize();
      end if;
    end if;
  end for;
end if;',
	1,
	'',
	3695);
INSERT INTO O_TFR
	VALUES (3697,
	3561,
	'getConfigurationInheritanceElementId',
	'',
	317,
	1,
	'select one pkg related by self->EP_PKG[R956];
if(not_empty pkg)
  return pkg.convertToInstance();
end if;
return self.convertToInstance();',
	1,
	'',
	3696);
INSERT INTO O_REF
	VALUES (3561,
	703,
	0,
	743,
	3544,
	3562,
	3545,
	3698,
	3699,
	0,
	0,
	'',
	'Interaction Participant',
	'Part_ID',
	'R930');
INSERT INTO O_RATTR
	VALUES (3698,
	3561,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (3698,
	3561,
	0,
	'Part_ID',
	'',
	'',
	'Part_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (3561,
	2798,
	0,
	2825,
	3616,
	3617,
	3618,
	3700,
	3701,
	0,
	0,
	'',
	'Package',
	'Package_ID',
	'R956');
INSERT INTO O_RATTR
	VALUES (3700,
	3561,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (3700,
	3561,
	3698,
	'Package_ID',
	'',
	'',
	'Package_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (3702,
	3561,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one packageableElem related by self->SQ_P[R930]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;

if (isInGenericPackage)
  select one pkg related by self->EP_PKG[R956];
  if(not_empty pkg)
    self.Label = pkg.Name;
  else
    self.Label = self.InformalName;
  end if;
else
   self.Label = "";
end if;',
	1);
INSERT INTO O_BATTR
	VALUES (3702,
	3561);
INSERT INTO O_ATTR
	VALUES (3702,
	3561,
	3700,
	'Label',
	'User_Visible:false',
	'',
	'Label',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3703,
	3561);
INSERT INTO O_BATTR
	VALUES (3703,
	3561);
INSERT INTO O_ATTR
	VALUES (3703,
	3561,
	3702,
	'InformalName',
	'Full Name: Informal Function Package Name',
	'',
	'InformalName',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3704,
	3561);
INSERT INTO O_BATTR
	VALUES (3704,
	3561);
INSERT INTO O_ATTR
	VALUES (3704,
	3561,
	3703,
	'Descrip',
	'Full Name: Package Participant
Description: A textual description of this package.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (3705,
	3561,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one packageableElem related by self->SQ_P[R930]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;

if (isInGenericPackage)
  select one pkg related by self->EP_PKG[R956];
  self.isFormal = not empty pkg;
else
self.isFormal =false;
//  select one fp related by self->EP_PKG[R956];
//  self.isFormal = not empty fp;
end if;
',
	1);
INSERT INTO O_BATTR
	VALUES (3705,
	3561);
INSERT INTO O_ATTR
	VALUES (3705,
	3561,
	3704,
	'isFormal',
	'Full Name: Is Formal',
	'',
	'isFormal',
	0,
	316,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3561);
INSERT INTO O_OIDA
	VALUES (3698,
	3561,
	0,
	'Part_ID');
INSERT INTO O_ID
	VALUES (1,
	3561);
INSERT INTO O_ID
	VALUES (2,
	3561);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3538,
	'Lifespan',
	901,
	'SQ_LS',
	'This class represents the span of life that a participating instance has in a
sequence.',
	3521);
INSERT INTO O_TFR
	VALUES (3706,
	3538,
	'get_style',
	'',
	784,
	1,
	'if(param.at == End::End)
  if(self.Destroyed)
    return Style::Cross;
  end if;
end if;
return Style::DashDouble;',
	1,
	'',
	3707);
INSERT INTO O_TPARM
	VALUES (3708,
	3706,
	'at',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3709,
	3538,
	'get_connector_text',
	'',
	322,
	1,
	'return "";',
	1,
	'',
	3710);
INSERT INTO O_TPARM
	VALUES (3711,
	3709,
	'Obj_ID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (3712,
	3709,
	'Obj_TypeIsImported',
	316,
	0,
	'',
	3711,
	'');
INSERT INTO O_TPARM
	VALUES (3713,
	3709,
	'at',
	880,
	0,
	'',
	3712,
	'');
INSERT INTO O_TPARM
	VALUES (3714,
	3709,
	'parent_ID',
	296,
	0,
	'',
	3713,
	'');
INSERT INTO O_TFR
	VALUES (3710,
	3538,
	'dispose',
	'',
	19,
	1,
	'select many marks related by self->SQ_TM[R931];
for each mark in marks
  unrelate self from mark across R931;
  mark.dispose();
end for;
select one participant related by self->SQ_P[R930];
if(not_empty participant)
  participant.dispose();
end if;
select one part related by self->SQ_P[R940];
if(not_empty part)
  unrelate self from part across R940;
end if;
delete object instance self;',
	1,
	'',
	3715);
INSERT INTO O_TFR
	VALUES (3707,
	3538,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Part_ID;',
	1,
	'',
	3716);
INSERT INTO O_TFR
	VALUES (3716,
	3538,
	'get_name',
	'',
	322,
	1,
	'select one part related by self->SQ_P[R940];
if(not_empty part)
  return part.getLabel() + " Communication Link";
end if;
return "";',
	1,
	'',
	3709);
INSERT INTO O_TFR
	VALUES (3715,
	3538,
	'actionFilter',
	'',
	316,
	1,
	'if(param.name == "can")
  select one participant related by self->SQ_P[R940];
  select one compPart related by participant->SQ_COP[R930];
  select one instPart related by participant->SQ_CIP[R930];
  if(not_empty compPart or not_empty instPart)
    if(param.value == "destroy")
      return self.Destroyed == false;
    end if;
    if(param.value == "undestroy")
      return self.Destroyed == true;
    end if;
  end if;
end if;
return false;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (3717,
	3715,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (3718,
	3715,
	'value',
	322,
	0,
	'',
	3717,
	'');
INSERT INTO O_NBATTR
	VALUES (3719,
	3538);
INSERT INTO O_BATTR
	VALUES (3719,
	3538);
INSERT INTO O_ATTR
	VALUES (3719,
	3538,
	3720,
	'Descrip',
	'Full Name:  Communication Line Description
Description: A textual description of this communication line.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3721,
	3538);
INSERT INTO O_BATTR
	VALUES (3721,
	3538);
INSERT INTO O_ATTR
	VALUES (3721,
	3538,
	3719,
	'Destroyed',
	'Full Name: Is Destructed',
	'',
	'Destroyed',
	0,
	316,
	'',
	'');
INSERT INTO O_REF
	VALUES (3538,
	703,
	0,
	743,
	3544,
	3556,
	3545,
	3540,
	3722,
	0,
	0,
	'',
	'Interaction Participant',
	'Part_ID',
	'R930');
INSERT INTO O_RATTR
	VALUES (3540,
	3538,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (3540,
	3538,
	0,
	'Part_ID',
	'',
	'',
	'Part_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (3538,
	703,
	0,
	743,
	3607,
	3609,
	3608,
	3720,
	3723,
	0,
	0,
	'',
	'Interaction Participant',
	'Part_ID',
	'R940');
INSERT INTO O_RATTR
	VALUES (3720,
	3538,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (3720,
	3538,
	3540,
	'Source_Part_ID',
	'',
	'Source_',
	'Part_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3538);
INSERT INTO O_OIDA
	VALUES (3540,
	3538,
	0,
	'Part_ID');
INSERT INTO O_ID
	VALUES (1,
	3538);
INSERT INTO O_ID
	VALUES (2,
	3538);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (703,
	'Interaction Participant',
	914,
	'SQ_P',
	'The class represents a participant of a sequence.  The possible participants are
Class Instance, Class, Function Package, External Entity, and Lifespan.',
	3521);
INSERT INTO O_TFR
	VALUES (3724,
	703,
	'dispose',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one eep related by self->SQ_EEP[R930];
select one fpp related by self->SQ_FPP[R930];
select one cp related by self->SQ_CP[R930];
select one cip related by self->SQ_CIP[R930];
select one ls related by self->SQ_LS[R930];
select one ap related by self->SQ_AP[R930];
select one ucp related by self->IA_UCP[R930];
select one cop related by self->SQ_COP[R930];
select one pp  related by  self->SQ_PP[R930];
if(not_empty cop)
  unrelate self from cop across R930;
  cop.dispose();
end if;
if(not_empty eep)
  unrelate self from eep across R930;
  eep.dispose();
end if;
if(not_empty fpp)
  unrelate self from fpp across R930;
  fpp.dispose();
end if;
if(not_empty pp)
  unrelate self from pp across R930;
  pp.dispose();
end if;
if(not_empty cp)
  unrelate self from cp across R930;
  cp.dispose();
end if;
if(not_empty cip)
  unrelate self from cip across R930;
  cip.dispose();
end if;
if(not_empty ls)
  unrelate self from ls across R930;
  ls.dispose();
end if;
if(not_empty ap)
  unrelate self from ap across R930;
  ap.dispose();
end if;
if(not_empty ucp)
  unrelate self from ucp across R930;
  ucp.dispose();
end if;
select many messages related by self->MSG_M[R1007];
for each message in messages
  message.dispose();
end for;
select many messages related by self->MSG_M[R1008];
for each message in messages
  message.dispose();
end for;
select one sequence related by self->SQ_S[R929];
if(not_empty sequence)
  unrelate self from sequence across R929;
end if;
// dispose or unrelate communication associations
select one pic related by self->COMM_PIC[R1126];
if(not_empty pic)
  select one comm related by pic->COMM_COMM[R1126];
  if (not_empty comm)
    unrelate self from comm across R1126 using pic;
  end if;
  delete object instance pic;
end if;
select many comAssocs related by self->COMM_LNK[R1133];
for each comAssoc in comAssocs
  comAssoc.dispose();
end for;
select many comAssocs related by self->COMM_LNK[R1134];
for each comAssoc in comAssocs
  comAssoc.dispose();
end for;
select one piuc related by self->UC_PIUC[R1203];
if(not_empty piuc)
  select one ucc related by piuc->UC_UCC[R1203];
  if (not_empty ucc)
    unrelate self from ucc across R1203 using piuc;
  end if;
  delete object instance piuc;
end if;
select many startUcas related by self->UC_UCA[R1206];
for each uca in startUcas
  unrelate self from uca across R1206;
  uca.dispose();
end for;
select many endUcas related by self->UC_UCA[R1207];
for each uca in endUcas
  unrelate self from uca across R1207;
  uca.dispose();
end for;
// dispose lifespan connected to this participant
select one lifespan related by self->SQ_LS[R940];
if(not_empty lifespan)
  unrelate self from lifespan across R940;
  lifespan.dispose();
end if;
//select one pip related by self->PE_PIP[R8009];
//if (not_empty pip)
//  select one pkg related by self->EP_PKG[R8009];
//  unrelate self from pkg across R8009 using pip;
//  delete object instance pip;
//end if;
//select one pip related by self->PE_PIP[R8010];
//if (not_empty pip)
//  select one pkg related by self->EP_PKG[R8010];
//  unrelate self from pkg across R8010 using pip;
//  delete object instance pip;
//end if;
select one pe related by self->PE_PE[R8001];
if (not_empty pe)
  unrelate self from pe across R8001;
  pe.dispose();
end if;
delete object instance self;',
	1,
	'',
	3725);
INSERT INTO O_TFR
	VALUES (3726,
	703,
	'getMessageCompartmentText',
	'',
	322,
	1,
	'/**
 *
 *  This operation returns a string value representing the message
 *  compartment of a participant, excluding any duplicates.
 *
 */
select many msgs related by self->MSG_M[R1007];
result = "";
for each msg in msgs
  // exclude any return messages
  select one returnMessage related by msg->MSG_R[R1018];
  if(empty returnMessage)
    result = result + msg.getName();
    select many args related by msg->MSG_A[R1000];
    if(not_empty args)
      result = result + "(";     
    end if;
    count = 0;
    for each arg in args
      count = count + 1;
      result = result + arg.Label;
      if(count != cardinality args)
  	    result = result + ", ";          
      end if;
    end for;
    if(not_empty args)
      result = result + ")";
    end if;
    result = result + GD::newline();
  end if;
end for;
select one communicationLine related by self->SQ_LS[R940]->SQ_P[R930];
if(not_empty communicationLine)
  result = result + communicationLine.getMessageCompartmentText();
end if;
return Util::removeDuplicateStrings(completeString:result,
                                                       separator:GD::newline());',
	1,
	'',
	3727);
INSERT INTO O_TFR
	VALUES (3727,
	703,
	'getLabel',
	'',
	322,
	1,
	'select one cip related by self->SQ_CIP[R930];
if(not_empty cip)
  return cip.Name;
end if;
select one ap related by self->SQ_AP[R930];
if(not_empty ap)
  return ap.Name;
end if;
return "";
',
	1,
	'',
	3724);
INSERT INTO O_TFR
	VALUES (3725,
	703,
	'definedAtSystemLevel',
	'',
	316,
	1,
	'select one sequence related by self->SQ_S[R929];
select one comm related by self->COMM_COMM[R1126];
if(not_empty sequence)
  select one domain related by sequence->S_DOM[R913];
  select one ss related by sequence->S_SS[R914];
  select one sis related by sequence->SQ_SIS[R928];
  if(empty domain and empty ss and empty sis)
    return true;
  end if;
elif(not_empty comm)
  select one domain related by comm->S_DOM[R1132];
  select one ss related by comm->S_SS[R1131];
  select one sis related by comm->COMM_CIC[R1129];
  if(empty domain and empty ss and empty sis)
    return true;
  end if;
end if;
return false;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (3728,
	703,
	'getSystemId',
	'',
	296,
	1,
	'// Interaction Participant.getSystemId()
// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one packageableElem related by self->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;
if (isInGenericPackage)
  if not_empty package
    return package.getSystemId();
  elif not_empty component
    return component.getSystemId();
  end if; 
else
  select one sequence related by self->SQ_S[R929];
  select one comm related by self->COMM_COMM[R1126];
  if(not_empty sequence)
    return sequence.getSystemId();
  elif(not_empty comm)
    return comm.getSystemId();
  end if;
end if;
USER::logError(msg:"Interaction Participant.getSystemId: No parent found.",path:"");
return GD::NULL_UNIQUE_ID();',
	1,
	'',
	3726);
INSERT INTO O_REF
	VALUES (703,
	2144,
	0,
	2156,
	2158,
	2160,
	2159,
	3729,
	3730,
	0,
	0,
	'',
	'Sequence',
	'Package_ID',
	'R929');
INSERT INTO O_RATTR
	VALUES (3729,
	703,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (3729,
	703,
	743,
	'Sequence_Package_ID',
	'',
	'Sequence_',
	'Package_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (703,
	26,
	0,
	25,
	868,
	2828,
	870,
	743,
	3731,
	0,
	0,
	'',
	'Packageable Element',
	'Element_ID',
	'R8001');
INSERT INTO O_RATTR
	VALUES (743,
	703,
	25,
	26,
	0,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (743,
	703,
	0,
	'Part_ID',
	'',
	'',
	'Part_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	703);
INSERT INTO O_OIDA
	VALUES (743,
	703,
	0,
	'Part_ID');
INSERT INTO O_ID
	VALUES (1,
	703);
INSERT INTO O_ID
	VALUES (2,
	703);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3580,
	'Instance Attribute Value',
	918,
	'SQ_AV',
	'This class represents an instances attribute along with its value.  These may
be informal or directly derived from their formal model counterpart, i.e a real
instances attributes.',
	3521);
INSERT INTO O_TFR
	VALUES (3732,
	3580,
	'dispose',
	'',
	19,
	1,
	'select one attr related by self->O_ATTR[R938];
if(not_empty attr)
  unrelate self from attr across R938;
  select one cip related by self->SQ_CIP[R937];
  if(not_empty cip)
    unrelate self from cip across R937;
  end if;
  select one fav related by self->SQ_FAV[R948];
  if (not_empty fav)
    unrelate self from fav across R948;
    delete object instance fav;
  end if;
end if;
select one cip related by self->SQ_CIP[R936];
if(not_empty cip)
  unrelate cip from self across R936;
end if;
select one iav related by self->SQ_IAV[R948];
if(not_empty iav)
  unrelate self from iav across R948;
  delete object instance iav;
end if;
delete object instance self;',
	1,
	'',
	3733);
INSERT INTO O_TFR
	VALUES (3734,
	3580,
	'initialize',
	'',
	19,
	1,
	'name = "Informal Attribute";
success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:false);    
if ( success!="") 
 self.InformalName =success;
else 
 self.dispose();
end if; ',
	1,
	'',
	3735);
INSERT INTO O_TFR
	VALUES (3735,
	3580,
	'get_name',
	'',
	322,
	1,
	'return self.Label;',
	1,
	'',
	3732);
INSERT INTO O_TFR
	VALUES (3733,
	3580,
	'canRename',
	'',
	316,
	1,
	'return not self.isFormal;',
	1,
	'',
	3736);
INSERT INTO O_TFR
	VALUES (3736,
	3580,
	'canDelete',
	'',
	316,
	1,
	'return not self.isFormal;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (3737,
	3580,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'return this;',
	0,
	'',
	3738);
INSERT INTO O_TFR
	VALUES (3738,
	3580,
	'resolveAttributeLocal',
	'',
	19,
	1,
	'select one attrProxy related by self->O_ATTR[R938];
// if the component is not actually a proxy this imported
// component has already been handled
if(not_empty attrProxy) and
                    (Util::isProxy(element:attrProxy.convertToInstance()))
                       and (not Util::isProxy(element:self.convertToInstance()))
  // the parent of self should already have been resolved, so just check
  // the available attributes in the formal case
  // match by name
  select any attribute related by self->SQ_CIP[R937]->O_OBJ[R934]
                         ->O_ATTR[R102] where (selected.Name == attrProxy.Name);
  if(not_empty attribute)
    // update the association
    relate self to attribute across R938;
  else
    // otherwise remove this formal attr value
    self.dispose();
  end if;
end if;',
	1,
	'',
	3734);
INSERT INTO O_NBATTR
	VALUES (3602,
	3580);
INSERT INTO O_BATTR
	VALUES (3602,
	3580);
INSERT INTO O_ATTR
	VALUES (3602,
	3580,
	0,
	'Av_ID',
	'',
	'',
	'Av_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_REF
	VALUES (3580,
	37,
	0,
	168,
	3587,
	3588,
	3589,
	3739,
	3740,
	0,
	0,
	'',
	'Attribute',
	'Attr_ID',
	'R938');
INSERT INTO O_RATTR
	VALUES (3739,
	3580,
	168,
	37,
	1,
	'Attr_ID');
INSERT INTO O_ATTR
	VALUES (3739,
	3580,
	3741,
	'Attr_ID',
	'',
	'',
	'Attr_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (3742,
	3580,
	'select one attr related by self->O_ATTR[R938];
if(not_empty attr)
  if(self.Value != "")
    self.Label = attr.Name + " = " + self.Value;
  else
    self.Label = attr.Name;
  end if;
else
  if(self.Value != "")
    self.Label = self.InformalName + " = " + self.Value;
  else
    self.Label = self.InformalName;
  end if;
end if;',
	1);
INSERT INTO O_BATTR
	VALUES (3742,
	3580);
INSERT INTO O_ATTR
	VALUES (3742,
	3580,
	3739,
	'Label',
	'User_Visible:false',
	'',
	'Label',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3743,
	3580);
INSERT INTO O_BATTR
	VALUES (3743,
	3580);
INSERT INTO O_ATTR
	VALUES (3743,
	3580,
	3742,
	'Value',
	'Full Name: Attribute Value',
	'',
	'Value',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3744,
	3580);
INSERT INTO O_BATTR
	VALUES (3744,
	3580);
INSERT INTO O_ATTR
	VALUES (3744,
	3580,
	3743,
	'InformalName',
	'Full Name: Informal Attribute Name',
	'',
	'InformalName',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3745,
	3580);
INSERT INTO O_BATTR
	VALUES (3745,
	3580);
INSERT INTO O_ATTR
	VALUES (3745,
	3580,
	3746,
	'Descrip',
	'Full Name: Instance Attribute Description
Description: A textual description of this instance attribute.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (3747,
	3580,
	'select one inst related by self->SQ_CIP[R937];
self.isFormal = not_empty inst;',
	1);
INSERT INTO O_BATTR
	VALUES (3747,
	3580);
INSERT INTO O_ATTR
	VALUES (3747,
	3580,
	3745,
	'isFormal',
	'Full Name: Is Formal',
	'',
	'isFormal',
	0,
	316,
	'',
	'');
INSERT INTO O_REF
	VALUES (3580,
	3546,
	0,
	3583,
	3579,
	3581,
	3582,
	3748,
	3749,
	0,
	0,
	'',
	'Class Instance Participant',
	'Part_ID',
	'R936');
INSERT INTO O_RATTR
	VALUES (3748,
	3580,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (3748,
	3580,
	3744,
	'Informal_Part_ID',
	'',
	'Informal_',
	'Part_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (3580,
	3546,
	0,
	3583,
	3584,
	3585,
	3586,
	3746,
	3750,
	0,
	0,
	'',
	'Class Instance Participant',
	'Part_ID',
	'R937');
INSERT INTO O_RATTR
	VALUES (3746,
	3580,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (3746,
	3580,
	3748,
	'Formal_Part_ID',
	'',
	'Formal_',
	'Part_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (3580,
	37,
	0,
	169,
	3587,
	3588,
	3589,
	3741,
	3751,
	0,
	0,
	'',
	'Attribute',
	'Obj_ID',
	'R938');
INSERT INTO O_RATTR
	VALUES (3741,
	3580,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (3741,
	3580,
	3602,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3580);
INSERT INTO O_OIDA
	VALUES (3602,
	3580,
	0,
	'Av_ID');
INSERT INTO O_ID
	VALUES (1,
	3580);
INSERT INTO O_ID
	VALUES (2,
	3580);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3603,
	'Informal Attribute Value',
	924,
	'SQ_IAV',
	'This class is used to capture the fact that an Instance Attribute Value is
informal.  Clients may use the association between this class and its parent to
determine the above fact.',
	3521);
INSERT INTO O_REF
	VALUES (3603,
	3580,
	0,
	3602,
	3600,
	3604,
	3601,
	3752,
	3753,
	0,
	0,
	'',
	'Instance Attribute Value',
	'Av_ID',
	'R948');
INSERT INTO O_RATTR
	VALUES (3752,
	3603,
	3602,
	3580,
	1,
	'Av_ID');
INSERT INTO O_ATTR
	VALUES (3752,
	3603,
	0,
	'Av_ID',
	'',
	'',
	'Av_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3603);
INSERT INTO O_OIDA
	VALUES (3752,
	3603,
	0,
	'Av_ID');
INSERT INTO O_ID
	VALUES (1,
	3603);
INSERT INTO O_ID
	VALUES (2,
	3603);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3596,
	'Informal Attribute',
	921,
	'SQ_IA',
	'This class is used to capture the fact that a Class Participant Attribute is
informal.  Clients may use the association between this class and its parent to
determine the above fact.',
	3521);
INSERT INTO O_REF
	VALUES (3596,
	3577,
	0,
	3595,
	3593,
	3597,
	3594,
	3754,
	3755,
	0,
	0,
	'',
	'Class Participant Attribute',
	'Ia_ID',
	'R947');
INSERT INTO O_RATTR
	VALUES (3754,
	3596,
	3595,
	3577,
	1,
	'Ia_ID');
INSERT INTO O_ATTR
	VALUES (3754,
	3596,
	0,
	'Ia_ID',
	'',
	'',
	'Ia_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3596);
INSERT INTO O_OIDA
	VALUES (3754,
	3596,
	0,
	'Ia_ID');
INSERT INTO O_ID
	VALUES (1,
	3596);
INSERT INTO O_ID
	VALUES (2,
	3596);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3550,
	'Function Package Participant',
	916,
	'SQ_FPP',
	'This class represents a function package which is participating in a sequence.',
	3521);
INSERT INTO O_TFR
	VALUES (3756,
	3550,
	'dispose',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one participant related by self->SQ_P[R930];
if(not_empty participant)
  participant.dispose();
else
  select one fp related by self->S_FPK[R932];
  if(not_empty fp)
    unrelate fp from self across R932;
  end if;
  delete object instance self;
end if;',
	1,
	'',
	3757);
INSERT INTO O_TFR
	VALUES (3758,
	3550,
	'initialize',
	'',
	19,
	1,
	'self.InformalName = "Informal Function Package";',
	1,
	'',
	3759);
INSERT INTO O_TFR
	VALUES (3760,
	3550,
	'get_style',
	'',
	784,
	1,
	'return Style::Folder;',
	1,
	'',
	3761);
INSERT INTO O_TFR
	VALUES (3759,
	3550,
	'get_text_style',
	'',
	784,
	1,
	'return Style::None;',
	1,
	'',
	3760);
INSERT INTO O_TPARM
	VALUES (3762,
	3759,
	'comp_num',
	298,
	0,
	'',
	3763,
	'');
INSERT INTO O_TPARM
	VALUES (3764,
	3759,
	'ent_num',
	298,
	0,
	'',
	3762,
	'');
INSERT INTO O_TPARM
	VALUES (3763,
	3759,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3765,
	3550,
	'get_compartments',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	3766);
INSERT INTO O_TFR
	VALUES (3767,
	3550,
	'get_entries',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	3765);
INSERT INTO O_TPARM
	VALUES (3768,
	3767,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3761,
	3550,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Part_ID;',
	1,
	'',
	3769);
INSERT INTO O_TFR
	VALUES (3766,
	3550,
	'get_compartment_text',
	'',
	322,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
result = "";

select one fpk related by self->S_FPK[R932];
result = "";
if (param.at == Justification::Center_in_X)
    result = "function";
end if;
if(not_empty fpk)
  if(param.at == Justification::Center)
    result = fpk.getPath();
  end if;
else
  if (param.at == Justification::Center)
    result = self.InformalName;
  end if;
end if;
return result;',
	1,
	'',
	3770);
INSERT INTO O_TPARM
	VALUES (3771,
	3766,
	'comp_num',
	298,
	0,
	'',
	3772,
	'');
INSERT INTO O_TPARM
	VALUES (3773,
	3766,
	'ent_num',
	298,
	0,
	'',
	3771,
	'');
INSERT INTO O_TPARM
	VALUES (3772,
	3766,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3774,
	3550,
	'actionFilter',
	'',
	316,
	1,
	'if(param.name == "can")
  // if the current action is one which requires
  // this element to be selected along with a
  // synchronous message
  if(param.value == "formCommFunc")
    // no formalization support yet at system level
    if(self.definedAtSystemLevel())
      return false;
    end if;
    // if the selection count is not equal two return false, this
    // prevents the menu entries from existing while only one of the
    // elements is selected
    if(Sel::getCurrentSelectionCount() != 2)
      return false;
    end if;
    // return true if this participant represents
    // a function package which contains at least
    // one function
    return self.formalFPKHasFunctions();
  end if;
  if(param.value == "unform")
    return self.isFormal;
  end if;
end if;
return false;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (3775,
	3774,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (3776,
	3774,
	'value',
	322,
	0,
	'',
	3775,
	'');
INSERT INTO O_TFR
	VALUES (3777,
	3550,
	'unformalize',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one part related by self->SQ_P[R930];

select one fpk related by self->S_FPK[R932];
if(not_empty fpk)
  unrelate self from fpk across R932;
end if;

select many messages related by part->MSG_M[R1007];
for each message in messages
  message.unformalize();
end for;
// unformalize any communication links connected
// to this instance
select many links related by part->COMM_LNK[R1133];
for each link in links
  link.unformalize();
end for;',
	1,
	'',
	3758);
INSERT INTO O_TFR
	VALUES (3769,
	3550,
	'get_name',
	'',
	322,
	1,
	'return self.Label;',
	1,
	'',
	3767);
INSERT INTO O_TFR
	VALUES (3778,
	3550,
	'canRename',
	'',
	316,
	1,
	'return not self.isFormal;',
	1,
	'',
	3774);
INSERT INTO O_TFR
	VALUES (3770,
	3550,
	'formalize',
	'',
	19,
	1,
	'select any fp from instances of S_FPK where (selected.FunPack_ID == param.fpId);
if(self.isFormal)
  self.unformalize();
end if;
if (not_empty fp)
  relate self to fp across R932;
end if;',
	1,
	'',
	3779);
INSERT INTO O_TPARM
	VALUES (3780,
	3770,
	'fpId',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3779,
	3550,
	'formalFPKHasFunctions',
	'This operations returns true if the function package that this participant
represents contains at least one function.',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one packageableElem related by self->SQ_P[R930]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;

if (isInGenericPackage)
 /*// select one pkg related by self->SQ_P[R930]->EP_PKG[R8009];
  if(not_empty pkg)
    select many funcs related by pkg->PE_PE[R8000]->S_SYNC[R8001];
    return not_empty funcs;
  end if;*/
  return false;
else
  select one fpk related by self->S_FPK[R932];
  if(not_empty fpk)
    select many funcs related by fpk->S_FIP[R31]->S_SYNC[R31];
    return not_empty funcs;
  end if;
  return false;
end if;
',
	1,
	'',
	3756);
INSERT INTO O_TFR
	VALUES (3757,
	3550,
	'definedAtSystemLevel',
	'',
	316,
	1,
	'select one part related by self->SQ_P[R930];
return part.definedAtSystemLevel();',
	1,
	'',
	3778);
INSERT INTO O_TFR
	VALUES (3781,
	3550,
	'getFunctionCount',
	'',
	298,
	1,
	'if(self.isFormal)
  select many funcs related by self->S_FPK[R932]->S_FIP[R31]->S_SYNC[R31];
  return cardinality funcs;
end if;
return 0;',
	1,
	'',
	3777);
INSERT INTO O_TFR
	VALUES (3782,
	3550,
	'resolveFunctionPackage',
	'',
	19,
	1,
	'select one proxyPkg related by self->S_FPK[R932];
if(not_empty proxyPkg and not Util::isProxy(element:self.convertToInstance()))
  pkg = proxyPkg;
  // try to resolve the package by name
  select any pkg from instances of S_FPK where (selected.Name == proxyPkg.Name);
  pkgResolved = not_empty pkg;
  if(pkgResolved)
    relate self to pkg across R932;
    self.resolveMessageFormalizations();
  else
    // unformalize this PP
    self.unformalize();
  end if;
end if;',
	1,
	'',
	3781);
INSERT INTO O_TFR
	VALUES (3783,
	3550,
	'convertToInstance',
	'Translate:native',
	317,
	1,
	'return this;',
	0,
	'',
	3782);
INSERT INTO O_TFR
	VALUES (3784,
	3550,
	'resolveMessageFormalizations',
	'',
	19,
	1,
	'// first resolve those messages drawn directly to
// self
select many messages related by self->SQ_P[R930]->MSG_M[R1007];
for each message in messages
  select one syncMessage related by message->MSG_SM[R1018];
  if(not_empty syncMessage)
    // skip if informal
    if(not syncMessage.isFormal)
      continue;
    end if;
    select one funcMsg related by syncMessage->MSG_F[R1020];
    select one funcProxy related by funcMsg->S_SYNC[R1010];
    // we match by name
    select any function related by self->S_FPK[R932]->S_FIP[R31]->S_SYNC[R31]
                                        where (selected.Name == funcProxy.Name);
    if(not_empty function)
      syncMessage.formalizeWithFunction(functionId:function.Sync_ID);
    else
      // otherwise unformalize the message
      syncMessage.unformalize();
    end if;
  end if;
end for;
// now process all messages that go to our lifespan
select one ls related by self->SQ_P[R930]->SQ_LS[R940];
if(not_empty ls)
  select many messages related by ls->SQ_P[R930]->MSG_M[R1007];
  for each message in messages
    select one syncMessage related by message->MSG_SM[R1018];
    if(not_empty syncMessage)
      // skip if informal
      if(not syncMessage.isFormal)
        continue;
      end if;
      select one funcMsg related by syncMessage->MSG_F[R1020];
      select one funcProxy related by funcMsg->S_SYNC[R1010];
      // we match by name
      select any function related by self->S_FPK[R932]->S_FIP[R31]->S_SYNC[R31]
                                        where (selected.Name == funcProxy.Name);
      if(not_empty function)
        syncMessage.formalizeWithFunction(functionId:function.Sync_ID);
      else
        // otherwise unformalize the message
        syncMessage.unformalize();
      end if;
    end if;
  end for;
end if;',
	1,
	'',
	3783);
INSERT INTO O_TFR
	VALUES (3785,
	3550,
	'getConfigurationInheritanceElementId',
	'',
	317,
	1,
	'select one fpk related by self->S_FPK[R932];
if(not_empty fpk)
  return fpk.convertToInstance();
end if;
return self.convertToInstance();',
	1,
	'',
	3784);
INSERT INTO O_REF
	VALUES (3550,
	3523,
	0,
	3566,
	3563,
	3564,
	3565,
	3786,
	3787,
	0,
	0,
	'',
	'Function Package',
	'FunPack_ID',
	'R932');
INSERT INTO O_RATTR
	VALUES (3786,
	3550,
	3566,
	3523,
	1,
	'FunPack_ID');
INSERT INTO O_ATTR
	VALUES (3786,
	3550,
	3788,
	'FunPack_ID',
	'',
	'',
	'FunPack_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (3789,
	3550,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one packageableElem related by self->SQ_P[R930]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;

if (isInGenericPackage)
 // select one pkg related by self->SQ_P[R930]->EP_PKG[R8009];
//  if(not_empty pkg)
//    self.Label = pkg.Name;
//  else
    self.Label = self.InformalName;
//  end if;
else
  select one fpk related by self->S_FPK[R932];
  if(not_empty fpk)
    self.Label = fpk.Name;
  else
    self.Label = self.InformalName;
  end if;
end if;',
	1);
INSERT INTO O_BATTR
	VALUES (3789,
	3550);
INSERT INTO O_ATTR
	VALUES (3789,
	3550,
	3786,
	'Label',
	'User_Visible:false',
	'',
	'Label',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3790,
	3550);
INSERT INTO O_BATTR
	VALUES (3790,
	3550);
INSERT INTO O_ATTR
	VALUES (3790,
	3550,
	3789,
	'InformalName',
	'Full Name: Informal Function Package Name',
	'',
	'InformalName',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3791,
	3550);
INSERT INTO O_BATTR
	VALUES (3791,
	3550);
INSERT INTO O_ATTR
	VALUES (3791,
	3550,
	3790,
	'Descrip',
	'Full Name: Function Package Description
Description: A textual description of this function package.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (3792,
	3550,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one packageableElem related by self->SQ_P[R930]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;

if (isInGenericPackage)
//  select one pkg related by self->SQ_P[R930]->EP_PKG[R8009];
//  self.isFormal = not empty pkg;
    self.isFormal = false;
else
  select one fp related by self->S_FPK[R932];
  self.isFormal = not empty fp;
end if;',
	1);
INSERT INTO O_BATTR
	VALUES (3792,
	3550);
INSERT INTO O_ATTR
	VALUES (3792,
	3550,
	3791,
	'isFormal',
	'Full Name: Is Formal',
	'',
	'isFormal',
	0,
	316,
	'',
	'');
INSERT INTO O_REF
	VALUES (3550,
	703,
	0,
	743,
	3544,
	3551,
	3545,
	3788,
	3793,
	0,
	0,
	'',
	'Interaction Participant',
	'Part_ID',
	'R930');
INSERT INTO O_RATTR
	VALUES (3788,
	3550,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (3788,
	3550,
	0,
	'Part_ID',
	'',
	'',
	'Part_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3550);
INSERT INTO O_OIDA
	VALUES (3788,
	3550,
	0,
	'Part_ID');
INSERT INTO O_ID
	VALUES (1,
	3550);
INSERT INTO O_ID
	VALUES (2,
	3550);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3605,
	'Formal Attribute Value',
	923,
	'SQ_FAV',
	'This class is used to capture the fact that an Instance Attribute Value is
formal.  Clients may use the association between this class and its parent to
determine the above fact.',
	3521);
INSERT INTO O_REF
	VALUES (3605,
	3580,
	0,
	3602,
	3600,
	3606,
	3601,
	3794,
	3795,
	0,
	0,
	'',
	'Instance Attribute Value',
	'Av_ID',
	'R948');
INSERT INTO O_RATTR
	VALUES (3794,
	3605,
	3602,
	3580,
	1,
	'Av_ID');
INSERT INTO O_ATTR
	VALUES (3794,
	3605,
	0,
	'Av_ID',
	'',
	'',
	'Av_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3605);
INSERT INTO O_OIDA
	VALUES (3794,
	3605,
	0,
	'Av_ID');
INSERT INTO O_ID
	VALUES (1,
	3605);
INSERT INTO O_ID
	VALUES (2,
	3605);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3598,
	'Formal Attribute',
	922,
	'SQ_FA',
	'This class is used to capture the fact that a Class Participant Attribute is
formal.  Clients may use the association between this class and its parent to
determine the above fact.',
	3521);
INSERT INTO O_REF
	VALUES (3598,
	3577,
	0,
	3595,
	3593,
	3599,
	3594,
	3796,
	3797,
	0,
	0,
	'',
	'Class Participant Attribute',
	'Ia_ID',
	'R947');
INSERT INTO O_RATTR
	VALUES (3796,
	3598,
	3595,
	3577,
	1,
	'Ia_ID');
INSERT INTO O_ATTR
	VALUES (3796,
	3598,
	0,
	'Ia_ID',
	'',
	'',
	'Ia_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3598);
INSERT INTO O_OIDA
	VALUES (3796,
	3598,
	0,
	'Ia_ID');
INSERT INTO O_ID
	VALUES (1,
	3598);
INSERT INTO O_ID
	VALUES (2,
	3598);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3548,
	'External Entity Participant',
	915,
	'SQ_EEP',
	'This class represents an external entity which is participating in a sequence.',
	3521);
INSERT INTO O_TFR
	VALUES (3798,
	3548,
	'dispose',
	'',
	19,
	1,
	'select one participant related by self->SQ_P[R930];
if(not_empty participant)
  participant.dispose();
else
  select one ee related by self->S_EE[R933];
  if(not_empty ee)
    unrelate ee from self across R933;
  end if;
  delete object instance self;
end if;',
	1,
	'',
	3799);
INSERT INTO O_TFR
	VALUES (3800,
	3548,
	'initialize',
	'',
	19,
	1,
	'name = "Informal External Entity";
success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:false);     
if ( success!="") 
self.InformalName =success;
else 
 self.dispose();
end if;  ',
	1,
	'',
	3801);
INSERT INTO O_TFR
	VALUES (3802,
	3548,
	'get_style',
	'',
	784,
	1,
	'return Style::Box;',
	1,
	'',
	3803);
INSERT INTO O_TFR
	VALUES (3804,
	3548,
	'get_entries',
	'',
	298,
	1,
	'select one ee related by self->S_EE[R933];
// if an ee is related
if(not_empty ee)
  // return what the ee would for the entry numbers
  return ee.get_entries(comp_num:param.comp_num);
end if;
if (param.comp_num == 1)
  return 1;
elif (param.comp_num == 2)
  // the ee participant does not handle EDI''s
  return 0;
elif (param.comp_num == 3)
  select one participant related by self->SQ_P[R930];
  compartmentText = participant.getMessageCompartmentText();
  lineCount = GD::numberOfLines(string:compartmentText);
  return lineCount;
else
  return 0;
end if;',
	1,
	'',
	3805);
INSERT INTO O_TPARM
	VALUES (3806,
	3804,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3805,
	3548,
	'get_compartments',
	'',
	298,
	1,
	'return 3;',
	1,
	'',
	3807);
INSERT INTO O_TFR
	VALUES (3801,
	3548,
	'get_text_style',
	'',
	784,
	1,
	'return Style::None;',
	1,
	'',
	3802);
INSERT INTO O_TPARM
	VALUES (3808,
	3801,
	'comp_num',
	298,
	0,
	'',
	3809,
	'');
INSERT INTO O_TPARM
	VALUES (3810,
	3801,
	'ent_num',
	298,
	0,
	'',
	3808,
	'');
INSERT INTO O_TPARM
	VALUES (3809,
	3801,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3807,
	3548,
	'get_compartment_text',
	'',
	322,
	1,
	'select one participant related by self->SQ_P[R930];
select one ee related by self->S_EE[R933];
if(not_empty ee)
  // if an ee is related to this participant
  // return what the ee would for the text
  if((param.comp_num == 1) and (param.ent_num == 1))
    if(param.at == Justification::Center_in_X)
      result = "external entity";    
      result = result + GD::newline();
      result = result + ee.getPath();
      return result;
    else
      return ee.get_compartment_text(comp_num:param.comp_num, ent_num:param.ent_num, at:param.at);
    end if;
  else
    return ee.get_compartment_text(comp_num:param.comp_num, ent_num:param.ent_num, at:param.at);
  end if;
else
  result = "";
  if (param.comp_num == 1)
    if (param.ent_num == 1)
      if (param.at == Justification::Center_in_X)
        result = self.InformalName;
      end if;
    end if;
  elif (param.comp_num == 3)
    if (param.at == Justification::Left)
      cursor = 1;
      select many msgs related by self->SQ_P[R930]->MSG_M[R1007];
      if (not_empty msgs and param.ent_num == 1)
        result = "operation";
        result = result + GD::newline();
        // process the drawing only once
        // this logic will fill compartment 3
        if (param.ent_num == 1)
          return result + Util::removeDuplicateStrings(completeString:participant.getMessageCompartmentText(), separator:GD::newline());
        end if;        
      end if;
    end if;
  end if;
  return result;
end if;',
	1,
	'',
	3811);
INSERT INTO O_TPARM
	VALUES (3812,
	3807,
	'comp_num',
	298,
	0,
	'',
	3813,
	'');
INSERT INTO O_TPARM
	VALUES (3814,
	3807,
	'ent_num',
	298,
	0,
	'',
	3812,
	'');
INSERT INTO O_TPARM
	VALUES (3813,
	3807,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3803,
	3548,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Part_ID;',
	1,
	'',
	3815);
INSERT INTO O_TFR
	VALUES (3816,
	3548,
	'actionFilter',
	'',
	316,
	1,
	'if(param.name == "can")
  // if the current action is one which requires
  // this element to be selected along with a
  // synchronous message
  if(param.value == "formCommBrg")
    // no formalization support yet at system level
    if(self.definedAtSystemLevel())
      return false;
    end if;
    // if the selection count is not equal two return false, this
    // prevents the menu entries from existing while only one of the
    // elements is selected
    if(Sel::getCurrentSelectionCount() != 2)
      return false;
    end if;
    // return true if this participant represents
    // an external entity which contains at lease
    // one bridge operation
    return self.formalEEHasBridgeOperations();
  end if;
  if(param.value == "formEE spec pkg") or (param.value == "formEE generic pkg")
    select one packageableElem related by self->SQ_P[R930]->PE_PE[R8001];
    select one package related by packageableElem->EP_PKG[R8000];
    select one component related by packageableElem->C_C[R8003];
    isInGenericPackage = not_empty package or not_empty component;
  
    if ((param.value == "formEE spec pkg")  and (isInGenericPackage))
      return false;
    end if;
    if ((param.value == "formEE generic pkg") and (not isInGenericPackage))
      return false;
    end if;
    
    // no formalization support yet at system level
    if(self.definedAtSystemLevel())
      return false;
    end if;
    select many ees from instances of S_EE;
    count = cardinality ees;
    if(param.value == "formEE generic pkg")
      count = Util::getElementCountInSystem(
                                          elementType:ElementTypeConstants::EE, 
                                        askingElement:self.convertToInstance());
    end if;
    if(count == 1 and self.isFormal)
      // there is only one possibility and we
      // are already assigned to it
      return false;
    end if;
	return count != 0;
  end if;
  if(param.value == "unform")
    return self.isFormal;
  end if;
end if;
return false;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (3817,
	3816,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (3818,
	3816,
	'value',
	322,
	0,
	'',
	3817,
	'');
INSERT INTO O_TFR
	VALUES (3819,
	3548,
	'unformalize',
	'',
	19,
	1,
	'select one ee related by self->S_EE[R933];
if(not_empty ee)
  unrelate self from ee across R933;
end if;
select one part related by self->SQ_P[R930];
select many messages related by part->MSG_M[R1007];
for each message in messages
  message.unformalize();
end for;
// unformalize any communication links connected
// to this instance
select many links related by part->COMM_LNK[R1133];
for each link in links
  link.unformalize();
end for;',
	1,
	'',
	3800);
INSERT INTO O_TFR
	VALUES (3815,
	3548,
	'get_name',
	'',
	322,
	1,
	'return self.Label;',
	1,
	'',
	3804);
INSERT INTO O_TFR
	VALUES (3820,
	3548,
	'canRename',
	'',
	316,
	1,
	'return not self.isFormal;',
	1,
	'',
	3816);
INSERT INTO O_TFR
	VALUES (3811,
	3548,
	'formalize',
	'',
	19,
	1,
	'select any ee from instances of S_EE
                                where (selected.EE_ID == GD::NULL_UNIQUE_ID());
select one package related by self->SQ_P[R930]->PE_PE[R8001]->EP_PKG[R8000];
isInGenericPackage = not_empty package;
if(not isInGenericPackage)
  select any ee from instances of S_EE where (selected.EE_ID == param.eeId);
else
  select any pe from instances of PE_PE
                                   where (selected.Element_ID == param.eeId);
  select one ee related by pe->S_EE[R8001];
end if;
if(self.isFormal)
  self.unformalize();
end if;
if (not_empty ee)
  relate self to ee across R933;
end if;',
	1,
	'',
	3821);
INSERT INTO O_TPARM
	VALUES (3822,
	3811,
	'eeId',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3821,
	3548,
	'formalEEHasBridgeOperations',
	'This operation returns true if the participant represents an external entity
which contains at least one bridge operation.',
	316,
	1,
	'select one ee related by self->S_EE[R933];
if(not_empty ee)
  select many brgs related by ee->S_BRG[R19];
  return not_empty brgs;
end if;
return false;',
	1,
	'',
	3798);
INSERT INTO O_TFR
	VALUES (3799,
	3548,
	'definedAtSystemLevel',
	'',
	316,
	1,
	'select one part related by self->SQ_P[R930];
return part.definedAtSystemLevel();',
	1,
	'',
	3820);
INSERT INTO O_TFR
	VALUES (3823,
	3548,
	'getBridgeOperationCount',
	'',
	298,
	1,
	'if(self.isFormal)
  select many bridgeOps related by self->S_EE[R933]->S_BRG[R19];
  return cardinality bridgeOps;
end if;
return 0;',
	1,
	'',
	3819);
INSERT INTO O_TFR
	VALUES (3824,
	3548,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'return this;',
	0,
	'',
	3823);
INSERT INTO O_TFR
	VALUES (3825,
	3548,
	'resolveExternalEntity',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one proxyEE related by self->S_EE[R933];
if(not_empty proxyEE and not Util::isProxy(element:self.convertToInstance()))
  select one packageableElem related by self->SQ_P[R930]->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = not_empty package or not_empty component;

  if (isInGenericPackage)
    if (empty package)
      rootCompIdInPkg = component.getRootComponentId();
      select any rootComponent from instances of C_C where (selected.Id == rootCompIdInPkg);
      select one package related by rootComponent->PE_PE[R8001]->EP_PKG[R8000]; 
    end if;
    // locate all visible ees
    packageableElem.resolveEERelativeToSelf(expected_name:"");
    select any resultSet related by component->PE_CRS[R8007] where 
                                selected.Type == ElementTypeConstants::EE; 
    select many results related by resultSet->PE_CVS[R8008]->PE_PE[R8004];
    if not_empty package
      select any pkgResultSet related by package->PE_SRS[R8005] where 
                                selected.Type == ElementTypeConstants::EE; 
      select many results related by pkgResultSet->PE_VIS[R8006]
                                                                 ->PE_PE[R8002];
    end if;    
    select many ees related by results->S_EE[R8001];
    select any resolvedEE from instances of S_EE
                               where (selected.EE_ID == GD::NULL_UNIQUE_ID());
    for each ee in ees
      // first try to resolve the referred to EE by key letters and name
      if(ee.Key_Lett == proxyEE.Key_Lett and ee.Name == proxyEE.Name)
        resolvedEE = ee;
        break;
      else
        if(ee.Key_Lett == proxyEE.Key_Lett)
          resolvedEE = ee;
          break;
        else
          if(ee.Name == proxyEE.Name)
            resolvedEE = ee;
            break;
          end if;
        end if;
      end if;
    end for;
    if(not_empty resolvedEE)
      relate self to resolvedEE across R933;
      self.resolveMessageFormalizations();
    else
      // unformalize this EEP
      self.unformalize();
    end if;
    return;
  end if;  // end isInGenericPackage
  
  //////////////////////////////////////////////////////////////////////
  // Note: Everything below this point is for the case when we are using 
  //       specialized packages.
  //////////////////////////////////////////////////////////////////////
  
  // if a domain is resolved by the proxy ee
  // then this EEP has already been
  // resolved or does not need to be as the referred to
  // EE is contained in the copy
  select one dom related by proxyEE->S_DOM[R8];
  if(empty dom or Util::isProxy(element:dom.convertToInstance()))
    name = proxyEE.Name;
    key_letters = proxyEE.Key_Lett;
    unrelate self from proxyEE across R933;
    // this is safe as there will only ever be one
    // domain
    select any domain from instances of S_DOM;
    // first try to resolve the EE by key letters and name
    select any ee related by domain->S_EE[R8]
         where (selected.Key_Lett == key_letters and selected.Name == name);
    if(empty ee)
      // if no ee was found try to resolve it by key_letters alone
      select any ee related by domain->S_EE[R8]
           where (selected.Key_Lett == key_letters);
      if(empty ee)
        // if still no ee was found try to resolve on the name alone
        select any ee related by domain->S_EE[R8]
             where (selected.Name == name);
      end if;
    end if;
    eeResolved = not_empty ee;
    if(eeResolved)
      relate self to ee across R933;
      self.resolveMessageFormalizations();
    else
      // unformalize this EEP
      self.unformalize();
    end if;
  end if;
end if;
',
	1,
	'',
	3824);
INSERT INTO O_TFR
	VALUES (3826,
	3548,
	'resolveMessageFormalizations',
	'',
	19,
	1,
	'// first resolve those messages drawn directly to
// self
select many messages related by self->SQ_P[R930]->MSG_M[R1007];
for each message in messages
  select one syncMessage related by message->MSG_SM[R1018];
  select one asyncMessage related by message->MSG_AM[R1018];
  if(not_empty syncMessage)
    // skip if informal
    if(not syncMessage.isFormal)
      continue;
    end if;
    select one bridgeMsg related by syncMessage->MSG_B[R1020];
    select one opProxy related by bridgeMsg->S_BRG[R1012];
    // we match by name
    select any operation related by self->S_EE[R933]->S_BRG[R19]
                                          where (selected.Name == opProxy.Name);
    if(not_empty operation)
      syncMessage.formalizeWithBridgeOperation(bridgeId:operation.Brg_ID);
    else
      // otherwise unformalize the message
      syncMessage.unformalize();
    end if;
  end if;
end for;
// now process all messages that go to our lifespan
select one ls related by self->SQ_P[R930]->SQ_LS[R940];
if(not_empty ls)
  select many messages related by ls->SQ_P[R930]->MSG_M[R1007];
  for each message in messages
    select one syncMessage related by message->MSG_SM[R1018];
    select one asyncMessage related by message->MSG_AM[R1018];
    if(not_empty syncMessage)
      // skip if informal
      if(not syncMessage.isFormal)
        continue;
      end if;
      select one bridgeMsg related by syncMessage->MSG_B[R1020];
      select one opProxy related by bridgeMsg->S_BRG[R1012];
      // we match by name
      select any operation related by self->S_EE[R933]->S_BRG[R19]
                                          where (selected.Name == opProxy.Name);
      if(not_empty operation)
        syncMessage.formalizeWithBridgeOperation(bridgeId:operation.Brg_ID);
      else
        // otherwise unformalize the message
        syncMessage.unformalize();
      end if;
    end if;
  end for;
end if;',
	1,
	'',
	3825);
INSERT INTO O_TFR
	VALUES (3827,
	3548,
	'getConfigurationInheritanceElementId',
	'',
	317,
	1,
	'select one ee related by self->S_EE[R933];
if(not_empty ee)
  return ee.convertToInstance();
end if;
return self.convertToInstance();',
	1,
	'',
	3826);
INSERT INTO O_DBATTR
	VALUES (3828,
	3548,
	'select one ee related by self->S_EE[R933];
if(not_empty ee)
  self.Label = ee.Name;
else
  self.Label = self.InformalName;
end if;',
	1);
INSERT INTO O_BATTR
	VALUES (3828,
	3548);
INSERT INTO O_ATTR
	VALUES (3828,
	3548,
	3829,
	'Label',
	'User_Visible:false',
	'',
	'Label',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3830,
	3548);
INSERT INTO O_BATTR
	VALUES (3830,
	3548);
INSERT INTO O_ATTR
	VALUES (3830,
	3548,
	3828,
	'InformalName',
	'Full Name: Informal External Entity Name',
	'',
	'InformalName',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3831,
	3548);
INSERT INTO O_BATTR
	VALUES (3831,
	3548);
INSERT INTO O_ATTR
	VALUES (3831,
	3548,
	3830,
	'Descrip',
	'Full Name: External Entity Description
Description: A textual description of this external entity.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (3832,
	3548,
	'select one ee related by self->S_EE[R933];
self.isFormal = not empty ee;',
	1);
INSERT INTO O_BATTR
	VALUES (3832,
	3548);
INSERT INTO O_ATTR
	VALUES (3832,
	3548,
	3831,
	'isFormal',
	'Full Name: Is Formal',
	'',
	'isFormal',
	0,
	316,
	'',
	'');
INSERT INTO O_REF
	VALUES (3548,
	703,
	0,
	743,
	3544,
	3549,
	3545,
	3833,
	3834,
	0,
	0,
	'',
	'Interaction Participant',
	'Part_ID',
	'R930');
INSERT INTO O_RATTR
	VALUES (3833,
	3548,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (3833,
	3548,
	0,
	'Part_ID',
	'',
	'',
	'Part_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (3548,
	2820,
	0,
	3570,
	3567,
	3568,
	3569,
	3829,
	3835,
	0,
	0,
	'',
	'External Entity',
	'EE_ID',
	'R933');
INSERT INTO O_RATTR
	VALUES (3829,
	3548,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (3829,
	3548,
	3833,
	'EE_ID',
	'',
	'',
	'EE_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3548);
INSERT INTO O_OIDA
	VALUES (3833,
	3548,
	0,
	'Part_ID');
INSERT INTO O_ID
	VALUES (1,
	3548);
INSERT INTO O_ID
	VALUES (2,
	3548);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3559,
	'Component Participant',
	903,
	'SQ_COP',
	'This class represents an instance of a class which is participating in a
sequence.',
	3521);
INSERT INTO O_TFR
	VALUES (3836,
	3559,
	'initialize',
	'',
	19,
	1,
	'name= "Informal Component";
success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:false);    
if ( success!="") 
self.InformalComponentName =success;
else 
 self.dispose();
end if;      ',
	1,
	'',
	3837);
INSERT INTO O_TFR
	VALUES (3838,
	3559,
	'dispose',
	'',
	19,
	1,
	'select one participant related by self->SQ_P[R930];
if(not_empty participant)
  unrelate self from participant across R930;
  participant.dispose();
end if;
select one component related by self->C_C[R955];
if(not_empty component)
  unrelate self from component across R955;
end if;
delete object instance self;',
	1,
	'',
	3839);
INSERT INTO O_TFR
	VALUES (3840,
	3559,
	'get_compartment_text',
	'',
	322,
	1,
	'if(param.at == Justification::Center)
  return self.Label;  
end if;
return "";',
	1,
	'',
	3838);
INSERT INTO O_TPARM
	VALUES (3841,
	3840,
	'comp_num',
	298,
	0,
	'',
	3842,
	'');
INSERT INTO O_TPARM
	VALUES (3843,
	3840,
	'ent_num',
	298,
	0,
	'',
	3841,
	'');
INSERT INTO O_TPARM
	VALUES (3842,
	3840,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3844,
	3559,
	'get_compartments',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	3840);
INSERT INTO O_TFR
	VALUES (3845,
	3559,
	'get_entries',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	3844);
INSERT INTO O_TPARM
	VALUES (3846,
	3845,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3847,
	3559,
	'get_style',
	'',
	784,
	1,
	'return Style::Component;',
	1,
	'',
	3848);
INSERT INTO O_TFR
	VALUES (3837,
	3559,
	'get_text_style',
	'',
	784,
	1,
	'return Style::None;',
	1,
	'',
	3847);
INSERT INTO O_TPARM
	VALUES (3849,
	3837,
	'comp_num',
	298,
	0,
	'',
	3850,
	'');
INSERT INTO O_TPARM
	VALUES (3851,
	3837,
	'ent_num',
	298,
	0,
	'',
	3849,
	'');
INSERT INTO O_TPARM
	VALUES (3850,
	3837,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3848,
	3559,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Part_ID;',
	1,
	'',
	3852);
INSERT INTO O_TFR
	VALUES (3852,
	3559,
	'get_name',
	'',
	322,
	1,
	'return self.Label;',
	1,
	'',
	3845);
INSERT INTO O_TFR
	VALUES (3839,
	3559,
	'canRename',
	'',
	316,
	1,
	'return not self.isFormal;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (3853,
	3559,
	'actionFilter',
	'',
	316,
	1,
	'// Component Participant.actionFilter()
//
if(param.name == "can")
  select one packageableElem related by self->SQ_P[R930]->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = not_empty package or not_empty component;
  if(param.value == "unform")
    // only allow unformalizing if formal
    return self.isFormal;
  end if;
  if(param.value == "formComp spec pkg")
    if ((param.value == "formComp spec pkg")  and (isInGenericPackage))
      return false;
    end if;
    select one participant related by self->SQ_P[R930];
    if not_empty participant
      id = participant.getSystemId();
      select any system from instances of S_SYS where selected.Sys_ID == id;
      if not_empty system
        select many components related by system->CP_CP[R4606]->C_C[R4608];
        if(cardinality components == 1 and self.isFormal)
          // do not allow as the only available component
          // is already used to formalize this
          return false;
        end if;
        return not_empty components;
      end if;
    end if;
  elif(param.value == "formComp generic pkg")
    if(not isInGenericPackage)
      return false;
    end if;
    count = Util::getElementCountInSystem(
                                   elementType:ElementTypeConstants::COMPONENT,
                                        askingElement:self.convertToInstance());
    if(self.isFormal and count == 1)
      return false;
    end if;
    return count != 0;
  end if;
  if(param.value == "formCommMsgIOp" or param.value == "formCommMsgSig")
    if(Sel::getCurrentSelectionCount() != 2)
      return false;
    end if;
    if(param.value == "formCommMsgIOp" and self.isFormalAndHasIFOperations())
      return true;
    end if;
    if(param.value == "formCommMsgSig" and self.isFormalAndHasSignals())
      return true;
    end if;
  end if;
end if;
return false;',
	1,
	'',
	3836);
INSERT INTO O_TPARM
	VALUES (3854,
	3853,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (3855,
	3853,
	'value',
	322,
	0,
	'',
	3854,
	'');
INSERT INTO O_TFR
	VALUES (3856,
	3559,
	'formalize',
	'',
	19,
	1,
	'// Component Participant.formalize()
select any mcomp from instances of C_C where (selected.Id == param.compId);
if empty mcomp
  select one participant related by self->SQ_P[R930];
  if not_empty participant
    id = participant.getSystemId();
    select any system from instances of S_SYS where selected.Sys_ID == id;
    if not_empty system
      select any mcomp related by system->CP_CP[R4606]->C_C[R4608]
                                            where (selected.Id == param.compId);
    end if;
  end if;
end if;
if(self.isFormal)
  self.unformalize();
end if;
if (not_empty mcomp)
  relate mcomp to self across R955;
end if;
',
	1,
	'',
	3853);
INSERT INTO O_TPARM
	VALUES (3857,
	3856,
	'compId',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3858,
	3559,
	'unformalize',
	'',
	19,
	1,
	'// Component Participant.unformalize()
select one mcomp related by self->C_C[R955];
if(not_empty mcomp)
  unrelate self from mcomp across R955;
end if;
select one part related by self->SQ_P[R930];
select many messages related by part->MSG_M[R1007];
for each message in messages
  message.unformalize();
end for;
// unformalize messages that are on the lifeline if any
select one ls related by self->SQ_P[R930]->SQ_LS[R940];
if(not_empty ls)
  select many messages related by ls->SQ_P[R930]->MSG_M[R1007];
  for each message in messages
    message.unformalize();
  end for;
end if;
// unformalize any communication links connected
// to this instance
select many links related by part->COMM_LNK[R1133];
for each link in links
  link.unformalize();
end for;
',
	1,
	'',
	3856);
INSERT INTO O_TFR
	VALUES (3859,
	3559,
	'isFormalAndHasIFOperations',
	'',
	316,
	1,
	'// Component Participant.isFormalAndHasIFOperations()
if self.isFormal
  select one component related by self->C_C[R955];
  select many interfaceOps related by component->C_PO[R4010]->
                              C_IR[R4016]->C_I[R4012]->C_EP[R4003]->C_IO[R4004];
  return not_empty interfaceOps;
else
  return false;
end if;',
	1,
	'',
	3858);
INSERT INTO O_TFR
	VALUES (3860,
	3559,
	'isFormalAndHasSignals',
	'',
	316,
	1,
	'// Component Participant.isFormalAndHasSignals()
if self.isFormal
  select one component related by self->C_C[R955];
  select many signals related by component->C_PO[R4010]->
                              C_IR[R4016]->C_I[R4012]->C_EP[R4003]->C_AS[R4004];
  return not_empty signals;
else
  return false;
end if;',
	1,
	'',
	3859);
INSERT INTO O_TFR
	VALUES (3861,
	3559,
	'canFormalizeToComponent',
	'',
	316,
	1,
	'// currently we only check that we are not already formalized to
// the given component
select one component related by self->C_C[R955];
if(not_empty component)
  if(component.Id == param.id)
    return false;
  end if;
end if;
return true;',
	1,
	'',
	3860);
INSERT INTO O_TPARM
	VALUES (3862,
	3861,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3863,
	3559,
	'getInterfaceSignalCount',
	'',
	298,
	1,
	'if(self.isFormal)
  select many interfaceSignals related by self->C_C[R955]->C_PO[R4010]
                            ->C_IR[R4016]->C_I[R4012]->C_EP[R4003]->C_AS[R4004];
  return cardinality interfaceSignals;
end if;
return 0;',
	1,
	'',
	3861);
INSERT INTO O_TFR
	VALUES (3864,
	3559,
	'getInterfaceOperationCount',
	'',
	298,
	1,
	'if(self.isFormal)
  select many interfaceOperations related by self->C_C[R955]->C_PO[R4010]
                            ->C_IR[R4016]->C_I[R4012]->C_EP[R4003]->C_IO[R4004];
  return cardinality interfaceOperations;
end if;
return 0;',
	1,
	'',
	3863);
INSERT INTO O_TFR
	VALUES (3865,
	3559,
	'getElideCompartmentTextAtEnd',
	'',
	316,
	1,
	'// elide at the front if the given compartment/entry corresponds to
// the class''s path (and name), and a class has been assigned to this instance 
select one component related by self->C_C[R955];
elideAtFront = false;	// necessary due to bug with boolean expressions
elideAtFront = param.comp_num == 1 and param.ent_num == 0 
	and not_empty component;
return elideAtFront;',
	1,
	'',
	3864);
INSERT INTO O_TPARM
	VALUES (3866,
	3865,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (3867,
	3865,
	'ent_num',
	298,
	0,
	'',
	3866,
	'');
INSERT INTO O_TFR
	VALUES (3868,
	3559,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'return this;',
	0,
	'',
	3865);
INSERT INTO O_TFR
	VALUES (3869,
	3559,
	'resolveComponent',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one componentProxy related by self->C_C[R955];
// if the component is not actually a proxy this imported
// component has already been handled
if(not_empty componentProxy) and
                    (Util::isProxy(element:componentProxy.convertToInstance()))
                       and (not Util::isProxy(element:self.convertToInstance()))
  name = componentProxy.Name;
  select one part related by self->SQ_P[R930];
  sysId = part.getSystemId();
  select any system from instances of S_SYS where (selected.Sys_ID == sysId);
  select any resolvedComp from instances of C_C
                          where (selected.Id == GD::NULL_UNIQUE_ID());
  select many resolvedComps related by system->CP_CP[R4606]->C_C[R4604]
                            where (selected.Name == name);
                            
  select one packageableElem related by part->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = not_empty package or not_empty component;
  
  
  if (isInGenericPackage)
	select one packageableElement related by self->SQ_P[R930]->PE_PE[R8001];
	packageableElement.resolveComponentRelativeToSelf(expected_name:name);
	select many resolvedComps related by package->PE_VIS[R8002]->
                                                     PE_PE[R8002]->C_C[R8001];
    if (empty resolvedComps)
      select many resolvedComps related by component->PE_CVS[R8004]->
                       			                      PE_PE[R8004]->C_C[R8001];
    end if;	
  else
    select many resolvedComps related by system->CP_CP[R4606]->C_C[R4604]
                               	                where (selected.Name == name);
  end if;
  
  for each comp in resolvedComps
    // for now the first matched comp is the one we are using
    resolvedComp = comp;
    break;
  end for;
  // if one was not resolved
  if(empty resolvedComp)
    // unassign this comp
	self.unformalize();
  else
    // otherwise associate the found component
    relate self to resolvedComp across R955;
    self.resolveMessageFormalizations();
  end if;
end if;',
	1,
	'',
	3868);
INSERT INTO O_TFR
	VALUES (3870,
	3559,
	'resolveMessageFormalizations',
	'',
	19,
	1,
	'// first resolve those messages drawn directly to
// self
select many messages related by self->SQ_P[R930]->MSG_M[R1007];
for each message in messages
  select one syncMessage related by message->MSG_SM[R1018];
  select one asyncMessage related by message->MSG_AM[R1018];
  if(not_empty syncMessage)
    // skip if informal
    if(not syncMessage.isFormal)
      continue;
    end if;
    select one iopMsg related by syncMessage->MSG_IOP[R1020];
    select one opProxy related by iopMsg->C_IO[R1022];
    // we match by name
    select any operation related by self->C_C[R955]->C_PO[R4010]->C_IR[R4016]
                                          ->C_I[R4012]->C_EP[R4003]->C_IO[R4004]
                                          where (selected.Name == opProxy.Name);
    if(not_empty operation)
      syncMessage.formalizeWithInterfaceOperation(iOpId:operation.Id);
    else
      // otherwise unformalize the message
      syncMessage.unformalize();
    end if;
  elif(not_empty asyncMessage)
    if(not asyncMessage.isFormal)
      continue;
    end if;
    select one sigMessage related by asyncMessage->MSG_SIG[R1019];
    select one sigProxy related by sigMessage->C_AS[R1021];
    // we match by name
    select any signal related by self->C_C[R955]->C_PO[R4010]->C_IR[R4016]
                                          ->C_I[R4012]->C_EP[R4003]->C_AS[R4004]
                                         where (selected.Name == sigProxy.Name);
    if(not_empty signal)
      asyncMessage.formalizeWithSignal(signalId:signal.Id);
    else
      // otherwise unformalize the message
      asyncMessage.unformalize();
    end if;
  end if;
end for;
// now process all messages that go to our lifespan
select one ls related by self->SQ_P[R930]->SQ_LS[R940];
if(not_empty ls)
  select many messages related by ls->SQ_P[R930]->MSG_M[R1007];
  for each message in messages
    select one syncMessage related by message->MSG_SM[R1018];
    select one asyncMessage related by message->MSG_AM[R1018];
    if(not_empty syncMessage)
      // skip if informal
      if(not syncMessage.isFormal)
        continue;
      end if;
      select one iopMsg related by syncMessage->MSG_IOP[R1020];
      select one opProxy related by iopMsg->C_IO[R1022];
      // we match by name
      select any operation related by self->C_C[R955]->C_PO[R4010]->C_IR[R4016]
                                          ->C_I[R4012]->C_EP[R4003]->C_IO[R4004]
                                          where (selected.Name == opProxy.Name);
      if(not_empty operation)
        syncMessage.formalizeWithInterfaceOperation(iOpId:operation.Id);
      else
        // otherwise unformalize the message
        syncMessage.unformalize();
      end if;
    elif(not_empty asyncMessage)
      if(not asyncMessage.isFormal)
        continue;
      end if;
      select one sigMessage related by asyncMessage->MSG_SIG[R1019];
      select one sigProxy related by sigMessage->C_AS[R1021];
      // we match by name
      select any signal related by self->C_C[R955]->C_PO[R4010]->C_IR[R4016]
                                          ->C_I[R4012]->C_EP[R4003]->C_AS[R4004]
                                         where (selected.Name == sigProxy.Name);
      if(not_empty signal)
        asyncMessage.formalizeWithSignal(signalId:signal.Id);
      else
        // otherwise unformalize the message
        asyncMessage.unformalize();
      end if;
    end if;
  end for;
end if;',
	1,
	'',
	3869);
INSERT INTO O_TFR
	VALUES (3871,
	3559,
	'getConfigurationInheritanceElementId',
	'',
	317,
	1,
	'select one comp related by self->C_C[R955];
if(not_empty comp)
  return comp.convertToInstance();
end if;
return self.convertToInstance();',
	1,
	'',
	3870);
INSERT INTO O_TFR
	VALUES (3872,
	3559,
	'getCachedLabel',
	'Translate: native',
	322,
	1,
	'	return m_label;',
	0,
	'',
	3871);
INSERT INTO O_TFR
	VALUES (3873,
	3559,
	'setCachedLabel',
	'Translate:native',
	19,
	1,
	'	m_label = p_Value;',
	0,
	'',
	3872);
INSERT INTO O_TPARM
	VALUES (3874,
	3873,
	'value',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3875,
	3559,
	'canReferToComponent',
	'',
	316,
	1,
	'// always return true, we allow users to ignore
// visibility during assignment and at this point
// there is no way to determine if they wany visibility
// filtering or not
return true;',
	1,
	'',
	3873);
INSERT INTO O_TFR
	VALUES (3876,
	3559,
	'isReferringToDefaultComponent',
	'',
	316,
	1,
	'return not self.isFormal;',
	1,
	'',
	3875);
INSERT INTO O_NBATTR
	VALUES (3877,
	3559);
INSERT INTO O_BATTR
	VALUES (3877,
	3559);
INSERT INTO O_ATTR
	VALUES (3877,
	3559,
	3878,
	'InformalComponentName',
	'Full Name: Informal Component Name',
	'',
	'InformalComponentName',
	0,
	322,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (3878,
	3559,
	'select one component related by self->C_C[R955];
if(not_empty component)
  if(Util::isProxy(element:component.convertToInstance()))
    self.Label = self.getCachedLabel();
  else
    label = component.getPath(path:"", includeSelf:true);
    self.setCachedLabel(value: label);
    self.Label = label;
  end if;
else
  self.Label = self.InformalComponentName;
end if;',
	1);
INSERT INTO O_BATTR
	VALUES (3878,
	3559);
INSERT INTO O_ATTR
	VALUES (3878,
	3559,
	3879,
	'Label',
	'User_Visible:false',
	'',
	'Label',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3880,
	3559);
INSERT INTO O_BATTR
	VALUES (3880,
	3559);
INSERT INTO O_ATTR
	VALUES (3880,
	3559,
	3877,
	'Descrip',
	'Full Name: Component Description
Description: A textual description of this component participant.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (3881,
	3559,
	'select one component related by self->C_C[R955];
if(not_empty component)
  self.isFormal = true;
else
  self.isFormal = false;
end if;',
	1);
INSERT INTO O_BATTR
	VALUES (3881,
	3559);
INSERT INTO O_ATTR
	VALUES (3881,
	3559,
	3880,
	'isFormal',
	'Full Name: Is Formal',
	'',
	'isFormal',
	0,
	316,
	'',
	'');
INSERT INTO O_REF
	VALUES (3559,
	703,
	0,
	743,
	3544,
	3560,
	3545,
	3882,
	3883,
	0,
	0,
	'',
	'Interaction Participant',
	'Part_ID',
	'R930');
INSERT INTO O_RATTR
	VALUES (3882,
	3559,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (3882,
	3559,
	0,
	'Part_ID',
	'',
	'',
	'Part_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (3559,
	709,
	0,
	762,
	3610,
	3611,
	3612,
	3879,
	3884,
	0,
	0,
	'',
	'Component',
	'Id',
	'R955');
INSERT INTO O_RATTR
	VALUES (3879,
	3559,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (3879,
	3559,
	3882,
	'Component_Id',
	'',
	'Component_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3559);
INSERT INTO O_OIDA
	VALUES (3882,
	3559,
	0,
	'Part_ID');
INSERT INTO O_ID
	VALUES (1,
	3559);
INSERT INTO O_ID
	VALUES (2,
	3559);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3577,
	'Class Participant Attribute',
	917,
	'SQ_CPA',
	'This class represents attributes which are informal.  These attributes may be
added to an informal Class Participant.',
	3521);
INSERT INTO O_TFR
	VALUES (3885,
	3577,
	'dispose',
	'',
	19,
	1,
	'select one ia related by self->SQ_IA[R947];
select one fa related by self->SQ_FA[R947];
if(not_empty ia)
  unrelate self from ia across R947;
  delete object instance ia;
end if;
if(not_empty fa)
  unrelate self from fa across R947;
  delete object instance fa;
end if;
select one cp related by self->SQ_CP[R935];
if(not_empty cp)
  unrelate self from cp across R935;
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (3886,
	3577,
	'initialize',
	'',
	19,
	1,
	'name = "Informal Attribute";
success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:false);     
if ( success!="") 
self.Name =success;
else 
 self.dispose();
end if;  ',
	1,
	'',
	3885);
INSERT INTO O_TFR
	VALUES (3887,
	3577,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'return this;',
	0,
	'',
	3886);
INSERT INTO O_NBATTR
	VALUES (3595,
	3577);
INSERT INTO O_BATTR
	VALUES (3595,
	3577);
INSERT INTO O_ATTR
	VALUES (3595,
	3577,
	0,
	'Ia_ID',
	'',
	'',
	'Ia_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3888,
	3577);
INSERT INTO O_BATTR
	VALUES (3888,
	3577);
INSERT INTO O_ATTR
	VALUES (3888,
	3577,
	3595,
	'Name',
	'Full Name: Informal Attribute Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3889,
	3577);
INSERT INTO O_BATTR
	VALUES (3889,
	3577);
INSERT INTO O_ATTR
	VALUES (3889,
	3577,
	3888,
	'Type',
	'Full Name: Informal Attribute Type',
	'',
	'Type',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3890,
	3577);
INSERT INTO O_BATTR
	VALUES (3890,
	3577);
INSERT INTO O_ATTR
	VALUES (3890,
	3577,
	3891,
	'Descrip',
	'Full Name: Informal Attribute Description
Description: A textual description of this attribute.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (3577,
	3552,
	0,
	3576,
	3574,
	3578,
	3575,
	3891,
	3892,
	0,
	0,
	'',
	'Class Participant',
	'Part_ID',
	'R935');
INSERT INTO O_RATTR
	VALUES (3891,
	3577,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (3891,
	3577,
	3889,
	'Part_ID',
	'',
	'',
	'Part_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3577);
INSERT INTO O_OIDA
	VALUES (3595,
	3577,
	0,
	'Ia_ID');
INSERT INTO O_ID
	VALUES (1,
	3577);
INSERT INTO O_ID
	VALUES (2,
	3577);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3552,
	'Class Participant',
	913,
	'SQ_CP',
	'This class represents a class which is participating in a sequence.  The
participating class is always static and never has a life span.',
	3521);
INSERT INTO O_TFR
	VALUES (3893,
	3552,
	'dispose',
	'',
	19,
	1,
	'select one participant related by self->SQ_P[R930];
if(not_empty participant)
  participant.dispose();
else
  select one mclass related by self->O_OBJ[R939];
  if(not_empty mclass)
    unrelate mclass from self across R939;
  end if;
select many attrs related by self->SQ_CPA[R935];
  for each attr in attrs
    unrelate self from attr across R935;
    attr.dispose();
  end for;
  delete object instance self;
end if;',
	1,
	'',
	3894);
INSERT INTO O_TFR
	VALUES (3895,
	3552,
	'get_style',
	'',
	784,
	1,
	'return Style::Box;',
	1,
	'',
	3896);
INSERT INTO O_TFR
	VALUES (3897,
	3552,
	'get_entries',
	'',
	298,
	1,
	'select one mclass related by self->O_OBJ[R939];
if(not_empty mclass)
  // return what the associated model class would
  return mclass.get_entries(comp_num:param.comp_num);
end if;
if (param.comp_num == 1)
 return 1;
end if;
if (param.comp_num == 2)
  select many attrs related by self->SQ_CPA[R935];
  return cardinality attrs;
end if;
if (param.comp_num == 3)
  select one participant related by self->SQ_P[R930];
  compartmentText = participant.getMessageCompartmentText();
  lineCount = GD::numberOfLines(string:compartmentText);
  return lineCount;
end if;
return 0;',
	1,
	'',
	3898);
INSERT INTO O_TPARM
	VALUES (3899,
	3897,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3898,
	3552,
	'get_compartments',
	'',
	298,
	1,
	'return 3;',
	1,
	'',
	3900);
INSERT INTO O_TFR
	VALUES (3901,
	3552,
	'get_text_style',
	'',
	784,
	1,
	'select one mclass related by self->O_OBJ[R939];
if(not_empty mclass)
  // if this participant is formal return
  // what the associated element would
  return mclass.get_text_style(comp_num:param.comp_num, ent_num:param.ent_num, at:param.at);
end if;
// otherwise return none
return Style::None;',
	1,
	'',
	3895);
INSERT INTO O_TPARM
	VALUES (3902,
	3901,
	'comp_num',
	298,
	0,
	'',
	3903,
	'');
INSERT INTO O_TPARM
	VALUES (3904,
	3901,
	'ent_num',
	298,
	0,
	'',
	3902,
	'');
INSERT INTO O_TPARM
	VALUES (3903,
	3901,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3896,
	3552,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Part_ID;',
	1,
	'',
	3905);
INSERT INTO O_TFR
	VALUES (3900,
	3552,
	'get_compartment_text',
	'',
	322,
	1,
	'select one participant related by self->SQ_P[R930];
select one mclass related by self->O_OBJ[R939];
if(not_empty mclass)
  // if this participant is formal
  // return what the element would
  // append the path
  result = "";
  if((param.comp_num == 1) and (param.ent_num == 1))
    if(param.at == Justification::Center_in_X)
      result = GD::newline() + result;
      result = mclass.getPath(path:"", includeSelf:true) + result;
      return result;
    end if;
  end if;
  return mclass.get_compartment_text(comp_num:param.comp_num, ent_num:param.ent_num, at:param.at);    
end if;
if((param.comp_num == 1) and (param.ent_num == 1))
  if (param.at == Justification::Center_in_X)
    return self.InformalName;
  end if;
elif(param.comp_num == 2)
  if(param.at == Justification::Left)
    cursor = 1;
    result = "";
    select many attrs related by self->SQ_CPA[R935];
    for each attr in attrs
      if (cursor == param.ent_num)
		result = result + attr.Name;
        if(attr.Type != "")
          result = result + ":" + attr.Type;
        end if;
        if(cardinality attrs != cursor)
          result = result + GD::newline();
        end if;
        return result;
      end if;
      cursor = cursor + 1;
    end for;
  end if;
elif(param.comp_num == 3)
  if (param.at == Justification::Left)
    result = "";
    // process the drawing only once
    // this logic will fill compartment 3
    if (param.ent_num == 1)
      select many msgs related by self->SQ_P[R930]->MSG_M[R1007];
      if(not_empty msgs)
        return participant.getMessageCompartmentText();
      end if;
    end if;
  end if;
end if;
return "";',
	1,
	'',
	3906);
INSERT INTO O_TPARM
	VALUES (3907,
	3900,
	'comp_num',
	298,
	0,
	'',
	3908,
	'');
INSERT INTO O_TPARM
	VALUES (3909,
	3900,
	'ent_num',
	298,
	0,
	'',
	3907,
	'');
INSERT INTO O_TPARM
	VALUES (3908,
	3900,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3910,
	3552,
	'initialize',
	'',
	19,
	1,
	'name = "Informal Class";
success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:false);     
if ( success!="") 
self.InformalName =success;
else 
 self.dispose();
end if;  ',
	1,
	'',
	3901);
INSERT INTO O_TFR
	VALUES (3911,
	3552,
	'newAttribute',
	'',
	19,
	1,
	'create object instance attr of SQ_CPA;
relate attr to self across R935;
create object instance ia of SQ_IA;
relate ia to attr across R947;
attr.initialize();',
	1,
	'',
	3910);
INSERT INTO O_TFR
	VALUES (3912,
	3552,
	'actionFilter',
	'',
	316,
	1,
	'if(param.name == "can")
  // if the current action is one which requires
  // this element to be selected along with a
  // synchronous message
  if(param.value == "formCommClassOp")
    // no formalization support yet at system level
    if(self.definedAtSystemLevel())
      return false;
    end if;
    // if the selection count is not equal two return false, this
    // prevents the menu entries from existing while only one of the
    // elements is selected
    if(Sel::getCurrentSelectionCount() != 2)
      return false;
    end if;
    // return true if this participant
    // represents a class which contains
    // at least one class based operation
    return self.formalClassHasCBOperations();
  end if;
  // likewise if the current action is one
  // which requires this element to be selected
  // along with an asynchronous message
  if(param.value == "formCommClassEvent")
    // no formalization support yet at system level
    if(self.definedAtSystemLevel())
      return false;
    end if;
    if(Sel::getCurrentSelectionCount() != 2)
      return false;
    end if;
    // return true if this participant represents
    // a class which contains at least one class
    // based event
    return self.formalClassHasCBEvents();
  end if;
  if(param.value == "unform")
    // only allow unformalizing if formal
    return self.isFormal;
  end if;
  if(param.value == "addAttr")
    // only allow adding attributes if not formal
    return not self.isFormal;
  end if;
  if(param.value == "formClass spec pkg") or (param.value == "formClass generic pkg")
    select one packageableElem related by self->SQ_P[R930]->PE_PE[R8001];
    select one package related by packageableElem->EP_PKG[R8000];
    select one component related by packageableElem->C_C[R8003];
    isInGenericPackage = not_empty package or not_empty component;
  
    if ((param.value == "formClass spec pkg")  and (isInGenericPackage))
      return false;
    end if;
    if ((param.value == "formClass generic pkg") and (not isInGenericPackage))
      return false;
    end if;
    
    // no formalization support yet at system level
    if(self.definedAtSystemLevel())
      return false;
    end if;
    // allow formalization if at least one
    // class exists
    select many objs from instances of O_OBJ;
    count = cardinality objs;
    if(param.value == "formClass generic pkg")
      count = Util::getElementCountInSystem(
                                       elementType:ElementTypeConstants::CLASS,
                                        askingElement:self.convertToInstance());
    end if;
    if(count == 1 and self.isFormal)
      return false;
    end if;
    return count != 0;
  end if;
end if;
return false;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (3913,
	3912,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (3914,
	3912,
	'value',
	322,
	0,
	'',
	3913,
	'');
INSERT INTO O_TFR
	VALUES (3915,
	3552,
	'unformalize',
	'',
	19,
	1,
	'select one mclass related by self->O_OBJ[R939];
if(not_empty mclass)
  unrelate self from mclass across R939;
end if;
select one part related by self->SQ_P[R930];
select many messages related by part->MSG_M[R1007];
for each message in messages
  message.unformalize();
end for;
// unformalize any communication links connected
// to this instance
select many links related by part->COMM_LNK[R1133];
for each link in links
  link.unformalize();
end for;
select many cpas related by self->SQ_CPA[R935];
for each cpa in cpas
  select one fa related by cpa->SQ_FA[R947];
  if(not_empty fa)
    unrelate cpa from fa across R947;
    delete object instance fa;
  end if;
  create object instance ia of SQ_IA;
  relate cpa to ia across R947;
end for;',
	1,
	'',
	3911);
INSERT INTO O_TFR
	VALUES (3905,
	3552,
	'get_name',
	'',
	322,
	1,
	'return self.Label;',
	1,
	'',
	3897);
INSERT INTO O_TFR
	VALUES (3916,
	3552,
	'canRename',
	'',
	316,
	1,
	'return not self.isFormal;',
	1,
	'',
	3912);
INSERT INTO O_TFR
	VALUES (3906,
	3552,
	'formalize',
	'',
	19,
	1,
	'select any mclass from instances of O_OBJ
                                where (selected.Obj_ID == GD::NULL_UNIQUE_ID());
select one package related by self->SQ_P[R930]->PE_PE[R8001]->EP_PKG[R8000];
isInGenericPackage = not_empty package;
if(not isInGenericPackage)
  select any mclass from instances of O_OBJ
                                       where (selected.Obj_ID == param.classId);
else
  select any pe from instances of PE_PE
                                   where (selected.Element_ID == param.classId);
  select one mclass related by pe->O_OBJ[R8001];
end if;
if(self.isFormal)
  self.unformalize();
end if;
if (not_empty mclass)
  relate mclass to self across R939;
end if;
// delete all informal class attributes
select many cpas related by self->SQ_CPA[R935];
for each cpa in cpas
  select one ia related by cpa->SQ_IA[R947];
  if(not_empty ia)
    unrelate cpa from ia across R947;
    delete object instance ia;
  end if;
  create object instance fa of SQ_FA;
  relate cpa to fa across R947;
end for;
',
	1,
	'',
	3917);
INSERT INTO O_TPARM
	VALUES (3918,
	3906,
	'classId',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3917,
	3552,
	'formalClassHasCBOperations',
	'This operation returns true if the class which this class participant represents
contains at least one class based operation.',
	316,
	1,
	'select one mclass related by self->O_OBJ[R939];
if(not_empty mclass)
  select many ops related by mclass->O_TFR[R115] where (selected.Instance_Based == Scope::Class);
  return not_empty ops;
end if;
return false;',
	1,
	'',
	3919);
INSERT INTO O_TFR
	VALUES (3919,
	3552,
	'formalClassHasCBEvents',
	'This operation returns true if the class which this participant represents
contains a class based state machine with at least one event.',
	316,
	1,
	'select one mclass related by self->O_OBJ[R939];
if(not_empty mclass)
  select one asm related by mclass->SM_ASM[R519];
  if ( not_empty asm )
    select many evts related by asm->SM_SM[R517]->SM_EVT[R502];
    // if there are no class based events check to see if there are any creation
    // events
    if(cardinality evts < 1)
      select many creationTransitions related by mclass->SM_ISM[R518]->SM_SM[R517]->SM_TXN[R505]->SM_CRTXN[R507];
      foundCreationEvent = false;
      for each transition in creationTransitions
        select one event related by transition->SM_LEVT[R509]->SM_SEVT[R526]->SM_EVT[R525];
        if(not_empty event)
          foundCreationEvent = true;
          break;
        end if;
      end for;
      if(foundCreationEvent)
        return true;
      else
        return false;
      end if;
    else
      return true;
    end if; // not_empty asm
  end if;
end if;      
return false;',
	1,
	'',
	3893);
INSERT INTO O_TFR
	VALUES (3894,
	3552,
	'definedAtSystemLevel',
	'',
	316,
	1,
	'select one part related by self->SQ_P[R930];
return part.definedAtSystemLevel();',
	1,
	'',
	3916);
INSERT INTO O_TFR
	VALUES (3920,
	3552,
	'getClassOperationCount',
	'',
	298,
	1,
	'if(self.isFormal)
  select many operations related by self->O_OBJ[R939]->O_TFR[R115]
                                where (selected.Instance_Based == Scope::Class);
  return cardinality operations;
end if;
return 0;',
	1,
	'',
	3915);
INSERT INTO O_TFR
	VALUES (3921,
	3552,
	'getClassEventCount',
	'',
	298,
	1,
	'select one mclass related by self->O_OBJ[R939];
if(not_empty mclass)
  select one asm related by mclass->SM_ASM[R519];
  if ( not_empty asm )
    select many evts related by asm->SM_SM[R517]->SM_EVT[R502];
    // include count for any creation events
    select many creationTransitions related by mclass->SM_ISM[R518]->SM_SM[R517]
                                                 ->SM_TXN[R505]->SM_CRTXN[R507];
    count = 0;
    for each transition in creationTransitions
      select one event related by transition->SM_LEVT[R509]->SM_SEVT[R526]
                                                                 ->SM_EVT[R525];
      if(not_empty event)
        count = count + 1;
      end if;
    end for;
    return cardinality evts + count;
  end if;
end if;      
return 0;',
	1,
	'',
	3920);
INSERT INTO O_TFR
	VALUES (3922,
	3552,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'return this;',
	0,
	'',
	3921);
INSERT INTO O_TFR
	VALUES (3923,
	3552,
	'pasteClassParticipantAttribute',
	'',
	19,
	1,
	'select any attribute from instances of SQ_CPA
                                             where (selected.Ia_ID == param.id);
if(not_empty attribute)
  select one existingCp related by attribute->SQ_CP[R935];
  if(not_empty existingCp)
    unrelate attribute from existingCp across R935;
  end if;
  relate attribute to self across R935;
end if;',
	1,
	'',
	3922);
INSERT INTO O_TPARM
	VALUES (3924,
	3923,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3925,
	3552,
	'canCopyClassParticipantAttribute',
	'',
	316,
	1,
	'select any attribute from instances of SQ_CPA
                                             where (selected.Ia_ID == param.id);
if(not_empty attribute)
  select one informal related by attribute->SQ_IA[R947];
  if(empty informal)
    return false;
  end if;
else
  return false;
end if;
return true;',
	1,
	'',
	3923);
INSERT INTO O_TPARM
	VALUES (3926,
	3925,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3927,
	3552,
	'canPasteClassParticipantAttribute',
	'',
	316,
	1,
	'return not self.isFormal;',
	1,
	'',
	3925);
INSERT INTO O_TFR
	VALUES (3928,
	3552,
	'resolveModelClass',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one proxyClass related by self->O_OBJ[R939];
if(not_empty proxyClass and not Util::isProxy(element:self.convertToInstance()))
  select one packageableElem related by self->SQ_P[R930]->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = not_empty package or not_empty component;

  if (isInGenericPackage)
    if (empty package)
      rootCompIdInPkg = component.getRootComponentId();
      select any rootComponent from instances of C_C where (selected.Id == rootCompIdInPkg);
      select one package related by rootComponent->PE_PE[R8001]->EP_PKG[R8000]; 
    end if;
    // locate all visible classes
    packageableElem.resolveClassRelativeToSelf(expected_name:"");
    select any resultSet related by component->PE_CRS[R8007] where 
                                selected.Type == ElementTypeConstants::CLASS; 
    select many results related by resultSet->PE_CVS[R8008]->PE_PE[R8004];
    if not_empty package
      select any pkgResultSet related by package->PE_SRS[R8005] where 
                                selected.Type == ElementTypeConstants::CLASS; 
      select many results related by pkgResultSet->PE_VIS[R8006]
                                                                 ->PE_PE[R8002];
    end if;    
    select many classes related by results->O_OBJ[R8001];
    select any resolvedClass from instances of O_OBJ
                               where (selected.Obj_ID == GD::NULL_UNIQUE_ID());
    for each class in classes
      // first try to resolve the referred to Class by key letters and name
      if(class.Key_Lett == proxyClass.Key_Lett and class.Name == proxyClass.Name)
        resolvedClass = class;
        break;
      else
        if(class.Key_Lett == proxyClass.Key_Lett)
          resolvedClass = class;
          break;
        else
          if(class.Name == proxyClass.Name)
            resolvedClass = class;
            break;
          end if;
        end if;
      end if;
    end for;
    if(not_empty resolvedClass)
      relate self to resolvedClass across R939;
      self.resolveMessageFormalizations();
    else
      // unformalize this EEP
      self.unformalize();
    end if;
    return;
  end if;  // end isInGenericPackage
  
  //////////////////////////////////////////////////////////////////////
  // Note: Everything below this point is for the case when we are using 
  //       specialized packages.
  //////////////////////////////////////////////////////////////////////
  
  // if a subsystem is resolved by the proxy class
  // then this CP has already been
  // resolved or does not need to be as the referred to
  // class is contained in the copy
  select one ss related by proxyClass->S_SS[R2];
  if(empty ss or Util::isProxy(element:ss.convertToInstance()))
    name = proxyClass.Name;
    key_letters = proxyClass.Key_Lett;
    unrelate self from proxyClass across R939;
    // this is safe as there will only ever be one
    // domain
    select any domain from instances of S_DOM;
    // first try to resolve to referred to class by key letters and name
    select any clazz related by domain->S_SS[R1]->O_OBJ[R2]
         where (selected.Key_Lett == key_letters and selected.Name == name);
    if(empty clazz)
      // if no class was found try to resolve it by key_letters alone
      select any clazz related by domain->S_SS[R1]->O_OBJ[R2]
           where (selected.Key_Lett == key_letters);
      if(empty clazz)
        // if still no class was found try to resolve on the name alone
        select any clazz related by domain->S_SS[R1]->O_OBJ[R2]
             where (selected.Name == name);
      end if;
    end if;
    classResolved = not_empty clazz;
    if(classResolved)
      relate self to clazz across R939;
      self.resolveMessageFormalizations();
    else
      // unformalize this CP
      self.unformalize();
    end if;
  end if;
end if;
',
	1,
	'',
	3927);
INSERT INTO O_TFR
	VALUES (3929,
	3552,
	'resolveMessageFormalizations',
	'',
	19,
	1,
	'// first resolve those messages drawn directly to
// self
select many messages related by self->SQ_P[R930]->MSG_M[R1007];
for each message in messages
  select one syncMessage related by message->MSG_SM[R1018];
  select one asyncMessage related by message->MSG_AM[R1018];
  if(not_empty syncMessage)
    // skip if informal
    if(not syncMessage.isFormal)
      continue;
    end if;
    select one operationMessage related by syncMessage->MSG_O[R1020];
    select one opProxy related by operationMessage->O_TFR[R1011];
    // we match by name, additionally the operation must be class based
    select any operation related by self->O_OBJ[R939]->O_TFR[R115]
                                            where (selected.Name == opProxy.Name
                                   and selected.Instance_Based == Scope::Class);
    if(not_empty operation)
      syncMessage.formalizeWithClassOperation(operationId:operation.Tfr_ID);
    else
      // otherwise unformalize the message
      syncMessage.unformalize();
    end if;
  elif(not_empty asyncMessage)
    if(not asyncMessage.isFormal)
      continue;
    end if;
    select one eventMessage related by asyncMessage->MSG_E[R1019];
    select one evtProxy related by eventMessage->SM_EVT[R1009];
    // we match by name, additionally the event must be class based
    // or a creation event
    select any event related by self->O_OBJ[R939]->SM_ASM[R519]->SM_SM[R517]
                        ->SM_EVT[R502] where (selected.Mning == evtProxy.Mning);
    if(empty event)
      select any event related by self->O_OBJ[R939]->SM_ISM[R518]->SM_SM[R517]
                                   ->SM_TXN[R505]->SM_CRTXN[R507]->SM_LEVT[R509]
         ->SM_SEVT[R526]->SM_EVT[R525] where (selected.Mning == evtProxy.Mning);
    end if;
    if(not_empty event)
      asyncMessage.formalizeWithEvent(eventId:event.SMevt_ID);
    else
      // otherwise unformalize the message
      asyncMessage.unformalize();
    end if;
  end if;
end for;
// now process all messages that go to our lifespan
select one ls related by self->SQ_P[R930]->SQ_LS[R940];
if(not_empty ls)
  select many messages related by ls->SQ_P[R930]->MSG_M[R1007];
  for each message in messages
    select one syncMessage related by message->MSG_SM[R1018];
    select one asyncMessage related by message->MSG_AM[R1018];
    if(not_empty syncMessage)
      // skip if informal
      if(not syncMessage.isFormal)
        continue;
      end if;
      select one operationMessage related by syncMessage->MSG_O[R1020];
      select one opProxy related by operationMessage->O_TFR[R1011];
      // we match by name, additionally the operation must be class based
      select any operation related by self->O_OBJ[R939]->O_TFR[R115]
                                            where (selected.Name == opProxy.Name
                                and selected.Instance_Based == Scope::Class);
      if(not_empty operation)
        syncMessage.formalizeWithClassOperation(operationId:operation.Tfr_ID);
      else
        // otherwise unformalize the message
        syncMessage.unformalize();
      end if;
    elif(not_empty asyncMessage)
      if(not asyncMessage.isFormal)
        continue;
      end if;
      select one eventMessage related by asyncMessage->MSG_E[R1019];
      select one evtProxy related by eventMessage->SM_EVT[R1009];
      // we match by name, additionally the event must be class based
      // or a creation event
      select any event related by self->O_OBJ[R939]->SM_ASM[R519]->SM_SM[R517]
                        ->SM_EVT[R502] where (selected.Mning == evtProxy.Mning);
      if(empty event)
        select any event related by self->O_OBJ[R939]->SM_ISM[R518]->SM_SM[R517]
                                   ->SM_TXN[R505]->SM_CRTXN[R507]->SM_LEVT[R509]
         ->SM_SEVT[R526]->SM_EVT[R525] where (selected.Mning == evtProxy.Mning);
      end if;
      if(not_empty event)
        asyncMessage.formalizeWithEvent(eventId:event.SMevt_ID);
      else
        // otherwise unformalize the message
        asyncMessage.unformalize();
      end if;
    end if;
  end for;
end if;',
	1,
	'',
	3928);
INSERT INTO O_TFR
	VALUES (3930,
	3552,
	'getConfigurationInheritanceElementId',
	'',
	317,
	1,
	'select one obj related by self->O_OBJ[R939];
if(not_empty obj)
  return obj.convertToInstance();
end if;
return self.convertToInstance();',
	1,
	'',
	3929);
INSERT INTO O_DBATTR
	VALUES (3931,
	3552,
	'select one mclass related by self->O_OBJ[R939];
if(not_empty mclass)
  self.Label = mclass.Name;
else
  self.Label = self.InformalName;
end if;',
	1);
INSERT INTO O_BATTR
	VALUES (3931,
	3552);
INSERT INTO O_ATTR
	VALUES (3931,
	3552,
	3932,
	'Label',
	'User_Visible:false',
	'',
	'Label',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3933,
	3552);
INSERT INTO O_BATTR
	VALUES (3933,
	3552);
INSERT INTO O_ATTR
	VALUES (3933,
	3552,
	3931,
	'InformalName',
	'Full Name: Informal Class Name',
	'',
	'InformalName',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3934,
	3552);
INSERT INTO O_BATTR
	VALUES (3934,
	3552);
INSERT INTO O_ATTR
	VALUES (3934,
	3552,
	3933,
	'Descrip',
	'Full Name: Class Description
Description: A textual description of this class.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (3935,
	3552,
	'select one mclass related by self->O_OBJ[R939];
if(not_empty mclass)
  self.isFormal = true;
else
  self.isFormal = false;
end if;',
	1);
INSERT INTO O_BATTR
	VALUES (3935,
	3552);
INSERT INTO O_ATTR
	VALUES (3935,
	3552,
	3934,
	'isFormal',
	'Full Name: Is Formal',
	'',
	'isFormal',
	0,
	316,
	'',
	'');
INSERT INTO O_REF
	VALUES (3552,
	703,
	0,
	743,
	3544,
	3553,
	3545,
	3576,
	3936,
	0,
	0,
	'',
	'Interaction Participant',
	'Part_ID',
	'R930');
INSERT INTO O_RATTR
	VALUES (3576,
	3552,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (3576,
	3552,
	0,
	'Part_ID',
	'',
	'',
	'Part_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (3552,
	30,
	0,
	150,
	3590,
	3591,
	3592,
	3932,
	3937,
	0,
	0,
	'',
	'Model Class',
	'Obj_ID',
	'R939');
INSERT INTO O_RATTR
	VALUES (3932,
	3552,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (3932,
	3552,
	3576,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3552);
INSERT INTO O_OIDA
	VALUES (3576,
	3552,
	0,
	'Part_ID');
INSERT INTO O_ID
	VALUES (1,
	3552);
INSERT INTO O_ID
	VALUES (2,
	3552);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3546,
	'Class Instance Participant',
	902,
	'SQ_CIP',
	'This class represents an instance of a class which is participating in a
sequence.',
	3521);
INSERT INTO O_TFR
	VALUES (3938,
	3546,
	'initialize',
	'',
	19,
	1,
	'self.InformalClassName = "Informal Class";
name = "Unnamed Instance";
success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:false);    
if ( success!="") 
self.Name =success;
else 
 self.dispose();
end if;  ',
	1,
	'',
	3939);
INSERT INTO O_TFR
	VALUES (3940,
	3546,
	'dispose',
	'',
	19,
	1,
	'select one participant related by self->SQ_P[R930];
if(not_empty participant)
  participant.dispose();
else
  select one mclass related by self->O_OBJ[R934];
  if(not_empty mclass)
    unrelate self from mclass across R934;
  end if;
select many iiavs related by self->SQ_AV[R936];
select many fiavs related by self->SQ_AV[R937];
  for each iiav in iiavs
    unrelate self from iiav across R936;
    iiav.dispose();
  end for;
  for each fiav in fiavs
    unrelate self from fiav across R937;
    fiav.dispose();
  end for;
  delete object instance self;
end if;',
	1,
	'',
	3941);
INSERT INTO O_TFR
	VALUES (3942,
	3546,
	'get_compartment_text',
	'',
	322,
	1,
	'if((param.comp_num == 1) and (param.at == Justification::Center_in_X))
  select one mclass related by self->O_OBJ[R934];
  if(not_empty mclass)
    if(self.Name != "")
      return self.Name + " : " + mclass.Name;
    else
      return ": " + mclass.Name;
    end if;
  else
    if(self.Name != "")
      return self.Name + " : " + self.InformalClassName;
    else
      return ": " + self.InformalClassName;
    end if;
  end if;
end if;
if(param.comp_num == 2)
  count = 0;
  select many iavs related by self->SQ_AV[R937];
  if(not self.isFormal)
    select many iavs related by self->SQ_AV[R936];
  end if;
  for each iav in iavs
    count = count + 1;
    if(count == param.ent_num) and (param.at == Justification::Left)
      return iav.Label;
    end if;
  end for;
end if;
return "";',
	1,
	'',
	3943);
INSERT INTO O_TPARM
	VALUES (3944,
	3942,
	'comp_num',
	298,
	0,
	'',
	3945,
	'');
INSERT INTO O_TPARM
	VALUES (3946,
	3942,
	'ent_num',
	298,
	0,
	'',
	3944,
	'');
INSERT INTO O_TPARM
	VALUES (3945,
	3942,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3947,
	3546,
	'get_compartments',
	'',
	298,
	1,
	'return 2;',
	1,
	'',
	3942);
INSERT INTO O_TFR
	VALUES (3948,
	3546,
	'get_entries',
	'',
	298,
	1,
	'if(param.comp_num == 1)
  return 1;
end if;
if(param.comp_num == 2)
  select many favs related by self->SQ_AV[R937];
  if(cardinality favs != 0)
    return cardinality favs;
  else
    select many ifavs related by self->SQ_AV[R936];
	return cardinality ifavs;
  end if;
end if;
return 0;',
	1,
	'',
	3947);
INSERT INTO O_TPARM
	VALUES (3949,
	3948,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3950,
	3546,
	'get_style',
	'',
	784,
	1,
	'return Style::Box;',
	1,
	'',
	3951);
INSERT INTO O_TFR
	VALUES (3939,
	3546,
	'get_text_style',
	'',
	784,
	1,
	'return Style::None;',
	1,
	'',
	3950);
INSERT INTO O_TPARM
	VALUES (3952,
	3939,
	'comp_num',
	298,
	0,
	'',
	3953,
	'');
INSERT INTO O_TPARM
	VALUES (3954,
	3939,
	'ent_num',
	298,
	0,
	'',
	3952,
	'');
INSERT INTO O_TPARM
	VALUES (3953,
	3939,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3951,
	3546,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Part_ID;',
	1,
	'',
	3948);
INSERT INTO O_TFR
	VALUES (3955,
	3546,
	'newInstanceAttributeValue',
	'',
	19,
	1,
	'create object instance av of SQ_AV;
create object instance iav of SQ_IAV;
relate self to av across R936;
relate av to iav across R948;
av.initialize();',
	1,
	'',
	3938);
INSERT INTO O_TFR
	VALUES (3956,
	3546,
	'unformalize',
	'',
	19,
	1,
	'select one mclass related by self->O_OBJ[R934];
if (not_empty mclass)
  unrelate self from mclass across R934;
end if;
// dispose all of the formal attribute values
select many vals related by self->SQ_AV[R937];
for each val in vals
  val.dispose();
end for;
select one part related by self->SQ_P[R930];
// only unformalize messages which are coming into
// this instance
select many messages related by part->MSG_M[R1007];
for each message in messages
  message.unformalize();
end for;
// unformalize any messages destined for the
// lifespan attached to this instance
select one ls related by self->SQ_P[R930]->SQ_LS[R940];
if(not_empty ls)
  select many messages related by ls->SQ_P[R930]->MSG_M[R1007];
  for each message in messages
    message.unformalize();
  end for;
end if;
// unformalize any communication links connected
// to this instance
select many links related by part->COMM_LNK[R1133];
for each link in links
  link.unformalize();
end for;
// create the informal attribute values
select many avs related by self->SQ_AV[R936];
for each av in avs
  create object instance iav of SQ_IAV;
  relate av to iav across R948;
end for;',
	1,
	'',
	3955);
INSERT INTO O_TFR
	VALUES (3957,
	3546,
	'actionFilter',
	'',
	316,
	1,
	'if(param.name == "can")
  // if the current action is one which requires
  // this element to be selected along with a
  // synchronous message
  if(param.value == "formCommInstOp")
    // no formalization support yet at system level
    if(self.definedAtSystemLevel())
      return false;
    end if;
    // if the selection count is not equal two return false, this
    // prevents the menu entries from existing while only one of the
    // elements is selected
    if(Sel::getCurrentSelectionCount() != 2)
      return false;
    end if;
    return self.formalClassHasIBOperations();
  end if;
  if(param.value == "formCommInstEvent")
    // no formalization support yet at system level
    if(self.definedAtSystemLevel())
      return false;
    end if;
    // if the selection count is not equal two return false, this
    // prevents the menu entries from existing while only one of the
    // elements is selected
    if(Sel::getCurrentSelectionCount() != 2)
      return false;
    end if;
    // return true if this instance represents
    // a class which contains at least one
    // instance based event or one inherited
    // event
    return self.formalClassHasIBEvents();
  end if;
  if(param.value == "addAttr")
	return not self.isFormal;
  end if;
  if(param.value == "unform")
    return self.isFormal;
  end if;
  select one packageableElem related by self->SQ_P[R930]->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = (not_empty package or not_empty component);
  if(param.value == "formClass spec pkg")
    if (isInGenericPackage)
      return false;
    end if;
    // no formalization support yet at system level
    if(self.definedAtSystemLevel())
      return false;
    end if;
    select many objs from instances of O_OBJ;
    if(cardinality objs == 1 and self.isFormal)
      return false;
    end if;    
    return not_empty objs;
  end if;
  if(param.value == "formClass generic pkg")
    if (not isInGenericPackage)
      return false;
    end if;
    // no formalization support yet at system level
    if(self.definedAtSystemLevel())
      return false;
    end if;
    count = Util::getElementCountInSystem(
                                       elementType:ElementTypeConstants::CLASS,
                                        askingElement:self.convertToInstance());
    if(count == 1 and self.isFormal)
      return false;
    end if;
    return count != 0;
  end if;  
end if;
return false;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (3958,
	3957,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (3959,
	3957,
	'value',
	322,
	0,
	'',
	3958,
	'');
INSERT INTO O_TFR
	VALUES (3943,
	3546,
	'formalize',
	'',
	19,
	1,
	'// unrelate if already related
if(self.isFormal)
  self.unformalize();
end if;
select any mclass from instances of O_OBJ
                                where (selected.Obj_ID == GD::NULL_UNIQUE_ID());
select one package related by self->SQ_P[R930]->PE_PE[R8001]->EP_PKG[R8000];
isInGenericPackage = not_empty package;
if(not isInGenericPackage)
  select any mclass from instances of O_OBJ where (selected.Obj_ID == param.classId);
else
  select any pe from instances of PE_PE
                                   where (selected.Element_ID == param.classId);
  select one mclass related by pe->O_OBJ[R8001];
end if;
if ( not_empty mclass )
  relate self to mclass across R934;
  // create attribute value instances for all
  // attributes of the class
  select many attrs related by mclass->O_ATTR[R102]->O_BATTR[R106]->O_ATTR[R106];
  for each attr in attrs
    create object instance av of SQ_AV;
    create object instance fav of SQ_FAV;
    relate av to self across R937;
    relate attr to av across R938;
    relate av to fav across R948;
  end for;
  // migrate the existing informal attribute
  // values so that they no longer show under
  // this instance
  select many avs related by self->SQ_AV[R936];
  for each av in avs
    select one iav related by av->SQ_IAV[R948];
    if(not_empty iav)
      unrelate av from iav across R948;
      delete object instance iav;
    end if;
  end for;
end if;',
	1,
	'',
	3960);
INSERT INTO O_TPARM
	VALUES (3961,
	3943,
	'classId',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3960,
	3546,
	'formalClassHasIBOperations',
	'This operation returns true if the class which this instance represents contains
at least one instance based operation.',
	316,
	1,
	'// return true if this instance
// represents a class which contains
// at least one instance based operation
select one mclass related by self->O_OBJ[R934];
if(not_empty mclass)
  select many ops related by mclass->O_TFR[R115] where (selected.Instance_Based == Scope::Instance);
  return not_empty ops;
end if;
return false;',
	1,
	'',
	3962);
INSERT INTO O_TFR
	VALUES (3963,
	3546,
	'formalClassHasCBOperations',
	'This operation returns true if the class which this instance represents contains
at least one class based operation.',
	316,
	1,
	'select one mclass related by self->O_OBJ[R934];
if(not_empty mclass)
  select many ops related by mclass->O_TFR[R115] where (selected.Instance_Based == Scope::Class);
  return not_empty ops;
end if;
return false;',
	1,
	'',
	3964);
INSERT INTO O_TFR
	VALUES (3964,
	3546,
	'formalClassHasCBEvents',
	'This operation returns true if the class that this instance represents contains
a class based state machine with at least one event.',
	316,
	1,
	'select one mclass related by self->O_OBJ[R934];
if(not_empty mclass)
  select one asm related by mclass->SM_ASM[R519];
  if ( not_empty asm )
    select many evts related by asm->SM_SM[R517]->SM_EVT[R502];
    // if there are no class based events check to see if there are any creation
    // events
    if(cardinality evts < 1)
      if(param.checkForCreationEvents)
        select many creationTransitions related by mclass->SM_ISM[R518]->SM_SM[R517]->SM_TXN[R505]->SM_CRTXN[R507];
        foundCreationEvent = false;
        for each transition in creationTransitions
          select one event related by transition->SM_LEVT[R509]->SM_SEVT[R526]->SM_EVT[R525];
          if(not_empty event)
            foundCreationEvent = true;
            break;
          end if;
        end for;
        if(foundCreationEvent)
          return true;
        else
          return false;
        end if;
      end if;
    else
      return true;
    end if; // not_empty asm
  end if;
end if;      
return false;',
	1,
	'',
	3940);
INSERT INTO O_TPARM
	VALUES (3965,
	3964,
	'checkForCreationEvents',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3962,
	3546,
	'formalClassHasIBEvents',
	'This operation returns true if the class that this instance represents contains
an instance based state machine with at least one event.',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one mclass related by self->O_OBJ[R934];
if(not_empty mclass)
  select one stateMachine related by mclass->SM_ISM[R518]->SM_SM[R517];
  if (not_empty stateMachine)
    select many events related by stateMachine->SM_EVT[R502];
    if(cardinality events < 1)
      select many inheritedEvents related by mclass->S_SS[R2]->O_OBJ[R2]->SM_ISM[R518]->SM_SM[R517]->SM_EVT[R502];
    
      select one packageableElem related by mclass->PE_PE[R8001];
      select one package related by packageableElem->EP_PKG[R8000];
      select one component related by packageableElem->C_C[R8003];
      isInGenericPackage = not_empty package or not_empty component;
      if (isInGenericPackage)
        if (not_empty package)
          select many inheritedEvents related by package->S_SYS[R1405]->EP_PKG[R1405]->PE_PE[R8000]->O_OBJ[R8001]
                 ->SM_ISM[R518]->SM_SM[R517]->SM_EVT[R502];
        else
          rootCompIdInPkg = component.getRootComponentId();
          select any rootComponent from instances of C_C where (selected.Id == rootCompIdInPkg);
          select one system related by rootComponent->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405];
          select many machines related by system->EP_PKG[R1405]->PE_PE[R8000]->O_OBJ[R8001]->SM_ISM[R518]->SM_SM[R517]->SM_EVT[R502];
        end if;
      end if;
      foundSuperEvent = false;
      for each event in inheritedEvents
        if(stateMachine.canAssignEvent(eventId:event.SMevt_ID, eventStateMachineId:stateMachine.SM_ID, isCreationTransition:false))
          foundSuperEvent = true;
          break;
        end if;
      end for;
      if(foundSuperEvent)
        return true;
      else
        return false;
      end if;
    else
      return true;
    end if;
  end if; // not_empty  stateMachine
end if;
return false;
',
	1,
	'',
	3963);
INSERT INTO O_TFR
	VALUES (3941,
	3546,
	'definedAtSystemLevel',
	'',
	316,
	1,
	'select one part related by self->SQ_P[R930];
return part.definedAtSystemLevel();',
	1,
	'',
	3957);
INSERT INTO O_TFR
	VALUES (3966,
	3546,
	'getInstanceOperationCount',
	'',
	298,
	1,
	'if(self.isFormal)
  select many operations related by self->O_OBJ[R934]->O_TFR[R115]
                             where (selected.Instance_Based == Scope::Instance);
  return cardinality operations;
end if;
return 0;',
	1,
	'',
	3956);
INSERT INTO O_TFR
	VALUES (3967,
	3546,
	'getInstanceEventCount',
	'',
	298,
	1,
	'if(self.isFormal)
  select one mclass related by self->O_OBJ[R934];
  if(not_empty mclass)
    select one stateMachine related by mclass->SM_ISM[R518]->SM_SM[R517];
    if (not_empty stateMachine)
      select many events related by stateMachine->SM_EVT[R502];
      if(cardinality events < 1)
        select many inheritedEvents related by mclass->S_SS[R2]->O_OBJ[R2]
                                      ->SM_ISM[R518]->SM_SM[R517]->SM_EVT[R502];
        select one packageableElem related by mclass->PE_PE[R8001];
        select one package related by packageableElem->EP_PKG[R8000];
        select one component related by packageableElem->C_C[R8003];
        isInGenericPackage = not_empty package or not_empty component;
        if (isInGenericPackage)
          if (not_empty package)
            select many inheritedEvents related by package->S_SYS[R1405]
                                     ->EP_PKG[R1405]->PE_PE[R8000]->O_OBJ[R8001]
                                      ->SM_ISM[R518]->SM_SM[R517]->SM_EVT[R502];
          else
            rootCompIdInPkg = component.getRootComponentId();
            select any rootComponent from instances of C_C where (selected.Id == rootCompIdInPkg);
            select one system related by rootComponent->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405];
            select many machines related by system->EP_PKG[R1405]->PE_PE[R8000]
                        ->O_OBJ[R8001]->SM_ISM[R518]->SM_SM[R517]->SM_EVT[R502];
          end if;
        end if;
        count = 0;
        for each event in inheritedEvents
          if(stateMachine.canAssignEvent(eventId:event.SMevt_ID,
            eventStateMachineId:stateMachine.SM_ID, isCreationTransition:false))
			count = count + 1;
          end if;
        end for;
        if(count > 1)
          return count;
        end if;
      else
        return cardinality events;
      end if;
    end if; // not_empty  stateMachine
  end if;
end if;
return 0;',
	1,
	'',
	3966);
INSERT INTO O_TFR
	VALUES (3968,
	3546,
	'getClassEventCount',
	'',
	298,
	1,
	'select one mclass related by self->O_OBJ[R934];
if(not_empty mclass)
  select one asm related by mclass->SM_ASM[R519];
  if ( not_empty asm )
    select many evts related by asm->SM_SM[R517]->SM_EVT[R502];
    // include count for any creation events
    select many creationTransitions related by mclass->SM_ISM[R518]->SM_SM[R517]->SM_TXN[R505]->SM_CRTXN[R507];
    count = 0;
    for each transition in creationTransitions
      select one event related by transition->SM_LEVT[R509]->SM_SEVT[R526]->SM_EVT[R525];
      if(not_empty event)
        count = count + 1;
      end if;
    end for;
    return cardinality evts + count;
  end if;
end if;      
return 0;',
	1,
	'',
	3967);
INSERT INTO O_TFR
	VALUES (3969,
	3546,
	'getClassOperationCount',
	'',
	298,
	1,
	'select one mclass related by self->O_OBJ[R934];
if(not_empty mclass)
  select many ops related by mclass->O_TFR[R115]
                                where (selected.Instance_Based == Scope::Class);
  return cardinality ops;
end if;
return 0;',
	1,
	'',
	3968);
INSERT INTO O_TFR
	VALUES (3970,
	3546,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'return this;',
	0,
	'',
	3969);
INSERT INTO O_TFR
	VALUES (3971,
	3546,
	'pasteInstanceAttributeValue',
	'',
	19,
	1,
	'select any iav from instances of SQ_AV where (selected.Av_ID == param.id);
if(not_empty iav)
  select one existingIP related by iav->SQ_CIP[R936];
  if(not_empty existingIP)
    unrelate existingIP from iav across R936;
  end if;
  relate iav to self across R936;
end if;',
	1,
	'',
	3970);
INSERT INTO O_TPARM
	VALUES (3972,
	3971,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3973,
	3546,
	'canCopyInstanceAttributeValue',
	'',
	316,
	1,
	'select any iav from instances of SQ_AV where (selected.Av_ID == param.id);
if(not_empty iav)
  select one informal related by iav->SQ_IAV[R948];
  if(empty informal)
    return false;
  end if;
else
  return false;
end if;
return true;',
	1,
	'',
	3971);
INSERT INTO O_TPARM
	VALUES (3974,
	3973,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3975,
	3546,
	'canPasteInstanceAttributeValue',
	'',
	316,
	1,
	'return not self.isFormal;',
	1,
	'',
	3973);
INSERT INTO O_TFR
	VALUES (3976,
	3546,
	'resolveModelClass',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one proxyClass related by self->O_OBJ[R934];
if(not_empty proxyClass and not Util::isProxy(element:self.convertToInstance()))
  select one packageableElem related by self->SQ_P[R930]->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = not_empty package or not_empty component;

  if (isInGenericPackage)
    if (empty package)
      rootCompIdInPkg = component.getRootComponentId();
      select any rootComponent from instances of C_C where (selected.Id == rootCompIdInPkg);
      select one package related by rootComponent->PE_PE[R8001]->EP_PKG[R8000]; 
    end if;
    // locate all visible classes
    packageableElem.resolveClassRelativeToSelf(expected_name:"");
    select any resultSet related by component->PE_CRS[R8007] where 
                                selected.Type == ElementTypeConstants::CLASS; 
    select many results related by resultSet->PE_CVS[R8008]->PE_PE[R8004];
    if not_empty package
      select any pkgResultSet related by package->PE_SRS[R8005] where 
                                selected.Type == ElementTypeConstants::CLASS; 
      select many results related by pkgResultSet->PE_VIS[R8006]
                                                                 ->PE_PE[R8002];
    end if;    
    select many classes related by results->O_OBJ[R8001];
    select any resolvedClass from instances of O_OBJ
                               where (selected.Obj_ID == GD::NULL_UNIQUE_ID());
    for each class in classes
      // first try to resolve the referred to Class by key letters and name
      if(class.Key_Lett == proxyClass.Key_Lett and class.Name == proxyClass.Name)
        resolvedClass = class;
        break;
      else
        if(class.Key_Lett == proxyClass.Key_Lett)
          resolvedClass = class;
          break;
        else
          if(class.Name == proxyClass.Name)
            resolvedClass = class;
            break;
          end if;
        end if;
      end if;
    end for;
    if(not_empty resolvedClass)
      relate self to resolvedClass across R934;
      // resolve attributes here, as we cannot
      // guarantee the order under normal paste
      // resolutions
      select many iavs related by self->SQ_AV[R937];
      for each iav in iavs
        iav.resolveAttributeLocal();
      end for;
      // create any additional attribute value instances
      select many attrs related by resolvedClass->O_ATTR[R102]->O_BATTR[R106]
                                                                 ->O_ATTR[R106];
      for each attr in attrs
        select any existing related by self->SQ_AV[R937]->O_ATTR[R938] 
                                     where (selected.Attr_ID == attr.Attr_ID);
        if(empty existing)
          create object instance av of SQ_AV;
          create object instance fav of SQ_FAV;
          relate av to self across R937;
          relate attr to av across R938;
          relate av to fav across R948;
        end if;
      end for;
      // resolve any messages drawn to this
      // CIP, or its lifespan
      self.resolveMessageFormalizations();
    else
      // unformalize this CIP
      self.unformalize();
    end if;
    return;
  end if;  // end isInGenericPackage
  
  //////////////////////////////////////////////////////////////////////
  // Note: Everything below this point is for the case when we are using 
  //       specialized packages.
  //////////////////////////////////////////////////////////////////////
  
  // if a subsystem is resolved by the proxy class
  // then this CIP has already been
  // resolved or does not need to be as the referred to
  // class is contained in the copy
  select one ss related by proxyClass->S_SS[R2];
  if(empty ss or Util::isProxy(element:ss.convertToInstance()))
    name = proxyClass.Name;
    key_letters = proxyClass.Key_Lett;
    unrelate self from proxyClass across R934;
    // this is safe as there will only ever be one
    // domain
    select any domain from instances of S_DOM;
    // first try to resolve to referred to class by key letters and name
    select any clazz related by domain->S_SS[R1]->O_OBJ[R2]
         where (selected.Key_Lett == key_letters and selected.Name == name);
    if(empty clazz)
      // if no class was found try to resolve it by key_letters alone
      select any clazz related by domain->S_SS[R1]->O_OBJ[R2]
           where (selected.Key_Lett == key_letters);
      if(empty clazz)
        // if still no class was found try to resolve on the name alone
        select any clazz related by domain->S_SS[R1]->O_OBJ[R2]
             where (selected.Name == name);
      end if;
    end if;
    classResolved = not_empty clazz;
    if(classResolved)
      relate self to clazz across R934;
      // resolve attributes here, as we cannot
      // guarantee the order under normal paste
      // resolutions
      select many iavs related by self->SQ_AV[R937];
      for each iav in iavs
        iav.resolveAttributeLocal();
      end for;
      // create any additional attribute value instances
      select many attrs related by clazz->O_ATTR[R102]->O_BATTR[R106]
                                                                 ->O_ATTR[R106];
      for each attr in attrs
        select any existing related by self->SQ_AV[R937]->O_ATTR[R938] 
                                       where (selected.Attr_ID == attr.Attr_ID);
        if(empty existing)
          create object instance av of SQ_AV;
          create object instance fav of SQ_FAV;
          relate av to self across R937;
          relate attr to av across R938;
          relate av to fav across R948;
        end if;
      end for;
      self.resolveMessageFormalizations();
    else
      // unformalize this CIP
      self.unformalize();
    end if;
  end if;
end if;
',
	1,
	'',
	3975);
INSERT INTO O_TFR
	VALUES (3977,
	3546,
	'resolveMessageFormalizations',
	'',
	19,
	1,
	'// first resolve those messages drawn directly to
// self
select many messages related by self->SQ_P[R930]->MSG_M[R1007];
for each message in messages
  select one syncMessage related by message->MSG_SM[R1018];
  select one asyncMessage related by message->MSG_AM[R1018];
  if(not_empty syncMessage)
    // skip if informal
    if(not syncMessage.isFormal)
      continue;
    end if;
    select one operationMessage related by syncMessage->MSG_O[R1020];
    select one opProxy related by operationMessage->O_TFR[R1011];
    // we match by name, additionally the operation must be class based
    select any operation related by self->O_OBJ[R934]->O_TFR[R115]
                                            where (selected.Name == opProxy.Name
                                   and selected.Instance_Based == Scope::Class);
    if(not_empty operation)
      syncMessage.formalizeWithClassOperation(operationId:operation.Tfr_ID);
    else
      // otherwise unformalize the message
      syncMessage.unformalize();
    end if;
  elif(not_empty asyncMessage)
    if(not asyncMessage.isFormal)
      continue;
    end if;
    select one eventMessage related by asyncMessage->MSG_E[R1019];
    select one evtProxy related by eventMessage->SM_EVT[R1009];
    // we match by name, additionally the event must be class based
    // or a creation event
    select any event related by self->O_OBJ[R934]->SM_ASM[R519]->SM_SM[R517]
                        ->SM_EVT[R502] where (selected.Mning == evtProxy.Mning);
    if(empty event)
      select any event related by self->O_OBJ[R934]->SM_ISM[R518]->SM_SM[R517]
                                   ->SM_TXN[R505]->SM_CRTXN[R507]->SM_LEVT[R509]
         ->SM_SEVT[R526]->SM_EVT[R525] where (selected.Mning == evtProxy.Mning);
    end if;
    if(not_empty event)
      asyncMessage.formalizeWithEvent(eventId:event.SMevt_ID);
    else
      // otherwise unformalize the message
      asyncMessage.unformalize();
    end if;
  end if;
end for;
// now process all messages that go to our lifespan
select one ls related by self->SQ_P[R930]->SQ_LS[R940];
if(not_empty ls)
  select many messages related by ls->SQ_P[R930]->MSG_M[R1007];
  for each message in messages
    select one syncMessage related by message->MSG_SM[R1018];
    select one asyncMessage related by message->MSG_AM[R1018];
    if(not_empty syncMessage)
      // skip if informal
      if(not syncMessage.isFormal)
        continue;
      end if;
      select one operationMessage related by syncMessage->MSG_O[R1020];
      select one opProxy related by operationMessage->O_TFR[R1011];
      // we match by name, additionally the operation must be instance based
      select any operation related by self->O_OBJ[R934]->O_TFR[R115]
                                            where (selected.Name == opProxy.Name
                                and selected.Instance_Based == Scope::Instance);
      if(not_empty operation)
        syncMessage.formalizeWithClassOperation(operationId:operation.Tfr_ID);
      else
        // otherwise unformalize the message
        syncMessage.unformalize();
      end if;
    elif(not_empty asyncMessage)
      if(not asyncMessage.isFormal)
        continue;
      end if;
      select one eventMessage related by asyncMessage->MSG_E[R1019];
      select one evtProxy related by eventMessage->SM_EVT[R1009];
      // we match by name
      select any event related by self->O_OBJ[R934]->SM_ISM[R518]->SM_SM[R517]
                        ->SM_EVT[R502] where (selected.Mning == evtProxy.Mning);
      if(not_empty event)
        asyncMessage.formalizeWithEvent(eventId:event.SMevt_ID);
      else
        // otherwise unformalize the message
        asyncMessage.unformalize();
      end if;
    end if;
  end for;
end if;',
	1,
	'',
	3976);
INSERT INTO O_TFR
	VALUES (3978,
	3546,
	'getConfigurationInheritanceElementId',
	'',
	317,
	1,
	'select one obj related by self->O_OBJ[R934];
if(not_empty obj)
  return obj.convertToInstance();
end if;
return self.convertToInstance();',
	1,
	'',
	3977);
INSERT INTO O_NBATTR
	VALUES (3979,
	3546);
INSERT INTO O_BATTR
	VALUES (3979,
	3546);
INSERT INTO O_ATTR
	VALUES (3979,
	3546,
	3980,
	'Name',
	'Full Name: Instance Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3981,
	3546);
INSERT INTO O_BATTR
	VALUES (3981,
	3546);
INSERT INTO O_ATTR
	VALUES (3981,
	3546,
	3979,
	'InformalClassName',
	'Full Name: Informal Class Name',
	'',
	'InformalClassName',
	0,
	322,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (3982,
	3546,
	'select one mclass related by self->O_OBJ[R934];
if(not_empty mclass)
  if(self.Name != "")
    self.Label = self.Name + " : " + mclass.Name;
  else
    self.Label = ": " + mclass.Name;
  end if;
else
  if(self.Name != "")
    self.Label = self.Name + " : " + self.InformalClassName;
  else
    self.Label = ": " + self.InformalClassName;
  end if;
end if;',
	1);
INSERT INTO O_BATTR
	VALUES (3982,
	3546);
INSERT INTO O_ATTR
	VALUES (3982,
	3546,
	3981,
	'Label',
	'User_Visible:false',
	'',
	'Label',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (3983,
	3546);
INSERT INTO O_BATTR
	VALUES (3983,
	3546);
INSERT INTO O_ATTR
	VALUES (3983,
	3546,
	3982,
	'Descrip',
	'Full Name: Instance Description
Description: A textual description of this instance.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (3984,
	3546,
	'select one mclass related by self->O_OBJ[R934];
if(not_empty mclass)
  self.isFormal = true;
else
  self.isFormal = false;
end if;',
	1);
INSERT INTO O_BATTR
	VALUES (3984,
	3546);
INSERT INTO O_ATTR
	VALUES (3984,
	3546,
	3983,
	'isFormal',
	'Full Name: Is Formal',
	'',
	'isFormal',
	0,
	316,
	'',
	'');
INSERT INTO O_REF
	VALUES (3546,
	703,
	0,
	743,
	3544,
	3547,
	3545,
	3583,
	3985,
	0,
	0,
	'',
	'Interaction Participant',
	'Part_ID',
	'R930');
INSERT INTO O_RATTR
	VALUES (3583,
	3546,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (3583,
	3546,
	0,
	'Part_ID',
	'',
	'',
	'Part_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (3546,
	30,
	0,
	150,
	3571,
	3572,
	3573,
	3980,
	3986,
	0,
	0,
	'',
	'Model Class',
	'Obj_ID',
	'R934');
INSERT INTO O_RATTR
	VALUES (3980,
	3546,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (3980,
	3546,
	3583,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3546);
INSERT INTO O_OIDA
	VALUES (3583,
	3546,
	0,
	'Part_ID');
INSERT INTO O_ID
	VALUES (1,
	3546);
INSERT INTO O_ID
	VALUES (2,
	3546);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3554,
	'Actor Participant',
	920,
	'SQ_AP',
	'The actor participant represents an outside element.  It has a life span and can
send/receive messages.',
	3521);
INSERT INTO O_TFR
	VALUES (3987,
	3554,
	'get_style',
	'',
	784,
	1,
	'return Style::StickFigure;',
	1,
	'',
	3988);
INSERT INTO O_TFR
	VALUES (3989,
	3554,
	'get_text_style',
	'',
	784,
	1,
	'return Style::None;',
	1,
	'',
	3987);
INSERT INTO O_TPARM
	VALUES (3990,
	3989,
	'comp_num',
	298,
	0,
	'',
	3991,
	'');
INSERT INTO O_TPARM
	VALUES (3992,
	3989,
	'ent_num',
	298,
	0,
	'',
	3990,
	'');
INSERT INTO O_TPARM
	VALUES (3991,
	3989,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3988,
	3554,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Part_ID;',
	1,
	'',
	3993);
INSERT INTO O_TFR
	VALUES (3993,
	3554,
	'get_entries',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	3994);
INSERT INTO O_TPARM
	VALUES (3995,
	3993,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (3996,
	3554,
	'get_compartment_text',
	'',
	322,
	1,
	'if(param.at == Justification::Center_in_X) and (param.comp_num == 2)
  return self.Name;
else
  return "";
end if;',
	1,
	'',
	3997);
INSERT INTO O_TPARM
	VALUES (3998,
	3996,
	'comp_num',
	298,
	0,
	'',
	3999,
	'');
INSERT INTO O_TPARM
	VALUES (4000,
	3996,
	'ent_num',
	298,
	0,
	'',
	3998,
	'');
INSERT INTO O_TPARM
	VALUES (3999,
	3996,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (4001,
	3554,
	'initialize',
	'',
	19,
	1,
	'name = "Unnamed Actor";
success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:false);    
if ( success!="") 
 self.Name=success;
else 
 self.dispose();
end if;      ',
	1,
	'',
	3989);
INSERT INTO O_TFR
	VALUES (3994,
	3554,
	'get_compartments',
	'',
	298,
	1,
	'return 2;',
	1,
	'',
	3996);
INSERT INTO O_TFR
	VALUES (3997,
	3554,
	'dispose',
	'',
	19,
	1,
	'select one ls related by self->SQ_LS[R949];
if(not_empty ls)
  // no need to delete the ls, in fact this is
  // only left in place while 949 is left in
  // place
  unrelate ls from self across R949;
end if;
select one participant related by self->SQ_P[R930];
if(not_empty participant)
  participant.dispose();
else
  delete object instance self;
end if;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (4002,
	3554,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'return this;',
	0,
	'',
	4001);
INSERT INTO O_NBATTR
	VALUES (4003,
	3554);
INSERT INTO O_BATTR
	VALUES (4003,
	3554);
INSERT INTO O_ATTR
	VALUES (4003,
	3554,
	4004,
	'Name',
	'Full Name: Actor Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (4005,
	3554);
INSERT INTO O_BATTR
	VALUES (4005,
	3554);
INSERT INTO O_ATTR
	VALUES (4005,
	3554,
	4003,
	'Descrip',
	'Full Name: Actor Description',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (3554,
	703,
	0,
	743,
	3544,
	3555,
	3545,
	4004,
	4006,
	0,
	0,
	'',
	'Interaction Participant',
	'Part_ID',
	'R930');
INSERT INTO O_RATTR
	VALUES (4004,
	3554,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (4004,
	3554,
	0,
	'Part_ID',
	'',
	'',
	'Part_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (3554,
	3538,
	0,
	3540,
	3613,
	3615,
	3614,
	4007,
	4008,
	0,
	0,
	'',
	'Lifespan',
	'Part_ID',
	'R949');
INSERT INTO O_RATTR
	VALUES (4007,
	3554,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (4007,
	3554,
	4005,
	'LS_Part_ID',
	'',
	'LS_',
	'Part_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3554);
INSERT INTO O_OIDA
	VALUES (4004,
	3554,
	0,
	'Part_ID');
INSERT INTO O_ID
	VALUES (1,
	3554);
INSERT INTO O_ID
	VALUES (2,
	3554);
-- BP 7.1 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (4009,
	'Instance Access',
	'Abstracts the concepts of creation, deletion and assignment to
instances. Also includes assignment to transient local variables.
Notify_Changes:false
Persistent:false
// This is used by schema_gen to ignore this subsystem (for publication)
TRANSLATE_FOR_EXTERNAL_USE:FALSE
',
	'ACT',
	600,
	1,
	4010);
INSERT INTO S_SID
	VALUES (1,
	4009);
INSERT INTO O_IOBJ
	VALUES (4011,
	129,
	5,
	4009,
	'Variable',
	'V_VAR');
INSERT INTO O_IOBJ
	VALUES (4012,
	70,
	5,
	4009,
	'Value',
	'V_VAL');
INSERT INTO O_IOBJ
	VALUES (4013,
	30,
	5,
	4009,
	'Model Class',
	'O_OBJ');
INSERT INTO R_SIMP
	VALUES (4014);
INSERT INTO R_REL
	VALUES (4014,
	609,
	'',
	4009);
INSERT INTO R_FORM
	VALUES (4015,
	4014,
	4016,
	0,
	1,
	'');
INSERT INTO R_RGO
	VALUES (4015,
	4014,
	4016);
INSERT INTO R_OIR
	VALUES (4015,
	4014,
	4016,
	0);
INSERT INTO R_PART
	VALUES (70,
	4014,
	4017,
	0,
	0,
	'reads');
INSERT INTO O_RTIDA
	VALUES (72,
	70,
	0,
	4014,
	4017);
INSERT INTO R_RTO
	VALUES (70,
	4014,
	4017,
	0);
INSERT INTO R_OIR
	VALUES (70,
	4014,
	4017,
	4012);
INSERT INTO R_SIMP
	VALUES (4018);
INSERT INTO R_REL
	VALUES (4018,
	633,
	'',
	4009);
INSERT INTO R_FORM
	VALUES (4019,
	4018,
	4020,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (4019,
	4018,
	4020);
INSERT INTO R_OIR
	VALUES (4019,
	4018,
	4020,
	0);
INSERT INTO R_PART
	VALUES (129,
	4018,
	4021,
	0,
	0,
	'result');
INSERT INTO O_RTIDA
	VALUES (131,
	129,
	0,
	4018,
	4021);
INSERT INTO R_RTO
	VALUES (129,
	4018,
	4021,
	0);
INSERT INTO R_OIR
	VALUES (129,
	4018,
	4021,
	4011);
INSERT INTO R_SIMP
	VALUES (4022);
INSERT INTO R_REL
	VALUES (4022,
	634,
	'',
	4009);
INSERT INTO R_FORM
	VALUES (4023,
	4022,
	4024,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (4023,
	4022,
	4024);
INSERT INTO R_OIR
	VALUES (4023,
	4022,
	4024,
	0);
INSERT INTO R_PART
	VALUES (129,
	4022,
	4025,
	0,
	0,
	'destroys');
INSERT INTO O_RTIDA
	VALUES (131,
	129,
	0,
	4022,
	4025);
INSERT INTO R_RTO
	VALUES (129,
	4022,
	4025,
	0);
INSERT INTO R_OIR
	VALUES (129,
	4022,
	4025,
	4011);
INSERT INTO R_SIMP
	VALUES (4026);
INSERT INTO R_REL
	VALUES (4026,
	671,
	'',
	4009);
INSERT INTO R_FORM
	VALUES (4019,
	4026,
	4027,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (4019,
	4026,
	4027);
INSERT INTO R_OIR
	VALUES (4019,
	4026,
	4027,
	0);
INSERT INTO R_PART
	VALUES (30,
	4026,
	4028,
	0,
	0,
	'instance of');
INSERT INTO O_RTIDA
	VALUES (150,
	30,
	0,
	4026,
	4028);
INSERT INTO R_RTO
	VALUES (30,
	4026,
	4028,
	0);
INSERT INTO R_OIR
	VALUES (30,
	4026,
	4028,
	4013);
INSERT INTO R_SIMP
	VALUES (4029);
INSERT INTO R_REL
	VALUES (4029,
	672,
	'',
	4009);
INSERT INTO R_PART
	VALUES (30,
	4029,
	4030,
	0,
	0,
	'instance of');
INSERT INTO O_RTIDA
	VALUES (150,
	30,
	0,
	4029,
	4030);
INSERT INTO R_RTO
	VALUES (30,
	4029,
	4030,
	0);
INSERT INTO R_OIR
	VALUES (30,
	4029,
	4030,
	4013);
INSERT INTO R_FORM
	VALUES (4031,
	4029,
	4032,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (4031,
	4029,
	4032);
INSERT INTO R_OIR
	VALUES (4031,
	4029,
	4032,
	0);
INSERT INTO R_SIMP
	VALUES (4033);
INSERT INTO R_REL
	VALUES (4033,
	689,
	'',
	4009);
INSERT INTO R_FORM
	VALUES (4015,
	4033,
	4034,
	0,
	1,
	'');
INSERT INTO R_RGO
	VALUES (4015,
	4033,
	4034);
INSERT INTO R_OIR
	VALUES (4015,
	4033,
	4034,
	0);
INSERT INTO R_PART
	VALUES (70,
	4033,
	4035,
	0,
	0,
	'writes');
INSERT INTO O_RTIDA
	VALUES (72,
	70,
	0,
	4033,
	4035);
INSERT INTO R_RTO
	VALUES (70,
	4033,
	4035,
	0);
INSERT INTO R_OIR
	VALUES (70,
	4033,
	4035,
	4012);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (4023,
	'Delete',
	614,
	'ACT_DEL',
	'This class represents a statement that deletes an instance.',
	4009);
INSERT INTO O_TFR
	VALUES (4036,
	4023,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'select one var related by self->V_VAR[R634];
if ( not_empty var )
  unrelate self from var across R634;
end if;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (4037,
	4023,
	'execute',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	4036);
INSERT INTO O_TPARM
	VALUES (4038,
	4037,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (4023,
	686,
	0,
	685,
	2386,
	4039,
	2388,
	4040,
	4041,
	0,
	0,
	'',
	'Statement',
	'Statement_ID',
	'R603');
INSERT INTO O_RATTR
	VALUES (4040,
	4023,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (4040,
	4023,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (4023,
	129,
	0,
	131,
	4022,
	4024,
	4025,
	4042,
	4043,
	0,
	0,
	'',
	'Variable',
	'Var_ID',
	'R634.''destroys''');
INSERT INTO O_RATTR
	VALUES (4042,
	4023,
	131,
	129,
	1,
	'Var_ID');
INSERT INTO O_ATTR
	VALUES (4042,
	4023,
	4040,
	'Var_ID',
	'

',
	'',
	'Var_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	4023);
INSERT INTO O_OIDA
	VALUES (4040,
	4023,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	4023);
INSERT INTO O_ID
	VALUES (2,
	4023);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (4031,
	'Create No Variable',
	607,
	'ACT_CNV',
	'This class represents a statement that creates a new instance of some class.',
	4009);
INSERT INTO O_TFR
	VALUES (4044,
	4031,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'select one obj related by self->O_OBJ[R672];
if ( not_empty obj )
  // it may be empty due to a parse error
  unrelate self from obj across R672;
end if;
delete object instance self;

',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (4045,
	4031,
	'execute',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	4044);
INSERT INTO O_REF
	VALUES (4031,
	686,
	0,
	685,
	2386,
	4046,
	2388,
	4047,
	4048,
	0,
	0,
	'',
	'Statement',
	'Statement_ID',
	'R603');
INSERT INTO O_RATTR
	VALUES (4047,
	4031,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (4047,
	4031,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (4049,
	4031);
INSERT INTO O_BATTR
	VALUES (4049,
	4031);
INSERT INTO O_ATTR
	VALUES (4049,
	4031,
	4050,
	'modelClassKeyLettersLineNumber',
	'',
	'',
	'modelClassKeyLettersLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (4051,
	4031);
INSERT INTO O_BATTR
	VALUES (4051,
	4031);
INSERT INTO O_ATTR
	VALUES (4051,
	4031,
	4049,
	'modelClassKeyLettersColumn',
	'',
	'',
	'modelClassKeyLettersColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_REF
	VALUES (4031,
	30,
	0,
	150,
	4029,
	4032,
	4030,
	4050,
	4052,
	0,
	0,
	'',
	'Model Class',
	'Obj_ID',
	'R672.''instance of''');
INSERT INTO O_RATTR
	VALUES (4050,
	4031,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (4050,
	4031,
	4047,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	4031);
INSERT INTO O_OIDA
	VALUES (4047,
	4031,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	4031);
INSERT INTO O_ID
	VALUES (2,
	4031);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (4019,
	'Create',
	613,
	'ACT_CR',
	'This class represents a statement that creates a new instance of some class.',
	4009);
INSERT INTO O_TFR
	VALUES (4053,
	4019,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'select one obj related by self->O_OBJ[R671];
if ( not_empty obj )
  // it may be empty due to a parse error
  unrelate self from obj across R671;
end if;

select one var related by self->V_VAR[R633];
if ( not_empty var )
  // it may be empty due to a parse error
  unrelate self from var across R633;
end if;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (4054,
	4019,
	'execute',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	4053);
INSERT INTO O_TPARM
	VALUES (4055,
	4054,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (4019,
	686,
	0,
	685,
	2386,
	4056,
	2388,
	4057,
	4058,
	0,
	0,
	'',
	'Statement',
	'Statement_ID',
	'R603');
INSERT INTO O_RATTR
	VALUES (4057,
	4019,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (4057,
	4019,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (4019,
	129,
	0,
	131,
	4018,
	4020,
	4021,
	4059,
	4060,
	0,
	0,
	'',
	'Variable',
	'Var_ID',
	'R633.''result''');
INSERT INTO O_RATTR
	VALUES (4059,
	4019,
	131,
	129,
	1,
	'Var_ID');
INSERT INTO O_ATTR
	VALUES (4059,
	4019,
	4057,
	'Var_ID',
	'

',
	'',
	'Var_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (4061,
	4019);
INSERT INTO O_BATTR
	VALUES (4061,
	4019);
INSERT INTO O_ATTR
	VALUES (4061,
	4019,
	4059,
	'is_implicit',
	'Full Name: Is Implicit
Specifies whether the instance handle found is being used for the first time in this scope or not.',
	'',
	'is_implicit',
	0,
	316,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (4062,
	4019);
INSERT INTO O_BATTR
	VALUES (4062,
	4019);
INSERT INTO O_ATTR
	VALUES (4062,
	4019,
	4063,
	'modelClassKeyLettersLineNumber',
	'',
	'',
	'modelClassKeyLettersLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (4064,
	4019);
INSERT INTO O_BATTR
	VALUES (4064,
	4019);
INSERT INTO O_ATTR
	VALUES (4064,
	4019,
	4062,
	'modelClassKeyLettersColumn',
	'',
	'',
	'modelClassKeyLettersColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_REF
	VALUES (4019,
	30,
	0,
	150,
	4026,
	4027,
	4028,
	4063,
	4065,
	0,
	0,
	'',
	'Model Class',
	'Obj_ID',
	'R671.''instance of''');
INSERT INTO O_RATTR
	VALUES (4063,
	4019,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (4063,
	4019,
	4061,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	4019);
INSERT INTO O_OIDA
	VALUES (4057,
	4019,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	4019);
INSERT INTO O_ID
	VALUES (2,
	4019);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (4015,
	'Assign to Member',
	603,
	'ACT_AI',
	'This class represents a statement that assigns a value to an attribute of some instance.',
	4009);
INSERT INTO O_TFR
	VALUES (4066,
	4015,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'select one value related by self->V_VAL[R609];
if ( not_empty value )
  unrelate self from value across R609;
  value.dispose();
end if;

select one value related by self->V_VAL[R689];
if (not_empty value)
  unrelate self from value across R689;
  value.dispose();
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (4067,
	4015,
	'execute',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	4066);
INSERT INTO O_TPARM
	VALUES (4068,
	4067,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (4015,
	686,
	0,
	685,
	2386,
	4069,
	2388,
	4070,
	4071,
	0,
	0,
	'',
	'Statement',
	'Statement_ID',
	'R603');
INSERT INTO O_RATTR
	VALUES (4070,
	4015,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (4070,
	4015,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (4015,
	70,
	0,
	72,
	4014,
	4016,
	4017,
	4072,
	4073,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R609.''reads''');
INSERT INTO O_RATTR
	VALUES (4072,
	4015,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (4072,
	4015,
	4070,
	'r_Value_ID',
	'

',
	'r_',
	'Value_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (4074,
	4015);
INSERT INTO O_BATTR
	VALUES (4074,
	4015);
INSERT INTO O_ATTR
	VALUES (4074,
	4015,
	4075,
	'attributeLineNumber',
	'',
	'',
	'attributeLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (4076,
	4015);
INSERT INTO O_BATTR
	VALUES (4076,
	4015);
INSERT INTO O_ATTR
	VALUES (4076,
	4015,
	4074,
	'attributeColumn',
	'',
	'',
	'attributeColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_REF
	VALUES (4015,
	70,
	0,
	72,
	4033,
	4034,
	4035,
	4075,
	4077,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R689.''writes''');
INSERT INTO O_RATTR
	VALUES (4075,
	4015,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (4075,
	4015,
	4072,
	'l_Value_ID',
	'',
	'l_',
	'Value_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	4015);
INSERT INTO O_OIDA
	VALUES (4070,
	4015,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	4015);
INSERT INTO O_ID
	VALUES (2,
	4015);
-- BP 7.1.6 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (4078,
	'Instance',
	'// This is used by schema_gen to ignore this subsystem (for publication)
TRANSLATE_FOR_EXTERNAL_USE:FALSE
Persistent:false
Import: java.util.concurrent.locks.ReentrantLock',
	'I',
	900,
	1,
	0);
INSERT INTO S_SID
	VALUES (1,
	4078);
INSERT INTO O_IOBJ
	VALUES (4079,
	2322,
	0,
	4078,
	'Association',
	'R_REL');
INSERT INTO O_IOBJ
	VALUES (4080,
	1492,
	0,
	4078,
	'State Machine State',
	'SM_STATE');
INSERT INTO O_IOBJ
	VALUES (4081,
	1488,
	0,
	4078,
	'State Machine Event',
	'SM_EVT');
INSERT INTO O_IOBJ
	VALUES (4082,
	37,
	0,
	4078,
	'Attribute',
	'O_ATTR');
INSERT INTO O_IOBJ
	VALUES (4083,
	52,
	0,
	4078,
	'State Machine Event Data Item',
	'SM_EVTDI');
INSERT INTO O_IOBJ
	VALUES (4084,
	699,
	0,
	4078,
	'Domain',
	'S_DOM');
INSERT INTO O_IOBJ
	VALUES (4085,
	1509,
	0,
	4078,
	'Transition',
	'SM_TXN');
INSERT INTO O_IOBJ
	VALUES (4086,
	709,
	0,
	4078,
	'Component',
	'C_C');
INSERT INTO O_IOBJ
	VALUES (4087,
	57,
	0,
	4078,
	'Property Parameter',
	'C_PP');
INSERT INTO O_IOBJ
	VALUES (4088,
	2807,
	0,
	4078,
	'Component Reference',
	'CL_IC');
INSERT INTO O_IOBJ
	VALUES (4089,
	2798,
	0,
	4078,
	'Package',
	'EP_PKG');
INSERT INTO R_SIMP
	VALUES (4090);
INSERT INTO R_REL
	VALUES (4090,
	2904,
	'',
	4078);
INSERT INTO R_PART
	VALUES (2322,
	4090,
	4091,
	0,
	0,
	'is instance of');
INSERT INTO O_RTIDA
	VALUES (2368,
	2322,
	0,
	4090,
	4091);
INSERT INTO R_RTO
	VALUES (2322,
	4090,
	4091,
	0);
INSERT INTO R_OIR
	VALUES (2322,
	4090,
	4091,
	4079);
INSERT INTO R_FORM
	VALUES (4092,
	4090,
	4093,
	1,
	1,
	'has instances');
INSERT INTO R_RGO
	VALUES (4092,
	4090,
	4093);
INSERT INTO R_OIR
	VALUES (4092,
	4090,
	4093,
	0);
INSERT INTO R_SIMP
	VALUES (4094);
INSERT INTO R_REL
	VALUES (4094,
	2906,
	'',
	4078);
INSERT INTO R_PART
	VALUES (1488,
	4094,
	4095,
	0,
	0,
	'is instance of');
INSERT INTO O_RTIDA
	VALUES (1604,
	1488,
	0,
	4094,
	4095);
INSERT INTO R_RTO
	VALUES (1488,
	4094,
	4095,
	0);
INSERT INTO R_OIR
	VALUES (1488,
	4094,
	4095,
	4081);
INSERT INTO R_FORM
	VALUES (4096,
	4094,
	4097,
	1,
	1,
	'has instances');
INSERT INTO R_RGO
	VALUES (4096,
	4094,
	4097);
INSERT INTO R_OIR
	VALUES (4096,
	4094,
	4097,
	0);
INSERT INTO R_SIMP
	VALUES (4098);
INSERT INTO R_REL
	VALUES (4098,
	2908,
	'',
	4078);
INSERT INTO R_PART
	VALUES (4096,
	4098,
	4099,
	0,
	1,
	'will be processed after');
INSERT INTO O_RTIDA
	VALUES (4100,
	4096,
	0,
	4098,
	4099);
INSERT INTO R_RTO
	VALUES (4096,
	4098,
	4099,
	0);
INSERT INTO R_OIR
	VALUES (4096,
	4098,
	4099,
	0);
INSERT INTO R_FORM
	VALUES (4096,
	4098,
	4101,
	0,
	1,
	'will be processed before');
INSERT INTO R_RGO
	VALUES (4096,
	4098,
	4101);
INSERT INTO R_OIR
	VALUES (4096,
	4098,
	4101,
	0);
INSERT INTO R_SIMP
	VALUES (4102);
INSERT INTO R_REL
	VALUES (4102,
	2910,
	'',
	4078);
INSERT INTO R_PART
	VALUES (37,
	4102,
	4103,
	0,
	0,
	'is instance of');
INSERT INTO O_RTIDA
	VALUES (168,
	37,
	0,
	4102,
	4103);
INSERT INTO O_RTIDA
	VALUES (169,
	37,
	0,
	4102,
	4103);
INSERT INTO R_RTO
	VALUES (37,
	4102,
	4103,
	0);
INSERT INTO R_OIR
	VALUES (37,
	4102,
	4103,
	4082);
INSERT INTO R_FORM
	VALUES (4104,
	4102,
	4105,
	1,
	1,
	'has instances');
INSERT INTO R_RGO
	VALUES (4104,
	4102,
	4105);
INSERT INTO R_OIR
	VALUES (4104,
	4102,
	4105,
	0);
INSERT INTO R_SIMP
	VALUES (4106);
INSERT INTO R_REL
	VALUES (4106,
	2907,
	'',
	4078);
INSERT INTO R_PART
	VALUES (4107,
	4106,
	4108,
	0,
	1,
	'is pending for');
INSERT INTO O_RTIDA
	VALUES (4109,
	4107,
	0,
	4106,
	4108);
INSERT INTO R_RTO
	VALUES (4107,
	4106,
	4108,
	0);
INSERT INTO R_OIR
	VALUES (4107,
	4106,
	4108,
	0);
INSERT INTO R_FORM
	VALUES (4096,
	4106,
	4110,
	1,
	1,
	'has waiting');
INSERT INTO R_RGO
	VALUES (4096,
	4106,
	4110);
INSERT INTO R_OIR
	VALUES (4096,
	4106,
	4110,
	0);
INSERT INTO R_SIMP
	VALUES (4111);
INSERT INTO R_REL
	VALUES (4111,
	2915,
	'',
	4078);
INSERT INTO R_PART
	VALUES (1492,
	4111,
	4112,
	0,
	1,
	'occupies');
INSERT INTO O_RTIDA
	VALUES (1521,
	1492,
	0,
	4111,
	4112);
INSERT INTO O_RTIDA
	VALUES (1522,
	1492,
	0,
	4111,
	4112);
INSERT INTO R_RTO
	VALUES (1492,
	4111,
	4112,
	0);
INSERT INTO R_OIR
	VALUES (1492,
	4111,
	4112,
	4080);
INSERT INTO R_FORM
	VALUES (4107,
	4111,
	4113,
	1,
	1,
	'defines state of');
INSERT INTO R_RGO
	VALUES (4107,
	4111,
	4113);
INSERT INTO R_OIR
	VALUES (4107,
	4111,
	4113,
	0);
INSERT INTO R_SIMP
	VALUES (4114);
INSERT INTO R_REL
	VALUES (4114,
	2909,
	'',
	4078);
INSERT INTO R_PART
	VALUES (4107,
	4114,
	4115,
	0,
	0,
	'defines value for characteristic of');
INSERT INTO O_RTIDA
	VALUES (4109,
	4107,
	0,
	4114,
	4115);
INSERT INTO R_RTO
	VALUES (4107,
	4114,
	4115,
	0);
INSERT INTO R_OIR
	VALUES (4107,
	4114,
	4115,
	0);
INSERT INTO R_FORM
	VALUES (4104,
	4114,
	4116,
	1,
	1,
	'has characteristic abstracted by');
INSERT INTO R_RGO
	VALUES (4104,
	4114,
	4116);
INSERT INTO R_OIR
	VALUES (4104,
	4114,
	4116,
	0);
INSERT INTO R_SIMP
	VALUES (4117);
INSERT INTO R_REL
	VALUES (4117,
	2933,
	'',
	4078);
INSERT INTO R_PART
	VALUES (4096,
	4117,
	4118,
	0,
	0,
	'');
INSERT INTO O_RTIDA
	VALUES (4100,
	4096,
	0,
	4117,
	4118);
INSERT INTO R_RTO
	VALUES (4096,
	4117,
	4118,
	0);
INSERT INTO R_OIR
	VALUES (4096,
	4117,
	4118,
	0);
INSERT INTO R_FORM
	VALUES (4119,
	4117,
	4120,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (4119,
	4117,
	4120);
INSERT INTO R_OIR
	VALUES (4119,
	4117,
	4120,
	0);
INSERT INTO R_SIMP
	VALUES (4121);
INSERT INTO R_REL
	VALUES (4121,
	2934,
	'',
	4078);
INSERT INTO R_PART
	VALUES (52,
	4121,
	4122,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (276,
	52,
	0,
	4121,
	4122);
INSERT INTO O_RTIDA
	VALUES (277,
	52,
	0,
	4121,
	4122);
INSERT INTO R_RTO
	VALUES (52,
	4121,
	4122,
	0);
INSERT INTO R_OIR
	VALUES (52,
	4121,
	4122,
	4083);
INSERT INTO R_FORM
	VALUES (4119,
	4121,
	4123,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (4119,
	4121,
	4123);
INSERT INTO R_OIR
	VALUES (4119,
	4121,
	4123,
	0);
INSERT INTO R_SIMP
	VALUES (4124);
INSERT INTO R_REL
	VALUES (4124,
	2935,
	'',
	4078);
INSERT INTO R_PART
	VALUES (4107,
	4124,
	4125,
	0,
	1,
	'targets');
INSERT INTO O_RTIDA
	VALUES (4109,
	4107,
	0,
	4124,
	4125);
INSERT INTO R_RTO
	VALUES (4107,
	4124,
	4125,
	0);
INSERT INTO R_OIR
	VALUES (4107,
	4124,
	4125,
	0);
INSERT INTO R_FORM
	VALUES (4096,
	4124,
	4126,
	1,
	1,
	'is target of');
INSERT INTO R_RGO
	VALUES (4096,
	4124,
	4126);
INSERT INTO R_OIR
	VALUES (4096,
	4124,
	4126,
	0);
INSERT INTO R_SIMP
	VALUES (4127);
INSERT INTO R_REL
	VALUES (4127,
	2937,
	'',
	4078);
INSERT INTO R_PART
	VALUES (4107,
	4127,
	4128,
	0,
	1,
	'was sent from');
INSERT INTO O_RTIDA
	VALUES (4109,
	4107,
	0,
	4127,
	4128);
INSERT INTO R_RTO
	VALUES (4107,
	4127,
	4128,
	0);
INSERT INTO R_OIR
	VALUES (4107,
	4127,
	4128,
	0);
INSERT INTO R_FORM
	VALUES (4096,
	4127,
	4129,
	1,
	1,
	'sends');
INSERT INTO R_RGO
	VALUES (4096,
	4127,
	4129);
INSERT INTO R_OIR
	VALUES (4096,
	4127,
	4129,
	0);
INSERT INTO R_SIMP
	VALUES (4130);
INSERT INTO R_REL
	VALUES (4130,
	2939,
	'',
	4078);
INSERT INTO R_PART
	VALUES (4096,
	4130,
	4131,
	0,
	1,
	'will be processed before');
INSERT INTO O_RTIDA
	VALUES (4100,
	4096,
	0,
	4130,
	4131);
INSERT INTO R_RTO
	VALUES (4096,
	4130,
	4131,
	0);
INSERT INTO R_OIR
	VALUES (4096,
	4130,
	4131,
	0);
INSERT INTO R_FORM
	VALUES (4096,
	4130,
	4132,
	0,
	1,
	'will be processed after');
INSERT INTO R_RGO
	VALUES (4096,
	4130,
	4132);
INSERT INTO R_OIR
	VALUES (4096,
	4130,
	4132,
	0);
INSERT INTO R_SIMP
	VALUES (4133);
INSERT INTO R_REL
	VALUES (4133,
	2940,
	'',
	4078);
INSERT INTO R_PART
	VALUES (4096,
	4133,
	4134,
	0,
	1,
	'provides delayed delivery of');
INSERT INTO O_RTIDA
	VALUES (4100,
	4096,
	0,
	4133,
	4134);
INSERT INTO R_RTO
	VALUES (4096,
	4133,
	4134,
	0);
INSERT INTO R_OIR
	VALUES (4096,
	4133,
	4134,
	0);
INSERT INTO R_FORM
	VALUES (4135,
	4133,
	4136,
	0,
	1,
	'delivered by');
INSERT INTO R_RGO
	VALUES (4135,
	4133,
	4136);
INSERT INTO R_OIR
	VALUES (4135,
	4133,
	4136,
	0);
INSERT INTO R_SIMP
	VALUES (4137);
INSERT INTO R_REL
	VALUES (4137,
	2948,
	'',
	4078);
INSERT INTO R_FORM
	VALUES (4138,
	4137,
	4139,
	0,
	1,
	'is being verified by');
INSERT INTO R_RGO
	VALUES (4138,
	4137,
	4139);
INSERT INTO R_OIR
	VALUES (4138,
	4137,
	4139,
	0);
INSERT INTO R_PART
	VALUES (699,
	4137,
	4140,
	0,
	1,
	'is verifying');
INSERT INTO O_RTIDA
	VALUES (712,
	699,
	0,
	4137,
	4140);
INSERT INTO R_RTO
	VALUES (699,
	4137,
	4140,
	0);
INSERT INTO R_OIR
	VALUES (699,
	4137,
	4140,
	4084);
INSERT INTO R_SIMP
	VALUES (4141);
INSERT INTO R_REL
	VALUES (4141,
	2953,
	'This association is used in Spotlight view to highlight last executed Transition ',
	4078);
INSERT INTO R_PART
	VALUES (1509,
	4141,
	4142,
	0,
	0,
	'entered last state via');
INSERT INTO O_RTIDA
	VALUES (1511,
	1509,
	0,
	4141,
	4142);
INSERT INTO O_RTIDA
	VALUES (1512,
	1509,
	0,
	4141,
	4142);
INSERT INTO R_RTO
	VALUES (1509,
	4141,
	4142,
	0);
INSERT INTO R_OIR
	VALUES (1509,
	4141,
	4142,
	4085);
INSERT INTO R_FORM
	VALUES (4107,
	4141,
	4143,
	1,
	1,
	'caused last state change to');
INSERT INTO R_RGO
	VALUES (4107,
	4141,
	4143);
INSERT INTO R_OIR
	VALUES (4107,
	4141,
	4143,
	0);
INSERT INTO R_SIMP
	VALUES (4144);
INSERT INTO R_REL
	VALUES (4144,
	2955,
	'',
	4078);
INSERT INTO R_FORM
	VALUES (4138,
	4144,
	4145,
	1,
	1,
	'instance being verified by');
INSERT INTO R_RGO
	VALUES (4138,
	4144,
	4145);
INSERT INTO R_OIR
	VALUES (4138,
	4144,
	4145,
	0);
INSERT INTO R_PART
	VALUES (709,
	4144,
	4146,
	0,
	1,
	'is verifying instance of');
INSERT INTO O_RTIDA
	VALUES (762,
	709,
	0,
	4144,
	4146);
INSERT INTO R_RTO
	VALUES (709,
	4144,
	4146,
	0);
INSERT INTO R_OIR
	VALUES (709,
	4144,
	4146,
	4086);
INSERT INTO R_SIMP
	VALUES (4147);
INSERT INTO R_REL
	VALUES (4147,
	2956,
	'',
	4078);
INSERT INTO R_PART
	VALUES (57,
	4147,
	4148,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (254,
	57,
	0,
	4147,
	4148);
INSERT INTO R_RTO
	VALUES (57,
	4147,
	4148,
	0);
INSERT INTO R_OIR
	VALUES (57,
	4147,
	4148,
	4087);
INSERT INTO R_FORM
	VALUES (4119,
	4147,
	4149,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (4119,
	4147,
	4149);
INSERT INTO R_OIR
	VALUES (4119,
	4147,
	4149,
	0);
INSERT INTO R_SIMP
	VALUES (4150);
INSERT INTO R_REL
	VALUES (4150,
	2957,
	'',
	4078);
INSERT INTO R_PART
	VALUES (4138,
	4150,
	4151,
	0,
	0,
	'created by');
INSERT INTO O_RTIDA
	VALUES (4152,
	4138,
	0,
	4150,
	4151);
INSERT INTO R_RTO
	VALUES (4138,
	4150,
	4151,
	0);
INSERT INTO R_OIR
	VALUES (4138,
	4150,
	4151,
	0);
INSERT INTO R_FORM
	VALUES (4107,
	4150,
	4153,
	1,
	1,
	'creates');
INSERT INTO R_RGO
	VALUES (4107,
	4150,
	4153);
INSERT INTO R_OIR
	VALUES (4107,
	4150,
	4153,
	0);
INSERT INTO R_SIMP
	VALUES (4154);
INSERT INTO R_REL
	VALUES (4154,
	2958,
	'',
	4078);
INSERT INTO R_PART
	VALUES (4107,
	4154,
	4155,
	0,
	0,
	'');
INSERT INTO O_RTIDA
	VALUES (4109,
	4107,
	0,
	4154,
	4155);
INSERT INTO R_RTO
	VALUES (4107,
	4154,
	4155,
	0);
INSERT INTO R_OIR
	VALUES (4107,
	4154,
	4155,
	0);
INSERT INTO R_FORM
	VALUES (4156,
	4154,
	4157,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (4156,
	4154,
	4157);
INSERT INTO R_OIR
	VALUES (4156,
	4154,
	4157,
	0);
INSERT INTO R_SIMP
	VALUES (4158);
INSERT INTO R_REL
	VALUES (4158,
	2959,
	'',
	4078);
INSERT INTO R_FORM
	VALUES (4156,
	4158,
	4159,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (4156,
	4158,
	4159);
INSERT INTO R_OIR
	VALUES (4156,
	4158,
	4159,
	0);
INSERT INTO R_PART
	VALUES (2322,
	4158,
	4160,
	0,
	0,
	'');
INSERT INTO O_RTIDA
	VALUES (2368,
	2322,
	0,
	4158,
	4160);
INSERT INTO R_RTO
	VALUES (2322,
	4158,
	4160,
	0);
INSERT INTO R_OIR
	VALUES (2322,
	4158,
	4160,
	4079);
INSERT INTO R_SIMP
	VALUES (4161);
INSERT INTO R_REL
	VALUES (4161,
	2901,
	'',
	4078);
INSERT INTO R_FORM
	VALUES (4092,
	4161,
	4162,
	0,
	1,
	'participates in');
INSERT INTO R_RGO
	VALUES (4092,
	4161,
	4162);
INSERT INTO R_OIR
	VALUES (4092,
	4161,
	4162,
	0);
INSERT INTO R_PART
	VALUES (4156,
	4161,
	4163,
	0,
	0,
	'has participant');
INSERT INTO O_RTIDA
	VALUES (4164,
	4156,
	0,
	4161,
	4163);
INSERT INTO O_RTIDA
	VALUES (4165,
	4156,
	0,
	4161,
	4163);
INSERT INTO R_RTO
	VALUES (4156,
	4161,
	4163,
	0);
INSERT INTO R_OIR
	VALUES (4156,
	4161,
	4163,
	0);
INSERT INTO R_SIMP
	VALUES (4166);
INSERT INTO R_REL
	VALUES (4166,
	2902,
	'',
	4078);
INSERT INTO R_FORM
	VALUES (4092,
	4166,
	4167,
	0,
	1,
	'formalizes');
INSERT INTO R_RGO
	VALUES (4092,
	4166,
	4167);
INSERT INTO R_OIR
	VALUES (4092,
	4166,
	4167,
	0);
INSERT INTO R_PART
	VALUES (4156,
	4166,
	4168,
	0,
	0,
	'has formalizing participant');
INSERT INTO O_RTIDA
	VALUES (4164,
	4156,
	0,
	4166,
	4168);
INSERT INTO O_RTIDA
	VALUES (4165,
	4156,
	0,
	4166,
	4168);
INSERT INTO R_RTO
	VALUES (4156,
	4166,
	4168,
	0);
INSERT INTO R_OIR
	VALUES (4156,
	4166,
	4168,
	0);
INSERT INTO R_SIMP
	VALUES (4169);
INSERT INTO R_REL
	VALUES (4169,
	2903,
	'',
	4078);
INSERT INTO R_FORM
	VALUES (4092,
	4169,
	4170,
	0,
	1,
	'is associator for');
INSERT INTO R_RGO
	VALUES (4092,
	4169,
	4170);
INSERT INTO R_OIR
	VALUES (4092,
	4169,
	4170,
	0);
INSERT INTO R_PART
	VALUES (4156,
	4169,
	4171,
	0,
	1,
	'has associator');
INSERT INTO O_RTIDA
	VALUES (4164,
	4156,
	0,
	4169,
	4171);
INSERT INTO O_RTIDA
	VALUES (4165,
	4156,
	0,
	4169,
	4171);
INSERT INTO R_RTO
	VALUES (4156,
	4169,
	4171,
	0);
INSERT INTO R_OIR
	VALUES (4156,
	4169,
	4171,
	0);
INSERT INTO R_SIMP
	VALUES (4172);
INSERT INTO R_REL
	VALUES (4172,
	2963,
	'',
	4078);
INSERT INTO R_FORM
	VALUES (4138,
	4172,
	4173,
	1,
	1,
	'instance being verified by');
INSERT INTO R_RGO
	VALUES (4138,
	4172,
	4173);
INSERT INTO R_OIR
	VALUES (4138,
	4172,
	4173,
	0);
INSERT INTO R_PART
	VALUES (2807,
	4172,
	4174,
	0,
	1,
	'is verifying instance of');
INSERT INTO O_RTIDA
	VALUES (4175,
	2807,
	0,
	4172,
	4174);
INSERT INTO R_RTO
	VALUES (2807,
	4172,
	4174,
	0);
INSERT INTO R_OIR
	VALUES (2807,
	4172,
	4174,
	4088);
INSERT INTO R_SIMP
	VALUES (4176);
INSERT INTO R_REL
	VALUES (4176,
	2964,
	'',
	4078);
INSERT INTO R_FORM
	VALUES (4096,
	4176,
	4177,
	1,
	1,
	'houses');
INSERT INTO R_RGO
	VALUES (4096,
	4176,
	4177);
INSERT INTO R_OIR
	VALUES (4096,
	4176,
	4177,
	0);
INSERT INTO R_PART
	VALUES (4138,
	4176,
	4178,
	0,
	0,
	'is pending in');
INSERT INTO O_RTIDA
	VALUES (4152,
	4138,
	0,
	4176,
	4178);
INSERT INTO R_RTO
	VALUES (4138,
	4176,
	4178,
	0);
INSERT INTO R_OIR
	VALUES (4138,
	4176,
	4178,
	0);
INSERT INTO R_SIMP
	VALUES (4179);
INSERT INTO R_REL
	VALUES (4179,
	2970,
	'',
	4078);
INSERT INTO R_FORM
	VALUES (4138,
	4179,
	4180,
	0,
	1,
	'is being verified by');
INSERT INTO R_RGO
	VALUES (4138,
	4179,
	4180);
INSERT INTO R_OIR
	VALUES (4138,
	4179,
	4180,
	0);
INSERT INTO R_PART
	VALUES (2798,
	4179,
	4181,
	0,
	1,
	'is verifying');
INSERT INTO O_RTIDA
	VALUES (2825,
	2798,
	0,
	4179,
	4181);
INSERT INTO R_RTO
	VALUES (2798,
	4179,
	4181,
	0);
INSERT INTO R_OIR
	VALUES (2798,
	4179,
	4181,
	4089);
INSERT INTO R_SIMP
	VALUES (4182);
INSERT INTO R_REL
	VALUES (4182,
	2974,
	'',
	4078);
INSERT INTO R_PART
	VALUES (4138,
	4182,
	4183,
	0,
	0,
	'');
INSERT INTO O_RTIDA
	VALUES (4152,
	4138,
	0,
	4182,
	4183);
INSERT INTO R_RTO
	VALUES (4138,
	4182,
	4183,
	0);
INSERT INTO R_OIR
	VALUES (4138,
	4182,
	4183,
	0);
INSERT INTO R_FORM
	VALUES (4184,
	4182,
	4185,
	0,
	1,
	'');
INSERT INTO R_RGO
	VALUES (4184,
	4182,
	4185);
INSERT INTO R_OIR
	VALUES (4184,
	4182,
	4185,
	0);
INSERT INTO R_SIMP
	VALUES (4186);
INSERT INTO R_REL
	VALUES (4186,
	2975,
	'',
	4078);
INSERT INTO R_PART
	VALUES (4184,
	4186,
	4187,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (4188,
	4184,
	0,
	4186,
	4187);
INSERT INTO R_RTO
	VALUES (4184,
	4186,
	4187,
	0);
INSERT INTO R_OIR
	VALUES (4184,
	4186,
	4187,
	0);
INSERT INTO R_FORM
	VALUES (4138,
	4186,
	4189,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (4138,
	4186,
	4189);
INSERT INTO R_OIR
	VALUES (4138,
	4186,
	4189,
	0);
INSERT INTO R_SIMP
	VALUES (4190);
INSERT INTO R_REL
	VALUES (4190,
	2976,
	'',
	4078);
INSERT INTO R_PART
	VALUES (4138,
	4190,
	4191,
	0,
	1,
	'originates from');
INSERT INTO O_RTIDA
	VALUES (4152,
	4138,
	0,
	4190,
	4191);
INSERT INTO R_RTO
	VALUES (4138,
	4190,
	4191,
	0);
INSERT INTO R_OIR
	VALUES (4138,
	4190,
	4191,
	0);
INSERT INTO R_FORM
	VALUES (4096,
	4190,
	4192,
	1,
	1,
	'sends');
INSERT INTO R_RGO
	VALUES (4096,
	4190,
	4192);
INSERT INTO R_OIR
	VALUES (4096,
	4190,
	4192,
	0);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (4135,
	'Timer',
	2913,
	'I_TIM',
	'',
	4078);
INSERT INTO O_TFR
	VALUES (4193,
	4135,
	'tick',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	4194);
INSERT INTO O_TFR
	VALUES (4195,
	4135,
	'fire',
	'',
	19,
	1,
	'// Timer.fire()
select one evt related by self->I_EVI[R2940];
self.removeTimer();
if (not_empty evt)
  if (self.recurring == true)
    self.expiration = Util::addIntToLong(longVar:self.currentTime(), intVar:self.delay);
    evt_ID = evt.clone();
    select any newEvt from instances of I_EVI where selected.Event_ID == evt_ID;
    unrelate self from evt across R2940;
    relate self to newEvt across R2940;
    select one comptInst related by evt ->I_EXE[R2964];
    self.insertTimer(componentInstanceId:comptInst.Execution_Engine_ID);
  end if;
  evt.fire();
end if;
if (self.recurring == false)
  discard = self.dispose();
end if;',
	1,
	'',
	4196);
INSERT INTO O_TFR
	VALUES (4196,
	4135,
	'dispose',
	'',
	316,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return false;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (4194,
	4135,
	'set',
	'',
	19,
	1,
	'self.running = false;
self.recurring = false;
self.delay = param.delay;
self.expiration = Util::addIntToLong(longVar:self.currentTime(), intVar:self.delay);',
	1,
	'',
	4195);
INSERT INTO O_TPARM
	VALUES (4197,
	4194,
	'delay',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (4198,
	4135,
	'currentTime',
	'Translate:native',
	2978,
	1,
	'return lib.TIM.getCurrentTime();',
	0,
	'',
	4193);
INSERT INTO O_TFR
	VALUES (4199,
	4135,
	'removeTimer',
	'Translate:native',
	19,
	1,
	'lib.TIM.removeTimer(this);',
	0,
	'',
	4198);
INSERT INTO O_TFR
	VALUES (4200,
	4135,
	'insertTimer',
	'Translate:native',
	19,
	1,
	'ModelRoot modelRoot = getModelRoot();
		ComponentInstance_c ee = (ComponentInstance_c) modelRoot
				.getInstanceList(ComponentInstance_c.class).getGlobal(
						p_Componentinstanceid);
lib.TIM.insertTimer(this, ee);
',
	0,
	'',
	4199);
INSERT INTO O_TPARM
	VALUES (4201,
	4200,
	'componentInstanceId',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_NBATTR
	VALUES (4202,
	4135);
INSERT INTO O_BATTR
	VALUES (4202,
	4135);
INSERT INTO O_ATTR
	VALUES (4202,
	4135,
	0,
	'Timer_ID',
	'',
	'',
	'Timer_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (4203,
	4135);
INSERT INTO O_BATTR
	VALUES (4203,
	4135);
INSERT INTO O_ATTR
	VALUES (4203,
	4135,
	4202,
	'delay',
	'',
	'',
	'delay',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (4204,
	4135);
INSERT INTO O_BATTR
	VALUES (4204,
	4135);
INSERT INTO O_ATTR
	VALUES (4204,
	4135,
	4203,
	'running',
	'',
	'',
	'running',
	0,
	316,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (4205,
	4135);
INSERT INTO O_BATTR
	VALUES (4205,
	4135);
INSERT INTO O_ATTR
	VALUES (4205,
	4135,
	4204,
	'recurring',
	'',
	'',
	'recurring',
	0,
	316,
	'',
	'');
INSERT INTO O_REF
	VALUES (4135,
	4096,
	0,
	4100,
	4133,
	4136,
	4134,
	4206,
	4207,
	0,
	0,
	'',
	'Pending Event',
	'Event_ID',
	'R2940.''provides delayed delivery of''');
INSERT INTO O_RATTR
	VALUES (4206,
	4135,
	4100,
	4096,
	1,
	'Event_ID');
INSERT INTO O_ATTR
	VALUES (4206,
	4135,
	4205,
	'Event_ID',
	'',
	'',
	'Event_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (4208,
	4135,
	'timeLeft = Util::diffLongsToInt(v1:self.expiration, v2:self.currentTime());
result = GD::int_to_string(value:timeLeft) + " uS remaining";
select one evt related by self->I_EVI[R2940];
if (timeLeft < 0 or empty evt)
  result = "not running";
else
  result = result + ", " + evt.Label;
end if;
self.Label = result;',
	1);
INSERT INTO O_BATTR
	VALUES (4208,
	4135);
INSERT INTO O_ATTR
	VALUES (4208,
	4135,
	4206,
	'Label',
	'',
	'',
	'Label',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (4209,
	4135);
INSERT INTO O_BATTR
	VALUES (4209,
	4135);
INSERT INTO O_ATTR
	VALUES (4209,
	4135,
	4208,
	'expiration',
	'',
	'',
	'expiration',
	0,
	2978,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	4135);
INSERT INTO O_OIDA
	VALUES (4202,
	4135,
	0,
	'Timer_ID');
INSERT INTO O_ID
	VALUES (1,
	4135);
INSERT INTO O_ID
	VALUES (2,
	4135);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (4096,
	'Pending Event',
	2902,
	'I_EVI',
	'',
	4078);
INSERT INTO O_TFR
	VALUES (4210,
	4096,
	'dispose',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	4211);
INSERT INTO O_TFR
	VALUES (4212,
	4096,
	'fire',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	4210);
INSERT INTO O_TFR
	VALUES (4213,
	4096,
	'fireToInstSM',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	4214);
INSERT INTO O_TFR
	VALUES (4214,
	4096,
	'fireToClassSM',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	4212);
INSERT INTO O_TFR
	VALUES (4215,
	4096,
	'createInstance',
	'This operation is responsible for creating a new instance of a class when a
pending event is generated for a creation transition.',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	4216);
INSERT INTO O_TPARM
	VALUES (4217,
	4215,
	'stack_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (4218,
	4215,
	'step_in',
	316,
	0,
	'',
	4217,
	'');
INSERT INTO O_TFR
	VALUES (4219,
	4096,
	'getValue',
	'Translate:native',
	317,
	1,
	'return this;',
	0,
	'',
	4213);
INSERT INTO O_TFR
	VALUES (4211,
	4096,
	'deliverAs',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	4215);
INSERT INTO O_TPARM
	VALUES (4220,
	4211,
	'evt_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (4221,
	4211,
	'to_inst_id',
	296,
	0,
	'',
	4222,
	'');
INSERT INTO O_TPARM
	VALUES (4223,
	4211,
	'stack_id',
	296,
	0,
	'',
	4220,
	'');
INSERT INTO O_TPARM
	VALUES (4222,
	4211,
	'step_in',
	316,
	0,
	'',
	4223,
	'');
INSERT INTO O_TFR
	VALUES (4216,
	4096,
	'clone',
	'',
	296,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return GD::NULL_UNIQUE_ID();',
	1,
	'',
	0);
INSERT INTO O_NBATTR
	VALUES (4100,
	4096);
INSERT INTO O_BATTR
	VALUES (4100,
	4096);
INSERT INTO O_ATTR
	VALUES (4100,
	4096,
	0,
	'Event_ID',
	'',
	'',
	'Event_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (4224,
	4096);
INSERT INTO O_BATTR
	VALUES (4224,
	4096);
INSERT INTO O_ATTR
	VALUES (4224,
	4096,
	4100,
	'isExecuting',
	'',
	'',
	'isExecuting',
	0,
	316,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (4225,
	4096);
INSERT INTO O_BATTR
	VALUES (4225,
	4096);
INSERT INTO O_ATTR
	VALUES (4225,
	4096,
	4224,
	'isCreation',
	'',
	'',
	'isCreation',
	0,
	316,
	'',
	'');
INSERT INTO O_REF
	VALUES (4096,
	1488,
	0,
	1604,
	4094,
	4097,
	4095,
	4226,
	4227,
	0,
	0,
	'',
	'State Machine Event',
	'SMevt_ID',
	'R2906.''is instance of''');
INSERT INTO O_RATTR
	VALUES (4226,
	4096,
	1604,
	1488,
	1,
	'SMevt_ID');
INSERT INTO O_ATTR
	VALUES (4226,
	4096,
	4225,
	'SMevt_ID',
	'',
	'',
	'SMevt_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (4096,
	4107,
	0,
	4109,
	4106,
	4110,
	4108,
	4228,
	4229,
	0,
	0,
	'',
	'Instance',
	'Inst_ID',
	'R2907.''is pending for''');
INSERT INTO O_REF
	VALUES (4096,
	4107,
	0,
	4109,
	4124,
	4126,
	4125,
	4228,
	4230,
	4229,
	0,
	'',
	'Instance',
	'Inst_ID',
	'R2935.''targets''');
INSERT INTO O_RATTR
	VALUES (4228,
	4096,
	4109,
	4107,
	1,
	'Inst_ID');
INSERT INTO O_ATTR
	VALUES (4228,
	4096,
	4226,
	'Target_Inst_ID',
	'',
	'Target_',
	'Inst_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (4096,
	4096,
	0,
	4100,
	4098,
	4101,
	4099,
	4231,
	4232,
	0,
	0,
	'',
	'Pending Event',
	'Event_ID',
	'R2908.''will be processed after''');
INSERT INTO O_RATTR
	VALUES (4231,
	4096,
	4100,
	4096,
	1,
	'Event_ID');
INSERT INTO O_ATTR
	VALUES (4231,
	4096,
	4228,
	'nextEvent_ID',
	'',
	'next',
	'Event_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (4096,
	4107,
	0,
	4109,
	4127,
	4129,
	4128,
	4233,
	4234,
	0,
	0,
	'',
	'Instance',
	'Inst_ID',
	'R2937.''was sent from''');
INSERT INTO O_RATTR
	VALUES (4233,
	4096,
	4109,
	4107,
	1,
	'Inst_ID');
INSERT INTO O_ATTR
	VALUES (4233,
	4096,
	4231,
	'Sent_By_Inst_ID',
	'',
	'Sent_By_',
	'Inst_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (4096,
	4096,
	0,
	4100,
	4130,
	4132,
	4131,
	4235,
	4236,
	0,
	0,
	'',
	'Pending Event',
	'Event_ID',
	'R2939.''will be processed before''');
INSERT INTO O_RATTR
	VALUES (4235,
	4096,
	4100,
	4096,
	1,
	'Event_ID');
INSERT INTO O_ATTR
	VALUES (4235,
	4096,
	4233,
	'next_self_Event_ID',
	'',
	'next_self_',
	'Event_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (4237,
	4096,
	'// Pending Event.Label
result = "";
select one evt related by self ->SM_EVT[R2906];
  if (not_empty evt)
    select one signalEvt related by evt->SM_SEVT[R525]->SM_SGEVT[R526];
    if(not_empty signalEvt)
      result = signalEvt.get_event_text();
    else
      result = evt.get_event_text();
    end if;
    select one timer related by self->I_TIM[R2940];
    if (not_empty timer)
      result = result + " delayed by " + GD::int_to_string(value:timer.delay) + " uS";
    end if;
  end if;
self.Label = result;',
	1);
INSERT INTO O_BATTR
	VALUES (4237,
	4096);
INSERT INTO O_ATTR
	VALUES (4237,
	4096,
	4238,
	'Label',
	'',
	'',
	'Label',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (4096,
	4138,
	0,
	4152,
	4176,
	4177,
	4178,
	4239,
	4240,
	0,
	0,
	'',
	'Component Instance',
	'Execution_Engine_ID',
	'R2964.''is pending in''');
INSERT INTO O_RATTR
	VALUES (4239,
	4096,
	4152,
	4138,
	1,
	'Execution_Engine_ID');
INSERT INTO O_ATTR
	VALUES (4239,
	4096,
	4235,
	'Execution_Engine_ID',
	'',
	'',
	'Execution_Engine_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (4096,
	4138,
	0,
	4152,
	4190,
	4192,
	4191,
	4238,
	4241,
	0,
	0,
	'',
	'Component Instance',
	'Execution_Engine_ID',
	'R2976.''originates from''');
INSERT INTO O_RATTR
	VALUES (4238,
	4096,
	4152,
	4138,
	1,
	'Execution_Engine_ID');
INSERT INTO O_ATTR
	VALUES (4238,
	4096,
	4239,
	'Originating_Execution_Engine_ID',
	'',
	'Originating_',
	'Execution_Engine_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	4096);
INSERT INTO O_OIDA
	VALUES (4100,
	4096,
	0,
	'Event_ID');
INSERT INTO O_ID
	VALUES (1,
	4096);
INSERT INTO O_ID
	VALUES (2,
	4096);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (4156,
	'Link Participation',
	2919,
	'I_LIP',
	'',
	4078);
INSERT INTO O_TFR
	VALUES (4242,
	4156,
	'dispose',
	'',
	19,
	1,
	'// Get rid of the link relationships related to this instance
select one partLink related by self->I_LNK[R2901];
if(not_empty partLink)
  unrelate partLink from self across R2901;
  partLink.dispose();
end if;

select one formalizingLink related by self->I_LNK[R2902];
if(not_empty formalizingLink)
  unrelate formalizingLink from self across R2902;
  formalizingLink.dispose();
end if;

select one associatorLink related by self->I_LNK[R2903];
if(not_empty associatorLink)
  unrelate associatorLink from self across R2903;
  associatorLink.dispose();
end if;

select one ins related by self->I_INS[R2958];
if (not_empty ins)
  unrelate ins from self across R2958;
end if;

select one rel related by self->R_REL[R2959];
if (not_empty rel)
  unrelate rel from self across R2959;
end if;


delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (4156,
	4107,
	0,
	4109,
	4154,
	4157,
	4155,
	4243,
	4244,
	0,
	0,
	'',
	'Instance',
	'Inst_ID',
	'R2958');
INSERT INTO O_RATTR
	VALUES (4243,
	4156,
	4109,
	4107,
	1,
	'Inst_ID');
INSERT INTO O_ATTR
	VALUES (4243,
	4156,
	4164,
	'Inst_ID',
	'',
	'',
	'Inst_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (4245,
	4156,
	'select one assoc related by self->R_REL[R2959];
if not_empty assoc
  phrase = "";
  select one origin related by self->I_LNK[R2901];
  select one associator related by self->I_LNK[R2903];
  if(empty associator)
    select one simp related by assoc->R_SIMP[R206];
    if(not_empty simp)
      if(not_empty origin)
        select many parts related by simp->R_PART[R207];
        for each part in parts
          // in the case of an unformalized association
          // we will have two parts and want the last one''s
          // text phrase
          phrase = part.Txt_Phrs;
        end for;    
      else
        select one form related by simp->R_FORM[R208];
        if(not_empty form)
          phrase = form.Txt_Phrs;
        else
          // we are dealing with an unformalized
          // association, in which case the first
          // R_PART is always used as the origin
          // we want to return its text phrase
          select many parts related by simp->R_PART[R207];
          for each part in parts
            phrase = part.Txt_Phrs;
            break;
          end for;          
        end if;
      end if;
    end if;
    select one linked related by assoc->R_ASSOC[R206];
    if(not_empty linked)
      if(not_empty origin)
        select one aoth related by linked->R_AOTH[R210];
        if(not_empty aoth)
          phrase = aoth.Txt_Phrs;
        end if;
      else
        select one aone related by linked->R_AONE[R209];
        if(not_empty aone)
          phrase = aone.Txt_Phrs;
        end if;
      end if;
    end if;
  end if;
  if(phrase != "")
    self.Label = assoc.get_name() + "."
                                     + Util::getTic() + phrase + Util::getTic();
  else
  	self.Label = assoc.get_name();
  end if;
else
  self.Label = "Unknown Association";
end if;',
	1);
INSERT INTO O_BATTR
	VALUES (4245,
	4156);
INSERT INTO O_ATTR
	VALUES (4245,
	4156,
	4243,
	'Label',
	'',
	'',
	'Label',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (4156,
	2322,
	0,
	2368,
	4158,
	4159,
	4160,
	4164,
	4246,
	0,
	0,
	'',
	'Association',
	'Rel_ID',
	'R2959');
INSERT INTO O_RATTR
	VALUES (4164,
	4156,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (4164,
	4156,
	4165,
	'Rel_ID',
	'',
	'',
	'Rel_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (4165,
	4156);
INSERT INTO O_BATTR
	VALUES (4165,
	4156);
INSERT INTO O_ATTR
	VALUES (4165,
	4156,
	0,
	'Participation_ID',
	'',
	'',
	'Participation_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	4156);
INSERT INTO O_OIDA
	VALUES (4164,
	4156,
	0,
	'Rel_ID');
INSERT INTO O_OIDA
	VALUES (4165,
	4156,
	0,
	'Participation_ID');
INSERT INTO O_ID
	VALUES (1,
	4156);
INSERT INTO O_ID
	VALUES (2,
	4156);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (4092,
	'Link',
	2901,
	'I_LNK',
	'',
	4078);
INSERT INTO O_TFR
	VALUES (4247,
	4092,
	'dispose',
	'',
	19,
	1,
	'// Instance:Link.dispose()

select one OriginInst related by self->I_LIP[R2901];
select one DestinationInst related by self->I_LIP[R2902];
select one AssociatorInst related by self->I_LIP[R2903];

//  Unrelate the links
if (not_empty OriginInst)
  unrelate OriginInst from self across R2901;
  OriginInst.dispose();
end if;

if (not_empty DestinationInst)
  unrelate DestinationInst from self across R2902;
  DestinationInst.dispose();
end if;

if (not_empty AssociatorInst)
  unrelate AssociatorInst from self across R2903;
  AssociatorInst.dispose();
end if;

// Unrelate from the association
select one association related by self->R_REL[R2904];
if (not_empty association)
  unrelate association from self across R2904;
end if;

// And delete ourself
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_NBATTR
	VALUES (4248,
	4092);
INSERT INTO O_BATTR
	VALUES (4248,
	4092);
INSERT INTO O_ATTR
	VALUES (4248,
	4092,
	0,
	'Link_ID',
	'',
	'',
	'Link_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_REF
	VALUES (4092,
	2322,
	0,
	2368,
	4090,
	4093,
	4091,
	4249,
	4250,
	0,
	0,
	'',
	'Association',
	'Rel_ID',
	'R2904.''is instance of''');
INSERT INTO O_REF
	VALUES (4092,
	4156,
	0,
	4164,
	4161,
	4162,
	4163,
	4249,
	4251,
	4250,
	0,
	'',
	'Link Participation',
	'Rel_ID',
	'R2901.''has participant''');
INSERT INTO O_REF
	VALUES (4092,
	4156,
	0,
	4164,
	4166,
	4167,
	4168,
	4249,
	4252,
	4251,
	0,
	'',
	'Link Participation',
	'Rel_ID',
	'R2902.''has formalizing participant''');
INSERT INTO O_REF
	VALUES (4092,
	4156,
	0,
	4164,
	4169,
	4170,
	4171,
	4249,
	4253,
	4252,
	0,
	'',
	'Link Participation',
	'Rel_ID',
	'R2903.''has associator''');
INSERT INTO O_RATTR
	VALUES (4249,
	4092,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (4249,
	4092,
	4248,
	'Rel_ID',
	'',
	'',
	'Rel_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (4092,
	4156,
	0,
	4165,
	4161,
	4162,
	4163,
	4254,
	4255,
	0,
	0,
	'',
	'Link Participation',
	'Participation_ID',
	'R2901.''has participant''');
INSERT INTO O_RATTR
	VALUES (4254,
	4092,
	4165,
	4156,
	1,
	'Participation_ID');
INSERT INTO O_ATTR
	VALUES (4254,
	4092,
	4249,
	'Participation_ID',
	'',
	'',
	'Participation_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (4092,
	4156,
	0,
	4165,
	4166,
	4167,
	4168,
	4256,
	4257,
	0,
	0,
	'',
	'Link Participation',
	'Participation_ID',
	'R2902.''has formalizing participant''');
INSERT INTO O_RATTR
	VALUES (4256,
	4092,
	4165,
	4156,
	1,
	'Participation_ID');
INSERT INTO O_ATTR
	VALUES (4256,
	4092,
	4254,
	'Formalizing_Participation_ID',
	'',
	'Formalizing_',
	'Participation_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (4092,
	4156,
	0,
	4165,
	4169,
	4170,
	4171,
	4258,
	4259,
	0,
	0,
	'',
	'Link Participation',
	'Participation_ID',
	'R2903.''has associator''');
INSERT INTO O_RATTR
	VALUES (4258,
	4092,
	4165,
	4156,
	1,
	'Participation_ID');
INSERT INTO O_ATTR
	VALUES (4258,
	4092,
	4256,
	'Associator_Participation_ID',
	'',
	'Associator_',
	'Participation_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	4092);
INSERT INTO O_OIDA
	VALUES (4248,
	4092,
	0,
	'Link_ID');
INSERT INTO O_ID
	VALUES (1,
	4092);
INSERT INTO O_ID
	VALUES (2,
	4092);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (4107,
	'Instance',
	2904,
	'I_INS',
	'',
	4078);
INSERT INTO O_TFR
	VALUES (4260,
	4107,
	'takeEvent',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	4261);
INSERT INTO O_TPARM
	VALUES (4262,
	4260,
	'stack_id',
	296,
	0,
	'',
	4263,
	'');
INSERT INTO O_TPARM
	VALUES (4264,
	4260,
	'step_in',
	316,
	0,
	'',
	4262,
	'');
INSERT INTO O_TPARM
	VALUES (4263,
	4260,
	'event_queue_entry_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (4265,
	4107,
	'dispose',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	4266);
INSERT INTO O_TFR
	VALUES (4267,
	4107,
	'initialize',
	'This operation is responsible for setting up everything that is known about
an instance upon creation.  For example, it will create any attributes for
unique identifiers, populate their values, and if an instance state machine
exists it will relate the states to this instance.',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	4268);
INSERT INTO O_TPARM
	VALUES (4269,
	4267,
	'initializeState',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (4270,
	4107,
	'stepIn',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	4267);
INSERT INTO O_TFR
	VALUES (4261,
	4107,
	'stepOver',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	4270);
INSERT INTO O_TFR
	VALUES (4271,
	4107,
	'takeNextEvent',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	4260);
INSERT INTO O_TPARM
	VALUES (4272,
	4271,
	'step_in',
	316,
	0,
	'',
	4273,
	'');
INSERT INTO O_TPARM
	VALUES (4273,
	4271,
	'stack_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (4268,
	4107,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Inst_ID;',
	1,
	'',
	4265);
INSERT INTO O_TFR
	VALUES (4266,
	4107,
	'deliverEventToSubtypeInstance',
	'',
	316,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return false;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (4274,
	4266,
	'class_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (4275,
	4266,
	'event_id',
	296,
	0,
	'',
	4274,
	'');
INSERT INTO O_TPARM
	VALUES (4276,
	4266,
	'evt_inst_id',
	296,
	0,
	'',
	4275,
	'');
INSERT INTO O_TPARM
	VALUES (4277,
	4266,
	'stack_id',
	296,
	0,
	'',
	4276,
	'');
INSERT INTO O_TPARM
	VALUES (4278,
	4266,
	'step_in',
	316,
	0,
	'',
	4277,
	'');
INSERT INTO O_NBATTR
	VALUES (4109,
	4107);
INSERT INTO O_BATTR
	VALUES (4109,
	4107);
INSERT INTO O_ATTR
	VALUES (4109,
	4107,
	0,
	'Inst_ID',
	'',
	'',
	'Inst_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (4279,
	4107);
INSERT INTO O_BATTR
	VALUES (4279,
	4107);
INSERT INTO O_ATTR
	VALUES (4279,
	4107,
	4109,
	'Name',
	'',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (4107,
	1492,
	0,
	1521,
	4111,
	4113,
	4112,
	4280,
	4281,
	0,
	0,
	'',
	'State Machine State',
	'SM_ID',
	'R2915.''occupies''');
INSERT INTO O_REF
	VALUES (4107,
	1509,
	0,
	1512,
	4141,
	4143,
	4142,
	4280,
	4282,
	4281,
	0,
	'',
	'Transition',
	'SM_ID',
	'R2953.''entered last state via''');
INSERT INTO O_RATTR
	VALUES (4280,
	4107,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (4280,
	4107,
	4279,
	'SM_ID',
	'',
	'',
	'SM_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (4107,
	1492,
	0,
	1522,
	4111,
	4113,
	4112,
	4283,
	4284,
	0,
	0,
	'',
	'State Machine State',
	'SMstt_ID',
	'R2915.''occupies''');
INSERT INTO O_RATTR
	VALUES (4283,
	4107,
	1522,
	1492,
	1,
	'SMstt_ID');
INSERT INTO O_ATTR
	VALUES (4283,
	4107,
	4280,
	'SMstt_ID',
	'',
	'',
	'SMstt_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (4285,
	4107,
	'// Mentor Graphics Verifier-specific Implementation
self.Label="";',
	1);
INSERT INTO O_BATTR
	VALUES (4285,
	4107);
INSERT INTO O_ATTR
	VALUES (4285,
	4107,
	4286,
	'Label',
	'',
	'',
	'Label',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (4287,
	4107);
INSERT INTO O_BATTR
	VALUES (4287,
	4107);
INSERT INTO O_ATTR
	VALUES (4287,
	4107,
	4285,
	'Default_Name',
	'',
	'',
	'Default_Name',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (4107,
	1509,
	0,
	1511,
	4141,
	4143,
	4142,
	4286,
	4288,
	0,
	0,
	'',
	'Transition',
	'Trans_ID',
	'R2953.''entered last state via''');
INSERT INTO O_RATTR
	VALUES (4286,
	4107,
	1511,
	1509,
	1,
	'Trans_ID');
INSERT INTO O_ATTR
	VALUES (4286,
	4107,
	4289,
	'Trans_ID',
	'',
	'',
	'Trans_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (4107,
	4138,
	0,
	4152,
	4150,
	4153,
	4151,
	4289,
	4290,
	0,
	0,
	'',
	'Component Instance',
	'Execution_Engine_ID',
	'R2957.''created by''');
INSERT INTO O_RATTR
	VALUES (4289,
	4107,
	4152,
	4138,
	1,
	'Execution_Engine_ID');
INSERT INTO O_ATTR
	VALUES (4289,
	4107,
	4283,
	'Execution_Engine_ID',
	'',
	'',
	'Execution_Engine_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	4107);
INSERT INTO O_OIDA
	VALUES (4109,
	4107,
	0,
	'Inst_ID');
INSERT INTO O_ID
	VALUES (1,
	4107);
INSERT INTO O_ID
	VALUES (2,
	4107);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (4119,
	'Data Item Value',
	2912,
	'I_DIV',
	'',
	4078);
INSERT INTO O_TFR
	VALUES (4291,
	4119,
	'setBoolean',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation

',
	1,
	'',
	4292);
INSERT INTO O_TPARM
	VALUES (4293,
	4291,
	'value',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (4294,
	4119,
	'setInteger',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	4291);
INSERT INTO O_TPARM
	VALUES (4295,
	4294,
	'value',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (4296,
	4119,
	'setReal',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	4294);
INSERT INTO O_TPARM
	VALUES (4297,
	4296,
	'value',
	374,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (4298,
	4119,
	'setString',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	4296);
INSERT INTO O_TPARM
	VALUES (4299,
	4298,
	'value',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (4300,
	4119,
	'setUnique_ID',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	4298);
INSERT INTO O_TPARM
	VALUES (4301,
	4300,
	'value',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (4292,
	4119,
	'getValue',
	'',
	317,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return GD::NULL_INSTANCE();',
	1,
	'',
	4302);
INSERT INTO O_TFR
	VALUES (4302,
	4119,
	'dispose',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (4119,
	4096,
	0,
	4100,
	4117,
	4120,
	4118,
	4303,
	4304,
	0,
	0,
	'',
	'Pending Event',
	'Event_ID',
	'R2933');
INSERT INTO O_RATTR
	VALUES (4303,
	4119,
	4100,
	4096,
	1,
	'Event_ID');
INSERT INTO O_ATTR
	VALUES (4303,
	4119,
	4305,
	'Event_ID',
	'',
	'',
	'Event_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (4119,
	52,
	0,
	276,
	4121,
	4123,
	4122,
	4306,
	4307,
	0,
	0,
	'',
	'State Machine Event Data Item',
	'SM_ID',
	'R2934');
INSERT INTO O_RATTR
	VALUES (4306,
	4119,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (4306,
	4119,
	4303,
	'SM_ID',
	'',
	'',
	'SM_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (4119,
	52,
	0,
	277,
	4121,
	4123,
	4122,
	4308,
	4309,
	0,
	0,
	'',
	'State Machine Event Data Item',
	'SMedi_ID',
	'R2934');
INSERT INTO O_RATTR
	VALUES (4308,
	4119,
	277,
	52,
	1,
	'SMedi_ID');
INSERT INTO O_ATTR
	VALUES (4308,
	4119,
	4306,
	'SMedi_ID',
	'',
	'',
	'SMedi_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (4119,
	57,
	0,
	254,
	4147,
	4149,
	4148,
	4310,
	4311,
	0,
	0,
	'',
	'Property Parameter',
	'PP_Id',
	'R2956');
INSERT INTO O_RATTR
	VALUES (4310,
	4119,
	254,
	57,
	1,
	'PP_Id');
INSERT INTO O_ATTR
	VALUES (4310,
	4119,
	4308,
	'PP_Id',
	'',
	'',
	'PP_Id',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (4305,
	4119);
INSERT INTO O_BATTR
	VALUES (4305,
	4119);
INSERT INTO O_ATTR
	VALUES (4305,
	4119,
	0,
	'DIV_ID',
	'',
	'',
	'DIV_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	4119);
INSERT INTO O_OIDA
	VALUES (4305,
	4119,
	0,
	'DIV_ID');
INSERT INTO O_ID
	VALUES (1,
	4119);
INSERT INTO O_ID
	VALUES (2,
	4119);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (4184,
	'Component Instance Container',
	2921,
	'I_CIN',
	'',
	4078);
INSERT INTO O_REF
	VALUES (4184,
	4138,
	0,
	4152,
	4182,
	4185,
	4183,
	4188,
	4312,
	0,
	0,
	'',
	'Component Instance',
	'Execution_Engine_ID',
	'R2974');
INSERT INTO O_RATTR
	VALUES (4188,
	4184,
	4152,
	4138,
	0,
	'Execution_Engine_ID');
INSERT INTO O_ATTR
	VALUES (4188,
	4184,
	0,
	'Container_ID',
	'',
	'',
	'Container_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	4184);
INSERT INTO O_OIDA
	VALUES (4188,
	4184,
	0,
	'Container_ID');
INSERT INTO O_ID
	VALUES (1,
	4184);
INSERT INTO O_ID
	VALUES (2,
	4184);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (4138,
	'Component Instance',
	2906,
	'I_EXE',
	'',
	4078);
INSERT INTO O_TFR
	VALUES (4313,
	4138,
	'step',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	4314);
INSERT INTO O_TFR
	VALUES (4315,
	4138,
	'InitializeArchitecture',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (4316,
	4138,
	'getNextUnique_ID',
	'

',
	298,
	1,
	'//  Instance:Execution Engine.getNextUnique_ID()
self.Next_Unique_ID = self.Next_Unique_ID + 1;
return self.Next_Unique_ID;',
	1,
	'',
	4317);
INSERT INTO O_TFR
	VALUES (4314,
	4138,
	'start',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	4318);
INSERT INTO O_TFR
	VALUES (4319,
	4138,
	'stop',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	4313);
INSERT INTO O_TFR
	VALUES (4317,
	4138,
	'getNextInstance_ID',
	'',
	322,
	1,
	'//  Instance:Execution Engine.getNextInstance_ID()
self.Next_Instance_ID = self.Next_Instance_ID + 1;
return GD::int_to_string(value:self.Next_Instance_ID);',
	1,
	'',
	4320);
INSERT INTO O_TFR
	VALUES (4318,
	4138,
	'reset',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	4316);
INSERT INTO O_TFR
	VALUES (4321,
	4138,
	'dispose',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	4315);
INSERT INTO O_TFR
	VALUES (4320,
	4138,
	'getEngineNumber',
	'',
	298,
	1,
	'select one component related by self->C_C[R2955];
if(not_empty component)
  count = 0;
  select many engines related by component->I_EXE[R2955];
  for each engine in engines
    count = count + 1;
    if(engine == self)
      return count;
    end if;
  end for;
else
  select one icomponent related by self->CL_IC[R2963];
  if(not_empty icomponent)
    count = 0;
    select many engines related by icomponent->I_EXE[R2963];
      for each engine in engines
        count = count + 1;
        if(engine == self)
          return count;
        end if;
      end for;
    end if;  
end if;
return 1;',
	1,
	'',
	4321);
INSERT INTO O_TFR
	VALUES (4322,
	4138,
	'initializeClasses',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	4319);
INSERT INTO O_TFR
	VALUES (4323,
	4138,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.
                            
Translate: native',
	317,
	1,
	'// just return this instance as an Object
return this;',
	0,
	'',
	4322);
INSERT INTO O_TFR
	VALUES (4324,
	4138,
	'notify',
	'Translate:native',
	19,
	1,
	'if (lib.TIM.isSIM_TIME()) {
  lib.TIM.busyNotification(this);
}

synchronized(this) {
  this.notify();
}',
	0,
	'',
	4323);
INSERT INTO O_TFR
	VALUES (4325,
	4138,
	'lockQueue',
	'Translate:native',
	19,
	1,
	'if (p_Queue_name.compareTo("I_EQE")==0) {
	m_eqe_lock.lock();
} else if (p_Queue_name.compareTo("I_SQE")==0) {
	m_sqe_lock.lock();
} else {
	Exception e = new Exception();
	e.fillInStackTrace();
	CorePlugin.logError(
			"Invalid queue name specified: " + p_Queue_name,
			e);
}
',
	0,
	'',
	4324);
INSERT INTO O_TPARM
	VALUES (4326,
	4325,
	'queue_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (4327,
	4138,
	'unlockQueue',
	'Translate:native',
	19,
	1,
	'if (p_Queue_name.compareTo("I_EQE")==0) {
	m_eqe_lock.unlock();
} else if (p_Queue_name.compareTo("I_SQE")==0) {
	m_sqe_lock.unlock();
} else {
	Exception e = new Exception();
	e.fillInStackTrace();
	CorePlugin.logError(
			"Invalid queue name specified: " + p_Queue_name,
			e);
}
',
	0,
	'',
	4325);
INSERT INTO O_TPARM
	VALUES (4328,
	4327,
	'queue_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (4329,
	4138,
	'getName',
	'',
	322,
	1,
	'// Execution Engine.getName()
result = "";
select one component related by self->C_C[R2955];
if not_empty component
  result = component.Name + GD::int_to_string(value:self.getEngineNumber());
end if;
return result;',
	1,
	'',
	4327);
INSERT INTO O_TFR
	VALUES (4330,
	4138,
	'resolveTargetChannel',
	'',
	296,
	0,
	'// Mentor Graphics Verifier-specific Implementation
return GD::NULL_UNIQUE_ID();',
	1,
	'',
	4329);
INSERT INTO O_TPARM
	VALUES (4331,
	4330,
	'specifiedComponentInstance',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (4332,
	4330,
	'isRequired',
	316,
	0,
	'',
	4331,
	'');
INSERT INTO O_TPARM
	VALUES (4333,
	4330,
	'localComponentInstance',
	296,
	0,
	'',
	4332,
	'');
INSERT INTO O_TPARM
	VALUES (4334,
	4330,
	'interfaceReference',
	296,
	0,
	'',
	4333,
	'');
INSERT INTO O_TFR
	VALUES (4335,
	4138,
	'resolveTargetBody',
	'',
	296,
	0,
	'// Mentor Graphics Verifier-specific Implementation
return GD::NULL_UNIQUE_ID();',
	1,
	'',
	4330);
INSERT INTO O_TPARM
	VALUES (4336,
	4335,
	'isRequired',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (4337,
	4335,
	'channel',
	296,
	0,
	'',
	4336,
	'');
INSERT INTO O_TPARM
	VALUES (4338,
	4335,
	'invokingPath',
	322,
	0,
	'',
	4337,
	'');
INSERT INTO O_TPARM
	VALUES (4339,
	4335,
	'messageName',
	322,
	0,
	'',
	4338,
	'');
INSERT INTO O_TFR
	VALUES (4340,
	4138,
	'transferValueToTarget',
	'',
	19,
	0,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	4335);
INSERT INTO O_TPARM
	VALUES (4341,
	4340,
	'message',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (4342,
	4340,
	'body',
	296,
	0,
	'',
	4341,
	'');
INSERT INTO O_TPARM
	VALUES (4343,
	4340,
	'arg',
	296,
	0,
	'',
	4342,
	'');
INSERT INTO O_TPARM
	VALUES (4344,
	4340,
	'stack_frame_id',
	296,
	0,
	'',
	4343,
	'');
INSERT INTO O_TPARM
	VALUES (4345,
	4340,
	'local_stack_frame_id',
	296,
	0,
	'',
	4344,
	'');
INSERT INTO O_NBATTR
	VALUES (4152,
	4138);
INSERT INTO O_BATTR
	VALUES (4152,
	4138);
INSERT INTO O_ATTR
	VALUES (4152,
	4138,
	4346,
	'Execution_Engine_ID',
	'',
	'',
	'Execution_Engine_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (4346,
	4138);
INSERT INTO O_BATTR
	VALUES (4346,
	4138);
INSERT INTO O_ATTR
	VALUES (4346,
	4138,
	0,
	'Running',
	'',
	'',
	'Running',
	0,
	316,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (4347,
	4138);
INSERT INTO O_BATTR
	VALUES (4347,
	4138);
INSERT INTO O_ATTR
	VALUES (4347,
	4138,
	4348,
	'Next_Unique_ID',
	'',
	'',
	'Next_Unique_ID',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (4349,
	4138);
INSERT INTO O_BATTR
	VALUES (4349,
	4138);
INSERT INTO O_ATTR
	VALUES (4349,
	4138,
	4347,
	'Next_Instance_ID',
	'',
	'',
	'Next_Instance_ID',
	0,
	298,
	'',
	'');
INSERT INTO O_REF
	VALUES (4138,
	699,
	0,
	712,
	4137,
	4139,
	4140,
	4350,
	4351,
	0,
	0,
	'',
	'Domain',
	'Dom_ID',
	'R2948.''is verifying''');
INSERT INTO O_RATTR
	VALUES (4350,
	4138,
	712,
	699,
	1,
	'Dom_ID');
INSERT INTO O_ATTR
	VALUES (4350,
	4138,
	4152,
	'Dom_ID',
	'',
	'',
	'Dom_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (4352,
	4138,
	'result = "";
select one component related by self->C_C[R2955];
if(not_empty component)
  result = component.Label;
  select many engines related by component->I_EXE[R2955];
  number = self.getEngineNumber();
  if(cardinality engines > 1)
    result = result + " - " + GD::int_to_string(value:number);
  end if;
end if;
select one icomponent related by self->CL_IC[R2963];
if(not_empty icomponent)
  result = icomponent.Name;
  select many engines related by icomponent->I_EXE[R2963];
  number = self.getEngineNumber();
  if(cardinality engines > 1)
    result = result + " - " + GD::int_to_string(value:number);
  end if;
end if;
select one domain related by self->S_DOM[R2948];
if(not_empty domain)
  result = domain.Name;
end if;
if not Util::isNull(element:self.RealizedBy)
  result = result + " (Realized)";
end if;
self.Label = result;',
	1);
INSERT INTO O_BATTR
	VALUES (4352,
	4138);
INSERT INTO O_ATTR
	VALUES (4352,
	4138,
	4353,
	'Label',
	'',
	'',
	'Label',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (4354,
	4138);
INSERT INTO O_BATTR
	VALUES (4354,
	4138);
INSERT INTO O_ATTR
	VALUES (4354,
	4138,
	4352,
	'EQE_Lock',
	'User_Visible:false',
	'',
	'EQE_Lock',
	0,
	4355,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (4356,
	4138);
INSERT INTO O_BATTR
	VALUES (4356,
	4138);
INSERT INTO O_ATTR
	VALUES (4356,
	4138,
	4354,
	'SQE_Lock',
	'User_Visible:false',
	'',
	'SQE_Lock',
	0,
	4355,
	'',
	'');
INSERT INTO O_REF
	VALUES (4138,
	709,
	0,
	762,
	4144,
	4145,
	4146,
	4357,
	4358,
	0,
	0,
	'',
	'Component',
	'Id',
	'R2955.''is verifying instance of''');
INSERT INTO O_RATTR
	VALUES (4357,
	4138,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (4357,
	4138,
	4350,
	'Component_Id',
	'',
	'Component_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (4138,
	2807,
	0,
	4175,
	4172,
	4173,
	4174,
	4353,
	4359,
	0,
	0,
	'',
	'Component Reference',
	'Id',
	'R2963.''is verifying instance of''');
INSERT INTO O_RATTR
	VALUES (4353,
	4138,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (4353,
	4138,
	4349,
	'ImportedComponent_Id',
	'',
	'ImportedComponent_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (4138,
	2798,
	0,
	2825,
	4179,
	4180,
	4181,
	4348,
	4360,
	0,
	0,
	'',
	'Package',
	'Package_ID',
	'R2970.''is verifying''');
INSERT INTO O_RATTR
	VALUES (4348,
	4138,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (4348,
	4138,
	4357,
	'Package_ID',
	'',
	'',
	'Package_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (4138,
	4184,
	0,
	4188,
	4186,
	4189,
	4187,
	4361,
	4362,
	0,
	0,
	'',
	'Component Instance Container',
	'Container_ID',
	'R2975');
INSERT INTO O_RATTR
	VALUES (4361,
	4138,
	4152,
	4138,
	1,
	'Execution_Engine_ID');
INSERT INTO O_ATTR
	VALUES (4361,
	4138,
	4356,
	'Container_ID',
	'',
	'',
	'Container_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (4363,
	4138);
INSERT INTO O_BATTR
	VALUES (4363,
	4138);
INSERT INTO O_ATTR
	VALUES (4363,
	4138,
	4361,
	'RealizedBy',
	'User_Visible:false',
	'',
	'RealizedBy',
	0,
	317,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	4138);
INSERT INTO O_OIDA
	VALUES (4152,
	4138,
	0,
	'Execution_Engine_ID');
INSERT INTO O_ID
	VALUES (1,
	4138);
INSERT INTO O_ID
	VALUES (2,
	4138);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (4104,
	'Attribute Value',
	2903,
	'I_AVL',
	'',
	4078);
INSERT INTO O_TFR
	VALUES (4364,
	4104,
	'setBoolean',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	4365);
INSERT INTO O_TPARM
	VALUES (4366,
	4364,
	'value',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (4367,
	4104,
	'setInteger',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	4364);
INSERT INTO O_TPARM
	VALUES (4368,
	4367,
	'value',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (4369,
	4104,
	'setString',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	4370);
INSERT INTO O_TPARM
	VALUES (4371,
	4369,
	'value',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (4370,
	4104,
	'setReal',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	4367);
INSERT INTO O_TPARM
	VALUES (4372,
	4370,
	'value',
	374,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (4373,
	4104,
	'dispose',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (4374,
	4104,
	'setUnique_ID',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	4369);
INSERT INTO O_TPARM
	VALUES (4375,
	4374,
	'value',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (4365,
	4104,
	'getValue',
	'',
	317,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return GD::NULL_INSTANCE();',
	1,
	'',
	4376);
INSERT INTO O_TFR
	VALUES (4376,
	4104,
	'getRuntimeValue',
	'',
	296,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return GD::NULL_UNIQUE_ID();',
	1,
	'',
	4373);
INSERT INTO O_DBATTR
	VALUES (4377,
	4104,
	'select one sdt related by self->O_ATTR[R2910]->S_DT[R114]->S_SDT[R17];
if (empty sdt)
  self.Value = GD::instance_to_string(value:self.getValue());
else
  select one dt related by sdt->S_DT[R17];
  self.Value = dt.Name;
end if;
',
	1);
INSERT INTO O_BATTR
	VALUES (4377,
	4104);
INSERT INTO O_ATTR
	VALUES (4377,
	4104,
	4378,
	'Value',
	'',
	'',
	'Value',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (4104,
	4107,
	0,
	4109,
	4114,
	4116,
	4115,
	4379,
	4380,
	0,
	0,
	'',
	'Instance',
	'Inst_ID',
	'R2909.''defines value for characteristic of''');
INSERT INTO O_RATTR
	VALUES (4379,
	4104,
	4109,
	4107,
	1,
	'Inst_ID');
INSERT INTO O_ATTR
	VALUES (4379,
	4104,
	0,
	'Inst_ID',
	'',
	'',
	'Inst_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (4104,
	37,
	0,
	168,
	4102,
	4105,
	4103,
	4378,
	4381,
	0,
	0,
	'',
	'Attribute',
	'Attr_ID',
	'R2910.''is instance of''');
INSERT INTO O_RATTR
	VALUES (4378,
	4104,
	168,
	37,
	1,
	'Attr_ID');
INSERT INTO O_ATTR
	VALUES (4378,
	4104,
	4382,
	'Attr_ID',
	'',
	'',
	'Attr_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (4383,
	4104,
	'// Mentor Graphics Verifier-specific Implementation
self.Label="";',
	1);
INSERT INTO O_BATTR
	VALUES (4383,
	4104);
INSERT INTO O_ATTR
	VALUES (4383,
	4104,
	4377,
	'Label',
	'',
	'',
	'Label',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (4104,
	37,
	0,
	169,
	4102,
	4105,
	4103,
	4382,
	4384,
	0,
	0,
	'',
	'Attribute',
	'Obj_ID',
	'R2910.''is instance of''');
INSERT INTO O_RATTR
	VALUES (4382,
	4104,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (4382,
	4104,
	4379,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	4104);
INSERT INTO O_OIDA
	VALUES (4379,
	4104,
	0,
	'Inst_ID');
INSERT INTO O_OIDA
	VALUES (4378,
	4104,
	0,
	'Attr_ID');
INSERT INTO O_ID
	VALUES (1,
	4104);
INSERT INTO O_ID
	VALUES (2,
	4104);
-- BP 7.1 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (4385,
	'Globals',
	'Persistent:false',
	'G',
	0,
	1,
	0);
INSERT INTO S_SID
	VALUES (1,
	4385);
INSERT INTO O_IOBJ
	VALUES (4386,
	705,
	0,
	4385,
	'System Model',
	'S_SYS');
INSERT INTO O_IOBJ
	VALUES (4387,
	26,
	0,
	4385,
	'Packageable Element',
	'PE_PE');
INSERT INTO R_ASSOC
	VALUES (4388);
INSERT INTO R_REL
	VALUES (4388,
	9100,
	'',
	4385);
INSERT INTO R_AONE
	VALUES (26,
	4388,
	4389,
	1,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (25,
	26,
	0,
	4388,
	4389);
INSERT INTO R_RTO
	VALUES (26,
	4388,
	4389,
	0);
INSERT INTO R_OIR
	VALUES (26,
	4388,
	4389,
	4387);
INSERT INTO R_AOTH
	VALUES (705,
	4388,
	4390,
	1,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (754,
	705,
	0,
	4388,
	4390);
INSERT INTO R_RTO
	VALUES (705,
	4388,
	4390,
	0);
INSERT INTO R_OIR
	VALUES (705,
	4388,
	4390,
	4386);
INSERT INTO R_ASSR
	VALUES (4391,
	4388,
	4392,
	0);
INSERT INTO R_RGO
	VALUES (4391,
	4388,
	4392);
INSERT INTO R_OIR
	VALUES (4391,
	4388,
	4392,
	0);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (4391,
	'Global Element in System',
	1,
	'G_EIS',
	'',
	4385);
INSERT INTO O_REF
	VALUES (4391,
	26,
	0,
	25,
	4388,
	4392,
	4389,
	4393,
	4394,
	0,
	0,
	'',
	'Packageable Element',
	'Element_ID',
	'R9100');
INSERT INTO O_RATTR
	VALUES (4393,
	4391,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (4393,
	4391,
	0,
	'Element_ID',
	'',
	'',
	'Element_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (4391,
	705,
	0,
	754,
	4388,
	4392,
	4390,
	4395,
	4396,
	0,
	0,
	'',
	'System Model',
	'Sys_ID',
	'R9100');
INSERT INTO O_RATTR
	VALUES (4395,
	4391,
	754,
	705,
	1,
	'Sys_ID');
INSERT INTO O_ATTR
	VALUES (4395,
	4391,
	4393,
	'Sys_ID',
	'',
	'',
	'Sys_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	4391);
INSERT INTO O_OIDA
	VALUES (4393,
	4391,
	0,
	'Element_ID');
INSERT INTO O_OIDA
	VALUES (4395,
	4391,
	0,
	'Sys_ID');
INSERT INTO O_ID
	VALUES (1,
	4391);
INSERT INTO O_ID
	VALUES (2,
	4391);
-- BP 7.1 content: FunctionPackage syschar: 3 persistence-version: 7.1.6

INSERT INTO S_FPK
	VALUES (4397,
	'Functions',
	1,
	0);
INSERT INTO S_FPIP
	VALUES (4397);
INSERT INTO PL_FPID
	VALUES (4397,
	1);
INSERT INTO S_FIP
	VALUES (4397,
	4398);
INSERT INTO S_SYNC
	VALUES (4398,
	1,
	'enableModelChangeListenersFor',
	'Set the value of the model change listener enable mask to the value passed in.
The function returns the previous value logically ORed of both the masks.

The return value then shall be sent in both parameters in the succeeding calls 
to the function.

Translate: native
',
	'int ret_val = enabledEventsMask | enabledDeltaMask;
if ((p_Eventmask & Modeleventnotification_c.MODEL_ELEMENT_CHANGED) != 0) {
   	enabledDeltaMask = (p_Deltamask & Modeleventnotification_c.MASK_ALL_DELTAS);
}
enabledEventsMask = (p_Eventmask & Modeleventnotification_c.MASK_ALL_EVENTS);		
return ret_val;',
	4399,
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4400,
	4398,
	'eventMask',
	4399,
	0,
	'',
	4401,
	'');
INSERT INTO S_SPARM
	VALUES (4401,
	4398,
	'deltaMask',
	4399,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4397,
	4402);
INSERT INTO S_SYNC
	VALUES (4402,
	1,
	'getOrphanedElementName',
	'',
	'return "Orphaned";
',
	322,
	1,
	'');
INSERT INTO S_FIP
	VALUES (4397,
	4403);
INSERT INTO S_SYNC
	VALUES (4403,
	1,
	'getOrphanedElementKL',
	'',
	'return "ORPH";
',
	322,
	1,
	'');
INSERT INTO S_FIP
	VALUES (4397,
	4404);
INSERT INTO S_SYNC
	VALUES (4404,
	1,
	'canStateIgnoreOrSayEventCantHappen',
	'',
	'/* ::canStateIgnoreOrSayEventCantHappen()
This is merely a pass-through function, meant as a workaround to a generator 
bug where method calls made on object instances in the ''where'' clause of a 
select statement are not generated correctly (BZ issue 278).  In some cases (but
not all), a call to this function may be made to access the desired operation
indirectly.
*/
select any state from instances of SM_STATE
	where selected.SMstt_ID == param.stateId 
		and selected.SM_ID == param.stateStateMachineId;
return state.canIgnoreOrSayEventCantHappen(
	eventId:param.eventId, eventStateMachineId:param.eventStateMachineId, 
	considerCantHappen:param.considerCantHappen);
	',
	316,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4405,
	4404,
	'eventId',
	296,
	0,
	'',
	4406,
	'');
INSERT INTO S_SPARM
	VALUES (4407,
	4404,
	'eventStateMachineId',
	296,
	0,
	'',
	4405,
	'');
INSERT INTO S_SPARM
	VALUES (4408,
	4404,
	'stateId',
	296,
	0,
	'',
	4407,
	'');
INSERT INTO S_SPARM
	VALUES (4409,
	4404,
	'stateStateMachineId',
	296,
	0,
	'',
	4408,
	'');
INSERT INTO S_SPARM
	VALUES (4406,
	4404,
	'considerCantHappen',
	316,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4397,
	4410);
INSERT INTO S_SYNC
	VALUES (4410,
	1,
	'convertRelocatableTags',
	'Translate: native',
	'return com.mentor.nucleus.bp.core.relocatables.RelocatableTagConversionUtil.convertRelocatableTags(modelRoot, p_In);
',
	322,
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4411,
	4410,
	'in',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4397,
	4412);
INSERT INTO S_SYNC
	VALUES (4412,
	1,
	'getUniqueInitialName',
	'Translate: native',
	'return PersistenceManager.getDefaultInstance().getUniqueNameForComponent(
	(NonRootModelElement)p_Instance, p_Candidatename);',
	322,
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4413,
	4412,
	'instance',
	317,
	0,
	'',
	4414,
	'');
INSERT INTO S_SPARM
	VALUES (4414,
	4412,
	'candidateName',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4397,
	4415);
INSERT INTO S_SYNC
	VALUES (4415,
	1,
	'getCoreDatatypesPackageName',
	'',
	'return "Datatypes";',
	322,
	1,
	'');
INSERT INTO S_FIP
	VALUES (4397,
	4416);
INSERT INTO S_SYNC
	VALUES (4416,
	1,
	'getUniqueInitialNameInParent',
	'Translate: native',
	'return PersistenceManager.getDefaultInstance().getUniqueNameForComponent(
	(NonRootModelElement)p_Instance, (NonRootModelElement) p_Parent, p_Name);',
	322,
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4417,
	4416,
	'name',
	322,
	0,
	'',
	4418,
	'');
INSERT INTO S_SPARM
	VALUES (4418,
	4416,
	'instance',
	317,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4419,
	4416,
	'parent',
	317,
	0,
	'',
	4417,
	'');
INSERT INTO S_FIP
	VALUES (4397,
	4420);
INSERT INTO S_SYNC
	VALUES (4420,
	1,
	'getMissingInheritedEventMessage',
	'',
	'if(not param.missingInheritedEvent)
  return "Some transitions that were pasted rely on inherited events that are not available in the destination state model.  Resulting transitions will have no events assigned.";
else
  return "Pasted state models rely on inherited events that are not included on the clipboard.  Resulting state models will be incomplete.";
end if;',
	322,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4421,
	4420,
	'missingInheritedEvent',
	316,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4397,
	4422);
INSERT INTO S_SYNC
	VALUES (4422,
	1,
	'removeInconsistentNonLocalEvents',
	'',
	'select many nlevts from instances of SM_NLEVT;
for each nlevt in nlevts
  // when importing 6.1 we need to fix up non-local event''s
  // such that the event consumption rules of today are
  // honored, the rules for event consumption state that
  // an event is consumed if a state says that it is ignored,
  // or can''t happen, or if it has assignment to a transition
  // for remove any that do not fulfill the above
  select one poly related by nlevt->SM_PEVT[R527];
  if(empty poly)
    continue;
  end if;
  select one evt related by nlevt->SM_SEVT[R526]->SM_EVT[R525];
  select one thisMachine related by nlevt->SM_SEVT[R526]->SM_EVT[R525]->SM_SM[R502];
  select many transitions related by nlevt->SM_SEVT[R526]->SM_SEME[R503]->SM_NSTXN[R504];
  select any ignored related by nlevt->SM_SEVT[R526]->SM_SEME[R503]->SM_EIGN[R504];
  select any ch related by nlevt->SM_SEVT[R526]->SM_SEME[R503]->SM_CH[R504];
  if(empty transitions and empty ignored and empty ch and not_empty evt)
    evt.dispose();
    continue;
  end if;
  // then check for non-local events that are assigned to
  // a transition, and make sure they are not consumed else
  // where
  if(not_empty transitions)
    select many otherNLEs related by poly->SM_NLEVT[R527];
    for each otherNLE in otherNLEs
      select one nleEvt related by otherNLE->SM_SEVT[R526]->SM_EVT[R525];
      select one machine related by nleEvt->SM_SM[R502];
      select one thisClass related by thisMachine->SM_ISM[R517]->O_OBJ[R518];
      select one nleClass related by machine->SM_ISM[R517]->O_OBJ[R518];
      if(machine != thisMachine) and ((thisClass.isSupertypeOf(classId:nleClass.Obj_ID)) or (nleClass.isSupertypeOf(classId:thisClass.Obj_ID)))
        nleEvt.dispose();
      end if;
    end for;
  else
    // if there is only can''t happens we dispose this
    // non-local event
    if(empty ignored and not_empty ch)
      evt.dispose();
    end if;
  end if;
end for;
// now clean up all event ignores, these will only exist if the
// above code did not remove them
select many clazzes from instances of O_OBJ;
for each clazz in clazzes
  clazz.removeInconsistentSubtypeIgnores();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (4397,
	4423);
INSERT INTO S_SYNC
	VALUES (4423,
	1,
	'changeNotificationEnablement',
	'Translate: native
',
	'',
	19,
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4424,
	4423,
	'enabled',
	316,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4397,
	4425);
INSERT INTO S_SYNC
	VALUES (4425,
	1,
	'getNewElementName',
	'Translate: native',
	'  return p_Name;
',
	322,
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4426,
	4425,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4427,
	4425,
	'instance',
	317,
	0,
	'',
	4426,
	'');
INSERT INTO S_SPARM
	VALUES (4428,
	4425,
	'validateName',
	316,
	0,
	'',
	4427,
	'');
INSERT INTO S_FIP
	VALUES (4397,
	4429);
INSERT INTO S_SYNC
	VALUES (4429,
	1,
	'getMissingClassMessage',
	'',
	'return "Pasted imported classes could not have their classes resolved.";',
	322,
	1,
	'');
-- BP 7.1.6 content: FunctionPackage syschar: 3 persistence-version: 7.1.6

INSERT INTO S_FPK
	VALUES (4430,
	'OAL Validation Utility Functions',
	0,
	4397);
INSERT INTO PL_FPID
	VALUES (4430,
	1);
INSERT INTO S_FIP
	VALUES (4430,
	4431);
INSERT INTO S_SYNC
	VALUES (4431,
	1,
	'binary_operation_validate',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'  select any comp_val from instances of V_VAL where ( selected.Value_ID == param.a2_operator );
  if ( empty comp_val  )
    ERR::reportParseError( msg: "Operator not found for " + param.a4_op_type,
        token: param.a6_rule_token );
  else
    select any lhs_val from instances of V_VAL where ( selected.Value_ID == param.a1_left_op );
    select any rhs_val from instances of V_VAL where ( selected.Value_ID == param.a3_right_op );
    if ( empty lhs_val  )
      if ( not_empty rhs_val )
        rhs_val.dispose();
      end if;
      comp_val.dispose();
       ERR::reportParseError( msg: "Left hand operand not found for " + param.a4_op_type,
          token: param.a6_rule_token );
    else
      if ( empty rhs_val  )
        lhs_val.dispose();
        comp_val.dispose();
        ERR::reportParseError( msg: "Right hand operand not found for " + param.a4_op_type,
            token: param.a6_rule_token );
      else
         if lhs_val.getDimensions() < 0
        	ERR::reportParseError(msg:"The rvalue has incompatible array depth", 
                                                   token: param.a6_rule_token ); 
        elif rhs_val.getDimensions() < 0
        
          ERR::reportParseError(msg:"The rvalue has incompatible array depth", 
                                                   token: param.a6_rule_token );
        
        elif rhs_val.getDimensions() != lhs_val.getDimensions()
          ERR::reportParseError(msg:"Incompatible array depth for the oprands", 
                                                   token: param.a6_rule_token );
        end if;
        select one lhs_val_dt related by lhs_val->S_DT[R820];
        if ( empty lhs_val_dt )
         comp_val.dispose();
         ERR::reportParseError( msg: "Left hand operand for " + param.a4_op_type + " has unknown data type.",
            token: param.a6_rule_token );
        else
          select one rhs_val_dt related by rhs_val->S_DT[R820];
          if ( empty rhs_val_dt )
           comp_val.dispose();
           ERR::reportParseError( msg: "Right hand operand for " + param.a4_op_type + " has unknown data type.",
              token: param.a6_rule_token );
          else
            select one bin related by comp_val->V_BIN[R801];
            if ( empty bin )
              ERR::reportParseError( msg: "Cannot find Binary Operator subtype",
                   token: param.a6_rule_token );
            else
              op_dt_id =  ::data_types_compatible( dt1:lhs_val_dt.DT_ID, dt2: rhs_val_dt.DT_ID,
                   op: bin.Operator );
              if (  op_dt_id == GD::NULL_UNIQUE_ID() )
                // must clear garbage before reporting error, reportParseError wont return
                comp_val.dispose();
                lhs_val.dispose();
                rhs_val.dispose();

                ERR::reportParseError( msg: "Incompatible operands for " + param.a4_op_type,
                  token: param.a6_rule_token );
              else
                relate bin to lhs_val across R802;
                relate bin to rhs_val across R803;
                if ( param.a5_set_dt )
                  if ( op_dt_id == lhs_val_dt.DT_ID )
                    relate comp_val to lhs_val_dt across R820;
                  else
                    relate comp_val to rhs_val_dt across R820;
                  end if;
                end if;
                return bin.Value_ID;
              end if;
            end if;
          end if;
        end if;
      end if;
    end if;
  end if;

  return param.a7_rule_id;



',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4432,
	4431,
	'a1_left_op',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4433,
	4431,
	'a2_operator',
	296,
	0,
	'',
	4432,
	'');
INSERT INTO S_SPARM
	VALUES (4434,
	4431,
	'a3_right_op',
	296,
	0,
	'',
	4433,
	'');
INSERT INTO S_SPARM
	VALUES (4435,
	4431,
	'a4_op_type',
	322,
	0,
	'',
	4434,
	'');
INSERT INTO S_SPARM
	VALUES (4436,
	4431,
	'a5_set_dt',
	316,
	0,
	'',
	4435,
	'');
INSERT INTO S_SPARM
	VALUES (4437,
	4431,
	'a6_rule_token',
	4438,
	0,
	'',
	4436,
	'');
INSERT INTO S_SPARM
	VALUES (4439,
	4431,
	'a7_rule_id',
	296,
	0,
	'',
	4437,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4440);
INSERT INTO S_SYNC
	VALUES (4440,
	1,
	'data_types_compatible',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Try to locate the datatypes in the domain-level datatype package(s)
current_scope = ::get_current_scope();
select any block from instances of ACT_BLK where
                                             selected.Block_ID == current_scope;
select one body related by block->ACT_ACT[R612];
isInGenericPackage = body.associateWithContainer();
if isInGenericPackage 
  containerId = ::getValidationDomain();
  select any package from instances of EP_PKG where
                                             selected.Package_ID == containerId;
  select any comp from instances of C_C where selected.Id == containerId;
  if not_empty package
    package.collectVisibleElementsForName(name:"",
         type:ElementTypeConstants::DATATYPE, descending:false,
                           originatingContainerID:package.Package_ID,
                                          delegatingPkgID:GD::NULL_UNIQUE_ID(),
                                                          collectGlobally:true);
  else
    comp.collectVisibleElementsForName(name:"",
         type:ElementTypeConstants::DATATYPE,
                          originatingContainerID:comp.Id,
                                    delegatingContainerID:GD::NULL_UNIQUE_ID(),
                                                          collectGlobally:true);
  end if;
  select any resultSet related by package->PE_SRS[R8005] where
        selected.Name == "" and selected.Type == ElementTypeConstants::DATATYPE; 
  select any dt1_dt related by resultSet->PE_VIS[R8006]->
                    PE_PE[R8002]->S_DT[R8001] where selected.DT_ID == param.dt1;
  select any dt2_dt related by resultSet->PE_VIS[R8006]->
                    PE_PE[R8002]->S_DT[R8001] where selected.DT_ID == param.dt2;
  if not_empty comp
    select any dt1_dt related by comp->PE_CVS[R8004]->
                    PE_PE[R8004]->S_DT[R8001] where selected.DT_ID == param.dt1;
    select any dt2_dt related by comp->PE_CVS[R8004]->
                    PE_PE[R8004]->S_DT[R8001] where selected.DT_ID == param.dt2;
  end if;
  if empty dt1_dt
    USER::logError(msg: "Internal Error in OAL Validation Utility Function " +
        "data_types_compatible().  Variable <dt1_dt> is empty.",path:"PathNotProvided");
    return GD::NULL_UNIQUE_ID();
  end if;
  if empty dt2_dt
    USER::logError(msg: "Internal Error in OAL Validation Utility Function " +
        "data_types_compatible().  Variable <dt2_dt> is empty.",path:"PathNotProvided");
    return GD::NULL_UNIQUE_ID();
  end if;

  // Set up some flags to be used in the type-equality checks
  foundCDTLHS = false;
  foundCDTRHS = false;
  areCompatible = false;

  // If it''s a UDT, perform compatability tests on the underlying core type
  select one udt1 related by dt1_dt->S_UDT[R17];
  if ( not_empty udt1 )
    foundCDTLHS = true;
    coreId = udt1.getCoreType();
    select any corePE from instances of PE_PE
                                        where (selected.Element_ID == coreId);
    select one dt1_dt related by corePE->S_DT[R8001];
  end if;
  select one udt2 related by dt2_dt->S_UDT[R17];
  if ( not_empty udt2 )
    foundCDTRHS = true;
    coreId = udt2.getCoreType();
    select any corePE from instances of PE_PE
                                        where (selected.Element_ID == coreId);
    select one dt2_dt related by corePE->S_DT[R8001];
  end if;

  // Check if either is a CDT
  select one cdt1 related by dt1_dt->S_CDT[R17];
  if ( not_empty cdt1 )
    foundCDTLHS = true;
  end if;
  select one cdt2 related by dt2_dt->S_CDT[R17];
  if ( not_empty cdt2 )
    foundCDTRHS = true;
  end if;

  select one irdt1 related by dt1_dt->S_IRDT[R17];

  dt1_is_ir = not_empty irdt1 and not irdt1.isSet;
  dt1_is_irs = not_empty irdt1 and irdt1.isSet;

  select one irdt2 related by dt2_dt->S_IRDT[R17];
  dt2_is_ir = not_empty irdt2 and not irdt2.isSet;
  dt2_is_irs = not_empty irdt2 and irdt2.isSet;

  /**
   *  If both types are not IRDTs then they are incompatible, with
   *  one exception inst_ref<Object>
   */
  if(dt1_is_ir and (not dt2_is_ir and not ::has_substring(p1_base: dt2_dt.Name,
                                  p2_str: "inst_ref<Object>", p3_fromIndex: 0)))
    return GD::NULL_UNIQUE_ID();
  end if;

  if(dt1_is_irs and (not dt2_is_irs and not ::has_substring(p1_base: dt2_dt.Name,
                              p2_str: "inst_ref_set<Object>", p3_fromIndex: 0)))
    return GD::NULL_UNIQUE_ID();
  end if;

  /**
   *  Check the opposite, where dt1 is inst_ref<Object> and dt2 is IRDT
   */
  if((not dt1_is_ir and not ::has_substring(p1_base: dt1_dt.Name,
                                  p2_str: "inst_ref<Object>", p3_fromIndex: 0))
                                  and dt2_is_ir)
    return GD::NULL_UNIQUE_ID();                                  
  end if;

  if((not dt1_is_irs and not ::has_substring(p1_base: dt1_dt.Name,
                                p2_str: "inst_ref_set<Object", p3_fromIndex: 0))
                                and dt2_is_irs)
    return GD::NULL_UNIQUE_ID();
  end if;

  if(not dt1_is_ir)
    // check for special case inst_refs
    dt1_is_ir = ::has_substring(p1_base: dt1_dt.Name, p2_str: "inst_ref<Object>", p3_fromIndex: 0)
                   or ::has_substring(p1_base: dt1_dt.Name, p2_str: "inst_ref<Mapping>", p3_fromIndex: 0)
                   or ::has_substring(p1_base: dt1_dt.Name, p2_str: "inst_ref<Timer>", p3_fromIndex: 0);
  end if;

  if(not dt1_is_irs)
    // check for special case inst_ref_sets
    dt1_is_irs = ::has_substring(p1_base: dt1_dt.Name, p2_str: "inst_ref_set<Object>", p3_fromIndex: 0);  
  end if;

  if ( foundCDTLHS and foundCDTRHS )
    if ( dt1_dt.Name == dt2_dt.Name )
      areCompatible = true;
    end if;
  else
    if ( dt1_dt.DT_ID == dt2_dt.DT_ID )
      areCompatible = true;
    end if;
  end if;

  if ( areCompatible )
    // only check for disallowed operations, since they are fewer
    if ( (not dt1_is_ir and not dt1_is_irs and dt1_dt.Name != "boolean") and
        (param.op == "and" or param.op == "or")  )
      return GD::NULL_UNIQUE_ID();
    elif ( dt1_dt.Name == "boolean" and
       ( param.op == "+" or param.op == "-" or param.op == "*" or param.op == "/"  or
         param.op == "%"  or
         param.op == ">" or param.op == "<" or param.op == ">=" or param.op == "<=" ) )
      return GD::NULL_UNIQUE_ID();
    elif ( dt1_dt.Name == "string" and
       ( param.op == "-" or param.op == "*" or param.op == "/" or param.op == "%") )
      return GD::NULL_UNIQUE_ID();
    elif ( dt1_dt.Name == "unique_id" and
       ( param.op == "+" or param.op == "-" or param.op == "*" or param.op == "/"  or
         param.op == "%"  or
         param.op == ">" or param.op == "<" or param.op == ">=" or param.op == "<=" ) )
      return GD::NULL_UNIQUE_ID();
    elif ( (dt1_is_ir or dt1_is_irs) and
       ( param.op == "*" or param.op == "/" or param.op == "%"  or
         param.op == ">" or param.op == "<" or param.op == ">=" or param.op == "<=" ) )
      return GD::NULL_UNIQUE_ID();
    elif ( (dt1_is_ir or dt1_is_irs) and
       ( param.op == "and" or param.op == "or" or param.op == "+"  or
         param.op == "-" ) )
      return_type = param.dt1;
      if ( dt1_is_ir )
        // The result of an operation on two inst_ref''s is an inst_ref_set.  So,
        // locate the appropriate inst_ref_set, or error if it doesn''t exist.
        select one irdt1_obj related by dt1_dt->S_IRDT[R17]->O_OBJ[R123];
        select any irsdt related by irdt1_obj->S_IRDT[R123] where selected.isSet == true;
        if ( empty irsdt )
          // TODO - it would be nice to report a meaningful parse error here.
          // However, we don''t have a token to pass to the error reporting function.
          // Also, the error reporting function does not return, so not sure how that
          // affects downstream code that uses the return value.
          return_type = GD::NULL_UNIQUE_ID();
        else
          return_type = irsdt.DT_ID;
        end if;
      end if;
      return return_type;
    else
      return param.dt1;
    end if;
  else
    //   The following truth table represents the logic of this inst_ref checking
    //   block.  Any other operations on mixed inst_ref and inst_ref_set are
    //   invalid.  Also, the referenced class must match (i.e. you can''t perform
    //   an operation such as inst_ref<foo> + inst_ref<bar>).
    //
    //      left               right
    //      type           op  type             return
    //      -------------  --  --------------   ------
    //      <inst_ref>      |  <inst_ref_set>   <inst_ref_set>
    //      <inst_ref>      &  <inst_ref_set>   <inst_ref_set>
    //      <inst_ref>      +  <inst_ref_set>   <inst_ref_set>
    //      <inst_ref>      -  <inst_ref_set>   <inst_ref_set>
    //      <inst_ref_set>  |  <inst_ref>       <inst_ref_set>
    //      <inst_ref_set>  &  <inst_ref>       <inst_ref_set>
    //      <inst_ref_set>  +  <inst_ref>       <inst_ref_set>
    //      <inst_ref_set>  -  <inst_ref>       <inst_ref_set>
    if ( dt1_is_ir or dt1_is_irs )
      if ( param.op != "and" and param.op != "or" and param.op != "+" and
         param.op != "-" )
        return GD::NULL_UNIQUE_ID();
      end if;

      // Now that we''ve established we''re using a valid operator, check that the
      // reference and set are for the same class
      select one irdt1_obj related by dt1_dt->S_IRDT[R17]->O_OBJ[R123];
      select one irdt2_obj related by dt2_dt->S_IRDT[R17]->O_OBJ[R123];

      if empty irdt1_obj
        USER::logError(msg: "Internal Error in OAL Validation Utility Function " +
        "data_types_compatible().  Variable <irdt1_obj> is empty.",path:"PathNotProvided");
      end if;
      if empty irdt2_obj
        USER::logError(msg: "Internal Error in OAL Validation Utility Function " +
        "data_types_compatible().  Variable <irdt2_obj> is empty.",path:"PathNotProvided");
      end if;

      if ( irdt1_obj.Obj_ID != irdt2_obj.Obj_ID )
        return GD::NULL_UNIQUE_ID();
      end if;

      // We''ve passed all the checks, so return the set datatype
      if ( dt1_is_irs )
        return param.dt1;
      else
        return param.dt2;
      end if;
    end if;

    // Disallow boolean operations of non-matching data types
    if ( param.op == "and" or param.op == "or" )
      return GD::NULL_UNIQUE_ID();
    end if;

    //
    // The follow truth table represents the logic this block implements.
    // Operator "=" means assignment, operator "+" means all other operators.
    //
    //      left    right
    //      type    type    operator    coercion    promotion   return
    //      ----    ----    --------    --------    ---------   ------
    //      i       r       =           T           T           i
    //      i       r       =           F           T           bad
    //      i       r       =           F           F           bad
    //      i       r       +           T           T           r
    //      i       r       +           F           T           r
    //      i       r       +           F           F           bad
    //      r       i       =           T           T           r
    //      r       i       =           F           T           r
    //      r       i       =           F           F           bad
    //      r       i       +           T           T           r
    //      r       i       +           F           T           r
    //      r       i       +           F           F           bad
    //
    // The following combinations are prevented from occurring by the UI, as they
    // don''t really make sense:
    //
    //      left    right
    //      type    type    operator    coercion    promotion   return
    //      ----    ----    --------    --------    ---------   ------
    //      i       r       =           T           F           i
    //      i       r       +           T           F           bad
    //      r       i       =           T           F           bad
    //      r       i       +           T           F           bad
    //
    prefAllowIntToRealPromotion = "bridgepoint_prefs_allow_int_to_real_promotion";
    prefAllowRealToIntCoercion = "bridgepoint_prefs_allow_real_to_int_coercion";

    if ( dt1_dt.Name == "integer" )
      if ( dt2_dt.Name == "real" )
        if ( param.op == "assign" )
          if ( PREF::getBoolean( name:prefAllowRealToIntCoercion ) == true )
	      	return param.dt1;
          else
        	return GD::NULL_UNIQUE_ID();
          end if;
        elif ( PREF::getBoolean( name:prefAllowIntToRealPromotion ) == true )
      	  return param.dt2;
        else
      	  return GD::NULL_UNIQUE_ID();
        end if;
      else
        return GD::NULL_UNIQUE_ID();
      end if;
    elif ( dt1_dt.Name == "real" )
      if ( dt2_dt.Name == "integer" )
        if ( PREF::getBoolean( name:prefAllowIntToRealPromotion ) == true )
      	  return param.dt1;
        else
      	  return GD::NULL_UNIQUE_ID();
        end if;
      else
        return GD::NULL_UNIQUE_ID();
      end if;
    else
      return GD::NULL_UNIQUE_ID();
    end if;
  end if;
else
  select any dom from instances of S_DOM where
                                     selected.Dom_ID == ::getValidationDomain();
  select any dt1_dt related by dom->S_DT[R14] where selected.DT_ID == param.dt1;
  select any dt2_dt related by dom->S_DT[R14] where selected.DT_ID == param.dt2;
  if empty dt1_dt
    // If we are not at the domain level, then we need to look for the datatypes
    // in the system-level datatype package(s)
    cur_sys_name = ::getSystemName();
    select any sys from instances of S_SYS where (selected.Name == cur_sys_name);
    select any dt1_dt related by sys->SLD_SDINP[R4402]->S_DT[R4401] where
                                                    selected.DT_ID == param.dt1;
    if empty dt1_dt and not_empty sys and sys.useGlobals
        select any dt1_dt related by sys->G_EIS[R9100]->
                    PE_PE[R9100]->S_DT[R8001] where selected.DT_ID == param.dt1;
    end if;
    if empty dt1_dt
      USER::logError(msg: "Internal Error in OAL Validation Utility Function " +
        "data_types_compatible().  Variable <dt1_dt> is empty.",path:"PathNotProvided");
    end if;
  end if;
  if empty dt2_dt
    // If we are not at the domain level, then we need to look for the datatypes
    // in the system-level datatype package(s)
    cur_sys_name = ::getSystemName();
    select any sys from instances of S_SYS where (selected.Name == cur_sys_name);
    select any dt2_dt related by sys->SLD_SDINP[R4402]->S_DT[R4401] where
                                                    selected.DT_ID == param.dt2;
    if empty dt2_dt and not_empty sys and sys.useGlobals
        select any dt2_dt related by sys->G_EIS[R9100]->
                    PE_PE[R9100]->S_DT[R8001] where selected.DT_ID == param.dt2;
    end if;
    if empty dt2_dt
      USER::logError(msg: "Internal Error in OAL Validation Utility Function " +
        "data_types_compatible().  Variable <dt2_dt> is empty.",path:"PathNotProvided");
    end if;
  end if;

  // Set up some flags to be used in the type-equality checks
  foundCDTLHS = false;
  foundCDTRHS = false;
  areCompatible = false;

  // If it''s a UDT, perform compatability tests on the underlying core type
  select one udt1 related by dt1_dt->S_UDT[R17];
  if ( not_empty udt1 )
    foundCDTLHS = true;
    select one dt1_dt related by udt1->S_DT[R18];
  end if;
  select one udt2 related by dt2_dt->S_UDT[R17];
  if ( not_empty udt2 )
    foundCDTRHS = true;
    select one dt2_dt related by udt2->S_DT[R18];
  end if;

  // Check if either is a CDT
  select one cdt1 related by dt1_dt->S_CDT[R17];
  if ( not_empty cdt1 )
    foundCDTLHS = true;
  end if;
  select one cdt2 related by dt2_dt->S_CDT[R17];
  if ( not_empty cdt2 )
    foundCDTRHS = true;
  end if;

  select one irdt1 related by dt1_dt->S_IRDT[R17];

  dt1_is_ir = not_empty irdt1 and not irdt1.isSet;
  dt1_is_irs = not_empty irdt1 and irdt1.isSet;

  select one irdt2 related by dt2_dt->S_IRDT[R17];
  dt2_is_ir = not_empty irdt2 and not irdt2.isSet;
  dt2_is_irs = not_empty irdt2 and irdt2.isSet;

  /**
   *  If both types are not IRDTs then they are incompatible, with
   *  one exception inst_ref<Object>
   */
  if(dt1_is_ir and (not dt2_is_ir and not ::has_substring(p1_base: dt2_dt.Name,
                                  p2_str: "inst_ref<Object>", p3_fromIndex: 0)))
    return GD::NULL_UNIQUE_ID();
  end if;

  if(dt1_is_irs and (not dt2_is_irs and not ::has_substring(p1_base: dt2_dt.Name,
                              p2_str: "inst_ref_set<Object>", p3_fromIndex: 0)))
    return GD::NULL_UNIQUE_ID();
  end if;

  /**
   *  Check the opposite, where dt1 is inst_ref<Object> and dt2 is IRDT
   */
  if((not dt1_is_ir and not ::has_substring(p1_base: dt1_dt.Name,
                                  p2_str: "inst_ref<Object>", p3_fromIndex: 0))
                                  and dt2_is_ir)
    return GD::NULL_UNIQUE_ID();                                  
  end if;

  if((not dt1_is_irs and not ::has_substring(p1_base: dt1_dt.Name,
                                p2_str: "inst_ref_set<Object", p3_fromIndex: 0))
                                and dt2_is_irs)
    return GD::NULL_UNIQUE_ID();
  end if;

  if(not dt1_is_ir)
    // check for special case inst_refs
    dt1_is_ir = ::has_substring(p1_base: dt1_dt.Name, p2_str: "inst_ref<Object>", p3_fromIndex: 0)
                   or ::has_substring(p1_base: dt1_dt.Name, p2_str: "inst_ref<Mapping>", p3_fromIndex: 0)
                   or ::has_substring(p1_base: dt1_dt.Name, p2_str: "inst_ref<Timer>", p3_fromIndex: 0);
  end if;

  if(not dt1_is_irs)
    // check for special case inst_ref_sets
    dt1_is_irs = ::has_substring(p1_base: dt1_dt.Name, p2_str: "inst_ref_set<Object>", p3_fromIndex: 0);  
  end if;

  if ( foundCDTLHS and foundCDTRHS )
    if ( dt1_dt.Name == dt2_dt.Name )
      areCompatible = true;
    end if;
  else
    if ( dt1_dt.DT_ID == dt2_dt.DT_ID )
      areCompatible = true;
    end if;
  end if;

  if ( areCompatible )
    // only check for disallowed operations, since they are fewer
    if ( (not dt1_is_ir and not dt1_is_irs and dt1_dt.Name != "boolean") and
        (param.op == "and" or param.op == "or")  )
      return GD::NULL_UNIQUE_ID();
    elif ( dt1_dt.Name == "boolean" and
       ( param.op == "+" or param.op == "-" or param.op == "*" or param.op == "/"  or
         param.op == "%"  or
         param.op == ">" or param.op == "<" or param.op == ">=" or param.op == "<=" ) )
      return GD::NULL_UNIQUE_ID();
    elif ( dt1_dt.Name == "string" and
       ( param.op == "-" or param.op == "*" or param.op == "/" or param.op == "%") )
      return GD::NULL_UNIQUE_ID();
    elif ( dt1_dt.Name == "unique_id" and
       ( param.op == "+" or param.op == "-" or param.op == "*" or param.op == "/"  or
         param.op == "%"  or
         param.op == ">" or param.op == "<" or param.op == ">=" or param.op == "<=" ) )
      return GD::NULL_UNIQUE_ID();
    elif ( (dt1_is_ir or dt1_is_irs) and
       ( param.op == "*" or param.op == "/" or param.op == "%"  or
         param.op == ">" or param.op == "<" or param.op == ">=" or param.op == "<=" ) )
      return GD::NULL_UNIQUE_ID();
    elif ( (dt1_is_ir or dt1_is_irs) and
       ( param.op == "and" or param.op == "or" or param.op == "+"  or
         param.op == "-" ) )
      return_type = param.dt1;
      if ( dt1_is_ir )
        // The result of an operation on two inst_ref''s is an inst_ref_set.  So,
        // locate the appropriate inst_ref_set, or error if it doesn''t exist.
        select one irdt1_obj related by dt1_dt->S_IRDT[R17]->O_OBJ[R123];
        select any irsdt related by irdt1_obj->S_IRDT[R123] where selected.isSet == true;
        if ( empty irsdt )
          // TODO - it would be nice to report a meaningful parse error here.
          // However, we don''t have a token to pass to the error reporting function.
          // Also, the error reporting function does not return, so not sure how that
          // affects downstream code that uses the return value.
          return_type = GD::NULL_UNIQUE_ID();
        else
          return_type = irsdt.DT_ID;
        end if;
      end if;
      return return_type;
    else
      return param.dt1;
    end if;
  else
    //   The following truth table represents the logic of this inst_ref checking
    //   block.  Any other operations on mixed inst_ref and inst_ref_set are
    //   invalid.  Also, the referenced class must match (i.e. you can''t perform
    //   an operation such as inst_ref<foo> + inst_ref<bar>).
    //
    //      left               right
    //      type           op  type             return
    //      -------------  --  --------------   ------
    //      <inst_ref>      |  <inst_ref_set>   <inst_ref_set>
    //      <inst_ref>      &  <inst_ref_set>   <inst_ref_set>
    //      <inst_ref>      +  <inst_ref_set>   <inst_ref_set>
    //      <inst_ref>      -  <inst_ref_set>   <inst_ref_set>
    //      <inst_ref_set>  |  <inst_ref>       <inst_ref_set>
    //      <inst_ref_set>  &  <inst_ref>       <inst_ref_set>
    //      <inst_ref_set>  +  <inst_ref>       <inst_ref_set>
    //      <inst_ref_set>  -  <inst_ref>       <inst_ref_set>
    if ( dt1_is_ir or dt1_is_irs )
      if ( param.op != "and" and param.op != "or" and param.op != "+" and
         param.op != "-" )
        return GD::NULL_UNIQUE_ID();
      end if;

      // Now that we''ve established we''re using a valid operator, check that the
      // reference and set are for the same class
      select one irdt1_obj related by dt1_dt->S_IRDT[R17]->O_OBJ[R123];
      select one irdt2_obj related by dt2_dt->S_IRDT[R17]->O_OBJ[R123];

      if empty irdt1_obj
        USER::logError(msg: "Internal Error in OAL Validation Utility Function " +
        "data_types_compatible().  Variable <irdt1_obj> is empty.",path:"PathNotProvided");
      end if;
      if empty irdt2_obj
        USER::logError(msg: "Internal Error in OAL Validation Utility Function " +
        "data_types_compatible().  Variable <irdt2_obj> is empty.",path:"PathNotProvided");
      end if;

      if ( irdt1_obj.Obj_ID != irdt2_obj.Obj_ID )
        return GD::NULL_UNIQUE_ID();
      end if;

      // We''ve passed all the checks, so return the set datatype
      if ( dt1_is_irs )
        return param.dt1;
      else
        return param.dt2;
      end if;
    end if;

    // Disallow boolean operations of non-matching data types
    if ( param.op == "and" or param.op == "or" )
      return GD::NULL_UNIQUE_ID();
    end if;

    //
    // The follow truth table represents the logic this block implements.
    // Operator "=" means assignment, operator "+" means all other operators.
    //
    //      left    right
    //      type    type    operator    coercion    promotion   return
    //      ----    ----    --------    --------    ---------   ------
    //      i       r       =           T           T           i
    //      i       r       =           F           T           bad
    //      i       r       =           F           F           bad
    //      i       r       +           T           T           r
    //      i       r       +           F           T           r
    //      i       r       +           F           F           bad
    //      r       i       =           T           T           r
    //      r       i       =           F           T           r
    //      r       i       =           F           F           bad
    //      r       i       +           T           T           r
    //      r       i       +           F           T           r
    //      r       i       +           F           F           bad
    //
    // The following combinations are prevented from occurring by the UI, as they
    // don''t really make sense:
    //
    //      left    right
    //      type    type    operator    coercion    promotion   return
    //      ----    ----    --------    --------    ---------   ------
    //      i       r       =           T           F           i
    //      i       r       +           T           F           bad
    //      r       i       =           T           F           bad
    //      r       i       +           T           F           bad
    //
    prefAllowIntToRealPromotion = "bridgepoint_prefs_allow_int_to_real_promotion";
    prefAllowRealToIntCoercion = "bridgepoint_prefs_allow_real_to_int_coercion";

    if ( dt1_dt.Name == "integer" )
      if ( dt2_dt.Name == "real" )
        if ( param.op == "assign" )
          if ( PREF::getBoolean( name:prefAllowRealToIntCoercion ) == true )
	      	return param.dt1;
          else
        	return GD::NULL_UNIQUE_ID();
          end if;
        elif ( PREF::getBoolean( name:prefAllowIntToRealPromotion ) == true )
      	  return param.dt2;
        else
      	  return GD::NULL_UNIQUE_ID();
        end if;
      else
        return GD::NULL_UNIQUE_ID();
      end if;
    elif ( dt1_dt.Name == "real" )
      if ( dt2_dt.Name == "integer" )
        if ( PREF::getBoolean( name:prefAllowIntToRealPromotion ) == true )
      	  return param.dt1;
        else
      	  return GD::NULL_UNIQUE_ID();
        end if;
      else
        return GD::NULL_UNIQUE_ID();
      end if;
    else
      return GD::NULL_UNIQUE_ID();
    end if;
  end if;
end if;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4441,
	4440,
	'dt1',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4442,
	4440,
	'dt2',
	296,
	0,
	'',
	4441,
	'');
INSERT INTO S_SPARM
	VALUES (4443,
	4440,
	'op',
	322,
	0,
	'',
	4442,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4444);
INSERT INTO S_SYNC
	VALUES (4444,
	1,
	'binary_operator_create',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
create object instance bin of V_BIN;
bin.Operator = param.a1_text;
create object instance val of V_VAL;
current_scope = ::get_current_scope();
select any blk from instances of ACT_BLK where (selected.Block_ID == current_scope);
relate val to blk across R826;
if ( param.a2_dt_name != "" )
  select any dom from instances of S_DOM where selected.Dom_ID == ::getValidationDomain();
  select any dt related by dom->S_DT[R14] where
                                              selected.Name == param.a2_dt_name;
  if empty dt
    cur_sys_name = ::getSystemName();
    select any sys from instances of S_SYS where selected.Name == cur_sys_name;
    dt_id = GD::NULL_UNIQUE_ID();
    if not_empty sys
      dt_id = sys.getCoreTypeId(name:param.a2_dt_name);
    end if;
    select any pe from instances of PE_PE where selected.Element_ID == dt_id;
    select one dt related by pe->S_DT[R8001];
  end if;
  if ( not_empty dt )
    relate val to dt across R820;
  else
    USER::logError(msg: "Internal Error in OAL Validation Utility Function " +
      "binary_operator_create().  Variable <dt> is empty.",path:"PathNotProvided");
  end if;
end if;
relate val to bin across R801;
return val.Value_ID;






































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4445,
	4444,
	'a1_text',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4446,
	4444,
	'a2_dt_name',
	322,
	0,
	'',
	4445,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4447);
INSERT INTO S_SYNC
	VALUES (4447,
	1,
	'unary_operation_validate',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any operand from instances of V_VAL
      where ( selected.Value_ID == param.a5_val_id );
if ( empty operand  )
    ERR::reportParseError( msg: "Operand not found for " + param.a2_op_type,
        token: param.a1_rule_token );
else
    select one op_dt related by operand->S_DT[R820];
    if ( empty op_dt )
      operand.dispose();
      ERR::reportParseError( msg: "Operand for "+param.a2_op_type+"  has unknown data type.",
            token: param.a1_rule_token );
    else
      select one op_udt related by op_dt->S_UDT[R17];
      if ( not_empty op_udt )
        // use the udt''s core data type
        coreId = op_udt.getCoreType();
        select any corePE from instances of PE_PE
                                        where (selected.Element_ID == coreId);
        select one op_dt related by corePE->S_DT[R8001];
      end if;
      if ( op_dt.Name != param.a3_op_dt_name )
        operand.dispose();
        ERR::reportParseError( msg: "Operand for "+param.a2_op_type+" is not of type "
                     +param.a3_op_dt_name,
            token: param.a1_rule_token );
      else
        create object instance u of V_UNY;
        u.Operator = param.a6_text;
        create object instance val of V_VAL;
        current_scope = ::get_current_scope();
        select any blk from instances of ACT_BLK where (selected.Block_ID == current_scope);
        relate val to blk across R826;
        select any dom from instances of S_DOM where selected.Dom_ID == ::getValidationDomain();
        select any result_dt related by dom->S_DT[R14] where
                                              selected.Name == param.a4_dt_name;
        if empty result_dt
          cur_sys_name = ::getSystemName();
          select any sys from instances of S_SYS where selected.Name == cur_sys_name;
          dt_id = GD::NULL_UNIQUE_ID();
          if not_empty sys
            dt_id = sys.getCoreTypeId(name:param.a4_dt_name);
          end if;
          select any pe from instances of PE_PE where selected.Element_ID == dt_id;
          select one result_dt related by pe->S_DT[R8001]; 
        end if;
        if ( not_empty result_dt )
          relate val to result_dt across R820;
        else
          USER::logError(msg: "Internal Error in OAL Validation Utility Function " +
                 "unary_operation_validate().  Variable <result_dt> is empty.",path:"PathNotProvided");
        end if;
        relate val to u across R801;
        relate u to operand across R804;
        return val.Value_ID;
    end if;
  end if;
end if;
return param.a7_rule_id;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4448,
	4447,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4449,
	4447,
	'a2_op_type',
	322,
	0,
	'',
	4448,
	'');
INSERT INTO S_SPARM
	VALUES (4450,
	4447,
	'a3_op_dt_name',
	322,
	0,
	'',
	4449,
	'');
INSERT INTO S_SPARM
	VALUES (4451,
	4447,
	'a4_dt_name',
	322,
	0,
	'',
	4450,
	'');
INSERT INTO S_SPARM
	VALUES (4452,
	4447,
	'a5_val_id',
	296,
	0,
	'',
	4451,
	'');
INSERT INTO S_SPARM
	VALUES (4453,
	4447,
	'a6_text',
	322,
	0,
	'',
	4452,
	'');
INSERT INTO S_SPARM
	VALUES (4454,
	4447,
	'a7_rule_id',
	296,
	0,
	'',
	4453,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4455);
INSERT INTO S_SYNC
	VALUES (4455,
	1,
	'get_current_scope',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'act_id = ::get_current_context();
select any act from instances of ACT_ACT where ( selected.Action_ID == act_id );
if ( empty act )
  return GD::NULL_UNIQUE_ID();
else
  select one scope related by act->ACT_BLK[R699];
  if ( empty scope )
    return GD::NULL_UNIQUE_ID();
  else
    return scope.Block_ID;
  end if;
end if;

































































































',
	296,
	1,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4456);
INSERT INTO S_SYNC
	VALUES (4456,
	1,
	'get_enclosing_block',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'select any blk from instances of ACT_BLK where ( selected.Block_ID == param.block_id );

select one act related by blk->ACT_ACT[R650];
if ( not_empty act )
  // we are the root block
  return GD::NULL_UNIQUE_ID();
else
  select one whl_stmt related by blk->ACT_WHL[R608];
  if ( not_empty whl_stmt )
    select one enclosing_block related by whl_stmt->ACT_SMT[R603]->ACT_BLK[R602];
    return enclosing_block.Block_ID;
  else
    select one if_stmt related by blk->ACT_IF[R607];
    if ( not_empty if_stmt )
      select one enclosing_block related by if_stmt->ACT_SMT[R603]->ACT_BLK[R602];
      return enclosing_block.Block_ID;
    else
      select one elif_stmt related by blk->ACT_EL[R658];
      if ( not_empty elif_stmt )
        select one enclosing_block related by elif_stmt->ACT_SMT[R603]->ACT_BLK[R602];
        return enclosing_block.Block_ID;
      else
        select one else_stmt related by blk->ACT_E[R606];
        if ( not_empty else_stmt )
          select one enclosing_block related by else_stmt->ACT_SMT[R603]->ACT_BLK[R602];
          return enclosing_block.Block_ID;
        else
          select one for_stmt related by blk->ACT_FOR[R605];
          if ( not_empty for_stmt )
            select one enclosing_block related by for_stmt->ACT_SMT[R603]->ACT_BLK[R602];
            return enclosing_block.Block_ID;
          else
            ERR::reportParseError( msg: "Unable to determine enclosing block",
                      token: param.rule_token );
          end if;
        end if;
      end if;
    end if;
  end if;
end if;

return GD::NULL_UNIQUE_ID();





























































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4457,
	4456,
	'block_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4458,
	4456,
	'rule_token',
	4438,
	0,
	'',
	4457,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4459);
INSERT INTO S_SYNC
	VALUES (4459,
	1,
	'get_var_in_scope',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'current_scope = ::get_current_scope();
select any block from instances of ACT_BLK
    where ( selected.Block_ID == current_scope );

select any var_inst related by block->V_VAR[R823]
  where ( selected.Name == param.name );

if ( not_empty var_inst )
  return var_inst.Var_ID;
else
  // search enclosing blocks for variable
  encl_block_id = ::get_enclosing_block( block_id: current_scope, rule_token: param.rule_token );
  while ( encl_block_id != GD::NULL_UNIQUE_ID() and empty var_inst)
    select any enclosing_block from instances of ACT_BLK
        where ( selected.Block_ID == encl_block_id );
    select any var_inst related by enclosing_block->V_VAR[R823] 
         where ( selected.Name == param.name );
    if ( not_empty var_inst )
      return var_inst.Var_ID;
    else
      encl_block_id = ::get_enclosing_block( block_id: encl_block_id, rule_token: param.rule_token );
    end if;
  end while;
end if;

return GD::NULL_UNIQUE_ID();


























































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4460,
	4459,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4461,
	4459,
	'rule_token',
	4438,
	0,
	'',
	4460,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4462);
INSERT INTO S_SYNC
	VALUES (4462,
	1,
	'inst_ref_operator_validate',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'select any operand from instances of V_VAL
      where ( selected.Value_ID == param.a1_variable_id );
select one op_dt related by operand->S_DT[R820];
if (empty op_dt)
      ERR::reportParseError( msg: "Operand for "+ param.a2_operator_name +" operator"+"  has unknown data type.",
            token: param.a4_rule_token ); 
end if;
select one irdt related by op_dt->S_IRDT[R17];
if ( (::has_substring(p1_base: op_dt.Name, p2_str: "inst_ref<Timer>", p3_fromIndex: 0) == true ) or
     (::has_substring(p1_base: op_dt.Name, p2_str: "inst_ref<Mapping>", p3_fromIndex: 0) == true ))
  return ::unary_operation_validate( a1_rule_token: param.a4_rule_token,
      a2_op_type: param.a2_operator_name + " operator", a3_op_dt_name: "inst_ref<Object>",
      a4_dt_name: param.a3_op_dt, a5_val_id: param.a1_variable_id,
      a6_text: param.a2_operator_name, a7_rule_id: param.a5_rule_id );
elif ( ::has_substring(p1_base: op_dt.Name, p2_str: "inst_ref<Object>", p3_fromIndex: 0) or
       ::has_substring(p1_base: op_dt.Name, p2_str: "inst_ref_set<Object>", p3_fromIndex: 0) or
       not_empty irdt )
  return ::unary_operation_validate( a1_rule_token: param.a4_rule_token,
      a2_op_type: param.a2_operator_name  + " operator", a3_op_dt_name: op_dt.Name,
      a4_dt_name: param.a3_op_dt, a5_val_id: param.a1_variable_id,
      a6_text: param.a2_operator_name, a7_rule_id: param.a5_rule_id );
else
  return ::unary_operation_validate( a1_rule_token: param.a4_rule_token,
      a2_op_type: param.a2_operator_name + " operator", a3_op_dt_name: "inst_ref<Object>",
      a4_dt_name: param.a3_op_dt, a5_val_id: param.a1_variable_id,
      a6_text: param.a2_operator_name, a7_rule_id: param.a5_rule_id );
end if;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4463,
	4462,
	'a1_variable_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4464,
	4462,
	'a2_operator_name',
	322,
	0,
	'',
	4463,
	'');
INSERT INTO S_SPARM
	VALUES (4465,
	4462,
	'a3_op_dt',
	322,
	0,
	'',
	4464,
	'');
INSERT INTO S_SPARM
	VALUES (4466,
	4462,
	'a4_rule_token',
	4438,
	0,
	'',
	4465,
	'');
INSERT INTO S_SPARM
	VALUES (4467,
	4462,
	'a5_rule_id',
	296,
	0,
	'',
	4466,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4468);
INSERT INTO S_SYNC
	VALUES (4468,
	1,
	'is_valid_relationship',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'if ( param.a3_rel == GD::NULL_UNIQUE_ID() )
  ::clear_rel_data( a1_chain_start_val: param.a6_chain_start_val, a2_chain_id: param.a7_chain_id, a3_where_val: GD::NULL_UNIQUE_ID() );
  ERR::reportParseError( msg: 
      "Invalid association specification",
      token: param.a5_rule_token );
end if;

select any left_obj  from instances of O_OBJ where ( selected.Obj_ID == param.a1_left );
select any right_obj  from instances of O_OBJ where ( selected.Obj_ID == param.a2_right );
select any r_rel from instances of R_REL where ( selected.Rel_ID == param.a3_rel );
select one r_assoc related by r_rel->R_ASSOC[R206];
select one rel_assr related by r_assoc->R_ASSR[R211];
current_scope = ::get_current_scope();
select any blk from instances of ACT_BLK where (selected.Block_ID == current_scope);
rel_is_reflexive = r_rel.is_reflexive();

select many oir_set related by r_rel->R_OIR[R201];
left_object_found = false;
right_object_found = false;
select any left_oir from instances of R_OIR;
select any right_oir from instances of R_OIR;
for each oir in oir_set
  if ( left_object_found and right_object_found )
    break;
  end if;
      // We must get two distinct class-in-associations if we have a
      // reflexive association.
  if ( oir.Obj_ID == left_obj.Obj_ID )
    if ( not left_object_found )
      if ( empty r_assoc )
        left_object_found = true;
        left_oir = oir;
      else
        if ( not rel_is_reflexive )
          left_object_found = true;
          left_oir = oir;
        else
          // reflexive link association
          select one rel_assr related by r_assoc->R_ASSR[R211];
          if ( left_obj.Obj_ID == rel_assr.Obj_ID )
            // navigating from assr back to aone/aoth
            left_object_found = true;
            left_oir = oir;
          elif ( right_obj.Obj_ID == rel_assr.Obj_ID )
            // navigating from aone/aoth to assr for reflexive link association
            // check for the correct phrase
            if ( blk.TempBuffer != "" )
              dest_rel_phrase = OS::remove_ticks( ticked_string: blk.TempBuffer );
              if ( oir.get_text_phrase() == dest_rel_phrase )
                left_object_found = true;
                left_oir = oir;
              else
                select one aone related by r_assoc->R_AONE[R209];
                select one aoth related by r_assoc->R_AOTH[R210];
                if ( aone.Txt_Phrs != dest_rel_phrase and 
                     aoth.Txt_Phrs != dest_rel_phrase )
                  // invalid phrase, use this oir for later code to throw error for bad phrase
                  left_object_found = true;
                  left_oir = oir;
                end if;
              end if;  // oir.get_text_phrase() == dest_rel_phrase
            else
              // use this oir for later code to detect empty phrase
              left_object_found = true;
              left_oir = oir;
            end if;  // blk.TempBuffer != "" 
          else
            // navigating directly without using assr
            left_object_found = true;
            left_oir = oir;
          end if;  // left_obj is assr
        end if; // not rel_is_reflexive
      end if;  // empty r_assoc
    end if;  // not left_object_found
  end if;  // oir.Obj_ID == left_obj.Obj_ID
  if ( oir.Obj_ID == right_obj.Obj_ID )
    if ( not left_object_found or oir.OIR_ID != left_oir.OIR_ID )
      right_object_found = true;
      right_oir = oir;
    end if;
  end if;
end for;
if ( not left_object_found or not right_object_found )
  ::clear_rel_data( a1_chain_start_val: param.a6_chain_start_val, a2_chain_id: param.a7_chain_id, a3_where_val: GD::NULL_UNIQUE_ID() );
  ERR::reportParseError( msg: 
      "The specified association ->R"+
          GD::int_to_string(value: r_rel.Numb) + "<- does not exist between classes ->"+
          left_obj.Name+"<- and ->"+right_obj.Name+"<-",
      token: param.a5_rule_token );
else
  // make sure that the right_oir is the one with the specified phrase for reflexive rels
  if ( rel_is_reflexive )
    if ( blk.TempBuffer != "" )
      swap_oirs = false;
      // empty phrases for reflexive associations are handled elsewhere
      dest_rel_phrase = OS::remove_ticks( ticked_string: blk.TempBuffer );
      if ( empty r_assoc )
        if ( right_oir.get_text_phrase() != dest_rel_phrase )
          swap_oirs = true;
        end if;
      else
        // figure out if the link class in in the link
        if ( left_oir.OIR_ID != rel_assr.OIR_ID and right_oir.OIR_ID != rel_assr.OIR_ID )
          // link class is not part of the link
          if ( right_oir.get_text_phrase() != dest_rel_phrase )
            swap_oirs = true;
          end if;
        end if;
      end if;    // empty r_assoc
      if ( swap_oirs )
        temp_oir = left_oir;
        left_oir = right_oir;
        right_oir = temp_oir;
      end if;  // swap_oirs
    end if;  // blk.TempBuffer != ""
  end if;  // is_reflexive
  select one left_oasub related by left_oir->R_RGO[R203]->R_SUB[R205];
  select one right_oasub related by right_oir->R_RGO[R203]->R_SUB[R205];
  if ( not_empty left_oasub and not_empty right_oasub )
    ::clear_rel_data( a1_chain_start_val: param.a6_chain_start_val, a2_chain_id: param.a7_chain_id, a3_where_val: GD::NULL_UNIQUE_ID() );
    ERR::reportParseError( msg: 
           "The classes ->" + left_obj.Name+"<- and ->"+right_obj.Name+"<- " +
           "are subtype classes in the association ->R" +
           GD::int_to_string(value: r_rel.Numb) + "<-", 
      token: param.a5_rule_token );
  else
    select one subsup related by r_rel->R_SUBSUP[R206];
    if ( not_empty subsup and param.a4_phrase != GD::NULL_UNIQUE_ID() )
      ::clear_rel_data( a1_chain_start_val: param.a6_chain_start_val, a2_chain_id: param.a7_chain_id, a3_where_val: GD::NULL_UNIQUE_ID() );
      ERR::reportParseError( msg: 
          "A destination association phrase is not allowed for a supertype/subtype association",
          token: param.a5_rule_token );
    else
      if ( ::has_valid_phrase(a1_rel: param.a3_rel, a2_phrase: param.a4_phrase,
         a3_right_oir_id: right_oir.OIR_ID, a4_right_obj_name: right_obj.Name, a5_right_obj_id: right_obj.Obj_ID,
         a6_left_oir_id: left_oir.OIR_ID, a7_left_obj_name: left_obj.Name, a8_left_obj_id: left_obj.Obj_ID,
         a9_rule_token: param.a5_rule_token, b1_chain_start_val: param.a6_chain_start_val,
        b2_chain_id: param.a7_chain_id  ) )
        return ::get_right_object_multiplicity(a1_left: left_oir.OIR_ID, a2_rel: r_rel.Rel_ID, a3_right: right_oir.OIR_ID);
      end if;
    end if;
  end if;
end if;
return Multiplicity::Unknown;



















































































',
	2434,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4469,
	4468,
	'a1_left',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4470,
	4468,
	'a2_right',
	296,
	0,
	'',
	4469,
	'');
INSERT INTO S_SPARM
	VALUES (4471,
	4468,
	'a3_rel',
	296,
	0,
	'',
	4470,
	'');
INSERT INTO S_SPARM
	VALUES (4472,
	4468,
	'a4_phrase',
	296,
	0,
	'',
	4471,
	'');
INSERT INTO S_SPARM
	VALUES (4473,
	4468,
	'a5_rule_token',
	4438,
	0,
	'',
	4472,
	'');
INSERT INTO S_SPARM
	VALUES (4474,
	4468,
	'a6_chain_start_val',
	296,
	0,
	'',
	4473,
	'');
INSERT INTO S_SPARM
	VALUES (4475,
	4468,
	'a7_chain_id',
	296,
	0,
	'',
	4474,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4476);
INSERT INTO S_SYNC
	VALUES (4476,
	1,
	'is_valid_assoc_relationship',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'if ( param.a4_rel == GD::NULL_UNIQUE_ID() )
  ::clear_rel_data( a1_chain_start_val: param.a7_chain_start_val, a2_chain_id: param.a8_chain_id, a3_where_val: GD::NULL_UNIQUE_ID() );
  ERR::reportParseError( msg: 
      "Invalid association specification",
      token: param.a6_rule_token );
end if;

select any r_rel from instances of R_REL where ( selected.Rel_ID == param.a4_rel );

select one r_assoc related by r_rel->R_ASSOC[R206];
if ( empty r_assoc )
  ::clear_rel_data( a1_chain_start_val: param.a7_chain_start_val, a2_chain_id: param.a8_chain_id, a3_where_val: GD::NULL_UNIQUE_ID() );
  ERR::reportParseError( msg: 
       "Association ->R" +
          GD::int_to_string(value: r_rel.Numb) + "<- is not linked",
          token: param.a6_rule_token );
else
  select any left_obj  from instances of O_OBJ where ( selected.Obj_ID == param.a1_left );
  select any right_obj  from instances of O_OBJ where ( selected.Obj_ID == param.a2_right );
  select any assoc_obj  from instances of O_OBJ where ( selected.Obj_ID == param.a3_assoc );

  left_object_found = false;
  right_object_found = false;
  assoc_obj_found = false;
  select any left_oir from instances of R_OIR;
  select any right_oir from instances of R_OIR;
  select any assoc_oir from instances of R_OIR;

  select many oir_set related by r_rel->R_OIR[R201];
  for each oir in oir_set
    if ( left_object_found and right_object_found and assoc_obj_found )
      break;
    end if;
    if ( oir.Obj_ID == left_obj.Obj_ID )
      if ( not left_object_found )
        left_object_found = true;
        left_oir = oir;
        // we need to get back to the top of this loop 
        // to prevent right_oir being set for reflexive associations
        continue;
      end if;
    end if;
    if ( oir.Obj_ID == right_obj.Obj_ID )
      right_object_found = true;
      right_oir = oir;
    end if;
    if ( oir.Obj_ID == assoc_obj.Obj_ID )
      assoc_obj_found = true;
      assoc_oir = oir;
    end if;
  end for;
  if ( not assoc_obj_found )
    ::clear_rel_data( a1_chain_start_val: param.a7_chain_start_val, a2_chain_id: param.a8_chain_id, a3_where_val: GD::NULL_UNIQUE_ID() );
    ERR::reportParseError( msg: 
           "Class ->"+assoc_obj.Name+"<- is not the link class between " +
           "classes ->"+left_obj.Name+"<- and ->"+right_obj.Name+
            "<- in link association ->R"+GD::int_to_string(value: r_rel.Numb)+"<-",
          token: param.a6_rule_token );
  elif ( not left_object_found )
    ::clear_rel_data( a1_chain_start_val: param.a7_chain_start_val, a2_chain_id: param.a8_chain_id, a3_where_val: GD::NULL_UNIQUE_ID() );
    ERR::reportParseError( msg: 
           "Class ->"+left_obj.Name+"<- does not participate in the link association ->R"+
           GD::int_to_string(value: r_rel.Numb) +"<-",
          token: param.a6_rule_token );
  elif ( not right_object_found )
    ::clear_rel_data( a1_chain_start_val: param.a7_chain_start_val, a2_chain_id: param.a8_chain_id, a3_where_val: GD::NULL_UNIQUE_ID() );
    ERR::reportParseError( msg: 
           "Class ->"+right_obj.Name+"<- does not participate in the link association ->R"+
           GD::int_to_string(value: r_rel.Numb) +"<-",
          token: param.a6_rule_token );
  else
    // Make sure each class is at its correct position in association. First check
    // link class, then associated classes.
    select one rel_assr related by r_assoc->R_ASSR[R211];
    select one oir_assr related by assoc_oir->R_RGO[R203]->R_ASSR[R205];
    if ( rel_assr != oir_assr )
      ::clear_rel_data( a1_chain_start_val: param.a7_chain_start_val, a2_chain_id: param.a8_chain_id, a3_where_val: GD::NULL_UNIQUE_ID() );
      ERR::reportParseError( msg: 
           "Class ->"+assoc_obj.Name+"<- is incorrectly specified in link association ->R" +
            GD::int_to_string(value: r_rel.Numb)+"<-",
            token: param.a6_rule_token );
    else
      select one rel_aone related by r_assoc->R_AONE[R209];
      select one rel_aoth related by r_assoc->R_AOTH[R210];
      select one l_aone related by left_oir->R_RTO[R203]->R_AONE[R204];
      select one l_aoth related by left_oir->R_RTO[R203]->R_AOTH[R204];
      select one r_aone related by right_oir->R_RTO[R203]->R_AONE[R204];
      select one r_aoth related by right_oir->R_RTO[R203]->R_AOTH[R204];
      if ( (empty l_aone and empty l_aoth) or
           (not_empty l_aone and l_aone != rel_aone) or
           (not_empty l_aoth and l_aoth != rel_aoth) )
        ::clear_rel_data( a1_chain_start_val: param.a7_chain_start_val, a2_chain_id: param.a8_chain_id, a3_where_val: GD::NULL_UNIQUE_ID() );
        ERR::reportParseError( msg: 
           "Class ->"+left_obj.Name+"<- is incorrectly specified in link association ->R"+
           GD::int_to_string(value: r_rel.Numb)+"<-",
            token: param.a6_rule_token );
      elif ( (empty r_aone and empty r_aoth) or
           (not_empty r_aone and r_aone != rel_aone) or
           (not_empty r_aoth and r_aoth != rel_aoth) )
        ::clear_rel_data( a1_chain_start_val: param.a7_chain_start_val, a2_chain_id: param.a8_chain_id, a3_where_val: GD::NULL_UNIQUE_ID() );
        ERR::reportParseError( msg: 
           "Class ->"+right_obj.Name+"<- is incorrectly specified in link association ->R"+
           GD::int_to_string(value: r_rel.Numb)+"<-",
            token: param.a6_rule_token );
       else
         return ::has_valid_phrase(a1_rel: param.a4_rel, a2_phrase: param.a5_phrase,
            a3_right_oir_id: right_oir.OIR_ID, a4_right_obj_name: right_obj.Name, a5_right_obj_id: right_obj.Obj_ID,
            a6_left_oir_id: left_oir.OIR_ID, a7_left_obj_name: left_obj.Name, a8_left_obj_id: left_obj.Obj_ID,
            a9_rule_token: param.a6_rule_token, b1_chain_start_val: param.a7_chain_start_val, b2_chain_id: param.a8_chain_id);
       end if;
    end if;
  end if;
end if;

return true;




















































































',
	316,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4477,
	4476,
	'a1_left',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4478,
	4476,
	'a2_right',
	296,
	0,
	'',
	4477,
	'');
INSERT INTO S_SPARM
	VALUES (4479,
	4476,
	'a3_assoc',
	296,
	0,
	'',
	4478,
	'');
INSERT INTO S_SPARM
	VALUES (4480,
	4476,
	'a4_rel',
	296,
	0,
	'',
	4479,
	'');
INSERT INTO S_SPARM
	VALUES (4481,
	4476,
	'a5_phrase',
	296,
	0,
	'',
	4480,
	'');
INSERT INTO S_SPARM
	VALUES (4482,
	4476,
	'a6_rule_token',
	4438,
	0,
	'',
	4481,
	'');
INSERT INTO S_SPARM
	VALUES (4483,
	4476,
	'a7_chain_start_val',
	296,
	0,
	'',
	4482,
	'');
INSERT INTO S_SPARM
	VALUES (4484,
	4476,
	'a8_chain_id',
	296,
	0,
	'',
	4483,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4485);
INSERT INTO S_SYNC
	VALUES (4485,
	1,
	'has_valid_phrase',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'select any r_rel from instances of R_REL where ( selected.Rel_ID == param.a1_rel );
if ( r_rel.is_reflexive() )
  if ( param.a2_phrase != GD::NULL_UNIQUE_ID() )
    current_scope = ::get_current_scope();
    select any blk from instances of ACT_BLK where (selected.Block_ID == current_scope);
    dest_rel_phrase = OS::remove_ticks( ticked_string: blk.TempBuffer );
    dest_rel_oir_id = param.a3_right_oir_id;
    left_oir_id = param.a6_left_oir_id;
    right_oir_id = param.a3_right_oir_id;
    if ( param.a8_left_obj_id == param.a5_right_obj_id )
      select any right_oir from instances of R_OIR where (selected.OIR_ID == GD::NULL_UNIQUE_ID()); 
      select any left_oir from instances of R_OIR where (selected.OIR_ID == GD::NULL_UNIQUE_ID()); 
      select many cias related by r_rel->R_OIR[R201];
      for each cia in cias
	    if (cia.OIR_ID == param.a3_right_oir_id)
		  right_oir = cia;
	    elif (cia.OIR_ID == param.a6_left_oir_id)
		  left_oir = cia;	
	    end if;
      end for;
      if ( left_oir.get_text_phrase() == dest_rel_phrase )
        dest_rel_oir_id = left_oir.OIR_ID;
      elif ( right_oir.get_text_phrase() != dest_rel_phrase )
        ::clear_rel_data( a1_chain_start_val: param.b1_chain_start_val, a2_chain_id: param.b2_chain_id, a3_where_val: GD::NULL_UNIQUE_ID() );
        ERR::reportParseError( msg: 
                 "Class ->"+ param.a4_right_obj_name+"<- in reflexive association ->R" +
              GD::int_to_string(value: r_rel.Numb) + 
               "<- does not contain destination association phrase ->"+
                 dest_rel_phrase  +"<-",
                 token: param.a9_rule_token );
      end if;
    else
              // We are navigating via the link class, which means we are
              // either at the associated class and going thru the link
              // class or we are at the link class going thru the
              // associated class. In either case, simply make sure the
              // association phrase match either one of the associated classes.
              // Remember we must save the oir affiliated with the phrase;
              // additionally we need to save the left and right oirs so the
              // multiplicity can be determined later.
             
              select one assoc_rel related by r_rel->R_ASSOC[R206]; 
              if ( empty assoc_rel )
                ::clear_rel_data( a1_chain_start_val: param.b1_chain_start_val, a2_chain_id: param.b2_chain_id, a3_where_val: GD::NULL_UNIQUE_ID() );
                ERR::reportParseError( msg: 
                   "Reflexive association ->R" +
                      GD::int_to_string(value: r_rel.Numb) + 
                      "<- is not linked, and should be",
                   token: param.a9_rule_token );
                  return false;
              end if;
              
              select one rel_associator related by assoc_rel->R_ASSR[R211];
              select one rel_aone related by assoc_rel->R_AONE[R209];
              select one rel_aoth related by assoc_rel->R_AOTH[R210];
              
              select any left_oir from instances of R_OIR where ( selected.OIR_ID == param.a6_left_oir_id );
              select one left_oir_assr related by left_oir->R_RGO[R203]->R_ASSR[R205];
              if ( not_empty rel_associator and not_empty left_oir_assr
                  and rel_associator.OIR_ID == left_oir_assr.OIR_ID )

                  // The left class is the link class and the right is
                  // one of the associators. The destination phrase should match
                  // one of the associators.
                  
                  if ( rel_aone.Txt_Phrs == dest_rel_phrase )
                      right_oir_id = rel_aone.OIR_ID;
                  elif ( rel_aoth.Txt_Phrs == dest_rel_phrase )
                      right_oir_id = rel_aoth.OIR_ID;
                  else
                    ::clear_rel_data( a1_chain_start_val: param.b1_chain_start_val, a2_chain_id: param.b2_chain_id, a3_where_val: GD::NULL_UNIQUE_ID() );
                     ERR::reportParseError( msg: 
                           "Class ->"+ param.a4_right_obj_name+"<- in reflexive association ->R" +
                           GD::int_to_string(value: r_rel.Numb) + 
                           "<- does not contain destination association phrase ->"+
                           dest_rel_phrase  +"<-",
                         token: param.a9_rule_token );
                      return false;
                   end if;
              else
                  // The left class is one of the associators and the right
                  // class is the link class. Even though the right
                  // class is the link class, the destination phrase
                  // must match with one of the associators, and we must
                  // store the destination phrase of the matching associator.
                  // However, the left_oinir_ptr should be OPPOSITE the phrase.
                  
                  if ( rel_aone.Txt_Phrs == dest_rel_phrase )
                      left_oir_id = rel_aoth.OIR_ID;
                  elif ( rel_aoth.Txt_Phrs == dest_rel_phrase )
                      left_oir_id = rel_aone.OIR_ID;
                  else
                    ::clear_rel_data( a1_chain_start_val: param.b1_chain_start_val, a2_chain_id: param.b2_chain_id, a3_where_val: GD::NULL_UNIQUE_ID() );
                     ERR::reportParseError( msg: 
                           "Class ->"+ param.a4_right_obj_name+"<- in reflexive association ->R" +
                           GD::int_to_string(value: r_rel.Numb) + 
                           "<- does not contain destination association phrase ->"+
                           dest_rel_phrase  +"<-",
                         token: param.a9_rule_token );
                      return false;
                  end if;
              end if;
    end if;
  else
    ::clear_rel_data( a1_chain_start_val: param.b1_chain_start_val, a2_chain_id: param.b2_chain_id, a3_where_val: GD::NULL_UNIQUE_ID() );
    ERR::reportParseError( msg: 
         "The destination association phrase must be specified for reflexive association ->R"+
          GD::int_to_string(value: r_rel.Numb) + "<- between classes ->" + 
             param.a7_left_obj_name+"<- and ->"+param.a4_right_obj_name+"<-",
          token: param.a9_rule_token );
  end if;
else
  // not reflexive
  if ( param.a2_phrase != GD::NULL_UNIQUE_ID() )
    current_scope = ::get_current_scope();
    select any blk from instances of ACT_BLK where (selected.Block_ID == current_scope);
    dest_rel_phrase = OS::remove_ticks( ticked_string: blk.TempBuffer );
    select any right_oir from instances of R_OIR where ( selected.OIR_ID == param.a3_right_oir_id );
    if ( right_oir.get_text_phrase() != dest_rel_phrase )
      ::clear_rel_data( a1_chain_start_val: param.b1_chain_start_val, a2_chain_id: param.b2_chain_id, a3_where_val: GD::NULL_UNIQUE_ID() );
      ERR::reportParseError( msg: 
              "Class ->"+param.a4_right_obj_name+"<- in association ->R" +
              GD::int_to_string(value: r_rel.Numb) + 
              "<- does not contain destination association phrase ->"+ dest_rel_phrase +"<-",
              token: param.a9_rule_token );
    end if;
  end if;
end if;
return true;















































































',
	316,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4486,
	4485,
	'a1_rel',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4487,
	4485,
	'a2_phrase',
	296,
	0,
	'',
	4486,
	'');
INSERT INTO S_SPARM
	VALUES (4488,
	4485,
	'a3_right_oir_id',
	296,
	0,
	'',
	4487,
	'');
INSERT INTO S_SPARM
	VALUES (4489,
	4485,
	'a4_right_obj_name',
	322,
	0,
	'',
	4488,
	'');
INSERT INTO S_SPARM
	VALUES (4490,
	4485,
	'a5_right_obj_id',
	296,
	0,
	'',
	4489,
	'');
INSERT INTO S_SPARM
	VALUES (4491,
	4485,
	'a6_left_oir_id',
	296,
	0,
	'',
	4490,
	'');
INSERT INTO S_SPARM
	VALUES (4492,
	4485,
	'a7_left_obj_name',
	322,
	0,
	'',
	4491,
	'');
INSERT INTO S_SPARM
	VALUES (4493,
	4485,
	'a8_left_obj_id',
	296,
	0,
	'',
	4492,
	'');
INSERT INTO S_SPARM
	VALUES (4494,
	4485,
	'a9_rule_token',
	4438,
	0,
	'',
	4493,
	'');
INSERT INTO S_SPARM
	VALUES (4495,
	4485,
	'b1_chain_start_val',
	296,
	0,
	'',
	4494,
	'');
INSERT INTO S_SPARM
	VALUES (4496,
	4485,
	'b2_chain_id',
	296,
	0,
	'',
	4495,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4497);
INSERT INTO S_SYNC
	VALUES (4497,
	1,
	'process_from_instances',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'  select any var from instances of V_VAR
          where (selected.Var_ID == param.a1_local_var );
  select any stmt from instances of ACT_SMT
          where (selected.Statement_ID ==   param.a2_stmt_id );
  select one irv related by var->V_INT[R814];
  select one irsv related by var->V_INS[R814];
  select one obj related by stmt->ACT_FIO[R603]->O_OBJ[R677];
  if ( param.a5_has_where )
    select one obj related by stmt->ACT_FIW[R603]->O_OBJ[R676];
  end if;
  if ( var.Declared and param.a3_mult == "any" and empty irv )
    stmt.dispose();
    ERR::reportParseError( msg: "Variable ->"+var.Name+"<- does not exist in scope as an object instance variable",
        token: param.a4_rule_token );
  elif ( var.Declared and param.a3_mult != "any" and empty irsv )
    stmt.dispose();
    ERR::reportParseError( msg: "Variable ->"+var.Name+"<- does not exist in scope as an object instance set variable",
        token: param.a4_rule_token );
  else
    is_implicit = false;
    stmt_ok = false;
    if ( var.Declared )
      if ( param.a3_mult != "any" )
        select one irsv_obj related by irsv->O_OBJ[R819];
        if ( irsv_obj.Obj_ID != obj.Obj_ID )
          stmt.dispose();
          ERR::reportParseError( msg: "Variable ->"+var.Name+"<- already exists as a different type",
            token: param.a4_rule_token );
        else
          is_implicit = false;
          stmt_ok = true;
        end if;
      elif ( param.a3_mult == "any" )
        select one irv_obj related by irv->O_OBJ[R818];
        if ( irv_obj.Obj_ID != obj.Obj_ID )
          stmt.dispose();
          ERR::reportParseError( msg: "Variable ->"+var.Name+"<- already exists as a different type",
            token: param.a4_rule_token );
        else
          is_implicit = false;
          stmt_ok = true;
        end if;
      end if;
    else
      stmt_ok = true;
      is_implicit = true;
      if ( param.a3_mult == "any" )
        var.migrate_to_int();
        select one inst_ref related by var->V_INT[R814];
        relate inst_ref to obj across R818;
        ::connect_inst_ref_var_to_datatype(p1_is_set:false, p2_var_id:var.Var_ID, p3_obj_id:obj.Obj_ID);
      else
        var.migrate_to_ins();
        select one inst_ref_set related by var->V_INS[R814];
        relate inst_ref_set to obj across R819;
        ::connect_inst_ref_var_to_datatype(p1_is_set:true, p2_var_id:var.Var_ID, p3_obj_id:obj.Obj_ID);
      end if;
      var.Declared = true;
    end if;
    if ( stmt_ok )
      if ( param.a5_has_where )
        select one fiw related by stmt->ACT_FIW[R603];
        fiw.cardinality = param.a3_mult;
        fiw.is_implicit = is_implicit;
        relate fiw to var across R665;
      else
        select one fio related by stmt->ACT_FIO[R603];
        fio.cardinality = param.a3_mult;
        fio.is_implicit = is_implicit;
        relate fio to var across R639;
      end if;
    end if;
  end if;
  return stmt.Statement_ID;











































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4498,
	4497,
	'a1_local_var',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4499,
	4497,
	'a2_stmt_id',
	296,
	0,
	'',
	4498,
	'');
INSERT INTO S_SPARM
	VALUES (4500,
	4497,
	'a3_mult',
	322,
	0,
	'',
	4499,
	'');
INSERT INTO S_SPARM
	VALUES (4501,
	4497,
	'a4_rule_token',
	4438,
	0,
	'',
	4500,
	'');
INSERT INTO S_SPARM
	VALUES (4502,
	4497,
	'a5_has_where',
	316,
	0,
	'',
	4501,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4503);
INSERT INTO S_SYNC
	VALUES (4503,
	1,
	'selected_validate',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'if ( param.name == "Selected" or param.name == "selected" or param.name == "SELECTED" )
  current_scope = ::get_current_scope();
  select any blk from instances of ACT_BLK where (selected.Block_ID == current_scope);
  if ( not blk.InWhereSpec )
    ERR::reportParseError( msg: "Keyword ->Selected<- cannot be used outside a where expression",
          token: param.rule_token );
    ::clear_value_data();
  end if;
  return true;
else
  return false;
end if;







































































',
	316,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4504,
	4503,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4505,
	4503,
	'rule_token',
	4438,
	0,
	'',
	4504,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4506);
INSERT INTO S_SYNC
	VALUES (4506,
	1,
	'process_related_by',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'  select any var from instances of V_VAR
          where (selected.Var_ID == param.a1_local_var );
  select any stmt from instances of ACT_SMT
          where (selected.Statement_ID == param.a2_stmt_id );
  select one sel related by stmt->ACT_SEL[R603];
  select one irv related by var->V_INT[R814];
  select one irsv related by var->V_INS[R814];
  select one link related by sel->ACT_LNK[R637];
  last_link = link;
  mult = "one";
  if ( not_empty irsv )
    mult = "many";
  end if;
  while ( not_empty link )
    last_link = link;
    if ( link.Mult == Multiplicity::Many )
      mult = "many";
    end if;
    select one link related by last_link->ACT_LNK[R604.''precedes''];
  end while;

  if ( param.a3_mult == "one" and mult == "many" )
    if ( not var.Declared )
      var.dispose();
    end if;
    stmt.dispose();
    ERR::reportParseError( msg: "At least one association has a right class with multiplicity of many.  With SELECT ONE, all right classes must have multiplicity of one",
        token: param.a4_rule_token );
  elif ( param.a3_mult == "any" and mult == "one" )
    if ( not var.Declared )
      var.dispose();
    end if;
    stmt.dispose();
    ERR::reportParseError( msg: "No right class has multiplicity of many. With SELECT ANY, at least one class must have multiplicity of many",
        token: param.a4_rule_token );
  elif ( param.a3_mult == "many" and mult == "one" )
    if ( not var.Declared )
      var.dispose();
    end if;
    stmt.dispose();
    ERR::reportParseError( msg: "No right class has multiplicity of many. With SELECT MANY, at least one class must have multiplicity of many",
        token: param.a4_rule_token );
  end if;

  select one obj related by last_link->O_OBJ[R678];
  if ( var.Declared and
        (param.a3_mult == "any" or param.a3_mult == "one") and empty irv )
    stmt.dispose();
    ERR::reportParseError( msg: "Variable ->"+var.Name+"<- does not exist in scope as an object instance variable",
        token: param.a4_rule_token );
  elif ( var.Declared and param.a3_mult == "many" and empty irsv )
    stmt.dispose();
    ERR::reportParseError( msg: "Variable ->"+var.Name+"<- does not exist in scope as an object instance set variable",
        token: param.a4_rule_token );
  else
    stmt_ok = false;
    if ( var.Declared )
      if ( param.a3_mult == "many" )
        select one irsv_obj related by irsv->O_OBJ[R819];
        if ( irsv_obj.Obj_ID != obj.Obj_ID )
          stmt.dispose();
          ERR::reportParseError( msg: "Variable ->"+var.Name+"<- already exists as a different type",
            token: param.a4_rule_token );
        else
          sel.is_implicit = false;
          stmt_ok = true;
        end if;
      else
        select one irv_obj related by irv->O_OBJ[R818];
        if ( irv_obj.Obj_ID != obj.Obj_ID )
          stmt.dispose();
          ERR::reportParseError( msg: "Variable ->"+var.Name+"<- already exists as a different type",
            token: param.a4_rule_token );
        else
          sel.is_implicit = false;
          stmt_ok = true;
        end if;
      end if;
    else
      stmt_ok = true;
      sel.is_implicit = true;
      if ( param.a3_mult != "many" )
        var.migrate_to_int();
        select one inst_ref related by var->V_INT[R814];
        relate inst_ref to obj across R818;
        ::connect_inst_ref_var_to_datatype(p1_is_set:false, p2_var_id:var.Var_ID, p3_obj_id:obj.Obj_ID);
      else
        var.migrate_to_ins();
        select one inst_ref_set related by var->V_INS[R814];
        relate inst_ref_set to obj across R819;
        ::connect_inst_ref_var_to_datatype(p1_is_set:true, p2_var_id:var.Var_ID, p3_obj_id:obj.Obj_ID);
      end if;
      var.Declared = true;
    end if;
    if ( stmt_ok )
      sel.cardinality = param.a3_mult;
      relate sel to var across R638;
    end if;
  end if;
  return stmt.Statement_ID;

',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4507,
	4506,
	'a1_local_var',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4508,
	4506,
	'a2_stmt_id',
	296,
	0,
	'',
	4507,
	'');
INSERT INTO S_SPARM
	VALUES (4509,
	4506,
	'a3_mult',
	322,
	0,
	'',
	4508,
	'');
INSERT INTO S_SPARM
	VALUES (4510,
	4506,
	'a4_rule_token',
	4438,
	0,
	'',
	4509,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4511);
INSERT INTO S_SYNC
	VALUES (4511,
	1,
	'get_right_object_multiplicity',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'result_mult = Multiplicity::Unknown;
  
// We also have to get the multiplicity of the right
// class so that the cardinality of the association chain can be determined
// to make sure matches the SELECT ONE/ANY/MANY.
select any r_rel from instances of R_REL where ( selected.Rel_ID == param.a2_rel );
select any right_oir from instances of R_OIR where (selected.OIR_ID == GD::NULL_UNIQUE_ID()); 
select any left_oir from instances of R_OIR where (selected.OIR_ID == GD::NULL_UNIQUE_ID()); 
select many cias related by r_rel->R_OIR[R201];
for each cia in cias
	if (cia.OIR_ID == param.a3_right)
		right_oir = cia;
	elif (cia.OIR_ID == param.a1_left)
		left_oir = cia;	
	end if;
end for;
select one simp related by r_rel->R_SIMP[R206];
if ( not_empty simp )
  result_mult = right_oir.get_multiplicity();
else  // empty simp
  select one inh related by r_rel->R_SUBSUP[R206];
  if (not_empty inh )
    result_mult = Multiplicity::One;
  else // empty inh
    select one comp related by r_rel->R_COMP[R206];
    if ( not_empty comp )
      result_mult = right_oir.get_multiplicity();
    else // empty comp
      select one assoc related by r_rel->R_ASSOC[R206];
      if ( not_empty assoc )
        select one assr related by left_oir->R_RGO[R203]->R_ASSR[R205];
        if ( not_empty assr )
          // Real simply, if the left class is the link class,
          // then we should ALWAYS use ONE multiplicity because we can
          // only navigate to ONE and only ONE of the associators.
          
          result_mult = Multiplicity::One;
        else 
          select one aone related by left_oir->R_RTO[R203]->R_AONE[R204];
          if (not_empty aone )
            select one aoth related by right_oir->R_RTO[R203]->R_AOTH[R204];
            if ( not_empty aoth )
              result_mult = right_oir.get_multiplicity();
            else 
              select one assr related by right_oir->R_RGO[R203]->R_ASSR[R205];
              if ( not_empty assr )
                select one assoc_aoth related by assoc->R_AOTH[R210];
                if ( assr.Mult == 0 )
                   if ( r_rel.is_reflexive() )
                    // the roles are not reversed for link reflexive associations
                    if ( aone.Mult == 0 )  // 0 == ONE
                      result_mult = Multiplicity::One;
                    else
                      result_mult = Multiplicity::Many;
                    end if;
                   else
                     if ( assoc_aoth.Mult == 0 )  // 0 == ONE
                       result_mult =Multiplicity::One;
                     else
                        result_mult = Multiplicity::Many;
                     end if;
                  end if;  // is_reflexive
                else
                  result_mult = Multiplicity::Many;
                end if;
              else  // empty assr
                result_mult = Multiplicity::One;
              end if;  // not_empty assr
            end if;  // not_empty aoth
          else 
            select one aoth related by left_oir->R_RTO[R203]->R_AOTH[R204];
            if ( not_empty aoth )
              select one aone related by right_oir->R_RTO[R203]->R_AONE[R204];
              if ( not_empty aone )
                result_mult = right_oir.get_multiplicity();
              else 
                select one assr related by right_oir->R_RGO[R203]->R_ASSR[R205];
                if ( not_empty assr )
                  select one assoc_aone related by assoc->R_AONE[R209];
                  if ( assr.Mult == 0)
                     if ( r_rel.is_reflexive() )
                      // the roles are not reversed for link reflexive associations
                      if ( aoth.Mult == 0 )  // 0 == ONE
                        result_mult = Multiplicity::One;
                      else
                        result_mult = Multiplicity::Many;
                      end if;
                     else
                      if ( assoc_aone.Mult == 0 )  // 0 == ONE
                        result_mult = Multiplicity::One;
                      else
                        result_mult = Multiplicity::Many;
                      end if;
                     end if;
                  else
                    result_mult = Multiplicity::Many;
                  end if;
                else
                  result_mult =Multiplicity::One;
                end if;
              end if;  // not_empty aone
            else  // empty aoth
              result_mult = Multiplicity::One;
            end if;  // not_empty aoth
          end if;  // not_empty aone
        end if;  // not_empty assr
      else  // empty assoc
        result_mult =Multiplicity::One;
      end if;  // not_empty assoc
    end if;  // not_empty comp
  end if;  // not_empty inh
end if;  // not_empty simp


return  result_mult ;



































































',
	2434,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4512,
	4511,
	'a1_left',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4513,
	4511,
	'a2_rel',
	296,
	0,
	'',
	4512,
	'');
INSERT INTO S_SPARM
	VALUES (4514,
	4511,
	'a3_right',
	296,
	0,
	'',
	4513,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4515);
INSERT INTO S_SYNC
	VALUES (4515,
	1,
	'clear_select',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'select any var from instances of V_VAR
        where (selected.Var_ID == param.var_id );
if ( not_empty var )
  if ( not var.Declared )
    var.dispose();
  end if;
end if;


',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4516,
	4515,
	'var_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4517);
INSERT INTO S_SYNC
	VALUES (4517,
	1,
	'clear_rel_data',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'  if ( param.a3_where_val != GD::NULL_UNIQUE_ID() )
    select any val from instances of V_VAL
         where ( selected.Value_ID == param.a3_where_val );
    if ( not_empty val )
      val.dispose();
    end if;
  end if;

  if ( param.a2_chain_id != GD::NULL_UNIQUE_ID() )
    select any start_link from instances of ACT_LNK 
         where ( selected.Link_ID == param.a2_chain_id );
    if ( not_empty start_link )
      // follow links to the end, deleting along the way
      //  but don''t delete start_link yet
      next_id = start_link.Next_Link_ID;
      select any link from instances of ACT_LNK where ( selected.Link_ID == next_id );
      while ( not_empty link )
        last_link = link;
        select one link related by last_link->ACT_LNK[R604.''precedes''];
        last_link.dispose();
      end while;

      //  follow links back to beginning, deleting along the way
      link = start_link;
      while ( not_empty link )
        this_link = link;
        select one link related by this_link->ACT_LNK[R604.''succeeds''];
        this_link.dispose();
      end while;
    end if;
  end if;

  if ( param.a1_chain_start_val != GD::NULL_UNIQUE_ID() )
    select any val from instances of V_VAL where ( selected.Value_ID == param.a1_chain_start_val );
    if ( not_empty val )
      val.dispose();
     end if;
  end if;

',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4518,
	4517,
	'a1_chain_start_val',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4519,
	4517,
	'a2_chain_id',
	296,
	0,
	'',
	4518,
	'');
INSERT INTO S_SPARM
	VALUES (4520,
	4517,
	'a3_where_val',
	296,
	0,
	'',
	4519,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4521);
INSERT INTO S_SYNC
	VALUES (4521,
	1,
	'clear_for_data',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'select any iter from instances of V_VAR where ( selected.Var_ID == param.a1_iter );
if ( not_empty iter and not iter.Declared )
  iter.dispose();
end if;

select any for_blk from instances of ACT_BLK where (selected.Block_ID == param.a2_block);
if ( not_empty for_blk )
  for_blk.dispose();
end if;

select any stmt from instances of ACT_SMT
          where ( selected.Statement_ID == param.a3_stmt_id );
if ( not_empty stmt )
  stmt.dispose();
end if;






















































',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4522,
	4521,
	'a1_iter',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4523,
	4521,
	'a2_block',
	296,
	0,
	'',
	4522,
	'');
INSERT INTO S_SPARM
	VALUES (4524,
	4521,
	'a3_stmt_id',
	296,
	0,
	'',
	4523,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4525);
INSERT INTO S_SYNC
	VALUES (4525,
	1,
	'is_valid_bridge',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
current_scope = ::get_current_scope();
select any block from instances of ACT_BLK where
                                             selected.Block_ID == current_scope;
select one body related by block->ACT_ACT[R612];
isInGenericPackage = body.associateWithContainer();
if isInGenericPackage
  select one containingElem related by body->ACT_BIE[R640]->PE_PE[R640];
  select one component related by containingElem->C_C[R8001];
  select one package related by containingElem->EP_PKG[R8001];

  // Check for EE keyletter match for token
  if not_empty component
    component.collectVisibleElementsForName(name:param.key_lett,
         type:ElementTypeConstants::EE, originatingContainerID:component.Id,
                                   delegatingContainerID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:true);
  else
    package.collectVisibleElementsForName(name:param.key_lett,
         type:ElementTypeConstants::EE, descending:false,
                           originatingContainerID:containingElem.Element_ID,
                                          delegatingPkgID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:true);
  end if;
  select any resultSet related by component->PE_CRS[R8007] where
                                    selected.Name == param.key_lett and 
                                      selected.Type == ElementTypeConstants::EE; 
  select many results related by resultSet->PE_CVS[R8008]->PE_PE[R8004];
  if not_empty package
    select any pkgResultSet related by package->PE_SRS[R8005] where
                                    selected.Name == param.key_lett and 
                                      selected.Type == ElementTypeConstants::EE; 
    select many results related by pkgResultSet->PE_VIS[R8006]->PE_PE[R8002];
  end if;
  if empty results
    ERR::reportParseError( 
        msg: "Cannot find external entity ->"+param.key_lett+"<-", 
                                                      token: param.rule_token ); 
  else  // results not empty
    // select the first ee in the result set (it is acceptable to have multiple
    // ees and we only want to validate multiple bridges in the same ee)
    select any ee related by results->S_EE[R8001];
    select many brg_set related by ee->S_BRG[R19]
                                              where selected.Name == param.name;
    if ( empty brg_set )
      ERR::reportParseError( 
          msg: "Cannot find specified bridge ->"+param.key_lett+"::%s<-", 
                                                      token: param.rule_token ); 
    elif ( cardinality brg_set > 1 )
      ERR::reportParseError(msg: "More than one bridge with name ->%s<- " +
          "You will need to eventually clear this up", token: param.rule_token);
    else // cardinality brg_set == 1
      select any brg related by results->S_EE[R8001]->S_BRG[R19]
                                              where selected.Name == param.name;
      create object instance brv of V_BRV;
      brv.ParmListOK = true;
      create object instance val of V_VAL;
      relate val to block across R826;
      relate val to brv across R801;

      val.LineNumber = ::getLineNumber(rule_token: param.rule_token);
      val.StartPosition = ::getColumn(rule_token: param.rule_token);
      val.setEndPosition();

      // store the textual position of the external entity key-letters
      brv.externalEntityKeyLettersLineNumber =
                                              block.currentKeyLettersLineNumber;
      brv.externalEntityKeyLettersColumn = block.currentKeyLettersColumn;

      relate brg to brv across R828;
      select one bdt related by brg->S_DT[R20];
      relate val to bdt across R820;

      return val.Value_ID;
    end if;
  end if;
  return GD::NULL_UNIQUE_ID();
else  // non-generic package path
  select any ee from instances of S_EE where
                                            selected.Key_Lett == param.key_lett;
  body.associateWithOwningComponent();
  select one component related by body->ACT_BIC[R694]->C_C[R694];
  if not_empty component
    // If we''re in a component, we just look for the external entity locally
    select any ee related by component->CN_DC[R4204]->
               S_DOM[R4204]->S_EE[R8] where selected.Key_Lett == param.key_lett;
  end if;
  select many brg_set related by ee->S_BRG[R19] where selected.Name == param.name;
  if ( empty brg_set )
    ERR::reportParseError( 
        msg: "Cannot find specified bridge ->"+ee.Key_Lett+"::%s<-", 
        token: param.rule_token ); 
  elif ( cardinality brg_set > 1 )
    ERR::reportParseError( msg:
"More than one bridge with name ->%s<- You will need to eventually clear this up",
          token: param.rule_token );
  else
    select any brg related by ee->S_BRG[R19] where selected.Name == param.name;
    create object instance brv of V_BRV;
    brv.ParmListOK = true;
    create object instance val of V_VAL;
    relate val to block across R826;
    relate val to brv across R801;

    val.LineNumber = ::getLineNumber(rule_token: param.rule_token);
    val.StartPosition = ::getColumn(rule_token: param.rule_token);
    val.setEndPosition();

	// store the textual position of the external entity key-letters
	brv.externalEntityKeyLettersLineNumber = block.currentKeyLettersLineNumber;
	brv.externalEntityKeyLettersColumn = block.currentKeyLettersColumn;

    relate brg to brv across R828;
    select one bdt related by brg->S_DT[R20];
    relate val to bdt across R820;

    return val.Value_ID;
  end if;
  return GD::NULL_UNIQUE_ID();
end if;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4526,
	4525,
	'key_lett',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4527,
	4525,
	'name',
	322,
	0,
	'',
	4526,
	'');
INSERT INTO S_SPARM
	VALUES (4528,
	4525,
	'rule_token',
	4438,
	0,
	'',
	4527,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4529);
INSERT INTO S_SYNC
	VALUES (4529,
	1,
	'is_valid_transform',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'select any obj from instances of O_OBJ where ( selected.Obj_ID == param.a1_obj_id ); 
select many tfr_set related by obj->O_TFR[R115] where selected.Name == param.a2_name;
if ( empty tfr_set )
   ERR::reportParseError( 
        msg: "Cannot find specified operation ->"+obj.Key_Lett+"::%s<-", 
        token: param.a3_rule_token ); 
elif ( cardinality tfr_set > 1 )
   ERR::reportParseError( msg:
"More than one operation with name ->%s<- You will need to eventually run the audit and/or clear this up",
          token: param.a3_rule_token );
else
  select any tfr related by obj->O_TFR[R115] where selected.Name == param.a2_name;
  if ( tfr.Instance_Based == Scope::Instance and param.a4_classBased )
    ERR::reportParseError( 
       msg: "Operation ->%s<- is instance-based and must be invoked as <var>."+param.a2_name,
        token: param.a3_rule_token ); 
  elif ( tfr.Instance_Based == Scope::Class and not param.a4_classBased )
    ERR::reportParseError( 
       msg: "Operation ->%s<- is class-based and must be invoked as <kl>::"+param.a2_name,
        token: param.a3_rule_token ); 
  else
    create object instance trv of V_TRV;
    trv.ParmListOK = true;
    create object instance val of V_VAL;
    current_scope = ::get_current_scope();
    select any block from instances of ACT_BLK where (selected.Block_ID == current_scope);
    relate val to block across R826;
    relate val to trv across R801;

    relate tfr to trv across R829;
    select one tdt related by tfr->S_DT[R116];
    relate val to tdt across R820;

    val.LineNumber = ::getLineNumber(rule_token: param.a3_rule_token);
    val.StartPosition = ::getColumn(rule_token: param.a3_rule_token);
    val.setEndPosition();

	// if the operation is class-based
	if (tfr.Instance_Based == Scope::Class)
		// store the textual position of the class key-letters
		trv.modelClassKeyLettersLineNumber = block.currentKeyLettersLineNumber;
		trv.modelClassKeyLettersColumn = block.currentKeyLettersColumn;
	end if;

    return val.Value_ID;
  end if;
end if;

return GD::NULL_UNIQUE_ID();







































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4530,
	4529,
	'a1_obj_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4531,
	4529,
	'a2_name',
	322,
	0,
	'',
	4530,
	'');
INSERT INTO S_SPARM
	VALUES (4532,
	4529,
	'a3_rule_token',
	4438,
	0,
	'',
	4531,
	'');
INSERT INTO S_SPARM
	VALUES (4533,
	4529,
	'a4_classBased',
	316,
	0,
	'',
	4532,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4534);
INSERT INTO S_SYNC
	VALUES (4534,
	1,
	'is_valid_invocation',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'// ::is_valid_invocation()
if ( param.a2_isRval )
  if ( param.a1_type == "void" )
    select any val from instances of V_VAL where
                                               selected.Value_ID == param.a3_id;
    if ( not_empty val )
      val.dispose();
    end if;
    ERR::reportParseError( msg: param.a4_name +
          "<- has no return type (return type is void) and " +
                                  "thus cannot be used in an expression",  
                                                   token: param.a5_rule_token );
  end if;
else
  if ( param.a1_type != "void" )
    select any val from instances of V_VAL where
                                               selected.Value_ID == param.a3_id;
    if ( not_empty val )
      val.dispose();
    end if;
    ERR::reportParseError( msg: param.a4_name +
          "<- has a return value which is not being assigned to a variable",
          token: param.a5_rule_token );
  end if;
end if;
return param.a3_id;



































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4535,
	4534,
	'a1_type',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4536,
	4534,
	'a2_isRval',
	316,
	0,
	'',
	4535,
	'');
INSERT INTO S_SPARM
	VALUES (4537,
	4534,
	'a3_id',
	296,
	0,
	'',
	4536,
	'');
INSERT INTO S_SPARM
	VALUES (4538,
	4534,
	'a4_name',
	322,
	0,
	'',
	4537,
	'');
INSERT INTO S_SPARM
	VALUES (4539,
	4534,
	'a5_rule_token',
	4438,
	0,
	'',
	4538,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4540);
INSERT INTO S_SYNC
	VALUES (4540,
	1,
	'statement_create',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'current_scope = ::get_current_scope();
select any blk from instances of ACT_BLK where (selected.Block_ID == current_scope);
if ( not_empty blk )
  create object instance stmt of ACT_SMT;
  relate blk to stmt across R602;

  return stmt.Statement_ID;
end if;
return GD::NULL_UNIQUE_ID();






',
	296,
	1,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4541);
INSERT INTO S_SYNC
	VALUES (4541,
	1,
	'is_readonly_value',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'select any val from instances of V_VAL where selected.Value_ID == param.val_id;

// there are fewer read-write value types
select one tvl related by val->V_TVL[R801];
if ( not_empty tvl )
  return false;
end if;

select one avl related by val->V_AVL[R801];
if ( not_empty avl )
  return false;
end if;

select one irf related by val->V_IRF[R801];
if ( not_empty irf )
  return false;
end if;

select one isr related by val->V_ISR[R801];
if ( not_empty isr )
  return false;
end if;

select one pvl related by val->V_PVL[R801];
if ( not_empty pvl )
  select one bparm related by pvl->S_BPARM[R831];
  if ( not_empty bparm )
    return bparm.By_Ref == 0;
  end if;
  select one sparm related by pvl->S_SPARM[R832];
  if ( not_empty sparm )
    return sparm.By_Ref == 0;
  end if;
  select one tparm related by pvl->O_TPARM[R833];
  if ( not_empty tparm )
    return tparm.By_Ref == 0;
  end if;
end if;


return true;

',
	316,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4542,
	4541,
	'val_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4543);
INSERT INTO S_SYNC
	VALUES (4543,
	1,
	'search_supertypes_for_event',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'select any sub_sm from instances of SM_SM where selected.SM_ID == param.a1_subtype_sm;
if not_empty sub_sm
  select one obj related by sub_sm->SM_ISM[R517]->O_OBJ[R518];
  select many oir_set related by obj->R_OIR[R201];
  event_no_splat = OS::remove_star( s: param.a2_evt_name );
  for each oir in oir_set
    select one sub related by oir->R_RGO[R203]->R_SUB[R205];
    if not_empty sub
      // it''s a subtype in this association
      select one sup_obj related by sub->R_SUBSUP[R213]->
          R_SUPER[R212]->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201];
      if not_empty sup_obj
        select one sup_sm related by sup_obj->SM_ISM[R518]->SM_SM[R517];
        if not_empty sup_sm
          select any evt related by sup_sm->SM_EVT[R502] 
              where selected.Drv_Lbl == event_no_splat;
          if not_empty evt
            return sup_sm.SM_ID;
          else
            sm_id = ::search_supertypes_for_event( 
               a1_subtype_sm: sup_sm.SM_ID, a2_evt_name: event_no_splat);
            if ( sm_id != GD::NULL_UNIQUE_ID() )
              return sm_id;
            end if;
          end if;
        end if;
      end if;  // not_empty sup_obj
    end if;  // not_empty sub
  end for;
end if;

return GD::NULL_UNIQUE_ID();




















',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4544,
	4543,
	'a1_subtype_sm',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4545,
	4543,
	'a2_evt_name',
	322,
	0,
	'',
	4544,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4546);
INSERT INTO S_SYNC
	VALUES (4546,
	1,
	'process_class_event',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'select any stmt from instances of ACT_SMT 
    where selected.Statement_ID == param.a1_stmt_id;
select one ess related by stmt->E_ESS[R603];
select one ges related by ess->E_GES[R701];

  select any sm from instances of SM_ASM 
      where selected.Obj_ID == param.a2_obj_id;
  select one evt related by ges->E_GSME[R703]->SM_EVT[R707];
  if ( empty sm )
    stmt.dispose();
    select any obj from instances of O_OBJ 
        where selected.Obj_ID == param.a2_obj_id;
    ERR::reportParseError( msg: 
        "Cannot find Class State Machine for class ->"+
        obj.Name+"<-",   token: param.a3_rule_token );
  elif ( empty evt )
    select one eeevt related by ges->E_GEE[R703]->S_EEEVT[R709];
    stmt.dispose();
    select one obj related by sm->O_OBJ[R519];
    ERR::reportParseError( msg: "Event ->"+eeevt.Drv_Lbl+
        "<- does not exist for class state machine of class ->"+obj.Name+"<-",
            token: param.a3_rule_token );
  else
    select one evt_sm related by evt->SM_SM[R502];
    if ( evt_sm.SM_ID != sm.SM_ID )
      stmt.dispose();
      select one obj related by sm->O_OBJ[R519];
      ERR::reportParseError( msg: "Event ->"+evt.Drv_Lbl+
          "<- does not exist for class state machine of class ->"+obj.Name+"<-",
              token: param.a3_rule_token );
    else
      if ( ess.PEIndicated )
        // non-polymorphic event with *
        stmt.dispose();
        ERR::reportParseError( msg: "Event is not a polymorphic event. Event label must not contain ''*''",
               token: param.a3_rule_token );
      else
        edi_ok = ::is_valid_sm_event_data( a1_stmt_id: param.a1_stmt_id, a2_sm_id: evt_sm.SM_ID,
            a3_smevt_id: evt.SMevt_ID, a4_rule_token: param.a3_rule_token );
        if ( edi_ok )   
          select one gsme related by ges->E_GSME[R703];
          create object instance gar of E_GAR;
          relate gar to gsme across R705;
          return stmt.Statement_ID;
        end if;
      end if;
    end if;
  end if;
return GD::NULL_UNIQUE_ID();
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4547,
	4546,
	'a1_stmt_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4548,
	4546,
	'a2_obj_id',
	296,
	0,
	'',
	4547,
	'');
INSERT INTO S_SPARM
	VALUES (4549,
	4546,
	'a3_rule_token',
	4438,
	0,
	'',
	4548,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4550);
INSERT INTO S_SYNC
	VALUES (4550,
	1,
	'process_creation_event',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'select any stmt from instances of ACT_SMT 
    where selected.Statement_ID == param.a1_stmt_id;
select one ess related by stmt->E_ESS[R603];
select one ges related by ess->E_GES[R701];

  select any sm from instances of SM_ISM 
      where selected.Obj_ID == param.a2_obj_id;
  select one evt related by ges->E_GSME[R703]->SM_EVT[R707];
  if ( empty evt )
    select one eeevt related by ges->E_GEE[R703]->S_EEEVT[R709];
    stmt.dispose();
    select one obj related by sm->O_OBJ[R518];
    ERR::reportParseError( msg: "Event ->"+eeevt.Drv_Lbl+
          "<- does not exist for class ->"+obj.Name+"<-",
            token: param.a3_rule_token );
  else
    select one evt_sm related by evt->SM_SM[R502];
    if ( evt_sm.SM_ID != sm.SM_ID )
      stmt.dispose();
      select one obj related by sm->O_OBJ[R518];
      ERR::reportParseError( msg: "Event ->"+evt.Drv_Lbl+
              "<- is not a creation transition for class ->"+obj.Name+"<-",
              token: param.a3_rule_token );
    else
      select one levt related by evt->SM_SEVT[R525]->SM_LEVT[R526];
      if ( empty levt )
        stmt.dispose();
        select one obj related by sm->O_OBJ[R518];
        ERR::reportParseError( msg: "Event ->"+evt.Drv_Lbl+ 
              "<- is not a creation transition for class ->"+obj.Name+"<-",
                token: param.a3_rule_token );
      else
        select one crtxn related by levt->SM_CRTXN[R509];
        if ( empty crtxn )
          stmt.dispose();
          select one obj related by sm->O_OBJ[R518];
          ERR::reportParseError( msg: "Event ->"+evt.Drv_Lbl+ 
                "<- is not a creation transition for class ->"+obj.Name+"<-",
                  token: param.a3_rule_token );
        else
          if ( ess.PEIndicated )
            // non-polymorphic event with *
            stmt.dispose();
            ERR::reportParseError( msg: "Event is not a polymorphic event. Event label must not contain ''*''",
               token: param.a3_rule_token );
          else
            edi_ok = ::is_valid_sm_event_data( a1_stmt_id: param.a1_stmt_id, a2_sm_id: evt_sm.SM_ID,
                a3_smevt_id: evt.SMevt_ID, a4_rule_token: param.a3_rule_token );
            if ( edi_ok )   
              select one gsme related by ges->E_GSME[R703];
              create object instance gec of E_GEC;
              relate gec to gsme across R705;
              return stmt.Statement_ID;
            end if;  // edi_ok
          end if;  // ess.PEIndicated
        end if;  // empty crtxn
      end if;  // empty levt
    end if;  // evt_sm.SM_ID != sm.SM_ID
  end if; // empty evt
return GD::NULL_UNIQUE_ID();


















',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4551,
	4550,
	'a1_stmt_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4552,
	4550,
	'a2_obj_id',
	296,
	0,
	'',
	4551,
	'');
INSERT INTO S_SPARM
	VALUES (4553,
	4550,
	'a3_rule_token',
	4438,
	0,
	'',
	4552,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4554);
INSERT INTO S_SYNC
	VALUES (4554,
	1,
	'process_instance_event',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'select any stmt from instances of ACT_SMT 
    where selected.Statement_ID == param.a1_stmt_id;
select one ess related by stmt->E_ESS[R603];
select one ges related by ess->E_GES[R701];

select any var from instances of V_VAR where ( selected.Var_ID == param.a2_var_id );
select one obj related by var->V_INT[R814]->O_OBJ[R818];
select one ism related by obj->SM_ISM[R518];
select one evt related by ges->E_GSME[R703]->SM_EVT[R707];
if ( empty ism )
  stmt.dispose();
  ERR::reportParseError( msg: 
    "Cannot find Instance State Machine for class ->"+
      obj.Name+"<-",   token: param.a3_rule_token );
elif ( empty evt )
  select one eeevt related by ges->E_GEE[R703]->S_EEEVT[R709];
  stmt.dispose();
  select one obj related by ism->O_OBJ[R518];
  ERR::reportParseError( msg: "Cannot find event ->"+ eeevt.Drv_Lbl +
          "<- for class ->"+obj.Name+"<-",   token: param.a3_rule_token );
else
  select one evt_sm related by evt->SM_SM[R502];
  if ( evt_sm.SM_ID != ism.SM_ID )
    sm_id = ::search_supertypes_for_event( 
         a1_subtype_sm: ism.SM_ID, a2_evt_name: evt.Drv_Lbl );
    if ( sm_id == GD::NULL_UNIQUE_ID() )
      stmt.dispose();
      select one obj related by ism->O_OBJ[R518];
      ERR::reportParseError( msg: "Cannot find event ->"+ evt.Drv_Lbl +
               "<- for class ->"+obj.Name+"<-",   token: param.a3_rule_token );
    else
      if ( not ess.PEIndicated )
        // polymorphic event without * -- not a problem re-render will add
      end if;
      
      select one polyEvent related by evt->SM_PEVT[R525]; 
      if ( empty polyEvent)
      	ERR::reportParseError( msg: "Supertype event ->" + evt.Drv_Lbl + "<- is not polymorphic",
      					token: param.a3_rule_token);
      end if;
      
      select any sm from instances of SM_SM where selected.SM_ID == sm_id;
      select one ism related by sm->SM_ISM[R517];
    end if;
  else
    if ( ess.PEIndicated )
      // determine if event is polymorphic
      select one pevt related by evt->SM_PEVT[R525];
      if ( empty pevt )
        // non-polymorphic event with *
        stmt.dispose();
        ERR::reportParseError( msg: "Event is not a polymorphic event. Event label must not contain ''*''",
             token: param.a3_rule_token );
      end if;
    end if;
  end if;
end if;

edi_ok = ::is_valid_sm_event_data( a1_stmt_id: param.a1_stmt_id, a2_sm_id: ism.SM_ID,
        a3_smevt_id: evt.SMevt_ID, a4_rule_token: param.a3_rule_token );

if ( edi_ok )   
  select one gsme related by ges->E_GSME[R703];
  create object instance gen of E_GEN;
  relate gsme to gen across R705;
  relate gen to var across R712;
  return stmt.Statement_ID;
end if;
return GD::NULL_UNIQUE_ID();




















',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4555,
	4554,
	'a1_stmt_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4556,
	4554,
	'a2_var_id',
	296,
	0,
	'',
	4555,
	'');
INSERT INTO S_SPARM
	VALUES (4557,
	4554,
	'a3_rule_token',
	4438,
	0,
	'',
	4556,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4558);
INSERT INTO S_SYNC
	VALUES (4558,
	1,
	'process_ee_event',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'select any stmt from instances of ACT_SMT 
    where selected.Statement_ID == param.a1_stmt_id;
select one ess related by stmt->E_ESS[R603];
select one ges related by ess->E_GES[R701];

    select any ee from instances of S_EE 
         where ( selected.EE_ID == param.a2_ee_id );
    select one eeevt related by ges->E_GEE[R703]->S_EEEVT[R709];
    if ( empty eeevt )
      select one evt related by ges->E_GSME[R703]->SM_EVT[R707];
      stmt.dispose();
      ERR::reportParseError( msg: "Cannot find event for event label ->"+evt.Drv_Lbl+
            "<- for external entity ->"+ee.Name+"<-",
                token: param.a3_rule_token );
    else
      if ( eeevt.EE_ID != ee.EE_ID )
        stmt.dispose();
        ERR::reportParseError( msg: "Cannot find event for event label ->"+eeevt.Drv_Lbl+
              "<- for external entity ->"+ee.Name+"<-",
                  token: param.a3_rule_token );
      else
        if ( ess.PEIndicated )
          // non-polymorphic event with *
          stmt.dispose();
          ERR::reportParseError( msg: "Event is not a polymorphic event. Event label must not contain ''*''",
               token: param.a3_rule_token );
       else
         edi_ok = ::is_valid_ee_event_data( a1_stmt_id: param.a1_stmt_id, a2_ee_id: ee.EE_ID,
              a3_evt_id: eeevt.EEevt_ID, a4_rule_token: param.a3_rule_token );
          if ( edi_ok )
           return stmt.Statement_ID;
         end if;
       end if;
      end if;
    end if;
return GD::NULL_UNIQUE_ID();


















',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4559,
	4558,
	'a1_stmt_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4560,
	4558,
	'a2_ee_id',
	296,
	0,
	'',
	4559,
	'');
INSERT INTO S_SPARM
	VALUES (4561,
	4558,
	'a3_rule_token',
	4438,
	0,
	'',
	4560,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4562);
INSERT INTO S_SYNC
	VALUES (4562,
	1,
	'is_valid_sm_event_data',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'select any ess from instances of E_ESS where
                                      selected.Statement_ID == param.a1_stmt_id;
if not ess.ParmListOK
  select one stmt related by ess->ACT_SMT[R603];
  stmt.dispose();
  return false;
end if;
select many parm_set related by ess->V_PAR[R700];
select any sm from instances of SM_SM where selected.SM_ID == param.a2_sm_id;
select any evt related by sm->SM_EVT[R502] where
                                         selected.SMevt_ID == param.a3_smevt_id;
select many edi_set related by evt->SM_EVTDI[R532];
for each edi in edi_set
  select many dups related by evt->SM_EVTDI[R532] where
                                                      selected.Name == edi.Name;
  if ( cardinality dups > 1 )
    select one stmt related by ess->ACT_SMT[R603];
    stmt.dispose();
    ERR::reportParseError( msg: "More than one parameter with name ->" +
                                   edi.Name +"<-", token: param.a4_rule_token );
  end if;
end for;
if cardinality parm_set <= cardinality edi_set
  for each edi in edi_set
    found = false;
    for each parm in parm_set
      if ( parm.Name == edi.Name )
        found = true;
        err_msg = "";
        select one parm_val related by parm->V_VAL[R800];
        select one parm_dt related by parm_val->S_DT[R820];
        if (empty parm_dt)
          err_msg = "Parameter ->"+ parm.Name +"<- value has an unknown data type.";
        elif ( ::data_types_compatible( dt1: edi.DT_ID, dt2: parm_dt.DT_ID,
                                        op: "assign")  == GD::NULL_UNIQUE_ID() )
          err_msg = "Parameter ->"+ parm.Name + "<- has been assigned value of different type";
        end if;
        if (edi.getDimensionsCnt()!= parm_val.getDimensions())
          err_msg = "Parameter ->" + edi.Name + "<- has incompatible array depth.";
        elif ( not parm_val.isElementCountValid() )
          err_msg = "Parameter ->"+ edi.Name +"<- contains an Array Index Out of Bounds.";
        end if;
        if (err_msg == "")
          break;
        else 
          select one stmt related by ess->ACT_SMT[R603];
          stmt.dispose();        
          ERR::reportParseError( msg: err_msg, token: param.a4_rule_token  );
        end if;
      end if;
    end for;
    if ( not found )
      select one stmt related by ess->ACT_SMT[R603];
      stmt.dispose();
      ERR::reportParseError( msg: "State machine event with label ->" +
                  evt.Drv_Lbl + "<- is missing corresponding parameter ->" +
                                  edi.Name + "<-", token: param.a4_rule_token );
    end if;
  end for;

  // If execution gets here, all the data items from the database
  // were found in the parse data items.

else // cardinality parm_set > cardinality edi_set

  // If there are more data items in the parse then were found in the
  // database, that means there were redundant or extra data items in the
  // parameter list found by the parse.  Generate an error.

  for each parm in parm_set
    found = false;
    for each edi in edi_set
      if ( parm.Name == edi.Name )
        found = true;
        break;
      end if;
    end for;
    if ( not found )
      select one stmt related by ess->ACT_SMT[R603];
      stmt.dispose();
      ERR::reportParseError( msg: "Parameter ->"+ parm.Name +
            "<- is not associated with state machine event with label ->" +
                               evt.Drv_Lbl + "<-", token: param.a4_rule_token );
    end if;
  end for;

  // If it gets out of the loop without error, there must be
  // a redundant data item, so report the error
  select one stmt related by ess->ACT_SMT[R603];
  stmt.dispose();
  ERR::reportParseError( msg: "State machine event with label ->" +
                               evt.Drv_Lbl+ "<- has redundant parameters",
                                                   token: param.a4_rule_token );
  return false;
end if;
return true;',
	316,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4563,
	4562,
	'a1_stmt_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4564,
	4562,
	'a2_sm_id',
	296,
	0,
	'',
	4563,
	'');
INSERT INTO S_SPARM
	VALUES (4565,
	4562,
	'a3_smevt_id',
	296,
	0,
	'',
	4564,
	'');
INSERT INTO S_SPARM
	VALUES (4566,
	4562,
	'a4_rule_token',
	4438,
	0,
	'',
	4565,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4567);
INSERT INTO S_SYNC
	VALUES (4567,
	1,
	'is_valid_ee_event_data',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'select any ess from instances of E_ESS where selected.Statement_ID == param.a1_stmt_id;
if not ess.ParmListOK
  select one stmt related by ess->ACT_SMT[R603];
  stmt.dispose();
  return false;
end if;

select many parm_set related by ess->V_PAR[R700];

select any ee from instances of S_EE where selected.EE_ID == param.a2_ee_id;
select any evt related by ee->S_EEEVT[R10] where selected.EEevt_ID == param.a3_evt_id;
select many edi_set related by evt->S_EEEDT[R13]->S_EEEDI[R13];

// first check that there are no duplicated data items
for each edi in edi_set
  select many dups related by ee->S_EEEDI[R12] where selected.Name == edi.Name;
  if ( cardinality dups > 1 )
    select one stmt related by ess->ACT_SMT[R603];
    stmt.dispose();
    ERR::reportParseError( msg: "More than one parameter with name ->"+ edi.Name +
             "<- You will need to eventually run the audit and/or clear this up",
              token: param.a4_rule_token );
  end if;
end for;

if ( cardinality parm_set < cardinality edi_set )
  select one stmt related by ess->ACT_SMT[R603];
  stmt.dispose();
  ERR::reportParseError( msg: "External entity event with label ->"+evt.Drv_Lbl+
      "<- is missing some parameters",
          token: param.a4_rule_token );
else
  for each edi in edi_set
    found = false;
    for each parm in parm_set
      if ( parm.Name == edi.Name )
        found = true;
        select one parm_dt related by parm->V_VAL[R800]->S_DT[R820];
        if (empty parm_dt)
          err_msg = "Parameter ->"+ parm.Name +"<- value has an unknown data type.";
        elif ( ::data_types_compatible( dt1: edi.DT_ID, dt2: parm_dt.DT_ID, op: "assign")  == GD::NULL_UNIQUE_ID() )
          select one stmt related by ess->ACT_SMT[R603];
          stmt.dispose();
          ERR::reportParseError( msg: "Parameter ->"+ parm.Name +
             "<- has been assigned value of different type",
              token: param.a4_rule_token );
        end if;
        break;
      end if;
    end for;
    if ( not found )
      select one stmt related by ess->ACT_SMT[R603];
      stmt.dispose();
      ERR::reportParseError( msg: "External entity event with label ->"+evt.Drv_Lbl+
          "<- is missing corresponding parameter(s)",
             token: param.a4_rule_token );
      break;
    end if;
  end for;
end if;

      // If execution gets here, all the data items from the database
      // were found in the parse data items.

      // If there are more data items in the parse then were found in the
      // database, that means there were redundant or extra data items in the
      // parameter list found by the parse.  Generate an error.

  if ( cardinality parm_set > cardinality edi_set )
    for each parm in parm_set
      found = false;
      for each edi in edi_set
        if ( parm.Name == edi.Name )
          found = true;
          break;
        end if;
      end for;
      if ( not found )
        select one stmt related by ess->ACT_SMT[R603];
        stmt.dispose();
        ERR::reportParseError( msg: "Parameter ->"+ parm.Name +
          "<- is not associated with external entity event with label ->"+evt.Drv_Lbl+"<-",
             token: param.a4_rule_token );
      end if;
    end for;

      // If it gets out of the loop without error, there must be
      // a redundant data item, so report the error
    select one stmt related by ess->ACT_SMT[R603];
    stmt.dispose();
    ERR::reportParseError( msg: "External entity event with label ->"+evt.Drv_Lbl+
      "<- has redundant parameters",
          token: param.a4_rule_token );
    return false;
  end if;

return true;

















',
	316,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4568,
	4567,
	'a1_stmt_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4569,
	4567,
	'a2_ee_id',
	296,
	0,
	'',
	4568,
	'');
INSERT INTO S_SPARM
	VALUES (4570,
	4567,
	'a3_evt_id',
	296,
	0,
	'',
	4569,
	'');
INSERT INTO S_SPARM
	VALUES (4571,
	4567,
	'a4_rule_token',
	4438,
	0,
	'',
	4570,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4572);
INSERT INTO S_SYNC
	VALUES (4572,
	1,
	'clear_assignment_data',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'select any stmt from instances of ACT_SMT 
     where ( selected.Statement_ID == param.stmt_id );
if ( not_empty stmt )
  stmt.dispose();
end if;

if (  param.var_id != GD::NULL_UNIQUE_ID() )
  select any var from instances of V_VAR where selected.Var_ID == param.var_id;
  if ( not_empty var )
    if ( not var.Declared )
      var.dispose();
    end if;
  end if;
end if;

',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4573,
	4572,
	'stmt_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4574,
	4572,
	'var_id',
	296,
	0,
	'',
	4573,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4575);
INSERT INTO S_SYNC
	VALUES (4575,
	1,
	'self_validate',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'if ( param.a1_text == "SELF" or param.a1_text == "Self" or param.a1_text == "self" )
  current_scope = ::get_current_scope();
  select any blk from instances of ACT_BLK where (selected.Block_ID == current_scope);
  select one act related by blk->ACT_ACT[R612];
  if ( not act.self_is_valid() )
    err_msg =  "Keyword ->%s<- cannot be used in " + act.Type +
                                                          " AL specifications.";
    ::clear_value_data();
    ERR::reportParseError( msg: err_msg,
        token: param.a3_token );
  else
    if ( param.a2_isLval )
      ::clear_value_data();
      ERR::reportParseError( msg: "Cannot assign a value to ->%s<-.",
                                                        token: param.a3_token );
    else
      var_id = ::get_var_in_scope( name: param.a1_text, rule_token: param.a3_token );
      if ( var_id == GD::NULL_UNIQUE_ID() )
        select one outer_blk related by act->ACT_BLK[R650];
        create object instance slf of V_INT;
        create object instance var_inst of V_VAR;
        relate var_inst to slf across R814;
        var_inst.Name = param.a1_text;
        relate var_inst to outer_blk across R823;
        select one op related by act->ACT_OPB[R698] ->O_TFR[R696];
        if ( not_empty op )
          select one obj related by op->O_OBJ[R115];
          relate obj to slf across R818;
          ::connect_inst_ref_var_to_datatype(p1_is_set:false, p2_var_id:var_inst.Var_ID, p3_obj_id:obj.Obj_ID);
        else
          select one sm_act related by act->ACT_SAB[R698]->SM_ACT[R691];
          if ( not_empty sm_act )
            // State action case
            select one obj related by sm_act->SM_SM[R515]->SM_ISM[R517]->O_OBJ[R518];
            if not_empty obj
              relate obj to slf across R818;
              ::connect_inst_ref_var_to_datatype(p1_is_set:false, p2_var_id:var_inst.Var_ID, p3_obj_id:obj.Obj_ID);
            end if;
          else
            select one sm_act related by act->ACT_TAB[R698]->SM_ACT[R688];
            if ( not_empty sm_act )
              // Transition action case
              select one obj related by sm_act->SM_SM[R515]->SM_ISM[R517]->O_OBJ[R518];
              if not_empty obj
                relate obj to slf across R818;
                ::connect_inst_ref_var_to_datatype(p1_is_set:false, p2_var_id:var_inst.Var_ID, p3_obj_id:obj.Obj_ID);
              end if;
            else
              select one dab related by act->ACT_DAB[R698]->O_DBATTR[R693];
              select one obj related by dab->O_BATTR[R107]->O_ATTR[R106]->O_OBJ[R102];
              relate obj to slf across R818;
              ::connect_inst_ref_var_to_datatype(p1_is_set:false, p2_var_id:var_inst.Var_ID, p3_obj_id:obj.Obj_ID);
            end if;
          end if;
        end if;
        var_inst.Declared = true;
      end if;  // var_id == GD::NULL_UNIQUE_ID
   end if;  // param.isLval
  end if;  // not act.SelfIsValid
end if;  // if param.text == "SELF" ...',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4576,
	4575,
	'a1_text',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4577,
	4575,
	'a2_isLval',
	316,
	0,
	'',
	4576,
	'');
INSERT INTO S_SPARM
	VALUES (4578,
	4575,
	'a3_token',
	4438,
	0,
	'',
	4577,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4579);
INSERT INTO S_SYNC
	VALUES (4579,
	1,
	'get_current_context',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE

Translate: native
',
	'return m_act_id;






',
	296,
	0,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4580);
INSERT INTO S_SYNC
	VALUES (4580,
	1,
	'set_current_context',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE

Translate: native
',
	'm_act_id = p_Context;






',
	19,
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4581,
	4580,
	'context',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4582);
INSERT INTO S_SYNC
	VALUES (4582,
	1,
	'getLineNumber',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE

Translate: native
',
	'if ( p_Rule_token != null )
  return p_Rule_token.getLine();
else
  return -1;

',
	298,
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4583,
	4582,
	'rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4584);
INSERT INTO S_SYNC
	VALUES (4584,
	1,
	'getColumn',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE

Translate: native
',
	'if ( p_Rule_token != null )
  return p_Rule_token.getColumn();
else
  return -1;

',
	298,
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4585,
	4584,
	'rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4586);
INSERT INTO S_SYNC
	VALUES (4586,
	1,
	'rememberLocation',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'current_scope = ::get_current_scope();
select any blk from instances of ACT_BLK where (selected.Block_ID == current_scope);
blk.CurrentLine = ::getLineNumber(rule_token: param.rule_token);
blk.CurrentCol = ::getColumn(rule_token: param.rule_token);

',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4587,
	4586,
	'rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4588);
INSERT INTO S_SYNC
	VALUES (4588,
	1,
	'ifStatementRemember',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'select any root_blk from instances of ACT_BLK 
   where selected.Block_ID == param.blk_id;
select any stmt from instances of ACT_SMT 
   where selected.Statement_ID == param.stmt_id;
stmt.LineNumber = root_blk.CurrentLine;
stmt.StartPosition = root_blk.CurrentCol;

',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4589,
	4588,
	'blk_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4590,
	4588,
	'stmt_id',
	296,
	0,
	'',
	4589,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4591);
INSERT INTO S_SYNC
	VALUES (4591,
	1,
	'field_create',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE',
	'// ::field_create()
select any attr from instances of O_ATTR where
                                selected.Attr_ID == param.new_attr_or_member_id;
select any member from instances of S_MBR where
                              selected.Member_ID == param.new_attr_or_member_id;
select any newVal from instances of V_VAL where
                                      selected.Block_ID == GD::NULL_UNIQUE_ID();
select many newVals from instances of V_VAL where
                                      selected.Block_ID == GD::NULL_UNIQUE_ID();
// we want the one with no subtype . . . .
valueFound = false;
for each candidateVal in newVals
  if (not candidateVal.hasSubtype())
    // Leave newVal referring to the instance that had no subtypes
    newVal = candidateVal;
    valueFound = true;
    break;
  end if;
end for;
if (valueFound == false)
  create object instance newVal of V_VAL;
end if;
if (not_empty attr)
  // There should be an Instance Reference Instance previously created.
  // Find it via the original variable found using the passed inst_id.
  select any var from instances of V_VAR where selected.Var_ID ==
                                               param.prev_var_attr_or_member_id;
  if (empty var)
    // TODO report internal error
  else
    select any prevVal related by var->V_IRF[R808]->V_VAL[R801] where
                                      selected.Block_ID == GD::NULL_UNIQUE_ID();
    if (empty prevVal)
      // TODO report internal error
    else
      create object instance attrRef of V_AVL;
      relate attrRef to newVal across R801;
      relate attrRef to attr across R806;
      select one newDt related by attr->S_DT[R114];
      relate newVal to newDt across R820;
      relate attrRef to prevVal across R807;
    end if;
  end if;
elif (not_empty member)
  // There should be either a Variable, Attribute Reference or a Member
  // Reference previously created. Find it via the original Attribute of
  // Member reference passed in the inst id.
  select any var from instances of V_VAR where selected.Var_ID ==
                                               param.prev_var_attr_or_member_id;
  select any prevAttr from instances of O_ATTR where selected.Attr_ID ==
                                               param.prev_var_attr_or_member_id;
  select any prevMember from instances of S_MBR where selected.Member_ID ==
                                               param.prev_var_attr_or_member_id;
  select any prevParmVal from instances of V_PVL where selected.Value_ID ==
                                               param.prev_var_attr_or_member_id;
  select any prevEvtVal from instances of V_EDV where selected.Value_ID ==
                                               param.prev_var_attr_or_member_id;
  if (empty prevAttr and empty prevMember and
                           empty var and empty prevParmVal and empty prevEvtVal)
    // TODO report internal error
  else
    select any prevVal related by prevAttr->V_AVL[R806]->V_VAL[R801] where
                                      selected.Block_ID == GD::NULL_UNIQUE_ID();
    if (not_empty prevMember)
      select any prevVal related by prevMember->V_MVL[R836]->V_VAL[R801] where
                                      selected.Block_ID == GD::NULL_UNIQUE_ID();
    elif (not_empty var)
      select any prevVal related by var->V_TVL[R805]->V_VAL[R801] where
                                      selected.Block_ID == GD::NULL_UNIQUE_ID();
    elif (not_empty prevParmVal)
      select one prevVal related by prevParmVal->V_VAL[R801];
    else // not_empty prevEvtVal
      select one prevVal related by prevEvtVal->V_VAL[R801];
    end if;
    create object instance memberRef of V_MVL;
    relate memberRef to newVal across R801;
    relate memberRef to member across R836;
    relate memberRef to prevVal across R837;
    select one dt related by member->S_DT[R45];
    relate newVal to dt across R820;
  end if;
end if;
newVal.LineNumber = ::getLineNumber(rule_token:param.token);
newVal.StartPosition = ::getColumn(rule_token:param.token);
newVal.setEndPosition();
return newVal.Value_ID;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4592,
	4591,
	'new_attr_or_member_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4593,
	4591,
	'prev_var_attr_or_member_id',
	296,
	0,
	'',
	4592,
	'');
INSERT INTO S_SPARM
	VALUES (4594,
	4591,
	'token',
	4438,
	0,
	'',
	4593,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4595);
INSERT INTO S_SYNC
	VALUES (4595,
	1,
	'handle_selected',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE',
	'select any val_inst from instances of V_VAL where
                                            selected.Value_ID == param.value_id;
if ( empty val_inst )
  ERR::reportParseError(msg:"R-value not found", token: param.token );
else
  select one attr_val related by val_inst->V_AVL[R807];
  if ( not_empty attr_val )
    select one instRef related by val_inst->V_IRF[R801];
    select one var related by instRef->V_VAR[R808];
    if (not_empty var)
      if (::selected_validate(name:var.Name, rule_token:param.token))
        // migrate to Selected Reference
        select one attr_inst related by attr_val->O_ATTR[R806];
        current_scope = ::get_current_scope();
        select any blk from instances of ACT_BLK where
                                             selected.Block_ID == current_scope;
        if ( not_empty blk )
          blk.SelectedFound = true;
        end if;
        select one attrRefVal related by attr_val->V_VAL[R801];
        unrelate attr_val from attrRefVal across R801;
        create object instance slr of V_SLR;
        relate slr to attrRefVal across R801;
        relate slr to attr_inst across R812;
        attr_val.dispose();
        // Now that we migrated to a selected reference, we no longer
        // need the instance reference at the start of the chain . . . 
        val_inst.dispose();
      end if;
    end if;
  end if;
end if;
',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4596,
	4595,
	'token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4597,
	4595,
	'value_id',
	296,
	0,
	'',
	4596,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4598);
INSERT INTO S_SYNC
	VALUES (4598,
	1,
	'param_validate',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE',
	'// ::param_validate()
current_scope = ::get_current_scope();
select any blk from instances of ACT_BLK where
                                             selected.Block_ID == current_scope;
select one act related by blk->ACT_ACT[R612];
select any val from instances of V_VAL where
                                         selected.Value_ID == param.b1_value_id;

select one state_action related by act->ACT_SAB[R698]->SM_ACT[R691];
// If in a state action context or a transition action context, validation was
// done previously in event_root_valude_validate, so here only return Val_ID
if not_empty state_action
  return val.Value_ID;
else
  select one trans_action related by act->ACT_TAB[R698]->SM_ACT[R688];
  if not_empty trans_action
    return val.Value_ID;
  else
    select one sync related by act->ACT_FNB[R698]->S_SYNC[R695];
    if not_empty sync
      select any parm related by sync->S_SPARM[R24] where
                                                 selected.Name == param.a3_text;
      if empty parm
        ::clear_value_data();
        ERR::reportParseError( msg: "Parameter ->%s<- is not associated with function ->"+
       sync.Name+"<-",   token: param.a1_rule_token );
      else
        select any pvl from instances of V_PVL where
                                         selected.Value_ID == param.b1_value_id;
        if not_empty pvl
          // pvl is empty when the parameter access is happening on a value chain
          // so we get here only when a basic param.param_name access is being used.
          relate pvl to parm across R832;
          select one pdt related by parm->S_DT[R26];
          relate val to pdt across R820;
          val.LineNumber = ::getLineNumber(rule_token: param.a1_rule_token);
          val.StartPosition = ::getColumn(rule_token: param.a1_rule_token);
          val.setEndPosition();
        end if;
        return val.Value_ID;
      end if;
    else
      select one tfr related by act->ACT_OPB[R698]->O_TFR[R696];
      if not_empty tfr
        select any parm related by tfr->O_TPARM[R117] where
                                                 selected.Name == param.a3_text;
        if empty parm
          ::clear_value_data();
          ERR::reportParseError( msg: "Parameter ->%s<- is not associated with operation ->"+
                                  tfr.Name+"<-",   token: param.a1_rule_token );
        else
          select any pvl from instances of V_PVL where
                                         selected.Value_ID == param.b1_value_id;
          if not_empty pvl
            // pvl is empty when the parameter access is happening on a value
            // chain so we get here only when a basic param.param_name access
            // is being used.
            relate pvl to parm across R833;
            select one pdt related by parm->S_DT[R118];
            relate val to pdt across R820;
            val.LineNumber = ::getLineNumber(rule_token: param.a1_rule_token);
            val.StartPosition = ::getColumn(rule_token: param.a1_rule_token);
            val.setEndPosition();
          end if;
          return val.Value_ID;
        end if;
      else
        select one brg related by act->ACT_BRB[R698]->S_BRG[R697];
        if not_empty brg
          select any parm related by brg->S_BPARM[R21] where
                                                 selected.Name == param.a3_text;
          if empty parm
            ::clear_value_data();
            ERR::reportParseError( msg: "Parameter ->%s<- is not associated with bridge ->"+
                                  brg.Name+"<-",   token: param.a1_rule_token );
          else
            select any pvl from instances of V_PVL where
                                         selected.Value_ID == param.b1_value_id;
            if not_empty val
              if not_empty pvl
                // pvl is empty when the parameter access is happening on a
                // value chain so we get here only when a basic param.param_name
                // access is being used.
                relate pvl to parm across R831;
                select one pdt related by parm->S_DT[R22];
                relate val to pdt across R820;
                val.LineNumber = ::getLineNumber(rule_token:
                                                           param.a1_rule_token);
                val.StartPosition = ::getColumn(rule_token:
                                                           param.a1_rule_token);
                val.setEndPosition();
              end if;
              return val.Value_ID;
            end if;
          end if;
        else
          select one reqSig related by act->ACT_RSB[R698]->SPR_RS[R684];
          if not_empty reqSig
            select any parm related by reqSig->SPR_REP[R4502]->
                  C_EP[R4500]->C_PP[R4006] where selected.Name == param.a3_text;
            if empty parm
              ::clear_value_data();
              ERR::reportParseError( msg:
                     "Parameter ->%s<- is not associated with signal ->" +
                             reqSig.Name + "<-",   token: param.a1_rule_token );
            else
              select any pvl from instances of V_PVL where
                                         selected.Value_ID == param.b1_value_id;
              if not_empty val
                if not_empty pvl
                  // pvl is empty when the parameter access is happening
                  // on a value chain so we get here only when a basic
                  // param.param_name access is being used.
                  relate pvl to parm across R843;
                  select one pdt related by parm->S_DT[R4007];
                  relate val to pdt across R820;
                  val.LineNumber = ::getLineNumber(rule_token:
                                                           param.a1_rule_token);
                  val.StartPosition = ::getColumn(rule_token:
                                                           param.a1_rule_token);
                  val.setEndPosition();
                end if;
                return val.Value_ID;
              end if;
            end if;
          else
            select one reqOp related by act->ACT_ROB[R698]->SPR_RO[R685];
            if not_empty reqOp
              select any parm related by reqOp->SPR_REP[R4502]->
                  C_EP[R4500]->C_PP[R4006] where selected.Name == param.a3_text;
              if empty parm
                ::clear_value_data();
                ERR::reportParseError( msg:
              "Parameter ->%s<- is not associated with interface operation ->" +
                              reqOp.Name + "<-",   token: param.a1_rule_token );
              else
                select any pvl from instances of V_PVL where
                                         selected.Value_ID == param.b1_value_id;
                if not_empty val
                  if not_empty pvl
                    // pvl is empty when the parameter access is happening
                    // on a value chain so we get here only when a basic
                    // param.param_name access is being used.
                    relate pvl to parm across R843;
                    select one pdt related by parm->S_DT[R4007];
                    relate val to pdt across R820;
                    val.LineNumber = ::getLineNumber(rule_token:
                                                           param.a1_rule_token);
                    val.StartPosition = ::getColumn(rule_token:
                                                           param.a1_rule_token);
                    val.setEndPosition();
                  end if;
                  return val.Value_ID;
                end if;
              end if;
            else
              select one provSig related by act->ACT_PSB[R698]->SPR_PS[R686];
              if not_empty provSig
                select any parm related by provSig->SPR_PEP[R4503]->
                  C_EP[R4501]->C_PP[R4006] where selected.Name == param.a3_text;
                if empty parm
                  ::clear_value_data();
                  ERR::reportParseError( msg:
                     "Parameter ->%s<- is not associated with signal ->" +
                            provSig.Name + "<-",   token: param.a1_rule_token );
                else
                  select any pvl from instances of V_PVL where
                                         selected.Value_ID == param.b1_value_id;
                  if not_empty val
                    if not_empty pvl
                      // pvl is empty when the parameter access is happening
                      // on a value chain so we get here only when a basic
                      // param.param_name access is being used.
                      relate pvl to parm across R843;
                      select one pdt related by parm->S_DT[R4007];
                      relate val to pdt across R820;
                      val.LineNumber = ::getLineNumber(rule_token:
                                                           param.a1_rule_token);
                      val.StartPosition = ::getColumn(rule_token:
                                                           param.a1_rule_token);
                      val.setEndPosition();
                    end if;
                    return val.Value_ID;
                  end if;
                end if;
              else
                select one provOp related by act->ACT_POB[R698]->SPR_PO[R687];
                if not_empty provOp
                  select any parm related by provOp->SPR_PEP[R4503]->
                  C_EP[R4501]->C_PP[R4006] where selected.Name == param.a3_text;
                  if empty parm
                    ::clear_value_data();
                    ERR::reportParseError( msg:
              "Parameter ->%s<- is not associated with interface operation ->" +
                             provOp.Name + "<-",   token: param.a1_rule_token );
                  else
                    select any pvl from instances of V_PVL where
                                         selected.Value_ID == param.b1_value_id;
                    if not_empty val
                      if not_empty pvl
                        // pvl is empty when the parameter access is happening
                        // on a value chain so we get here only when a basic
                        // param.param_name access is being used.
                        relate pvl to parm across R843;
                        select one pdt related by parm->S_DT[R4007];
                        relate val to pdt across R820;
                        val.LineNumber = ::getLineNumber(rule_token:
                                                           param.a1_rule_token);
                        val.StartPosition = ::getColumn(rule_token:
                                                           param.a1_rule_token);
                        val.setEndPosition();
                      end if;
                      return val.Value_ID;
                    end if;
                  end if;
                end if;
              end if;
            end if;
          end if;
        end if;
      end if;
    end if;
  end if;
end if;
return GD::NULL_UNIQUE_ID();',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4599,
	4598,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4600,
	4598,
	'a3_text',
	322,
	0,
	'',
	4599,
	'');
INSERT INTO S_SPARM
	VALUES (4601,
	4598,
	'b1_value_id',
	296,
	0,
	'',
	4600,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4602);
INSERT INTO S_SYNC
	VALUES (4602,
	1,
	'assignment_create',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'// ::assignment_create()
create object instance ata of ACT_AI;
select any value from instances of V_VAL where
                                           selected.Value_ID == param.member_id;
relate ata to value across R689;
select any stmt from instances of ACT_SMT where
                                    selected.Statement_ID == param.statement_id;
if ( empty stmt )
  ERR::reportParseError( msg:  "Statement not found", token: param.token );
  return GD::NULL_UNIQUE_ID();
else
  relate ata to stmt across R603;
  // store the textual position of the attribute name
  ata.attributeLineNumber = ::getLineNumber(rule_token: param.token);
  ata.attributeColumn = ::getColumn(rule_token:param.token);
  return ata.Statement_ID;
end if;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4603,
	4602,
	'member_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4604,
	4602,
	'statement_id',
	296,
	0,
	'',
	4603,
	'');
INSERT INTO S_SPARM
	VALUES (4605,
	4602,
	'token',
	4438,
	0,
	'',
	4604,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4606);
INSERT INTO S_SYNC
	VALUES (4606,
	1,
	'clear_value_data',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE',
	'// ::clear_value_data()
select many vals from instances of V_VAL where
                                      selected.Block_ID == GD::NULL_UNIQUE_ID();
for each val in vals
  val.dispose();
end for;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4607);
INSERT INTO S_SYNC
	VALUES (4607,
	1,
	'getText',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE

Translate: native',
	'if ( p_Rule_token != null )
  return p_Rule_token.getText();
else
  return "";
',
	322,
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4608,
	4607,
	'rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4609);
INSERT INTO S_SYNC
	VALUES (4609,
	1,
	'get_value_chain_end',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE',
	'// ::get_value_chain_end()
select any val from instances of V_VAL where
                                      selected.Value_ID == param.start_value_ID;
atEnd = false;
while not atEnd
  select one attrVal related by val->V_AVL[R807];
  select one membrVal related by val->V_MVL[R837];
  select one arrayVal related by val->V_AER[R838];
  select one arrayLenVal related by val->V_ALV[R840];
  if (not_empty attrVal)
    select one val related by attrVal->V_VAL[R801];
  elif (not_empty membrVal)
    select one val related by membrVal->V_VAL[R801];
  elif (not_empty arrayLenVal)
    select one val related by arrayLenVal->V_VAL[R801];
  elif (not_empty arrayVal)
    select one dt related by val->S_DT[R820];
    select one val related by arrayVal->V_VAL[R801];
    relate val to dt across R820;
  else
   atEnd = true;
  end if;
end while; // Iteration complete
if not_empty val
  return val.Value_ID;
else
  return GD::NULL_UNIQUE_ID();
end if;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4610,
	4609,
	'start_value_ID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4611);
INSERT INTO S_SYNC
	VALUES (4611,
	1,
	'get_array_value_root',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE',
	'// ::get_array_value_root()
select any val from instances of V_VAL where
                                      selected.Value_ID == param.start_value_ID;
select one arrayRef related by val->V_AER[R801];
while not_empty arrayRef
  select one val related by arrayRef->V_VAL[R838];
  select one arrayRef related by val->V_AER[R801];
end while;
return val.Value_ID;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4612,
	4611,
	'start_value_ID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4613);
INSERT INTO S_SYNC
	VALUES (4613,
	1,
	'param_root_value_validate',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE',
	'// ::param_root_value_validate()
current_scope = ::get_current_scope();
select any blk from instances of ACT_BLK where
                                             selected.Block_ID == current_scope;
select one act related by blk->ACT_ACT[R612];
select any val from instances of V_VAL where
                                         selected.Value_ID == param.a3_value_id;
select one sync related by act->ACT_FNB[R698]->S_SYNC[R695];
if not_empty sync
  select any parm related by sync->S_SPARM[R24] where 
                                                 selected.Name == param.a1_name;
  select one irdt related by parm->S_DT[R26]->S_IRDT[R17];
  if empty parm
    ::clear_value_data();
    ::set_token(a1_token:param.a2_token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);
    ERR::reportParseError(msg:
                     "Parameter ->%s<- is not associated with function ->" +
                                 sync.Name + "<-", token: param.a2_token );
  elif val.isLValue and parm.By_Ref == 0 and
                                       ((empty irdt) or (param.a4_isRootAccess))
    ::clear_value_data();
    ::set_token(a1_token:param.a2_token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);
    ERR::reportParseError(msg: "Parameter ->%s<- is not passed by reference" +
                         " and is not assignable", token: param.a2_token );
  else
    select one dt related by parm->S_DT[R26];
    relate val to dt across R820;
    select one parmVal related by val->V_PVL[R801];
    relate parm to parmVal across R832;
    val.LineNumber = ::getLineNumber(rule_token: param.a2_token);
    val.StartPosition = ::getColumn(rule_token: param.a2_token);
    val.setEndPosition();
  end if;
else
  select one tfr related by act->ACT_OPB[R698]->O_TFR[R696];
  if not_empty tfr
    select any parm related by tfr->O_TPARM[R117] where
                                                 selected.Name == param.a1_name;
    select one irdt related by parm->S_DT[R118]->S_IRDT[R17];
    if empty parm
      ::clear_value_data();
      ::set_token(a1_token:param.a2_token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);
      ERR::reportParseError( msg:
                        "Parameter ->%s<- is not associated with operation ->" +
                                  tfr.Name + "<-", token: param.a2_token );
    elif val.isLValue and parm.By_Ref == 0 and
                                       ((empty irdt) or (param.a4_isRootAccess))
      ::clear_value_data();
      ::set_token(a1_token:param.a2_token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);
      ERR::reportParseError(msg: "Parameter ->%s<- is not passed by reference" +
                         " and is not assignable", token: param.a2_token );
    else
      select one dt related by parm->S_DT[R118];
      relate val to dt across R820;
      select one parmVal related by val->V_PVL[R801];
      relate parm to parmVal across R833;
      val.LineNumber = ::getLineNumber(rule_token: param.a2_token);
      val.StartPosition = ::getColumn(rule_token: param.a2_token);
      val.setEndPosition();
    end if;
  else
    select one brg related by act->ACT_BRB[R698]->S_BRG[R697];
    if not_empty brg
      select any parm related by brg->S_BPARM[R21] where
                                                 selected.Name == param.a1_name;
      select one irdt related by parm->S_DT[R22]->S_IRDT[R17];
      if empty parm
        ::clear_value_data();
        ::set_token(a1_token:param.a2_token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);
        ERR::reportParseError(msg: 
                        "Parameter ->%s<- is not associated with bridge ->" +
                                  brg.Name + "<-", token: param.a2_token );
      elif val.isLValue and parm.By_Ref == 0 and
                                       ((empty irdt) or (param.a4_isRootAccess))
        ::clear_value_data();
        ::set_token(a1_token:param.a2_token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);
        ERR::reportParseError(msg: "Parameter ->%s<- is not passed by" +
               " reference and is not assignable", token: param.a2_token );
      else
        select one dt related by parm->S_DT[R22];
        relate val to dt across R820;
        select one parmVal related by val->V_PVL[R801];
        relate parm to parmVal across R831;
        val.LineNumber = ::getLineNumber(rule_token: param.a2_token);
        val.StartPosition = ::getColumn(rule_token: param.a2_token);
        val.setEndPosition();
      end if;
    else
      select one requiredSignal related by act->ACT_RSB[R698]->SPR_RS[R684];
      select one requiredOperation related by act->ACT_ROB[R698]->SPR_RO[R685];
      select one providedSignal related by act->ACT_PSB[R698]->SPR_PS[R686];
      select one providedOperation related by act->ACT_POB[R698]->SPR_PO[R687];
      if(not_empty requiredSignal)
        select any parm related by requiredSignal->SPR_REP[R4502]->C_EP[R4500]
                             ->C_PP[R4006] where selected.Name == param.a1_name;
        select one irdt related by parm->S_DT[R4007]->S_IRDT[R17];
        if empty parm
          ::clear_value_data();
          ::set_token(a1_token:param.a2_token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);
          ERR::reportParseError(msg: 
               "Parameter ->%s<- is not associated with required signal ->" +
                            requiredSignal.Name + "<-", token: param.a2_token );
        elif val.isLValue and parm.By_Ref == 0 and
                                       ((empty irdt) or (param.a4_isRootAccess))
          ::clear_value_data();
          ::set_token(a1_token:param.a2_token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);
          ERR::reportParseError(msg: "Parameter ->%s<- is not passed by" +
                    " reference and is not assignable", token: param.a2_token );
        else
          select one dt related by parm->S_DT[R4007];
          relate val to dt across R820;
          select one parmVal related by val->V_PVL[R801];
          relate parm to parmVal across R843;
          val.LineNumber = ::getLineNumber(rule_token: param.a2_token);
          val.StartPosition = ::getColumn(rule_token: param.a2_token);
          val.setEndPosition();
        end if;
      elif(not_empty requiredOperation)
        select any parm related by requiredOperation->SPR_REP[R4502]
                ->C_EP[R4500]->C_PP[R4006] where selected.Name == param.a1_name;
        select one irdt related by parm->S_DT[R4007]->S_IRDT[R17];
        if empty parm
          ::clear_value_data();
          ::set_token(a1_token:param.a2_token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);
          ERR::reportParseError(msg: 
            "Parameter ->%s<- is not associated with required operation ->" +
                            requiredOperation.Name + "<-", token: param.a2_token );
        elif val.isLValue and parm.By_Ref == 0 and
                                       ((empty irdt) or (param.a4_isRootAccess))
          ::clear_value_data();
          ::set_token(a1_token:param.a2_token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);
          ERR::reportParseError(msg: "Parameter ->%s<- is not passed by" +
                    " reference and is not assignable", token: param.a2_token );
        else
          select one dt related by parm->S_DT[R4007];
          relate val to dt across R820;
          select one parmVal related by val->V_PVL[R801];
          relate parm to parmVal across R843;
          val.LineNumber = ::getLineNumber(rule_token: param.a2_token);
          val.StartPosition = ::getColumn(rule_token: param.a2_token);
          val.setEndPosition();
        end if;
      elif(not_empty providedSignal)
        select any parm related by providedSignal->SPR_PEP[R4503]
                ->C_EP[R4501]->C_PP[R4006] where selected.Name == param.a1_name;
        select one irdt related by parm->S_DT[R4007]->S_IRDT[R17];
        if empty parm
          ::clear_value_data();
          ::set_token(a1_token:param.a2_token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);
          ERR::reportParseError(msg: 
               "Parameter ->%s<- is not associated with provided signal ->" +
                            providedSignal.Name + "<-", token: param.a2_token );
        elif val.isLValue and parm.By_Ref == 0 and
                                       ((empty irdt) or (param.a4_isRootAccess))
          ::clear_value_data();
          ::set_token(a1_token:param.a2_token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);
          ERR::reportParseError(msg: "Parameter ->%s<- is not passed by" +
                    " reference and is not assignable", token: param.a2_token );
        else
          select one dt related by parm->S_DT[R4007];
          relate val to dt across R820;
          select one parmVal related by val->V_PVL[R801];
          relate parm to parmVal across R843;
          val.LineNumber = ::getLineNumber(rule_token: param.a2_token);
          val.StartPosition = ::getColumn(rule_token: param.a2_token);
          val.setEndPosition();
        end if;
      elif(not_empty providedOperation)
        select any parm related by providedOperation->SPR_PEP[R4503]
                ->C_EP[R4501]->C_PP[R4006] where selected.Name == param.a1_name;
        select one irdt related by parm->S_DT[R4007]->S_IRDT[R17];
        if empty parm
          ::clear_value_data();
          ::set_token(a1_token:param.a2_token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);
          ERR::reportParseError(msg: 
            "Parameter ->%s<- is not associated with provided operation ->" +
                            providedOperation.Name + "<-", token: param.a2_token );
        elif val.isLValue and parm.By_Ref == 0 and
                                       ((empty irdt) or (param.a4_isRootAccess))
          ::clear_value_data();
          ::set_token(a1_token:param.a2_token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);
          ERR::reportParseError(msg: "Parameter ->%s<- is not passed by" +
                    " reference and is not assignable", token: param.a2_token );
        else
          select one dt related by parm->S_DT[R4007];
          relate val to dt across R820;
          select one parmVal related by val->V_PVL[R801];
          relate parm to parmVal across R843;
          val.LineNumber = ::getLineNumber(rule_token: param.a2_token);
          val.StartPosition = ::getColumn(rule_token: param.a2_token);
          val.setEndPosition();
        end if;
      end if;
    end if;
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4614,
	4613,
	'a1_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4615,
	4613,
	'a2_token',
	4438,
	0,
	'',
	4614,
	'');
INSERT INTO S_SPARM
	VALUES (4616,
	4613,
	'a3_value_id',
	296,
	0,
	'',
	4615,
	'');
INSERT INTO S_SPARM
	VALUES (4617,
	4613,
	'a4_isRootAccess',
	316,
	0,
	'',
	4616,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4618);
INSERT INTO S_SYNC
	VALUES (4618,
	1,
	'event_root_value_validate',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE',
	'// ::event_root_value_validate()
current_scope = ::get_current_scope();
select any blk from instances of ACT_BLK where
                                             selected.Block_ID == current_scope;
select one act related by blk->ACT_ACT[R612];

select one sm_act related by act->ACT_SAB[R698]->SM_ACT[R691];
if empty sm_act
  select one sm_act related by act->ACT_TAB[R698]->SM_ACT[R688];
end if;
if empty sm_act
  ERR::reportParseError(msg: "The ->rcvd_evt<- keyword cannot be used in a " +
               "non-state action. Use ->param<- instead.", token: param.token );
end if;
select one sm_sab related by act->ACT_SAB[R698];
if not_empty sm_sab
  // check state action 
  select many txns related by 
               sm_act->SM_AH[R514]->SM_MOAH[R513]->SM_STATE[R511]->SM_TXN[R506];
  if cardinality txns > 0
    for each txn in txns
      select one nsTxn related by txn->SM_NSTXN[R507];
      select one trigger related by nsTxn->SM_SEME[R504]->
                                                    SM_SEVT[R503]->SM_EVT[R525];
      if empty nsTxn
        select one crTxn related by txn->SM_CRTXN[R507];
        if not_empty crTxn
          select one trigger related by crTxn->SM_LEVT[R509]->
                                                    SM_SEVT[R526]->SM_EVT[R525];
        else
          ERR::reportParseError( 
              msg: "Attempted to access parameter ->%s<- when one or more" +
                         " incoming transitions do not have events assigned.",
                                                           token: param.token );
          break;
        end if;
      end if; // empty new state transition
      select one nlevt related by trigger->SM_SEVT[R525]->SM_NLEVT[R526];
      select one pevt related by nlevt->SM_PEVT[R527];
      if not_empty pevt
        select one trigger related by pevt->SM_EVT[R525];
      end if;
      select any val from instances of V_VAL where
                                            selected.Value_ID == param.value_id;
      if val.isLValue
        ::clear_value_data();
        ::set_token(a1_token:param.token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);
        ERR::reportParseError(msg: "Event parameters" +
                                    " are not assignable", token: param.token );
        break;
      else
        select one sigEvt related by trigger->SM_SEVT[R525]->SM_SGEVT[R526];
        if empty sigEvt // its a regular event with parameters
          select any edi related by trigger->SM_EVTDI[R532] where
                                                    selected.Name == param.name;
          if not_empty edi
            select one edv related by val->V_EDV[R801];
            if empty edv
              USER::logError(msg:"event_root_value_validate:" +
                   " Value is not an event value " + param.name,path:"PathNotProvided");
            end if;
            create object instance epr of V_EPR;
            relate epr to edv across R834; 
            relate epr to edi across R846;
            select one edt related by edi->S_DT[R524];
            relate val to edt across R820;
            val.setEndPosition();
            select one arrayElemRef related by val->V_AER[R838]->V_VAL[R801];
            if (not_empty arrayElemRef)
			  leafElem = arrayElemRef;
      		  while (not_empty arrayElemRef)
      		    leafElem = arrayElemRef;
      		    select one arrayElemRef related by arrayElemRef->V_AER[R838]->V_VAL[R801];
      		  end while;
              if leafElem.getDimensions() < 0
                 ::set_token(a1_token:param.token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);
			     ERR::reportParseError( 
                             msg: "Parameter ->%s<- has incompatible array depth." ,
                                                         token: param.token );
              end if;
            end if;
            //
          end if; // if no event parameter found, error will be reported below
        else // a signal reference . . . 
          select one exProp related by sigEvt->SPR_PS[R528]->
                                                    SPR_PEP[R4503]->C_EP[R4501];
          if empty exProp
            select one exProp related by sigEvt->SPR_RS[R529]->
                                                    SPR_REP[R4502]->C_EP[R4500];
          end if;
          if not_empty exProp
            select any sigParm related by exProp->C_PP[R4006] where
                                                    selected.Name == param.name;
            if not_empty sigParm
              select one edv related by val->V_EDV[R801];
              if empty edv
              USER::logError(msg:"event_root_value_validate:" +
                   " Value is not an event value " + param.name,path:"PathNotProvided");
              end if;
              create object instance epr of V_EPR;
              relate epr to edv across R834; 
              relate epr to sigParm across R847;
              select one pdt related by sigParm->S_DT[R4007];
              relate val to pdt across R820;
              val.setEndPosition();
              select one arrayElemRef related by val->V_AER[R838]->V_VAL[R801];
              if (not_empty arrayElemRef)
       		    leafElem = arrayElemRef;
      		    while (not_empty arrayElemRef)
      		      leafElem = arrayElemRef;
      		      select one arrayElemRef related by arrayElemRef->V_AER[R838]->V_VAL[R801];
      		    end while;
                if leafElem.getDimensions() < 0
                   ::set_token(a1_token:param.token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);
			       ERR::reportParseError( 
                               msg: "Parameter ->%s<- has incompatible array depth." ,
                                                           token: param.token );
                end if;
              end if;
            end if; // if no signal parameter found, error is reported below 
          else
            USER::logError(msg:"event_root_value_validate:" +
               " No signal declaration found for signal event carrying "
                                                                  + param.name,path:"PathNotProvided");
          end if;
        end if;  // empty signal event
      end if; // not l-value
    end for;
  else // no transitions found
    ERR::reportParseError( 
              msg: "Attempted to access parameter ->%s<- when there" +
                          " are no incoming transitions.", token: param.token );
  end if;
  // Now check that events on all incoming transitions carry the referenced
  // parameter. We do this in a separate loop because we don''''t want to consider
  // the same event more than once, as is likely when iterating transitions . .
  badEventList = "";
  sep = "";
  select many ns_triggers related by txns->SM_NSTXN[R507]->SM_SEME[R504]->
                                                    SM_SEVT[R503]->SM_EVT[R525];
  select any ns_evt related by txns->SM_NSTXN[R507]->SM_SEME[R504]->
                                                    SM_SEVT[R503]->SM_EVT[R525];
  for each ns_evt in ns_triggers
    select one nlevt related by ns_evt->SM_SEVT[R525]->SM_NLEVT[R526];
    if not_empty nlevt
      select one pevt related by nlevt->SM_PEVT[R527];
      if empty pevt
        ERR::reportParseError( 
           msg:"Parameter ->%s<- belongs to a Polymorphic Event that is no " +
                            "longer defined in supertype", token: param.token );
        break;
      else
        select one ns_evt related by pevt->SM_EVT[R525];
      end if;
    end if;
    select one sigEvt related by ns_evt->SM_SEVT[R525]->SM_SGEVT[R526];
    if not_empty sigEvt
      select one exProp related by sigEvt->SPR_PS[R528]->
                                                    SPR_PEP[R4503]->C_EP[R4501];
      if empty exProp
        select one exProp related by sigEvt->SPR_RS[R529]->
                                                    SPR_REP[R4502]->C_EP[R4500];
      end if;
      if not_empty exProp
        select any sigParm related by exProp->C_PP[R4006] where
                                                    selected.Name == param.name;
        if empty sigParm
          badEventList = badEventList + sep + ns_evt.Mning;
          sep = ", ";
        end if;
      end if;
    else
      select any edi related by ns_evt->SM_EVTDI[R532] where
                                                    selected.Name == param.name;
      if empty edi
        badEventList = badEventList + sep + ns_evt.Mning;
        sep = ", ";
      end if;
    end if;
  end for;
  // Need to repeat the same check for creation transitions
  select many triggers related by txns->SM_CRTXN[R507]->SM_LEVT[R509]->
                                                    SM_SEVT[R526]->SM_EVT[R525];
  select any cr_evt related by txns->SM_CRTXN[R507]->SM_LEVT[R509]->
                                                    SM_SEVT[R526]->SM_EVT[R525];
  for each cr_evt in triggers
    alreadyReported = false;
    for each prevCheckedEvt in ns_triggers
      if cr_evt == prevCheckedEvt
        alreadyReported = true;
        break;
      end if;
    end for;
    if not alreadyReported 
      select one pevt related by cr_evt->SM_SEVT[R525]->
                                                  SM_NLEVT[R526]->SM_PEVT[R527];
      if not_empty pevt
        select one cr_evt related by pevt->SM_EVT[R525];
      end if;
      select one sigEvt related by cr_evt->SM_SEVT[R525]->SM_SGEVT[R526];
      if not_empty sigEvt
        select one exProp related by sigEvt->SPR_PS[R528]->
                                                    SPR_PEP[R4503]->C_EP[R4501];
        if empty exProp
          select one exProp related by sigEvt->SPR_RS[R529]->
                                                    SPR_REP[R4502]->C_EP[R4500];
        end if;
        if not_empty exProp
          select any sigParm related by exProp->C_PP[R4006] where
                                                    selected.Name == param.name;
          if empty sigParm
            badEventList = badEventList + sep + cr_evt.Mning;
            sep = ", ";
          end if;
        end if;
      else
        select any edi related by cr_evt->SM_EVTDI[R532] where
                                                    selected.Name == param.name;
        if empty edi
          badEventList = badEventList + sep + cr_evt.Mning;
          sep = ", ";
        end if;
      end if;
    end if;
  end for;
  if badEventList != ""
    ERR::reportParseError( 
              msg: "The following incoming messages do not carry required" +
                                          " parameter ->%s<- " + badEventList,
                                                           token: param.token );
  end if;
else // check transition action
  select one txn related by sm_act->SM_AH[R514]->SM_TAH[R513]->SM_TXN[R530];
  select one nsTxn related by txn->SM_NSTXN[R507];
  select one trigger related by nsTxn->SM_SEME[R504]->
                                                    SM_SEVT[R503]->SM_EVT[R525];
  if empty nsTxn
    select one crTxn related by txn->SM_CRTXN[R507];
    if not_empty crTxn
      select one trigger related by crTxn->SM_LEVT[R509]->
                                                    SM_SEVT[R526]->SM_EVT[R525];
    else
      ERR::reportParseError( 
              msg: "Attempted to access parameter ->%s<- when associated" +
                               " transition does not have an event assigned.",
                                                           token: param.token );
    end if;
  end if; // empty new state transition
  select one nlevt related by trigger->SM_SEVT[R525]->SM_NLEVT[R526];
  if not_empty nlevt
    select one pevt related by nlevt->SM_PEVT[R527];
    if empty pevt
      ERR::reportParseError(
           msg:"Parameter ->%s<- belongs to a Polymorphic Event that is no " +
                            "longer defined in supertype", token: param.token );
    else
      select one trigger related by pevt->SM_EVT[R525];
    end if;
  end if;
  select any val from instances of V_VAL where
                                            selected.Value_ID == param.value_id;
  if val.isLValue
    ::clear_value_data();
    ::set_token(a1_token:param.token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);
    ERR::reportParseError(msg: "Event parameters" +
                                    " are not assignable", token: param.token );
  else
    select one sigEvt related by trigger->SM_SEVT[R525]->SM_SGEVT[R526];
    if empty sigEvt // its a regular event with parameters
      select any edi related by trigger->SM_EVTDI[R532] where
                                                    selected.Name == param.name;
      if not_empty edi
        select one edv related by val->V_EDV[R801];
        if empty edv
              USER::logError(msg:"event_root_value_validate:" +
                   " Value is not an event value " + param.name,path:"PathNotProvided");
        end if;
        create object instance epr of V_EPR;
        relate epr to edv across R834; 
        relate epr to edi across R846;
        select one edt related by edi->S_DT[R524];
        relate val to edt across R820;
        val.setEndPosition();
        select one arrayElemRef related by val->V_AER[R838]->V_VAL[R801];
        if (not_empty arrayElemRef)
       	  leafElem = arrayElemRef;
      	  while (not_empty arrayElemRef)
      	    leafElem = arrayElemRef;
      		select one arrayElemRef related by arrayElemRef->V_AER[R838]->V_VAL[R801];
      	  end while;
          if leafElem.getDimensions() < 0
            ::set_token(a1_token:param.token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);    
			ERR::reportParseError( 
                    msg: "Parameter ->%s<- has incompatible array depth." ,
                                                 token: param.token );
          end if;
        end if;
      else
        ERR::reportParseError( 
           msg:"Parameter ->%s<- is not carried by event " + trigger.Mning,
                                                           token: param.token );
      end if;
    else  // a signal reference
      select one exProp related by sigEvt->SPR_PS[R528]->
                                                    SPR_PEP[R4503]->C_EP[R4501];
      if empty exProp
        select one exProp related by sigEvt->SPR_RS[R529]->
                                                    SPR_REP[R4502]->C_EP[R4500];
      end if;
      if not_empty exProp
        select any sigParm related by exProp->C_PP[R4006] where
                                                    selected.Name == param.name;
        if not_empty sigParm
          select one edv related by val->V_EDV[R801];
          if empty edv
              USER::logError(msg:"event_root_value_validate:" +
                   " Value is not an event value " + param.name,path:"PathNotProvided");
          end if;
          create object instance epr of V_EPR;
          relate epr to edv across R834; 
          relate epr to sigParm across R847;
          select one pdt related by sigParm->S_DT[R4007];
          relate val to pdt across R820;
          val.setEndPosition();
          select one arrayElemRef related by val->V_AER[R838]->V_VAL[R801];
          if (not_empty arrayElemRef)
            leafElem = arrayElemRef;
       	    while (not_empty arrayElemRef)
      	      leafElem = arrayElemRef;
      		  select one arrayElemRef related by arrayElemRef->V_AER[R838]->V_VAL[R801];
      	    end while;
            if leafElem.getDimensions() < 0
              ::set_token(a1_token:param.token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);
			  ERR::reportParseError( 
                      msg: "Parameter ->%s<- has incompatible array depth." ,
                                                   token: param.token );
            end if;
          end if;
        else
          ERR::reportParseError( 
            msg:"Parameter ->%s<- is not carried by signal " +
                                            trigger.Mning, token: param.token );
        end if; // if no signal parameter found, error will be reported below 
      else
        USER::logError(msg:"event_root_value_validate:" +
             " No signal declaration found for signal event carrying "
                                                                  + param.name,path:"PathNotProvided");
      end if;
    end if;
  end if; // not l-value
end if;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4619,
	4618,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4620,
	4618,
	'token',
	4438,
	0,
	'',
	4619,
	'');
INSERT INTO S_SPARM
	VALUES (4621,
	4618,
	'value_id',
	296,
	0,
	'',
	4620,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4622);
INSERT INTO S_SYNC
	VALUES (4622,
	1,
	'array_length_validate',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// ::array_length_validate
result = false;
if (param.a1_name == "length" or param.a1_name == "Length") and param.a2_isArray
  select any curVal from instances of V_VAL where
                                        selected.Value_ID == param.a3_curVal_ID;
  if (curVal.isLValue)
    ::clear_value_data();
    ERR::reportParseError( msg: "Array length is read only. OAL arrays do " +
                              "not need to be sized. ", token: param.a4_token );
  else
    // Successfully recognized an array length reference
    // to an array of simple data types.
    create object instance alVal of V_ALV;
    relate alVal to curVal across R801;
    select any dom from instances of S_DOM where selected.Dom_ID == ::getValidationDomain();
    select any intDt related by dom->S_DT[R14] where selected.Name == "integer";
    if empty intDt
      cur_sys_name = ::getSystemName();
      select any sys from instances of S_SYS where selected.Name == cur_sys_name;
      dt_id = GD::NULL_UNIQUE_ID();
      if not_empty sys
        dt_id = sys.getCoreTypeId(name:"integer");
      end if;
      select any pe from instances of PE_PE where selected.Element_ID == dt_id;
      select one intDt related by pe->S_DT[R8001]; 
    end if;
    if ( not_empty intDt )
      relate curVal to intDt across R820;
    else
      USER::logError(msg: "Internal Error in OAL Validation Utility Function " +
                        "array_length_validate().  Variable <intDt> is empty.",path:"PathNotProvided");
    end if;
    select any endVal from instances of V_VAL where
                                        selected.Value_ID == param.a5_endVal_ID;
    relate endVal to alVal across R840;
    result = true;
  end if;
end if;
return result;',
	316,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4623,
	4622,
	'a1_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4624,
	4622,
	'a2_isArray',
	316,
	0,
	'',
	4623,
	'');
INSERT INTO S_SPARM
	VALUES (4625,
	4622,
	'a3_curVal_ID',
	296,
	0,
	'',
	4624,
	'');
INSERT INTO S_SPARM
	VALUES (4626,
	4622,
	'a4_token',
	4438,
	0,
	'',
	4625,
	'');
INSERT INTO S_SPARM
	VALUES (4627,
	4622,
	'a5_endVal_ID',
	296,
	0,
	'',
	4626,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4628);
INSERT INTO S_SYNC
	VALUES (4628,
	1,
	'set_token',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE

Translate: native',
	'    if (p_A1_token != null) {
    	p_A1_token.setLine(p_A2_line);
    	p_A1_token.setColumn(p_A3_column);
    	p_A1_token.setText(p_A4_text);
    }
',
	19,
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4629,
	4628,
	'a1_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4630,
	4628,
	'a2_line',
	298,
	0,
	'',
	4629,
	'');
INSERT INTO S_SPARM
	VALUES (4631,
	4628,
	'a3_column',
	298,
	0,
	'',
	4630,
	'');
INSERT INTO S_SPARM
	VALUES (4632,
	4628,
	'a4_text',
	322,
	0,
	'',
	4631,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4633);
INSERT INTO S_SYNC
	VALUES (4633,
	1,
	'is_valid_message',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// ::isValidMessage()
select any requirement from instances of C_R where
                                      selected.Requirement_Id == param.a1_ifRef;
select any provision from instances of C_P where
                                        selected.Provision_Id == param.a1_ifRef;
select one interface related by requirement->C_IR[R4009]->C_I[R4012];
if empty interface
  select one interface related by provision->C_IR[R4009]->C_I[R4012];
end if;
select any signal related by interface->C_EP[R4003]->C_AS[R4004] where
                                              selected.Name == param.a2_msgName;
select any op related by interface->C_EP[R4003]->C_IO[R4004] where
                                              selected.Name == param.a2_msgName;
select one message related by signal->C_EP[R4004];
if empty message
  select one message related by op->C_EP[R4004];
end if;
if empty message
  ERR::reportParseError(
       msg: "Cannot find specified message ->%s<-", token: param.a3_rule_token);
else
  // create a value, if there is no return value it will be removed later
  create object instance msv of V_MSV;
  msv.ParmListOK = true;
  create object instance val of V_VAL;
  current_scope = ::get_current_scope();
  select any block from instances of ACT_BLK where
                selected.Block_ID == current_scope;
  relate val to block across R826;
  relate val to msv across R801;
  // find the required or provided executable property
  if(not_empty provision)
    select any proEP related by message->SPR_PEP[R4501]
                        where (selected.Provision_Id == provision.Provision_Id);
    if(not_empty proEP)
      relate proEP to msv across R841; 
    end if;
  elif(not_empty requirement)
    select any reqEP related by message->SPR_REP[R4500]
                  where (selected.Requirement_Id == requirement.Requirement_Id);
    if(not_empty reqEP)
      relate reqEP to msv across R845;
    end if;
  end if;
  val.LineNumber = ::getLineNumber(rule_token: param.a3_rule_token);
  val.StartPosition = ::getColumn(rule_token: param.a3_rule_token);
  val.setEndPosition();
  // store the textual position of the interface name
  msv.ownerNameLineNumber = block.currentKeyLettersLineNumber;
  msv.ownerNameColumn = block.currentKeyLettersColumn;
  select one bdt related by op-> S_DT[R4008];
  if empty bdt
    if not_empty signal
      // it can''t return anything
      select any dom from instances of S_DOM where selected.Dom_ID == ::getValidationDomain();
      select any bdt related by dom->S_DT[R14] where selected.Name == "void";
      if empty bdt
        cur_sys_name = ::getSystemName();
        select any sys from instances of S_SYS where selected.Name == cur_sys_name;
        dt_id = GD::NULL_UNIQUE_ID();
        if not_empty sys
          dt_id = sys.getCoreTypeId(name:"void");
        end if;
        select any pe from instances of PE_PE where selected.Element_ID == dt_id;
        select one bdt related by pe->S_DT[R8001]; 
      end if;
      if empty bdt
        USER::logError(msg: "Internal Error in OAL Validation Utility Function " +
                               "is_valid_message().  Variable <bdt> is empty.",path:"PathNotProvided");
      end if;
    else
      USER::logError(msg:"is_valid_message: internal error" +
                               " no return type found for interface operation",path:"PathNotProvided");
    end if;
  end if;
  relate val to bdt across R820;
  return val.Value_ID;
end if;
return GD::NULL_UNIQUE_ID();',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4634,
	4633,
	'a1_ifRef',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4635,
	4633,
	'a2_msgName',
	322,
	0,
	'',
	4634,
	'');
INSERT INTO S_SPARM
	VALUES (4636,
	4633,
	'a3_rule_token',
	4438,
	0,
	'',
	4635,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4637);
INSERT INTO S_SYNC
	VALUES (4637,
	1,
	'sender_validate',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
if param.a1_name == "Sender" or param.a1_name == "sender" or
                                                       param.a1_name == "SENDER"
  current_scope = ::get_current_scope();
  select any block from instances of ACT_BLK where
                                             selected.Block_ID == current_scope;
  select one body related by block->ACT_ACT[R612];
  body.associateWithOwningComponent();
  select one component related by body->ACT_BIC[R694]->C_C[R694];
  if empty component
    ::clear_value_data();
    ERR::reportParseError(
         msg: "Sender keyword is valid only in the context of a component",
                                                        token: param.a3_token );
  else
    if param.a2_isLval
      ::clear_value_data();
      ERR::reportParseError( msg: "Cannot assign a value to ->%s<-.",
                                                        token: param.a3_token );
    else
      var_id = ::get_var_in_scope( name: param.a1_name,
                                                   rule_token: param.a3_token );
      if ( var_id == GD::NULL_UNIQUE_ID() )
        errMsg = ::is_valid_implicit_component_addressing();
        if errMsg == ""
          select one outer_blk related by body->ACT_BLK[R650];
          create object instance sndr of V_TRN;
          create object instance var_inst of V_VAR;
          relate var_inst to sndr across R814;
          var_inst.Name = param.a1_name;
          relate var_inst to outer_blk across R823;
          select any dom from instances of S_DOM where selected.Dom_ID == ::getValidationDomain();
          select any dt related by dom->S_DT[R14] where
                                               selected.Name == "component_ref";
          if empty dt
            cur_sys_name = ::getSystemName();
            select any sys from instances of S_SYS where
                                                  selected.Name == cur_sys_name;
            dt_id = GD::NULL_UNIQUE_ID();
            if not_empty sys
              dt_id = sys.getCoreTypeId(name:"component_ref");
            end if;
            select any pe from instances of PE_PE where selected.Element_ID == dt_id;
            select one dt related by pe->S_DT[R8001];
          end if;
          if ( not_empty dt )
            relate var_inst to dt across R848;
          else
            USER::logError(msg: "Internal Error in OAL Validation Utility Function " +
              "sender_validate().  Variable <dt> is empty.",path:"PathNotProvided");
          end if;
          var_inst.Declared = true;
        else
          ::clear_value_data();
          ERR::reportParseError( msg: errMsg, token: param.a3_token );
        end if;
      end if;  // var_id == GD::NULL_UNIQUE_ID
    end if; // not an Lval
  end if; // component in context
end if; // keyword matches
',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4638,
	4637,
	'a1_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4639,
	4637,
	'a2_isLval',
	316,
	0,
	'',
	4638,
	'');
INSERT INTO S_SPARM
	VALUES (4640,
	4637,
	'a3_token',
	4438,
	0,
	'',
	4639,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4641);
INSERT INTO S_SYNC
	VALUES (4641,
	1,
	'is_valid_implicit_component_addressing',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE',
	'// ::is_valid_implicit_component_addressing()
prefAllowImplicitComponentAddressing =
                        "bridgepoint_prefs_allow_implicit_component_addressing";
if PREF::getBoolean( name:prefAllowImplicitComponentAddressing) == false
  current_scope = ::get_current_scope();
  select any block from instances of ACT_BLK where
                                             selected.Block_ID == current_scope;
  select one body related by block->ACT_ACT[R612];
  // implicit addressing may be valid in interface bodies
  select one psb related by body->ACT_PSB[R698];
  select one pob related by body->ACT_POB[R698];
  select one rsb related by body->ACT_RSB[R698];
  select one rob related by body->ACT_ROB[R698];
  if empty psb and empty pob and empty rsb and empty rob
    select one sab related by body->ACT_SAB[R698];
    select one tab related by body->ACT_TAB[R698];
    if not_empty sab
      select one csm related by sab->SM_ACT[R691]->SM_SM[R515]->SM_ASM[R517];
      if not_empty csm
        select one state related by sab->SM_ACT[R691]->SM_AH[R514]->
                                                  SM_MOAH[R513]->SM_STATE[R511];
        // select all incoming transitions
        select many txns related by state->SM_TXN[R506];
        select many sigs related by txns->SM_NSTXN[R507]->
                                   SM_SEME[R504]->SM_SEVT[R503]->SM_SGEVT[R526];
        if cardinality txns == cardinality sigs
          // all is well
          return "";
        else
           return "Sender keyword can only be used where " +
                       "there are signals assigned to all incoming transitions";
        end if;
      end if; // is a class state model
    elif not_empty tab
      select one csm related by tab->SM_ACT[R688]->SM_SM[R515]->SM_ASM[R517];
      if not_empty csm
        select one txn related by tab->SM_ACT[R688]->SM_AH[R514]->
                                                     SM_TAH[R513]->SM_TXN[R530];
        select one sig related by txn->SM_NSTXN[R507]->
                                   SM_SEME[R504]->SM_SEVT[R503]->SM_SGEVT[R526];
        if not_empty sig
          // all is well
          return "";
        else
          return "Sender keyword can only be used when " +
                                      "a signal is assigned to this transition";
        end if;
      end if; // is a class state model
    end if; // is a state or transition action
    return "Sender keyword is valid " +
                                    "only where a message is serviced directly";
  else // it is a signal or operation, check the direction is incoming
    direction = IFDirectionType::ClientServer;
    targetType = "Signal";
    if not_empty psb or not_empty pob
      select one as related by psb->SPR_PS[R686]->SPR_PEP[R4503]->
                                                       C_EP[R4501]->C_AS[R4004];
      if not_empty as
        direction = as.Direction;
      end if;
      if not_empty pob
        select one op related by pob->SPR_PO[R687]->SPR_PEP[R4503]->
                                                       C_EP[R4501]->C_IO[R4004];
        targetType = "Interface Operation";
        if not_empty op
          direction = op.Direction;
        end if;
        if direction != IFDirectionType::ClientServer
          return "Sender keyword can only be used in an incoming " +
                                                               targetType + ".";
        end if;
      end if;
    else
      select one as related by rsb->SPR_RS[R684]->SPR_REP[R4502]->
                                                       C_EP[R4500]->C_AS[R4004];
      if not empty as
        direction = as.Direction;
      end if;
      if not_empty rob
        select one op related by rob->SPR_RO[R685]->SPR_REP[R4502]->
                                                       C_EP[R4500]->C_IO[R4004];
        targetType = "Interface Operation";
        if not_empty op
          direction = op.Direction;
        end if;
      end if;
      if direction != IFDirectionType::ServerClient
        return "Sender keyword can only be used in an incoming " +
                                                               targetType + ".";
      end if;
    end if;
  end if;
end if;
return "";',
	322,
	1,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4642);
INSERT INTO S_SYNC
	VALUES (4642,
	1,
	'getSystemName',
	'This function uses the model root parameter that is passed to the function in
the parser code.

It returns the system/project name using the inherited static function
getProjectNameFromModelRootId().

ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE

Translate: native
',
	'return Ooaofooa.getProjectNameFromModelRootId(modelRoot.getId());',
	322,
	0,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4643);
INSERT INTO S_SYNC
	VALUES (4643,
	1,
	'getValidationDomain',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE

Translate: native
',
	'java.util.UUID result = com.mentor.nucleus.bp.core.common.IdAssigner.NULL_UUID;
if (this.m_dom != null) {
  result = this.m_dom.getDom_id();
}
if (this.m_nrme != null) {
  result = this.m_nrme.Get_ooa_id();
}
return result;
',
	296,
	0,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4644);
INSERT INTO S_SYNC
	VALUES (4644,
	1,
	'connect_inst_ref_var_to_datatype',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
------------------
This function is used to connect a V_INT or V_INS instance''s V_VAR supertype
to the corresponding inst_ref<[classname]> or inst_ref_set<[classname]>
datatype.

Typically this is done after migrating a V_TRN to one of these instance
reference types.
',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// OAL Validation Utility Function::connect_inst_ref_var_to_datatype()

select any obj from instances of O_OBJ where selected.Obj_ID == param.p3_obj_id;
select any irdt related by obj->S_IRDT[R123] where selected.isSet == param.p1_is_set;
select any vvar from instances of V_VAR where selected.Var_ID == param.p2_var_id;

if (not_empty irdt)
  select one dt related by irdt->S_DT[R17];
  relate vvar to dt across R848;
else
  // Didn''t find a match for the class, set the datatype to the inst_ref<Object>
  // or inst_ref_set<Object> generic instance reference.
  dt_name = "inst_ref<Object>";
  if (param.p1_is_set)
    dt_name = "inst_ref_set<Object>";
  end if;

  elemId = ::getValidationDomain();
  select any dom from instances of S_DOM where selected.Dom_ID == elemId;
  select any dt1_dt related by dom->S_DT[R14] where selected.Name == dt_name;
  if empty dt1_dt
    select any packageableElem from instances of PE_PE where
                                                  selected.Element_ID == elemId;
    select one package related by packageableElem->EP_PKG[R8000];
    select one component related by packageableElem->C_C[R8003];
    isInGenericPackage = not_empty package or not_empty component;

    if (isInGenericPackage)
      dtID = packageableElem.resolveDataTypeRelativeToSelf(
                                   expected_name:dt_name, default_name:dt_name);
      select any dt1_dt related by package->PE_VIS[R8002]->
                         PE_PE[R8002]->S_DT[R8001] where selected.DT_ID == dtID;
      if (empty dt1_dt)
        select any dt1_dt related by component->PE_CVS[R8004]->
                         PE_PE[R8004]->S_DT[R8001] where selected.DT_ID == dtID;
      end if;
    else
    // If we are not at the domain level, then we need to look for the datatypes
    // in the system-level datatype package(s)
    cur_sys_name = ::getSystemName();
      select any sys from instances of S_SYS where
                                                (selected.Name == cur_sys_name);
      dt_id = GD::NULL_UNIQUE_ID();
      if not_empty sys
        dt_id = sys.getCoreTypeId(name:dt_name);
      end if;
      select any pe from instances of PE_PE where selected.Element_ID == dt_id;
      select one dt1_dt related by pe->S_DT[R8001];
    end if;
  end if;

  if not_empty dt1_dt
    relate vvar to dt1_dt across R848;
  else
    USER::logError(msg: "Internal Error in OAL Validation Utility Function " +
        "connect_inst_ref_var_to_datatype().  Variable <dt1_dt> is empty.",path:"PathNotProvided");
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4645,
	4644,
	'p1_is_set',
	316,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4646,
	4644,
	'p2_var_id',
	296,
	0,
	'',
	4645,
	'');
INSERT INTO S_SPARM
	VALUES (4647,
	4644,
	'p3_obj_id',
	296,
	0,
	'',
	4646,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4648);
INSERT INTO S_SYNC
	VALUES (4648,
	1,
	'has_substring',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE

Translate: native
-----------
Utility function that wraps Java indexOf() to search for a substring.',
	'return p_P1_base.indexOf(p_P2_str, p_P3_fromindex) != -1;',
	316,
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4649,
	4648,
	'p1_base',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4650,
	4648,
	'p2_str',
	322,
	0,
	'',
	4649,
	'');
INSERT INTO S_SPARM
	VALUES (4651,
	4648,
	'p3_fromIndex',
	298,
	0,
	'',
	4650,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4652);
INSERT INTO S_SYNC
	VALUES (4652,
	1,
	'is_message_direction_valid',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE',
	'current_scope = ::get_current_scope();
select any block from instances of ACT_BLK where
                                             selected.Block_ID == current_scope;
select one body related by block->ACT_ACT[R612];
isInGenericPackage = body.associateWithContainer();
if isInGenericPackage
  select one containingElem related by body->ACT_BIE[R640]->PE_PE[R640];
  select one component related by containingElem->C_C[R8001];
  if(not_empty component)
    select any ifRef related by component->C_PO[R4010]->C_IR[R4016]
                                      where (selected.Id == param.interface_id);
    if(param.direction == IFDirectionType::ServerClient)
      select one provision related by ifRef->C_P[R4009];
      if(empty provision)
        // the body is on the client side yet the expected
        // direction is server -> client
        return false;
      end if;
    else
      select one requirement related by ifRef->C_R[R4009];
      if(empty requirement)
        // the body is on the server side yet the expected
        // direction is client -> server
        return false;
      end if;
    end if;
  end if;
  return true;
else
  body.associateWithOwningComponent();
  select one component related by body->ACT_BIC[R694]->C_C[R694];
  if(not_empty component)
    select any ifRef related by component->C_PO[R4010]->C_IR[R4016]
                                      where (selected.Id == param.interface_id);
    if(param.direction == IFDirectionType::ServerClient)
      select one provision related by ifRef->C_P[R4009];
      if(empty provision)
        // the body is on the client side yet the expected
        // direction is server -> client
        return false;
      end if;
    else
      select one requirement related by ifRef->C_R[R4009];
      if(empty requirement)
        // the body is on the server side yet the expected
        // direction is client -> server
        return false;
      end if;
    end if;
  end if;
  return true;
end if;',
	316,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4653,
	4652,
	'direction',
	4654,
	0,
	'',
	4653,
	'');
INSERT INTO S_SPARM
	VALUES (4655,
	4652,
	'interface_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4656);
INSERT INTO S_SYNC
	VALUES (4656,
	1,
	'constant_validate',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE',
	'current_scope = ::get_current_scope();
select any block from instances of ACT_BLK where
                                             selected.Block_ID == current_scope;
select one body related by block->ACT_ACT[R612];
isInGenericPackage = body.associateWithContainer();
if (isInGenericPackage)
  // collect visible elements
   select one containingElem related by body->ACT_BIE[R640]->PE_PE[R640];
   select one component related by containingElem->C_C[R8001];
   select one package related by containingElem->EP_PKG[R8001];
    if not_empty component
    component.collectVisibleElementsForName(name:param.a1_name,
         type:ElementTypeConstants::CONSTANT,
                          originatingContainerID:component.Id,
                                   delegatingContainerID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:true);
    else
    package.collectVisibleElementsForName(name:param.a1_name,
         type:ElementTypeConstants::CONSTANT, descending:false,
                           originatingContainerID:package.Package_ID,
                                          delegatingPkgID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:true); 
    end if;
  select any resultSet related by component->PE_CRS[R8007] where
                                    selected.Name == param.a1_name and 
                                   selected.Type == ElementTypeConstants::CONSTANT; 
  select many results related by resultSet->PE_CVS[R8008]->PE_PE[R8004];
    if not_empty package
      select any pkgResultSet related by package->PE_SRS[R8005] where
                                     selected.Name == param.a1_name and 
                                   selected.Type == ElementTypeConstants::CONSTANT; 
      select many results related by pkgResultSet->PE_VIS[R8006]->PE_PE[R8002];
  end if;


select many sycs related by results->CNST_CSP[R8001]->CNST_SYC[R1504] where (selected.Name == param.a1_name);
  if (cardinality sycs > 1)

      err_msg =  "There is more than one constant named ->" + param.a1_name + "<- in the system, cannot resolve.";
      ::clear_value_data();
      ERR::reportParseError( msg: err_msg, token: param.a2_ruleToken);

    return GD::NULL_UNIQUE_ID();
  elif (cardinality sycs == 0)
    if (param.a3_reportError)
      ERR::reportParseError( msg: "Cannot find constant ->%s<-",
          token: param.a2_ruleToken);
    end if;
    return GD::NULL_UNIQUE_ID();
  end if;

create object instance scv of V_SCV;
for each syc in sycs
  // We only loop once due to cardinality checks earlier
  relate scv to syc across R850;
end for;

select any val from instances of V_VAL where selected.Value_ID == param.a4_valID;
if (empty val)
  create object instance newval of V_VAL;
  val = newval;
end if;
relate val to scv across R801;

current_scope = ::get_current_scope();
select any block from instances of ACT_BLK where
                                           (selected.Block_ID == current_scope);
relate val to block across R826;

select one dt related by syc->S_DT[R1500];
relate val to dt across R820;

val.LineNumber = ::getLineNumber(rule_token: param.a2_ruleToken);
val.StartPosition = ::getColumn(rule_token: param.a2_ruleToken);
val.setEndPosition();

return val.Value_ID;
else
//Specialized package behavior is kept as before 
select many sycs from instances of CNST_SYC where (selected.Name == param.a1_name );

if (cardinality sycs > 1)
  if (param.a3_reportError)
    err_msg =  "There is more than one constant named ->" + param.a1_name + "<- in this domain, cannot resolve.";
    ::clear_value_data();
    ERR::reportParseError( msg: err_msg, token: param.a2_ruleToken);
  end if;
  return GD::NULL_UNIQUE_ID();
end if;

if(empty sycs)
  // if the symbolic constant was not found, check the system level
  sysName = ::getSystemName();
  select any system from instances of S_SYS where (selected.Name == sysName);
  select many sycs related by system->SLD_SCINP[R4404]->CNST_CSP[R4403]
                          ->CNST_SYC[R1504] where (selected.Name == param.a1_name);

  if (cardinality sycs > 1)
    if (param.a3_reportError)
      err_msg =  "There is more than one constant named ->" + param.a1_name + "<- in the system, cannot resolve.";
      ::clear_value_data();
      ERR::reportParseError( msg: err_msg, token: param.a2_ruleToken);
    end if;
    return GD::NULL_UNIQUE_ID();
  elif (cardinality sycs == 0)
    if (param.a3_reportError)
      ERR::reportParseError( msg: "Cannot find constant ->%s<-",
          token: param.a2_ruleToken);
    end if;
    return GD::NULL_UNIQUE_ID();
  end if;
end if;

create object instance scv of V_SCV;
for each syc in sycs
  // We only loop once due to cardinality checks earlier
  relate scv to syc across R850;
end for;

select any val from instances of V_VAL where selected.Value_ID == param.a4_valID;
if (empty val)
  create object instance newval of V_VAL;
  val = newval;
end if;
relate val to scv across R801;

current_scope = ::get_current_scope();
select any block from instances of ACT_BLK where
                                           (selected.Block_ID == current_scope);
relate val to block across R826;

select one dt related by syc->S_DT[R1500];
relate val to dt across R820;

val.LineNumber = ::getLineNumber(rule_token: param.a2_ruleToken);
val.StartPosition = ::getColumn(rule_token: param.a2_ruleToken);
val.setEndPosition();

return val.Value_ID;
end if;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4657,
	4656,
	'a1_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4658,
	4656,
	'a2_ruleToken',
	4438,
	0,
	'',
	4657,
	'');
INSERT INTO S_SPARM
	VALUES (4659,
	4656,
	'a3_reportError',
	316,
	0,
	'',
	4658,
	'');
INSERT INTO S_SPARM
	VALUES (4660,
	4656,
	'a4_valID',
	296,
	0,
	'',
	4659,
	'');
INSERT INTO S_FIP
	VALUES (4430,
	4661);
INSERT INTO S_SYNC
	VALUES (4661,
	1,
	'create_custom_token',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE

Translate: native',
	'
		Token token = new Token(p_A1_token.getType() , p_A4_text);
    	token.setLine(p_A2_line);
    	token.setColumn(p_A3_column);
    	return token;',
	4438,
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4662,
	4661,
	'a1_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4663,
	4661,
	'a2_line',
	298,
	0,
	'',
	4662,
	'');
INSERT INTO S_SPARM
	VALUES (4664,
	4661,
	'a3_column',
	298,
	0,
	'',
	4663,
	'');
INSERT INTO S_SPARM
	VALUES (4665,
	4661,
	'a4_text',
	322,
	0,
	'',
	4664,
	'');
-- BP 7.1.6 content: FunctionPackage syschar: 3 persistence-version: 7.1.6

INSERT INTO S_FPK
	VALUES (4666,
	'OAL Validation Functions',
	0,
	4397);
INSERT INTO PL_FPID
	VALUES (4666,
	1);
INSERT INTO S_FIP
	VALUES (4666,
	4667);
INSERT INTO S_SYNC
	VALUES (4667,
	1,
	'Action_start',
	'ParserValidateFunction: TRUE',
	'if ( param.a2_type == OalConstants::FUNCTION_TYPE )
  select any func from instances of S_SYNC where (selected.Sync_ID == param.a1_ruleid_name);
  if ( not_empty func )
    select one act related by func->ACT_FNB[R695]->ACT_ACT[R698];
    isDisposed = false;
    if (not_empty act and (not Util::hasSameModelRoot(nrme1:func.convertToInstance(), nrme2:act.convertToInstance() )))
       // If there are different model roots then we must dispose of the ACT_ACT and
       // create a new one because we will no longer be able to find the OAL instance
       // in the other model root.
       act.dispose();
       isDisposed = true;
	end if;
    if ( empty act or isDisposed )
      create object instance act of ACT_ACT;
      create object instance fnb of ACT_FNB;
      act.Type = "function";
      relate fnb to func across R695;
      relate fnb to act across R698;
    else
      // need to clear out current data
      act.clear_blocks();
    end if;
    act.ReturnFound = false;
    ::set_current_context(context: act.Action_ID );
    return act.Action_ID;
  end if;
elif ( param.a2_type == OalConstants::OPERATION_TYPE )
  select any tfr from instances of O_TFR where (selected.Tfr_ID == param.a1_ruleid_name);
  if ( not_empty tfr )
    select one act related by tfr->ACT_OPB[R696]->ACT_ACT[R698];
    isDisposed = false;
    if (not_empty act and (not Util::hasSameModelRoot(nrme1:tfr.convertToInstance(), nrme2:act.convertToInstance() )))
       // If there are different model roots then we must dispose of the ACT_ACT and
       // create a new one because we will no longer be able to find the OAL instance
       // in the other model root.
       act.dispose();
       isDisposed = true;
	end if;
    if ( empty act or isDisposed )
      create object instance act of ACT_ACT;
      create object instance opb of ACT_OPB;
      if ( tfr.Instance_Based == Scope::Class )
        act.Type = "class operation";
      else
        act.Type = "operation";
      end if;
      relate opb to act across R698;
      relate opb to tfr across R696;
    else
      // need to clear out current data
      act.clear_blocks();
    end if;
    act.ReturnFound = false;
    ::set_current_context(context: act.Action_ID );
    return act.Action_ID;
  end if;
elif ( param.a2_type == OalConstants::BRIDGE_TYPE )
  select any brg from instances of S_BRG where (selected.Brg_ID == param.a1_ruleid_name);
  if ( not_empty brg )
    select one act related by brg->ACT_BRB[R697]->ACT_ACT[R698];
    isDisposed = false;
    if (not_empty act and (not Util::hasSameModelRoot(nrme1:brg.convertToInstance(), nrme2:act.convertToInstance() )))
       // If there are different model roots then we must dispose of the ACT_ACT and
       // create a new one because we will no longer be able to find the OAL instance
       // in the other model root.
       act.dispose();
       isDisposed = true;
	end if;
    if ( empty act or isDisposed )
      create object instance act of ACT_ACT;
      create object instance brb of ACT_BRB;
      act.Type = "bridge";
      relate brb to brg across R697;
      relate brb to act across R698;
    else
      // need to clear out current data
      act.clear_blocks();
    end if;
    act.ReturnFound = false;
    ::set_current_context(context: act.Action_ID );
    return act.Action_ID;
  end if;
elif ( param.a2_type == OalConstants::STATE_TYPE )
  select any sm_act from instances of SM_ACT where (selected.Act_ID == param.a1_ruleid_name);
  if ( not_empty sm_act )
    select one act related by sm_act->ACT_SAB[R691]->ACT_ACT[R698];
    isDisposed = false;
    if (not_empty act and (not Util::hasSameModelRoot(nrme1:sm_act.convertToInstance(), nrme2:act.convertToInstance() )))
       // If there are different model roots then we must dispose of the ACT_ACT and
       // create a new one because we will no longer be able to find the OAL instance
       // in the other model root.
       act.dispose();
       isDisposed = true;
	end if;
    if ( empty act or isDisposed )
      create object instance act of ACT_ACT;
      create object instance sab of ACT_SAB;
      select one asm related by sm_act->SM_SM[R515]->SM_ASM[R517];
      if ( empty asm )
        act.Type = "state";
      else
        act.Type = "class state";
      end if;
      relate sab to sm_act across R691;
      relate sab to act across R698;
    else
      // need to clear out current data
      act.clear_blocks();
    end if;
    act.ReturnFound = false;
    ::set_current_context(context: act.Action_ID );
    return act.Action_ID;
  end if;
elif ( param.a2_type == OalConstants::TRANSITION_TYPE )
  select any sm_act from instances of SM_ACT where (selected.Act_ID == param.a1_ruleid_name);
  if ( not_empty sm_act )
    select one act related by sm_act->ACT_TAB[R688]->ACT_ACT[R698];
    isDisposed = false;
    if (not_empty act and (not Util::hasSameModelRoot(nrme1:sm_act.convertToInstance(), nrme2:act.convertToInstance() )))
       // If there are different model roots then we must dispose of the ACT_ACT and
       // create a new one because we will no longer be able to find the OAL instance
       // in the other model root.
       act.dispose();
       isDisposed = true;
	end if;
    if ( empty act or isDisposed )
      create object instance act of ACT_ACT;
      create object instance tab of ACT_TAB;
      select one asm related by sm_act->SM_SM[R515]->SM_ASM[R517];
      if ( empty asm )
        act.Type = "transition";
      else
        act.Type = "class transition";
      end if;
      relate tab to sm_act across R688;
      relate tab to act across R698;
    else
      // need to clear out current data
      act.clear_blocks();
    end if;
    act.ReturnFound = false;
    ::set_current_context(context: act.Action_ID );
    return act.Action_ID;
  end if;
elif ( param.a2_type == OalConstants::MDA_TYPE )
  select any dbattr from instances of O_DBATTR where (selected.Attr_ID == param.a1_ruleid_name);
  if ( not_empty dbattr )
    select one act related by dbattr->ACT_DAB[R693]->ACT_ACT[R698];
    isDisposed = false;
    if (not_empty act and (not Util::hasSameModelRoot(nrme1:dbattr.convertToInstance(), nrme2:act.convertToInstance() )))
       // If there are different model roots then we must dispose of the ACT_ACT and
       // create a new one because we will no longer be able to find the OAL instance
       // in the other model root.
       act.dispose();
       isDisposed = true;
	end if;
    if ( empty act or isDisposed )
      create object instance act of ACT_ACT;
      create object instance dab of ACT_DAB;
      act.Type = "derived attribute";
      dab.AttributeWritten = false;
      relate dab to dbattr across R693;
      relate dab to act across R698;
    else
      // need to clear out current data
      select one dab related by act->ACT_DAB[R698];
      dab.AttributeWritten = false;
      act.clear_blocks();
    end if;
    act.ReturnFound = false;
    ::set_current_context(context: act.Action_ID );
    return act.Action_ID;
  end if;
elif ( param.a2_type == OalConstants::PROV_OPERATION_TYPE )
  select any provOp from instances of SPR_PO where
               selected.Id == param.a1_ruleid_name;
  if not_empty provOp
    select one act related by provOp->ACT_POB[R687]->ACT_ACT[R698];
    if ( empty act )
      create object instance act of ACT_ACT;
      create object instance pob of ACT_POB;
      act.Type = "interface operation";
      relate pob to provOp across R687;
      relate pob to act across R698;
    else
      // need to clear out current data
      act.clear_blocks();
    end if;
    act.ReturnFound = false;
    ::set_current_context(context: act.Action_ID );
    return act.Action_ID;
  end if;
elif ( param.a2_type == OalConstants::PROV_SIGNAL_TYPE )
  select any provSig from instances of SPR_PS where
               selected.Id == param.a1_ruleid_name;
  if not_empty provSig
    select one act related by provSig->ACT_PSB[R686]->ACT_ACT[R698];
    isDisposed = false;
    if (not_empty act and (not Util::hasSameModelRoot(nrme1:provSig.convertToInstance(), nrme2:act.convertToInstance() )))
       // If there are different model roots then we must dispose of the ACT_ACT and
       // create a new one because we will no longer be able to find the OAL instance
       // in the other model root.
       act.dispose();
       isDisposed = true;
	end if;
    if ( empty act or isDisposed )
      create object instance act of ACT_ACT;
      create object instance psb of ACT_PSB;
      act.Type = "signal";
      relate psb to provSig across R686;
      relate psb to act across R698;
    else
      // need to clear out current data
      act.clear_blocks();
    end if;
    act.ReturnFound = false;
    ::set_current_context(context: act.Action_ID );
    return act.Action_ID;
  end if;
elif ( param.a2_type == OalConstants::REQ_OPERATION_TYPE )
  select any reqOp from instances of SPR_RO where
               selected.Id == param.a1_ruleid_name;
  if not_empty reqOp
    select one act related by reqOp->ACT_ROB[R685]->ACT_ACT[R698];
    isDisposed = false;
    if (not_empty act and (not Util::hasSameModelRoot(nrme1:reqOp.convertToInstance(), nrme2:act.convertToInstance() )))
       // If there are different model roots then we must dispose of the ACT_ACT and
       // create a new one because we will no longer be able to find the OAL instance
       // in the other model root.
       act.dispose();
       isDisposed = true;
	end if;
    if ( empty act or isDisposed )
      create object instance act of ACT_ACT;
      create object instance rob of ACT_ROB;
      act.Type = "interface operation";
      relate rob to reqOp across R685;
      relate rob to act across R698;
    else
      // need to clear out current data
      act.clear_blocks();
    end if;
    act.ReturnFound = false;
    ::set_current_context(context: act.Action_ID );
    return act.Action_ID;
  end if;
elif ( param.a2_type == OalConstants::REQ_SIGNAL_TYPE )
  select any reqSig from instances of SPR_RS where
               selected.Id == param.a1_ruleid_name;
  if not_empty reqSig
    select one act related by reqSig->ACT_RSB[R684]->ACT_ACT[R698];
    isDisposed = false;
    if (not_empty act and (not Util::hasSameModelRoot(nrme1:reqSig.convertToInstance(), nrme2:act.convertToInstance() )))
       // If there are different model roots then we must dispose of the ACT_ACT and
       // create a new one because we will no longer be able to find the OAL instance
       // in the other model root.
       act.dispose();
       isDisposed = true;
	end if;
    if ( empty act or isDisposed )
      create object instance act of ACT_ACT;
      create object instance rsb of ACT_RSB;
      act.Type = "signal";
      relate rsb to reqSig across R684;
      relate rsb to act across R698;
    else
      // need to clear out current data
      act.clear_blocks();
    end if;
    act.ReturnFound = false;
    ::set_current_context(context: act.Action_ID );
    return act.Action_ID;
  end if;
end if;
return param.a1_ruleid_name;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4668,
	4667,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4669,
	4667,
	'a2_type',
	4670,
	0,
	'',
	4668,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4671);
INSERT INTO S_SYNC
	VALUES (4671,
	1,
	'Block_validate',
	'ParserValidateFunction: TRUE',
	'return param.a6_current_rule_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4672,
	4671,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4673,
	4671,
	'a2_isRoot',
	316,
	0,
	'',
	4672,
	'');
INSERT INTO S_SPARM
	VALUES (4674,
	4671,
	'a4_rule_ref_id',
	296,
	0,
	'',
	4673,
	'');
INSERT INTO S_SPARM
	VALUES (4675,
	4671,
	'a5_upper_rule_id',
	296,
	0,
	'',
	4674,
	'');
INSERT INTO S_SPARM
	VALUES (4676,
	4671,
	'a6_current_rule_id',
	296,
	0,
	'',
	4675,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4677);
INSERT INTO S_SYNC
	VALUES (4677,
	1,
	'Action_end',
	'ParserValidateFunction: TRUE',
	'// ::Action_end()
nonEmptyBody = ERR::tokenHasValues(token:param.a1_rule_token);
select any act from instances of ACT_ACT where
                                   selected.Action_ID == param.a3_rule_begin_id;
select any system from instances of S_SYS
                                where (selected.Sys_ID == GD::NULL_UNIQUE_ID());
if not_empty act and act.return_is_required() and not act.ReturnFound
  select one blk related by act->ACT_BLK[R650];
  if act.Type == "bridge" 
    reportError = true;
    select one brg related by act->ACT_BRB[R698]->S_BRG[R697];
    if(not nonEmptyBody)
      select any component from instances of C_C
                          where (selected.Id == brg.getContainingComponentId());
      isRealized = false;
      if(not_empty component)
        isRealized = component.isRealized;
        select any system from instances of S_SYS
                             where (selected.Sys_ID == component.getSystemId());
      end if;
      if(empty system)
        select one package related by brg->S_EE[R19]->PE_PE[R8001]
                                                                ->EP_PKG[R8000];
        select one system related by package->S_SYS[R1405];
      end if;
      if(not isRealized)
        select one ee related by brg->S_EE[R19];
        if(not_empty ee)
          isRealized = ee.isRealized;
        end if;
      end if;
      emptyNonRealizedCheck = PREF::getSystemBoolean(
            name:"bridgepoint_prefs_enable_error_for_empty_synchronous_message", systemName:system.Name);
      emptyRealizedCheck = PREF::getSystemBoolean(
                    name:"bridgepoint_prefs_enable_error_for_empty_synchronous_message_realized", systemName:system.Name);
      reportError = (not isRealized and emptyNonRealizedCheck)
                                         or (isRealized and emptyRealizedCheck);
    end if;
    if(reportError)
      ERR::reportParseError( msg: "Return value required by " + act.Type, token: param.a1_rule_token );
    end if;
  elif  act.Type == "interface operation"
    select one reqBody related by act->ACT_ROB[R698];
    select one proBody related by act->ACT_POB[R698];
    msgDirection = IFDirectionType::ClientServer;
    if not_empty reqBody // Required Operation
    	 select one reqOpr related by reqBody->SPR_RO[R685];
    	 select one reqExPro related by reqOpr->SPR_REP[R4502];
    	 select one exProp related by reqExPro->C_EP[R4500];
    	 select one intOpr related by exProp->C_IO[R4004];
    	 select any component from instances of C_C
    	              where (selected.Id == reqBody.getContainingComponentId());
    	 // If the port is delegated, then skip reporting "missing return statement" error
    	 select any delegated related by reqExPro->C_R[R4500]->C_IR[R4009]->C_RID[R4013]; 
    	 msgDirection = intOpr.Direction;
    	 if  ((empty delegated) and (msgDirection == IFDirectionType::ServerClient)) //From Provided
    	   reportError = true;
           if(not nonEmptyBody)
             isRealized = false;
             if(not_empty component)
               isRealized = component.isRealized;
               select any system from instances of S_SYS
                             where (selected.Sys_ID == component.getSystemId());
             end if;
             emptyNonRealizedCheck = PREF::getSystemBoolean(
                             name:"bridgepoint_prefs_enable_error_for_empty_synchronous_message", systemName:system.Name);
             emptyRealizedCheck = PREF::getSystemBoolean(
                    name:"bridgepoint_prefs_enable_error_for_empty_synchronous_message_realized", systemName:system.Name);
             reportError = (not isRealized and emptyNonRealizedCheck)
                                         or (isRealized and emptyRealizedCheck);
           end if;
           if(reportError)
  			 ERR::reportParseError( msg: "Return value required by " + act.Type,
                                                   token: param.a1_rule_token );
           end if;
    	 end if;       
    elif not_empty proBody // Provided Operation
    	 select one proOpr related by proBody->SPR_PO[R687];
    	 select one proExPro related by proOpr->SPR_PEP[R4503];
    	 select one exProp related by proExPro->C_EP[R4501];
    	 select one intOpr related by exProp->C_IO[R4004];
         select any component from instances of C_C
                      where (selected.Id == proBody.getContainingComponentId());
    	 // If the port is delegated, then skip reporting "missing return statement" error
    	 select any delegated related by proExPro->C_P[R4501]->C_IR[R4009]->C_RID[R4013];
    	 msgDirection = intOpr.Direction; 
    	 if ((empty delegated) and (msgDirection  == IFDirectionType::ClientServer)) // To Provided
    	   reportError = true;
           if(not nonEmptyBody)
             isRealized = false;
             if(not_empty component)
               isRealized = component.isRealized;
               select any system from instances of S_SYS
                             where (selected.Sys_ID == component.getSystemId());
             end if;
             emptyNonRealizedCheck = PREF::getSystemBoolean(
                             name:"bridgepoint_prefs_enable_error_for_empty_synchronous_message", systemName:system.Name);
             emptyRealizedCheck = PREF::getSystemBoolean(
                    name:"bridgepoint_prefs_enable_error_for_empty_synchronous_message_realized", systemName:system.Name);
             reportError = (not isRealized and emptyNonRealizedCheck)
                                         or (isRealized and emptyRealizedCheck);
           end if;
           if(reportError)
  			 ERR::reportParseError( msg: "Return value required by " + act.Type,
                                                   token: param.a1_rule_token );
           end if;

    	 end if;
    end if;
  else
    reportError = true;
    select any component from instances of C_C
                                    where (selected.Id == GD::NULL_UNIQUE_ID());
    select one function related by act->ACT_FNB[R698]->S_SYNC[R695];
    select one operation related by act->ACT_OPB[R698]->O_TFR[R696];
    if(not_empty operation)
      select any component from instances of C_C
                    where (selected.Id == operation.getContainingComponentId());
      if(empty component)
        select one package related by operation->O_OBJ[R115]
                                                  ->PE_PE[R8001]->EP_PKG[R8000];
        select one system related by package->S_SYS[R1405];
      end if;
    end if;
    if(not_empty function)
      select any component from instances of C_C
                    where (selected.Id == function.getContainingComponentId());
      if(empty component)
        select one package related by function->PE_PE[R8001]->EP_PKG[R8000];
        select one system related by package->S_SYS[R1405];
      end if;
    end if;
    if(not nonEmptyBody)
      isRealized = false;
      if(not_empty component)
        isRealized = component.isRealized;
        select any system from instances of S_SYS
                             where (selected.Sys_ID == component.getSystemId());
      end if;
      emptyNonRealizedCheck = PREF::getSystemBoolean(
                             name:"bridgepoint_prefs_enable_error_for_empty_synchronous_message", systemName:system.Name);
      emptyRealizedCheck = PREF::getSystemBoolean(
                    name:"bridgepoint_prefs_enable_error_for_empty_synchronous_message_realized", systemName:system.Name);
      reportError = (not isRealized and emptyNonRealizedCheck)
                                         or (isRealized and emptyRealizedCheck);
    end if;
    if(reportError)
  	  ERR::reportParseError( msg: "Return value required by " + act.Type,
                                                   token: param.a1_rule_token );
    end if;
  end if;
end if;
select one dab related by act->ACT_DAB[R698];
if ( not empty dab )
  if ( not dab.AttributeWritten )
    select one mdattr related by dab->O_DBATTR[R693]->
                                                    O_BATTR[R107]->O_ATTR[R106];
    ERR::reportParseError( 
        msg: "You must assign a value to the derived attribute self." +
                                      mdattr.Name, token: param.a1_rule_token );
  end if;
end if;
return param.a4_rule_id;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4678,
	4677,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4679,
	4677,
	'a2_upper_rule_id',
	296,
	0,
	'',
	4678,
	'');
INSERT INTO S_SPARM
	VALUES (4680,
	4677,
	'a3_rule_begin_id',
	296,
	0,
	'',
	4679,
	'');
INSERT INTO S_SPARM
	VALUES (4681,
	4677,
	'a4_rule_id',
	296,
	0,
	'',
	4680,
	'');
INSERT INTO S_SPARM
	VALUES (4682,
	4677,
	'b1_block1_id',
	296,
	0,
	'',
	4681,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4683);
INSERT INTO S_SYNC
	VALUES (4683,
	1,
	'Block_start',
	'ParserValidateFunction: TRUE',
	'if ( param.a2_isRoot)
  select any act from instances of ACT_ACT where (selected.Action_ID == param.a1_ruleid_name);
  if ( not_empty act )
    create object instance blk of ACT_BLK;
    relate blk to act across R612;
    select one first_blk related by act->ACT_BLK[R650];
    if ( empty first_blk )
     // we expect this to be empty
      relate blk to act across R650;
    end if;
    relate blk to act across R699;
    return blk.Block_ID;
  end if;
else
  select any stmt from instances of ACT_SMT 
      where (selected.Statement_ID == param.a1_ruleid_name);
  if ( not_empty stmt )
    create object instance blk of ACT_BLK;
    select one whl related by stmt->ACT_WHL[R603];
    if ( not_empty whl )
      relate blk to whl across R608;
    else
      select one for_stmt related by stmt->ACT_FOR[R603];
      if ( not_empty for_stmt )
        relate blk to for_stmt across R605;
      else
        select one if_stmt related by stmt->ACT_IF[R603];
        if ( not_empty if_stmt )
          select one if_blk related by if_stmt->ACT_BLK[R607];
          if (not_empty if_blk)
            // the currently associated block is an elif or else and
            // it will be hooked to the correct parsed element in
            // if_statement_end (else) or in if_statement_loop3_end (elif).
            // just unrelate it here . . . . 
            unrelate if_stmt from if_blk across R607;
          end if;
          relate blk to if_stmt across R607;
        else
          // internal error
          return GD::NULL_UNIQUE_ID();
        end if;
      end if;
    end if;
    select one enclosing_blk related by stmt->ACT_BLK[R602];
    select one act related by enclosing_blk->ACT_ACT[R699];
    if empty act
      // internal error - enclosing block association is inconsistent with current scope
      return GD::NULL_UNIQUE_ID();
    else
      unrelate enclosing_blk from act across R699;
      relate blk to act across R699;
      relate blk to act across R612;
      return blk.Block_ID;
    end if;
  end if;
end if;
return param.a1_ruleid_name;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4684,
	4683,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4685,
	4683,
	'a2_isRoot',
	316,
	0,
	'',
	4684,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4686);
INSERT INTO S_SYNC
	VALUES (4686,
	1,
	'Block_loop1_start',
	'ParserValidateFunction: TRUE',
	'return param.a2_rule_begin_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4687,
	4686,
	'a1_upper_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4688,
	4686,
	'a2_rule_begin_id',
	296,
	0,
	'',
	4687,
	'');
INSERT INTO S_SPARM
	VALUES (4689,
	4686,
	'a3_current_rule_id',
	296,
	0,
	'',
	4688,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4690);
INSERT INTO S_SYNC
	VALUES (4690,
	1,
	'Statement_validate',
	'ParserValidateFunction: TRUE',
	'select any stmt from instances of ACT_SMT 
      where ( selected.Statement_ID == param.a6_current_rule_id );
if ( not_empty stmt )
  select one if_stmt related by stmt->ACT_IF[R603];
  select one elif_stmt related by stmt->ACT_E[R603];
  select one else_stmt related by stmt->ACT_EL[R603];
  // the if statement handles the numbering itself
  if ( empty if_stmt and empty elif_stmt and empty else_stmt )
    select one blk related by stmt->ACT_BLK[R602];
    stmt.LineNumber = blk.CurrentLine;
    stmt.StartPosition = blk.CurrentCol;
  end if;
end if;
return param.a6_current_rule_id;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4691,
	4690,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4692,
	4690,
	'a3_text',
	322,
	0,
	'',
	4691,
	'');
INSERT INTO S_SPARM
	VALUES (4693,
	4690,
	'a4_rule_ref_id',
	296,
	0,
	'',
	4692,
	'');
INSERT INTO S_SPARM
	VALUES (4694,
	4690,
	'a5_upper_rule_id',
	296,
	0,
	'',
	4693,
	'');
INSERT INTO S_SPARM
	VALUES (4695,
	4690,
	'a6_current_rule_id',
	296,
	0,
	'',
	4694,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4696);
INSERT INTO S_SYNC
	VALUES (4696,
	1,
	'Block_loop1_end',
	'ParserValidateFunction: TRUE',
	'return param.a3_ruleid_name;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4697,
	4696,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4698,
	4696,
	'a2_upper_ruleid_name',
	296,
	0,
	'',
	4697,
	'');
INSERT INTO S_SPARM
	VALUES (4699,
	4696,
	'a3_ruleid_name',
	296,
	0,
	'',
	4698,
	'');
INSERT INTO S_SPARM
	VALUES (4700,
	4696,
	'a4_loop_id_name',
	296,
	0,
	'',
	4699,
	'');
INSERT INTO S_SPARM
	VALUES (4701,
	4696,
	'b1_statement3_id',
	296,
	0,
	'',
	4700,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4702);
INSERT INTO S_SYNC
	VALUES (4702,
	1,
	'Block_end',
	'ParserValidateFunction: TRUE',
	'
select any block from instances of ACT_BLK
    where ( selected.Block_ID == param.a3_rule_begin_id );

encl_block_id = ::get_enclosing_block( block_id: param.a3_rule_begin_id, rule_token: param.a1_rule_token );

select any enclosing_block from instances of ACT_BLK
        where ( selected.Block_ID == encl_block_id );

select one act related by block->ACT_ACT[R699];
if ( empty act )
   ERR::reportParseError( 
      msg: "Current block not marked as having current scope.",
      token: param.a1_rule_token );
end if;  

unrelate block from act across R699;

if ( not_empty enclosing_block )
  select one act2 related by block->ACT_ACT[R699];
  if ( not_empty act2 )
     ERR::reportParseError( 
        msg: "Non-current block marked as having current scope.",
        token: param.a1_rule_token );
  end if;  
  relate enclosing_block to act across R699;
end if;

return param.a4_rule_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4703,
	4702,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4704,
	4702,
	'a2_upper_rule_id',
	296,
	0,
	'',
	4703,
	'');
INSERT INTO S_SPARM
	VALUES (4705,
	4702,
	'a3_rule_begin_id',
	296,
	0,
	'',
	4704,
	'');
INSERT INTO S_SPARM
	VALUES (4706,
	4702,
	'a4_rule_id',
	296,
	0,
	'',
	4705,
	'');
INSERT INTO S_SPARM
	VALUES (4707,
	4702,
	'b1_statement3_id',
	296,
	0,
	'',
	4706,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4708);
INSERT INTO S_SYNC
	VALUES (4708,
	1,
	'Assignment_statement_start',
	'ParserValidateFunction: TRUE',
	'return ::statement_create();
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4709,
	4708,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4710);
INSERT INTO S_SYNC
	VALUES (4710,
	1,
	'Assignment_expr_validate',
	'ParserValidateFunction: TRUE',
	'return param.a6_current_rule_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4711,
	4710,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4712,
	4710,
	'a3_text',
	322,
	0,
	'',
	4711,
	'');
INSERT INTO S_SPARM
	VALUES (4713,
	4710,
	'a4_rule_ref_id',
	296,
	0,
	'',
	4712,
	'');
INSERT INTO S_SPARM
	VALUES (4714,
	4710,
	'a5_upper_rule_id',
	296,
	0,
	'',
	4713,
	'');
INSERT INTO S_SPARM
	VALUES (4715,
	4710,
	'a6_current_rule_id',
	296,
	0,
	'',
	4714,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4716);
INSERT INTO S_SYNC
	VALUES (4716,
	1,
	'Assignment_statement_end',
	'ParserValidateFunction: TRUE',
	'if ( param.b1_assignment_expr1_id == GD::NULL_UNIQUE_ID() )
  select any stmt from instances of ACT_SMT 
      where ( selected.Statement_ID == param.a3_rule_begin_id );
  if ( not_empty stmt )
    stmt.dispose();
  end if;
end if;
return param.a3_rule_begin_id;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4717,
	4716,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4718,
	4716,
	'a2_upper_rule_id',
	296,
	0,
	'',
	4717,
	'');
INSERT INTO S_SPARM
	VALUES (4719,
	4716,
	'a3_rule_begin_id',
	296,
	0,
	'',
	4718,
	'');
INSERT INTO S_SPARM
	VALUES (4720,
	4716,
	'a4_rule_id',
	296,
	0,
	'',
	4719,
	'');
INSERT INTO S_SPARM
	VALUES (4721,
	4716,
	'b1_assignment_expr1_id',
	296,
	0,
	'',
	4720,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4722);
INSERT INTO S_SYNC
	VALUES (4722,
	1,
	'Break_statement_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;

',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4723,
	4722,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4724);
INSERT INTO S_SYNC
	VALUES (4724,
	1,
	'Break_statement_end',
	'ParserValidateFunction: TRUE',
	'
current_scope = ::get_current_scope();
select any blk from instances of ACT_BLK where (selected.Block_ID == current_scope);
select one act related by blk->ACT_ACT[R612];
if ( not act.in_loop() )
  ERR::reportParseError( msg: "Break statement can only be used in WHILE and FOR EACH block",
       token: param.a1_rule_token );
else
  stmt_id =  ::statement_create();
  select any stmt from instances of ACT_SMT where selected.Statement_ID == stmt_id;
  create object instance brk of ACT_BRK;
  relate brk to stmt across R603;

  return stmt.Statement_ID;
end if;

return GD::NULL_UNIQUE_ID();


',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4725,
	4724,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4726,
	4724,
	'a2_upper_rule_id',
	296,
	0,
	'',
	4725,
	'');
INSERT INTO S_SPARM
	VALUES (4727,
	4724,
	'a3_rule_begin_id',
	296,
	0,
	'',
	4726,
	'');
INSERT INTO S_SPARM
	VALUES (4728,
	4724,
	'a4_rule_id',
	296,
	0,
	'',
	4727,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4729);
INSERT INTO S_SYNC
	VALUES (4729,
	1,
	'Bridge_statement_start',
	'ParserValidateFunction: TRUE',
	'return ::statement_create();
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4730,
	4729,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4731);
INSERT INTO S_SYNC
	VALUES (4731,
	1,
	'Local_variable_validate',
	'ParserValidateFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// ::Local_variable_validate()
::self_validate( a1_text: param.a3_text, a2_isLval: param.a2_isLval,
                                                a3_token: param.a1_rule_token );
::sender_validate( a1_name: param.a3_text, a2_isLval: param.a2_isLval,
                                                a3_token: param.a1_rule_token );
if (::selected_validate( name:param.a3_text, rule_token: param.a1_rule_token ))
  // selected is always an r-value
  current_scope = ::get_current_scope();
  select any blk from instances of ACT_BLK where
                                             selected.Block_ID == current_scope;
  blk.SelectedFound = true;
  create object instance val_inst of V_VAL;
  create object instance slr of V_SLR;
  relate slr to val_inst across R801;
  select any dom from instances of S_DOM where
                                     selected.Dom_ID == ::getValidationDomain();
  select any val_dt related by dom->S_DT[R14] where
                                            selected.Name == "inst_ref<Object>";
  if empty val_dt
    cur_sys_name = ::getSystemName();
    select any sys from instances of S_SYS where selected.Name == cur_sys_name;
    dt_id = GD::NULL_UNIQUE_ID();
    if not_empty sys
      dt_id = sys.getCoreTypeId(name:"inst_ref<Object>");
    end if;
    select any pe from instances of PE_PE where selected.Element_ID == dt_id;
    select one val_dt related by pe->S_DT[R8001]; 
  end if;
  if ( not_empty val_dt )
    relate val_inst to val_dt across R820;
  else
    USER::logError(msg: "Internal Error in OAL Validation Function " +
      "Local_variable_validate().  Variable <val_dt> is empty.",path:"PathNotProvided");
  end if;
  relate val_inst to blk across R826;
  return val_inst.Value_ID;
end if;
var_id = ::get_var_in_scope( name: param.a3_text,
                                              rule_token: param.a1_rule_token );
if ( var_id == GD::NULL_UNIQUE_ID() and not param.a2_isLval )
   ::clear_value_data();
   ERR::reportParseError( msg:
           "Variable ->%s<- used in context where it must already exist.",
                                                   token: param.a1_rule_token );
end if;
if (param.a2_isLval)
  if ( var_id != GD::NULL_UNIQUE_ID() )
    select any var_inst from instances of V_VAR where selected.Var_ID == var_id;
    l = ::getLineNumber(rule_token: param.a1_rule_token);
    c = ::getColumn(rule_token: param.a1_rule_token);
    var_inst.addLocation(line: l, col: c );
  else
    current_scope = ::get_current_scope();
    if ( current_scope == GD::NULL_UNIQUE_ID() )
      ERR::reportParseError( msg:
              "Unable to determine context to define variable ->%s<-.  ",
                                                   token: param.a1_rule_token );
    else
      select any block from instances of ACT_BLK where
                                             selected.Block_ID == current_scope;
      create object instance trn of V_TRN;
      create object instance var_inst of V_VAR;
      var_inst.Name = param.a3_text;
      l = ::getLineNumber(rule_token: param.a1_rule_token);
      c = ::getColumn(rule_token: param.a1_rule_token);
      var_inst.addLocation(line: l, col: c );
      relate trn to var_inst across R814;
      relate var_inst to block across R823;
      var_id = var_inst.Var_ID;
    end if;
  end if;
else // r-value
  select any var_inst from instances of V_VAR where selected.Var_ID == var_id;
  select one var_dt related by var_inst->S_DT[R848];
  if ( empty var_dt )
    select one inst related by var_inst->V_INT[R814];
    select any dom from instances of S_DOM where
                                     selected.Dom_ID == ::getValidationDomain();
    if ( not_empty inst )
      select any var_dt related by dom->S_DT[R14] where
                                            selected.Name == "inst_ref<Object>";
      if empty var_dt
        cur_sys_name = ::getSystemName();
        select any sys from instances of S_SYS where
                                                  selected.Name == cur_sys_name;
        dt_id = GD::NULL_UNIQUE_ID();
        if not_empty sys
          dt_id = sys.getCoreTypeId(name:"inst_ref<Object>");
        end if;
        select any pe from instances of PE_PE where selected.Element_ID == dt_id;
        select one var_dt related by pe->S_DT[R8001]; 
        if empty var_dt
          USER::logError(msg: "Internal Error in OAL Validation Function " +
            "Local_variable_validate().  Variable <var_dt> is empty.",path:"PathNotProvided");
        end if;
      end if;
    else
      select one inst_set related by var_inst->V_INS[R814];
      if ( not_empty inst_set )
        select any var_dt related by dom->S_DT[R14] where
                                        selected.Name == "inst_ref_set<Object>";
        if empty var_dt
          cur_sys_name = ::getSystemName();
          select any sys from instances of S_SYS where
                                                  selected.Name == cur_sys_name;
          dt_id = GD::NULL_UNIQUE_ID();
          if not_empty sys
            dt_id = sys.getCoreTypeId(name:"inst_ref_set<Object>");
          end if;
          select any pe from instances of PE_PE where selected.Element_ID == dt_id;
          select one var_dt related by pe->S_DT[R8001]; 
          if empty var_dt
            USER::logError(msg: "Internal Error in OAL Validation Function " +
               "Local_variable_validate().  Variable <var_dt> (set) is empty.",path:"PathNotProvided");
          end if;
        end if;
      else
        ERR::reportParseError( msg:
                "Variable ->%s<- has not been data typed yet.  ",
                                                   token: param.a1_rule_token );
      end if;
    end if;
  end if;
  if ( not_empty var_dt )
    create object instance val of V_VAL;
    current_scope = ::get_current_scope();
    select any blk from instances of ACT_BLK where
                                             selected.Block_ID == current_scope;
    relate val to blk across R826;
    /* TODO -
    orig code: if ( var_dt.Name == "inst_ref<Object>" )

    Does this need to prevent inst_ref<Timer> and inst_ref<Mapping>?
    */
    if ( ::has_substring(p1_base: var_dt.Name, p2_str: "inst_ref<", p3_fromIndex: 0) )
      create object instance t_val of V_IRF;
      relate val to t_val across R801;
      relate t_val to var_inst across R808;
    elif ( ::has_substring(p1_base: var_dt.Name, p2_str: "inst_ref_set<", p3_fromIndex: 0) )
      create object instance t_val of V_ISR;
      relate val to t_val across R801;
      relate t_val to var_inst across R809;
    else
      create object instance t_val of V_TVL;
      relate val to t_val across R801;
      relate t_val to var_inst across R805;
    end if;
    relate val to var_dt across R820;
    val.LineNumber = ::getLineNumber(rule_token: param.a1_rule_token);
    val.StartPosition = ::getColumn(rule_token: param.a1_rule_token);
    val.setEndPosition();
    return val.Value_ID;
  end if;
end if;
return var_id;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4732,
	4731,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4733,
	4731,
	'a2_isLval',
	316,
	0,
	'',
	4732,
	'');
INSERT INTO S_SPARM
	VALUES (4734,
	4731,
	'a3_text',
	322,
	0,
	'',
	4733,
	'');
INSERT INTO S_SPARM
	VALUES (4735,
	4731,
	'a4_rule_ref_id',
	296,
	0,
	'',
	4734,
	'');
INSERT INTO S_SPARM
	VALUES (4736,
	4731,
	'a5_upper_rule_id',
	296,
	0,
	'',
	4735,
	'');
INSERT INTO S_SPARM
	VALUES (4737,
	4731,
	'a6_current_rule_id',
	296,
	0,
	'',
	4736,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4738);
INSERT INTO S_SYNC
	VALUES (4738,
	1,
	'Param_data_access_validate',
	'ParserValidateFunction: TRUE',
	'// ::Param_data_access_validate()
return ::param_validate(a1_rule_token:param.a1_rule_token,
                   a3_text:param.a3_text, b1_value_id:param.a6_current_rule_id);',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4739,
	4738,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4740,
	4738,
	'a2_isLval',
	316,
	0,
	'',
	4739,
	'');
INSERT INTO S_SPARM
	VALUES (4741,
	4738,
	'a3_text',
	322,
	0,
	'',
	4740,
	'');
INSERT INTO S_SPARM
	VALUES (4742,
	4738,
	'a4_rule_ref_id',
	296,
	0,
	'',
	4741,
	'');
INSERT INTO S_SPARM
	VALUES (4743,
	4738,
	'a5_upper_rule_id',
	296,
	0,
	'',
	4742,
	'');
INSERT INTO S_SPARM
	VALUES (4744,
	4738,
	'a6_current_rule_id',
	296,
	0,
	'',
	4743,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4745);
INSERT INTO S_SYNC
	VALUES (4745,
	1,
	'Bridge_invocation_validate',
	'ParserValidateFunction: TRUE',
	'if ( param.a6_current_rule_id != GD::NULL_UNIQUE_ID() )
  select any val from instances of V_VAL where selected.Value_ID == param.a6_current_rule_id;
  if ( not_empty val )
    select one sdt related by val->S_DT[R820];
    if ( empty sdt )
      ERR::reportParseError( msg: "Value has unknown data type",
           token: param.a1_rule_token );
    else
      select one brg related by val->V_BRV[R801]->S_BRG[R828];
      if ( not_empty brg )
        return ::is_valid_invocation( a1_type: sdt.Name, a2_isRval: param.a2_isRval, a3_id: param.a6_current_rule_id,
            a4_name: "Bridge ->"  + brg.Name, a5_rule_token: param.a1_rule_token );
      end if;
    end if;
  end if;
end if;

return GD::NULL_UNIQUE_ID();












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4746,
	4745,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4747,
	4745,
	'a2_isRval',
	316,
	0,
	'',
	4746,
	'');
INSERT INTO S_SPARM
	VALUES (4748,
	4745,
	'a3_text',
	322,
	0,
	'',
	4747,
	'');
INSERT INTO S_SPARM
	VALUES (4749,
	4745,
	'a4_rule_ref_id',
	296,
	0,
	'',
	4748,
	'');
INSERT INTO S_SPARM
	VALUES (4750,
	4745,
	'a5_upper_rule_id',
	296,
	0,
	'',
	4749,
	'');
INSERT INTO S_SPARM
	VALUES (4751,
	4745,
	'a6_current_rule_id',
	296,
	0,
	'',
	4750,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4752);
INSERT INTO S_SYNC
	VALUES (4752,
	1,
	'Bridge_statement_end',
	'ParserValidateFunction: TRUE',
	'select any val from instances of V_VAL
       where ( selected.Value_ID == param.b4_bridge_invocation4_id );
if ( empty val )
  select any val from instances of V_VAL 
         where ( selected.Value_ID == param.b5_bridge_invocation5_id );
end if;
if ( empty val )
  // there was a problem with parsing the value
  select any stmt from instances of ACT_SMT 
        where selected.Statement_ID == param.a3_rule_begin_id;
  stmt.dispose();
  return GD::NULL_UNIQUE_ID();
end if;
if (  param.b1_member1_id != GD::NULL_UNIQUE_ID() )
  return ::Assignment_expr_end( a1_rule_token: param.a1_rule_token, 
      a2_upper_rule_id: param.a3_rule_begin_id,
      a3_rule_begin_id: param.a3_rule_begin_id,
      a4_rule_id: param.a4_rule_id,
      b1_member_id: param.b1_member1_id,
      b2_expr2_id: param.b4_bridge_invocation4_id,
      b3_param_data_access3_id: GD::NULL_UNIQUE_ID(),
      b4_expr4_id: GD::NULL_UNIQUE_ID()
  );
elif (  param.b3_param_data_access3_id != GD::NULL_UNIQUE_ID() )
  // this creates a statement with an AssignToParameter subtype
  return ::Assignment_expr_end( a1_rule_token: param.a1_rule_token, 
        a2_upper_rule_id: param.a3_rule_begin_id,
        a3_rule_begin_id: param.a3_rule_begin_id,
        a4_rule_id: param.a4_rule_id,
        b1_member_id: GD::NULL_UNIQUE_ID(),
        b2_expr2_id: GD::NULL_UNIQUE_ID(),
        b3_param_data_access3_id: param.b3_param_data_access3_id,
        b4_expr4_id: param.b4_bridge_invocation4_id
  );
else
  select any stmt from instances of ACT_SMT 
                          where selected.Statement_ID == param.a3_rule_begin_id;
  create object instance abrg of ACT_BRG;
  relate stmt to abrg across R603;
  select one brv related by val->V_BRV[R801];
  select one brg related by brv->S_BRG[R828];
  select many parm_set related by brv->V_PAR[R810];
  unrelate brg from brv across R828;
  relate brg to abrg across R674;
	// store the textual position of the bridge name
	abrg.bridgeNameLineNumber = val.LineNumber;
	abrg.bridgeNameColumn = val.StartPosition;
	// store the textual position of the external-entity key-letters; use the 
	// value that is in the bridge-value instance that was created 
	// when the bridge''''s named was parsed, rather than the value in the 
	// current block, since the latter may have been overwritten
	// during the parsing of the bridge''s parameters 
	abrg.externalEntityKeyLettersLineNumber =
	                                     brv.externalEntityKeyLettersLineNumber;
	abrg.externalEntityKeyLettersColumn = brv.externalEntityKeyLettersColumn;
  for each parm in parm_set
    unrelate parm from brv across R810;
    relate parm to abrg across R628;
  end for;
  val.dispose();
  return stmt.Statement_ID;
end if;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4753,
	4752,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4754,
	4752,
	'a2_upper_rule_id',
	296,
	0,
	'',
	4753,
	'');
INSERT INTO S_SPARM
	VALUES (4755,
	4752,
	'a3_rule_begin_id',
	296,
	0,
	'',
	4754,
	'');
INSERT INTO S_SPARM
	VALUES (4756,
	4752,
	'a4_rule_id',
	296,
	0,
	'',
	4755,
	'');
INSERT INTO S_SPARM
	VALUES (4757,
	4752,
	'b1_member1_id',
	296,
	0,
	'',
	4756,
	'');
INSERT INTO S_SPARM
	VALUES (4758,
	4752,
	'b3_param_data_access3_id',
	296,
	0,
	'',
	4757,
	'');
INSERT INTO S_SPARM
	VALUES (4759,
	4752,
	'b4_bridge_invocation4_id',
	296,
	0,
	'',
	4758,
	'');
INSERT INTO S_SPARM
	VALUES (4760,
	4752,
	'b5_bridge_invocation5_id',
	296,
	0,
	'',
	4759,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4761);
INSERT INTO S_SYNC
	VALUES (4761,
	1,
	'Control_statement_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4762,
	4761,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4763);
INSERT INTO S_SYNC
	VALUES (4763,
	1,
	'Control_statement_end',
	'ParserValidateFunction: TRUE',
	'stmt_id = ::statement_create();
select any stmt from instances of ACT_SMT where selected.Statement_ID == stmt_id;
if ( not_empty stmt )
  create object instance ctl of ACT_CTL;
  relate stmt to ctl across R603;

  return stmt_id;
end if;
return param.a4_rule_id;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4764,
	4763,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4765,
	4763,
	'a2_upper_rule_id',
	296,
	0,
	'',
	4764,
	'');
INSERT INTO S_SPARM
	VALUES (4766,
	4763,
	'a3_rule_begin_id',
	296,
	0,
	'',
	4765,
	'');
INSERT INTO S_SPARM
	VALUES (4767,
	4763,
	'a4_rule_id',
	296,
	0,
	'',
	4766,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4768);
INSERT INTO S_SYNC
	VALUES (4768,
	1,
	'Continue_statement_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4769,
	4768,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4770);
INSERT INTO S_SYNC
	VALUES (4770,
	1,
	'Continue_statement_end',
	'ParserValidateFunction: TRUE',
	'
current_scope = ::get_current_scope();
select any blk from instances of ACT_BLK where (selected.Block_ID == current_scope);
select one act related by blk->ACT_ACT[R612];
if ( not act.in_loop() )
  ERR::reportParseError( msg: "Continue statement can only be used in WHILE and FOR EACH block",
       token: param.a1_rule_token );
else
  stmt_id =  ::statement_create();
  select any stmt from instances of ACT_SMT where selected.Statement_ID == stmt_id;
  create object instance con of ACT_CON;
  relate con to stmt across R603;

  return stmt.Statement_ID;
end if;

return GD::NULL_UNIQUE_ID();
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4771,
	4770,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4772,
	4770,
	'a2_upper_rule_id',
	296,
	0,
	'',
	4771,
	'');
INSERT INTO S_SPARM
	VALUES (4773,
	4770,
	'a3_rule_begin_id',
	296,
	0,
	'',
	4772,
	'');
INSERT INTO S_SPARM
	VALUES (4774,
	4770,
	'a4_rule_id',
	296,
	0,
	'',
	4773,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4775);
INSERT INTO S_SYNC
	VALUES (4775,
	1,
	'Create_event_statement_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4776,
	4775,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4777);
INSERT INTO S_SYNC
	VALUES (4777,
	1,
	'Event_spec_validate',
	'ParserValidateFunction: TRUE',
	'// store the textual position of the event target''s key-letters
select any eventSpec from instances of E_ESS 
	where selected.Statement_ID == param.a6_current_rule_id;
current_scope = ::get_current_scope();
select any block from instances of ACT_BLK where (selected.Block_ID == current_scope);
eventSpec.eventTargetKeyLettersLineNumber = block.currentKeyLettersLineNumber;
eventSpec.eventTargetKeyLettersColumn = block.currentKeyLettersColumn;

return param.a6_current_rule_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4778,
	4777,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4779,
	4777,
	'a3_text',
	322,
	0,
	'',
	4778,
	'');
INSERT INTO S_SPARM
	VALUES (4780,
	4777,
	'a4_rule_ref_id',
	296,
	0,
	'',
	4779,
	'');
INSERT INTO S_SPARM
	VALUES (4781,
	4777,
	'a5_upper_rule_id',
	296,
	0,
	'',
	4780,
	'');
INSERT INTO S_SPARM
	VALUES (4782,
	4777,
	'a6_current_rule_id',
	296,
	0,
	'',
	4781,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4783);
INSERT INTO S_SYNC
	VALUES (4783,
	1,
	'Create_event_statement_end',
	'ParserValidateFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any gen_stmt from instances of ACT_SMT
      where ( selected.Statement_ID == param.b2_event_spec2_id );
select any var from instances of V_VAR where ( selected.Var_ID == param.b1_local_variable1_id );
if ( empty gen_stmt )
  select any ess from instances of ACT_SMT where ( selected.Statement_ID == param.a4_rule_id );
  if ( not_empty ess )
    ess.dispose();
   end if;
  if ( not_empty var )
    if ( not var.Declared )
      var.dispose();
    end if;
  end if;
  // the error has already been output
  return GD::NULL_UNIQUE_ID();
end if;

assign_ok = true;
err_msg = "";
if ( param.b1_local_variable1_id != GD::NULL_UNIQUE_ID() )
  if ( var.Declared )
    select one trn related by var->V_TRN[R814];
    if ( not_empty trn )
      select one dt related by var->S_DT[R848];
        if (dt.Name != "inst<Event>" )
          assign_ok = false;
          err_msg = "Variable ->"+ var.Name +"<- already exists as a different type";
        end if;
    else
      err_msg = "Variable ->"+ var.Name +"<- already exists as a different type";
      assign_ok = false;
    end if;
  end if;
end if;

if ( not assign_ok )
  gen_stmt.dispose();
  ::clear_value_data();
  ERR::reportParseError( msg: err_msg,
          token: param.a1_rule_token );
else
  // migrate the generate statement to a create statement
  select one ess related by gen_stmt->E_ESS[R603];
  select one ges related by ess->E_GES[R701];
  unrelate ges from ess across R701;
  create object instance ces of E_CES;
  relate ces to ess across R701;
  relate ces to var across R710;
  if ( not var.Declared )
    ces.is_implicit = true;
    select any dom from instances of S_DOM where selected.Dom_ID == ::getValidationDomain();
    select any dt related by dom->S_DT[R14] where
                                                 selected.Name == "inst<Event>";
    if empty dt
      cur_sys_name = ::getSystemName();
      select any sys from instances of S_SYS where selected.Name == cur_sys_name;
      dt_id = GD::NULL_UNIQUE_ID();
      if not_empty sys
        dt_id = sys.getCoreTypeId(name:"inst<Event>");
      end if;
      select any pe from instances of PE_PE where selected.Element_ID == dt_id;
      select one dt related by pe->S_DT[R8001]; 
    end if;
    select one trn related by var->V_TRN[R814];
    if ( not_empty dt )
      relate var to dt across R848;
    else
      select one body related by var->ACT_BLK[R823]->ACT_ACT[R601];
      pathMsg = "<No Path Available - Empty instance>";
    if (not_empty body)
      pathMsg = body.getPath();
    end if;
	USER::logError(msg: "Internal Error in OAL Validation Function " +
        "Create_event_statement_end().  Variable <dt> is empty.",path:pathMsg);
    end if;
    var.Declared = true;
  end if;

  select one gsme related by ges->E_GSME[R703];
  if ( not_empty gsme )
    create object instance csme of E_CSME;
    relate csme to ces across R702;
    select one evt related by gsme->SM_EVT[R707];
    relate csme to evt across R706;

    select one gen related by gsme->E_GEN[R705];
    if ( not_empty gen )
      create object instance cei of E_CEI;
      relate cei to csme across R704;
      select one dest related by gen->V_VAR[R712];
      relate dest to cei across R711;
    end if;

    select one gen_a related by gsme->E_GAR[R705];
    if ( not_empty gen_a )
      create object instance cea of E_CEA;
      relate cea to csme across R704;
    end if;

    select one gen_c related by gsme->E_GEC[R705];
    if ( not_empty gen_c )
      create object instance cec of E_CEC;
      relate cec to csme across R704;
    end if;
  else
    select one gee related by ges->E_GEE[R703];
    create object instance cee of E_CEE;
    relate cee to ces across R702;

    select one evt related by gee->S_EEEVT[R709];
    relate cee to evt across R708;
  end if;
  ges.dispose();
  return gen_stmt.Statement_ID;
end if;
return param.a4_rule_id;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4784,
	4783,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4785,
	4783,
	'a2_upper_rule_id',
	296,
	0,
	'',
	4784,
	'');
INSERT INTO S_SPARM
	VALUES (4786,
	4783,
	'a3_rule_begin_id',
	296,
	0,
	'',
	4785,
	'');
INSERT INTO S_SPARM
	VALUES (4787,
	4783,
	'a4_rule_id',
	296,
	0,
	'',
	4786,
	'');
INSERT INTO S_SPARM
	VALUES (4788,
	4783,
	'b1_local_variable1_id',
	296,
	0,
	'',
	4787,
	'');
INSERT INTO S_SPARM
	VALUES (4789,
	4783,
	'b2_event_spec2_id',
	296,
	0,
	'',
	4788,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4790);
INSERT INTO S_SYNC
	VALUES (4790,
	1,
	'Create_object_statement_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4791,
	4790,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4792);
INSERT INTO S_SYNC
	VALUES (4792,
	1,
	'Object_keyletters_validate',
	'ParserValidateFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
current_scope = ::get_current_scope();
select any block from instances of ACT_BLK where
                                             selected.Block_ID == current_scope;
select one body related by block->ACT_ACT[R612];
isInGenericPackage = body.associateWithContainer();
if isInGenericPackage
  // store the textual position of the key letters
  block.currentKeyLettersLineNumber =
                               ::getLineNumber(rule_token: param.a1_rule_token);
  block.currentKeyLettersColumn = ::getColumn(rule_token: param.a1_rule_token);
  select one containingElem related by body->ACT_BIE[R640]->PE_PE[R640];
  select one component related by containingElem->C_C[R8001];
  select one package related by containingElem->EP_PKG[R8001];

  // Check for Class keyletter match for token
  if not_empty component
    component.collectVisibleElementsForName(name:param.a3_text,
         type:ElementTypeConstants::CLASS,
                          originatingContainerID:component.Id,
                                   delegatingContainerID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:false);
  else
    package.collectVisibleElementsForName(name:param.a3_text,
         type:ElementTypeConstants::CLASS, descending:false,
                           originatingContainerID:package.Package_ID,
                                          delegatingPkgID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:false);
  end if;
  select any resultSet related by component->PE_CRS[R8007] where
                                    selected.Name == param.a3_text and 
                                   selected.Type == ElementTypeConstants::CLASS; 
  select many results related by resultSet->PE_CVS[R8008]->PE_PE[R8004];
  if not_empty package
    select any pkgResultSet related by package->PE_SRS[R8005] where
                                     selected.Name == param.a3_text and 
                                   selected.Type == ElementTypeConstants::CLASS; 
    select many results related by pkgResultSet->PE_VIS[R8006]->PE_PE[R8002];
  end if;
  if empty results
    ERR::reportParseError( 
        msg: "Cannot find specified class key letters ->%s<-.", 
                                                   token: param.a1_rule_token );
  elif cardinality results > 1
    ERR::reportParseError( msg:
    "More than one class with key letters ->%s<- You will need to eventually clear this up",
          token: param.a1_rule_token );
  else
    result = GD::NULL_UNIQUE_ID();
    for each clazz in results
      // will iterate only once
      result = clazz.Element_ID;
    end for;
    return result;
  end if;
  return param.a6_current_rule_id;
else
  // store the textual position of the key letters
  block.currentKeyLettersLineNumber =
                               ::getLineNumber(rule_token: param.a1_rule_token);
  block.currentKeyLettersColumn = ::getColumn(rule_token: param.a1_rule_token);
  select many classes from instances of O_OBJ where
                                             selected.Key_Lett == param.a3_text;
  body.associateWithOwningComponent();
  select one component related by body->ACT_BIC[R694]->C_C[R694];
  if not_empty component
    // If we''re in a component, we just look for the class locally
    select many classes related by component->CN_DC[R4204]->S_DOM[R4204]->
                   S_SS[R1]->O_OBJ[R2] where selected.Key_Lett == param.a3_text;
  end if;
  if empty classes
    ERR::reportParseError( 
        msg: "Cannot find specified class key letters ->%s<-.", 
        token: param.a1_rule_token );
  elif cardinality classes > 1
    ERR::reportParseError( msg:
    "More than one class with key letters ->%s<- You will need to eventually clear this up",
          token: param.a1_rule_token );
  else
    result = GD::NULL_UNIQUE_ID();
    for each clazz in classes
      // will iterate only once
      result = clazz.Obj_ID;
    end for;
    return result;
  end if;
  return param.a6_current_rule_id;
end if;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4793,
	4792,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4794,
	4792,
	'a3_text',
	322,
	0,
	'',
	4793,
	'');
INSERT INTO S_SPARM
	VALUES (4795,
	4792,
	'a4_rule_ref_id',
	296,
	0,
	'',
	4794,
	'');
INSERT INTO S_SPARM
	VALUES (4796,
	4792,
	'a5_upper_rule_id',
	296,
	0,
	'',
	4795,
	'');
INSERT INTO S_SPARM
	VALUES (4797,
	4792,
	'a6_current_rule_id',
	296,
	0,
	'',
	4796,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4798);
INSERT INTO S_SYNC
	VALUES (4798,
	1,
	'Create_object_statement_end',
	'ParserValidateFunction: TRUE',
	'select any obj from instances of O_OBJ where ( selected.Obj_ID == param.b2_object_keyletters2_id );
if empty obj
  select any objPE from instances of PE_PE where
                          selected.Element_ID == param.b2_object_keyletters2_id;
  select one obj related by objPE->O_OBJ[R8001];
end if;
select any var from instances of V_VAR where ( selected.Var_ID == param.b1_local_variable1_id );

assign_ok = true;
err_msg = "";
if ( param.b1_local_variable1_id != GD::NULL_UNIQUE_ID() )
  if ( var.Declared )
    select one int_var related by var->V_INT[R814];
    if ( not_empty int_var )
      select one l_obj related by int_var->O_OBJ[R818];
        if ( l_obj.Obj_ID != obj.Obj_ID)
          assign_ok = false;
          err_msg = "Variable ->"+ var.Name +"<- already exists as a different type";
        end if;
    else
      err_msg = "Variable ->"+ var.Name +"<- does not exist in scope as an object instance variable";
      assign_ok = false;
    end if;
  end if;
end if;

if ( not assign_ok )
  ::clear_value_data();
  ERR::reportParseError( msg: err_msg,
          token: param.a1_rule_token );
else
  stmt_id =  ::statement_create();
  select any stmt from instances of ACT_SMT where selected.Statement_ID == stmt_id;

  if ( param.b1_local_variable1_id != GD::NULL_UNIQUE_ID() )
    create object instance cr of ACT_CR;
    relate cr to stmt across R603;
    relate cr to obj across R671;
    if ( not var.Declared )
      var.migrate_to_int();
      select one inst_ref related by var->V_INT[R814];
      relate inst_ref to obj across R818;
      cr.is_implicit = true;
      var.Declared = true;
      ::connect_inst_ref_var_to_datatype(p1_is_set:false, p2_var_id:var.Var_ID, p3_obj_id:obj.Obj_ID);
    end if;
    relate cr to var across R633;

    // store the textual position of the class key-letters
	current_scope = ::get_current_scope();
	select any block from instances of ACT_BLK
		where (selected.Block_ID == current_scope);
    cr.modelClassKeyLettersLineNumber = block.currentKeyLettersLineNumber;
    cr.modelClassKeyLettersColumn = block.currentKeyLettersColumn;
  else
    create object instance cnv of ACT_CNV;
    relate cnv to stmt across R603;
    relate cnv to obj across R672;

    // store the textual position of the class key-letters
	current_scope = ::get_current_scope();
	select any block from instances of ACT_BLK
		where (selected.Block_ID == current_scope);
    cnv.modelClassKeyLettersLineNumber = block.currentKeyLettersLineNumber;
    cnv.modelClassKeyLettersColumn = block.currentKeyLettersColumn;
  end if;
  return stmt.Statement_ID;
end if;
return param.a3_rule_begin_id;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4799,
	4798,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4800,
	4798,
	'a2_upper_rule_id',
	296,
	0,
	'',
	4799,
	'');
INSERT INTO S_SPARM
	VALUES (4801,
	4798,
	'a3_rule_begin_id',
	296,
	0,
	'',
	4800,
	'');
INSERT INTO S_SPARM
	VALUES (4802,
	4798,
	'a4_rule_id',
	296,
	0,
	'',
	4801,
	'');
INSERT INTO S_SPARM
	VALUES (4803,
	4798,
	'b1_local_variable1_id',
	296,
	0,
	'',
	4802,
	'');
INSERT INTO S_SPARM
	VALUES (4804,
	4798,
	'b2_object_keyletters2_id',
	296,
	0,
	'',
	4803,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4805);
INSERT INTO S_SYNC
	VALUES (4805,
	1,
	'Debug_statement_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4806,
	4805,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4807);
INSERT INTO S_SYNC
	VALUES (4807,
	1,
	'Debug_statement_loop2_start',
	'ParserValidateFunction: TRUE',
	'return param.a2_rule_begin_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4808,
	4807,
	'a1_upper_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4809,
	4807,
	'a2_rule_begin_id',
	296,
	0,
	'',
	4808,
	'');
INSERT INTO S_SPARM
	VALUES (4810,
	4807,
	'a3_current_rule_id',
	296,
	0,
	'',
	4809,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4811);
INSERT INTO S_SYNC
	VALUES (4811,
	1,
	'Debug_operand_validate',
	'ParserValidateFunction: TRUE',
	'return param.a6_current_rule_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4812,
	4811,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4813,
	4811,
	'a3_text',
	322,
	0,
	'',
	4812,
	'');
INSERT INTO S_SPARM
	VALUES (4814,
	4811,
	'a4_rule_ref_id',
	296,
	0,
	'',
	4813,
	'');
INSERT INTO S_SPARM
	VALUES (4815,
	4811,
	'a5_upper_rule_id',
	296,
	0,
	'',
	4814,
	'');
INSERT INTO S_SPARM
	VALUES (4816,
	4811,
	'a6_current_rule_id',
	296,
	0,
	'',
	4815,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4817);
INSERT INTO S_SYNC
	VALUES (4817,
	1,
	'Debug_statement_loop2_end',
	'ParserValidateFunction: TRUE',
	'return param.a3_ruleid_name;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4818,
	4817,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4819,
	4817,
	'a2_upper_ruleid_name',
	296,
	0,
	'',
	4818,
	'');
INSERT INTO S_SPARM
	VALUES (4820,
	4817,
	'a3_ruleid_name',
	296,
	0,
	'',
	4819,
	'');
INSERT INTO S_SPARM
	VALUES (4821,
	4817,
	'a4_loop_id_name',
	296,
	0,
	'',
	4820,
	'');
INSERT INTO S_SPARM
	VALUES (4822,
	4817,
	'b1_debug_operand1_id',
	296,
	0,
	'',
	4821,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4823);
INSERT INTO S_SYNC
	VALUES (4823,
	1,
	'Debug_statement_end',
	'ParserValidateFunction: TRUE',
	'return param.a4_rule_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4824,
	4823,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4825,
	4823,
	'a2_upper_rule_id',
	296,
	0,
	'',
	4824,
	'');
INSERT INTO S_SPARM
	VALUES (4826,
	4823,
	'a3_rule_begin_id',
	296,
	0,
	'',
	4825,
	'');
INSERT INTO S_SPARM
	VALUES (4827,
	4823,
	'a4_rule_id',
	296,
	0,
	'',
	4826,
	'');
INSERT INTO S_SPARM
	VALUES (4828,
	4823,
	'b1_debug_operand1_id',
	296,
	0,
	'',
	4827,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4829);
INSERT INTO S_SYNC
	VALUES (4829,
	1,
	'Delete_statement_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4830,
	4829,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4831);
INSERT INTO S_SYNC
	VALUES (4831,
	1,
	'Inst_ref_var_validate',
	'ParserValidateFunction: TRUE',
	'::self_validate( a1_text: param.a3_text, a2_isLval: false, a3_token: param.a1_rule_token );

var_id = ::get_var_in_scope( name: param.a3_text, rule_token: param.a1_rule_token );

// the inst_ref_var rule is always an r-value
if ( var_id == GD::NULL_UNIQUE_ID()  )
   ::clear_value_data();
   ERR::reportParseError( msg: "Variable ->%s<- used in context where it must already exist",
      token: param.a1_rule_token );
else
  select any var from instances of V_VAR where ( selected.Var_ID == var_id );
  var.addLocation(line: ::getLineNumber(rule_token: param.a1_rule_token), 
        col: ::getColumn(rule_token: param.a1_rule_token) );
  return var_id;
end if;

return param.a6_current_rule_id;






















































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4832,
	4831,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4833,
	4831,
	'a3_text',
	322,
	0,
	'',
	4832,
	'');
INSERT INTO S_SPARM
	VALUES (4834,
	4831,
	'a4_rule_ref_id',
	296,
	0,
	'',
	4833,
	'');
INSERT INTO S_SPARM
	VALUES (4835,
	4831,
	'a5_upper_rule_id',
	296,
	0,
	'',
	4834,
	'');
INSERT INTO S_SPARM
	VALUES (4836,
	4831,
	'a6_current_rule_id',
	296,
	0,
	'',
	4835,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4837);
INSERT INTO S_SYNC
	VALUES (4837,
	1,
	'Delete_statement_end',
	'ParserValidateFunction: TRUE',
	'current_scope = ::get_current_scope();
select any blk from instances of ACT_BLK where (selected.Block_ID == current_scope);
if ( not_empty blk )
  select any var from instances of V_VAR where (selected.Var_ID == param.b1_inst_ref_var1_id );
  if ( not_empty var )
    select one inst_ref related by var->V_INT[R814];
    if ( empty inst_ref )
      ERR::reportParseError( msg: "Variable ->" + var.Name + "<- does not exist in scope as an object instance variable",
          token: param.a1_rule_token );
    else
      stmt_id =  ::statement_create();
      select any stmt from instances of ACT_SMT where selected.Statement_ID == stmt_id;
      create object instance del of ACT_DEL;
      relate stmt to del across R603;
      relate del to var across R634;
      return stmt.Statement_ID;
    end if;
  end if;
end if;
return param.a4_rule_id;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4838,
	4837,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4839,
	4837,
	'a2_upper_rule_id',
	296,
	0,
	'',
	4838,
	'');
INSERT INTO S_SPARM
	VALUES (4840,
	4837,
	'a3_rule_begin_id',
	296,
	0,
	'',
	4839,
	'');
INSERT INTO S_SPARM
	VALUES (4841,
	4837,
	'a4_rule_id',
	296,
	0,
	'',
	4840,
	'');
INSERT INTO S_SPARM
	VALUES (4842,
	4837,
	'b1_inst_ref_var1_id',
	296,
	0,
	'',
	4841,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4843);
INSERT INTO S_SYNC
	VALUES (4843,
	1,
	'Empty_statement_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;

',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4844,
	4843,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4845);
INSERT INTO S_SYNC
	VALUES (4845,
	1,
	'Empty_statement_end',
	'ParserValidateFunction: TRUE',
	'return param.a4_rule_id;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4846,
	4845,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4847,
	4845,
	'a2_upper_rule_id',
	296,
	0,
	'',
	4846,
	'');
INSERT INTO S_SPARM
	VALUES (4848,
	4845,
	'a3_rule_begin_id',
	296,
	0,
	'',
	4847,
	'');
INSERT INTO S_SPARM
	VALUES (4849,
	4845,
	'a4_rule_id',
	296,
	0,
	'',
	4848,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4850);
INSERT INTO S_SYNC
	VALUES (4850,
	1,
	'For_statement_start',
	'ParserValidateFunction: TRUE',
	'	
stmt_id =  ::statement_create();
select any stmt from instances of ACT_SMT where selected.Statement_ID == stmt_id;

create object instance f of ACT_FOR;
relate f to stmt across R603;

select one act related by stmt->ACT_BLK[R602]->ACT_ACT[R612];
act.entered_loop();

return stmt.Statement_ID;

',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4851,
	4850,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4852);
INSERT INTO S_SYNC
	VALUES (4852,
	1,
	'Inst_ref_set_var_validate',
	'ParserValidateFunction: TRUE',
	'
// inst_ref_set_var is always an r-value

var_id = ::get_var_in_scope( name: param.a3_text, rule_token: param.a1_rule_token );

// the inst_ref_set_var rule is always an r-value
if ( var_id == GD::NULL_UNIQUE_ID()  )
   ::clear_value_data();
   ERR::reportParseError( msg: "Variable ->%s<- used in context where it must already exist",
      token: param.a1_rule_token );
else
  select any iter from instances of V_VAR where ( selected.Var_ID == param.a6_current_rule_id );
  if ( not_empty iter  )
    if( not iter.Declared )
      select any iter_set from instances of V_VAR where ( selected.Var_ID == var_id );
      select one iter_set_obj related by iter_set->V_INS[R814]->O_OBJ[R819];
      if ( not_empty iter_set_obj )
        iter.migrate_to_int();
        select one inst_ref related by iter->V_INT[R814];
        relate inst_ref to iter_set_obj across R818;
        iter.Declared = true;
        inst_ref.IsImplicitInFor = true;
        ::connect_inst_ref_var_to_datatype(p1_is_set:false, p2_var_id:iter.Var_ID,
                                                 p3_obj_id:iter_set_obj.Obj_ID);
      end if;
    else
        select one inst_ref related by iter->V_INT[R814];
        if ( not_empty inst_ref )
          inst_ref.IsImplicitInFor = false;
        end if;
    end if;
  end if;
  select any var from instances of V_VAR where ( selected.Var_ID == var_id );
  var.addLocation(line: ::getLineNumber(rule_token: param.a1_rule_token),
        col: ::getColumn(rule_token: param.a1_rule_token) );
  return var_id;
end if;

return param.a6_current_rule_id;












































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4853,
	4852,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4854,
	4852,
	'a3_text',
	322,
	0,
	'',
	4853,
	'');
INSERT INTO S_SPARM
	VALUES (4855,
	4852,
	'a4_rule_ref_id',
	296,
	0,
	'',
	4854,
	'');
INSERT INTO S_SPARM
	VALUES (4856,
	4852,
	'a5_upper_rule_id',
	296,
	0,
	'',
	4855,
	'');
INSERT INTO S_SPARM
	VALUES (4857,
	4852,
	'a6_current_rule_id',
	296,
	0,
	'',
	4856,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4858);
INSERT INTO S_SYNC
	VALUES (4858,
	1,
	'For_statement_end',
	'ParserValidateFunction: TRUE',
	'current_scope = ::get_current_scope();
select any blk from instances of ACT_BLK where (selected.Block_ID == current_scope);
select one act related by blk->ACT_ACT[R612];
act.exitted_loop();

select any fstmt from instances of ACT_FOR
          where ( selected.Statement_ID == param.a3_rule_begin_id );
if ( empty fstmt )
  ::clear_for_data( a1_iter: param.b1_local_variable1_id, a2_block: param.b3_block3_id, a3_stmt_id: param.a3_rule_begin_id );
  ::clear_value_data();
  ERR::reportParseError( msg: "For statement not found.",
        token: param.a1_rule_token );
else
  select one stmt related by fstmt->ACT_SMT[R603];
  select any iter from instances of V_VAR where ( selected.Var_ID == param.b1_local_variable1_id );
  if ( empty iter  )
    ::clear_for_data( a1_iter: param.b1_local_variable1_id, a2_block: param.b3_block3_id, a3_stmt_id: param.a3_rule_begin_id );
    ::clear_value_data();
    ERR::reportParseError( msg: "For iter var not found.",
        token: param.a1_rule_token );
  else
    select any iter_set from instances of V_VAR
        where ( selected.Var_ID == param.b2_inst_ref_set_var2_id );
    select one iter_set_obj related by iter_set->V_INS[R814]->O_OBJ[R819];
    if ( empty iter_set_obj )
      ::clear_for_data( a1_iter: param.b1_local_variable1_id, a2_block: param.b3_block3_id, a3_stmt_id: param.a3_rule_begin_id );
      ::clear_value_data();
      ERR::reportParseError( msg: "Variable ->"+ iter_set.Name +"<- does not exist in scope as an object instance set variable",
          token: param.a1_rule_token );
    elif ( iter.Declared )
      select one v_int related by iter->V_INT[R814];
      if ( empty v_int )
        ::clear_for_data( a1_iter: param.b1_local_variable1_id,  a2_block: param.b3_block3_id, a3_stmt_id: param.a3_rule_begin_id );
        ::clear_value_data();
        ERR::reportParseError( msg: "Variable ->"+ iter.Name +"<- does not exist in scope as an object instance variable",
            token: param.a1_rule_token );
      else
        select one iter_obj related by v_int->O_OBJ[R818];
        if ( iter_obj.Obj_ID != iter_set_obj.Obj_ID )
          ::clear_for_data( a1_iter: param.b1_local_variable1_id,  a2_block: param.b3_block3_id, a3_stmt_id: param.a3_rule_begin_id );
          ::clear_value_data();
          ERR::reportParseError( msg: "Variable ->"+ iter.Name +"<- already exists as a different type",
              token: param.a1_rule_token );
        end if;
      end if;
    end if;
    relate fstmt to iter across R614;
    relate fstmt to iter_set across R652;
    relate fstmt to iter_set_obj across R670;
    select one inst_ref related by iter->V_INT[R814];
    fstmt.is_implicit = inst_ref.IsImplicitInFor;
  end if;
end if;
return param.a3_rule_begin_id;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4859,
	4858,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4860,
	4858,
	'a2_upper_rule_id',
	296,
	0,
	'',
	4859,
	'');
INSERT INTO S_SPARM
	VALUES (4861,
	4858,
	'a3_rule_begin_id',
	296,
	0,
	'',
	4860,
	'');
INSERT INTO S_SPARM
	VALUES (4862,
	4858,
	'a4_rule_id',
	296,
	0,
	'',
	4861,
	'');
INSERT INTO S_SPARM
	VALUES (4863,
	4858,
	'b1_local_variable1_id',
	296,
	0,
	'',
	4862,
	'');
INSERT INTO S_SPARM
	VALUES (4864,
	4858,
	'b2_inst_ref_set_var2_id',
	296,
	0,
	'',
	4863,
	'');
INSERT INTO S_SPARM
	VALUES (4865,
	4858,
	'b3_block3_id',
	296,
	0,
	'',
	4864,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4866);
INSERT INTO S_SYNC
	VALUES (4866,
	1,
	'Generate_statement_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4867,
	4866,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4868);
INSERT INTO S_SYNC
	VALUES (4868,
	1,
	'Generate_statement_end',
	'ParserValidateFunction: TRUE',
	'// ::Generate_statement_end()
if ( param.b2_member_id != GD::NULL_UNIQUE_ID() )
  select any val from instances of V_VAL 
                              where ( selected.Value_ID == param.b2_member_id );
  select one val_dt related by val->S_DT[R820];
  if ( (empty val_dt) or (val_dt.Name != "inst<Event>") )
    select one attrRef related by val->V_AVL[R801];
    select one tranRef related by val->V_TVL[R801];
    select one membRef related by val->V_MVL[R801];
    message = "";
    
    if (empty val_dt)
      message = "Value has an unknown data type.  ";
    end if;
    
	if (not_empty attrRef)
	  select one attr related by attrRef->O_ATTR[R806];
	  message = message + "Attribute ->" + attr.Name + "<- must be of type inst<Event>";
	elif not_empty tranRef
	  select one var related by tranRef->V_VAR[R805];
	  message = message + "Variable ->" + var.Name + "<- must be of type inst<Event>";
	elif not_empty membRef
	  select one member related by membRef->S_MBR[R836];
	  message = message + "Structure member ->" + member.Name +
	                                           "<- must be of type inst<Event>";
    end if;
    select one attr related by val->V_AVL[R801]->O_ATTR[R806];
    val.dispose();
    ERR::reportParseError( msg: message, token: param.a1_rule_token );
  else
    stmt_id =  ::statement_create();
    select any stmt from instances of ACT_SMT where
                                               selected.Statement_ID == stmt_id;
    create object instance gpre of E_GPR;
    relate gpre to stmt across R603;
    relate val to gpre across R714;
    return stmt_id;
  end if;  
elif ( param.b1_event_spec1_id == GD::NULL_UNIQUE_ID() )
  select any ess from instances of ACT_SMT where
                                      selected.Statement_ID == param.a4_rule_id;
  if ( not_empty ess )
    ess.dispose();
  end if;
end if;
// else the event_spec rule has already created the statement
return param.a4_rule_id;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4869,
	4868,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4870,
	4868,
	'a2_upper_rule_id',
	296,
	0,
	'',
	4869,
	'');
INSERT INTO S_SPARM
	VALUES (4871,
	4868,
	'a3_rule_begin_id',
	296,
	0,
	'',
	4870,
	'');
INSERT INTO S_SPARM
	VALUES (4872,
	4868,
	'a4_rule_id',
	296,
	0,
	'',
	4871,
	'');
INSERT INTO S_SPARM
	VALUES (4873,
	4868,
	'b1_event_spec1_id',
	296,
	0,
	'',
	4872,
	'');
INSERT INTO S_SPARM
	VALUES (4874,
	4868,
	'b2_member_id',
	296,
	0,
	'',
	4873,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4875);
INSERT INTO S_SYNC
	VALUES (4875,
	1,
	'If_statement_start',
	'ParserValidateFunction: TRUE',
	'stmt_id =  ::statement_create();
select any stmt from instances of ACT_SMT where selected.Statement_ID == stmt_id;

create object instance if_stmt of ACT_IF;
relate if_stmt to stmt across R603;

return stmt.Statement_ID;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4876,
	4875,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4877);
INSERT INTO S_SYNC
	VALUES (4877,
	1,
	'Expr_validate',
	'ParserValidateFunction: TRUE',
	'select any val from instances of V_VAL
  where (selected.Value_ID == param.a6_current_rule_id);
if ( not_empty val )
  val.setEndPosition();
end if;
return param.a6_current_rule_id;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4878,
	4877,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4879,
	4877,
	'a3_text',
	322,
	0,
	'',
	4878,
	'');
INSERT INTO S_SPARM
	VALUES (4880,
	4877,
	'a4_rule_ref_id',
	296,
	0,
	'',
	4879,
	'');
INSERT INTO S_SPARM
	VALUES (4881,
	4877,
	'a5_upper_rule_id',
	296,
	0,
	'',
	4880,
	'');
INSERT INTO S_SPARM
	VALUES (4882,
	4877,
	'a6_current_rule_id',
	296,
	0,
	'',
	4881,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4883);
INSERT INTO S_SYNC
	VALUES (4883,
	1,
	'If_statement_loop3_start',
	'ParserValidateFunction: TRUE',
	'
return param.a2_rule_begin_id;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4884,
	4883,
	'a1_upper_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4885,
	4883,
	'a2_rule_begin_id',
	296,
	0,
	'',
	4884,
	'');
INSERT INTO S_SPARM
	VALUES (4886,
	4883,
	'a3_current_rule_id',
	296,
	0,
	'',
	4885,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4887);
INSERT INTO S_SYNC
	VALUES (4887,
	1,
	'If_statement_loop3_end',
	'ParserValidateFunction: TRUE',
	'select any val from instances of V_VAL where ( selected.Value_ID == param.b3_expr3_id );
if ( empty val  )
  ERR::reportParseError( msg: "Elif expression not found",
        token: param.a1_rule_token );
else
  select one val_dt related by val->S_DT[R820];
  if ( empty val_dt )
    val.dispose();
    ERR::reportParseError( msg: "Elif expression unknown data type",
          token: param.a1_rule_token );
  elif ( val_dt.Name != "boolean" )
    val.dispose();
     ERR::reportParseError( msg: "Elif expression data type is not boolean",
          token: param.a1_rule_token );
  else
      if ( param.b4_block4_id != GD::NULL_UNIQUE_ID() )
        select any if_blk from instances of ACT_BLK where selected.Block_ID == param.b2_block2_id;
        select any elif_blk from instances of ACT_BLK where selected.Block_ID == param.b4_block4_id;

        // re-relate if block back to if statement
        select one istmt related by elif_blk->ACT_IF[R607];
        relate istmt to if_blk across R607;

        // create the Elif statement instance
        stmt_id =  ::statement_create();
        select any stmt from instances of ACT_SMT where selected.Statement_ID == stmt_id;
        create object instance elif_stmt of ACT_EL;
        relate elif_stmt to stmt across R603;
        relate elif_stmt to elif_blk across R658;
        relate elif_stmt to istmt across R682;
        select any root_blk from instances of ACT_BLK where selected.Block_ID == param.a2_upper_ruleid_name;
		stmt.LineNumber = root_blk.CurrentLine;
		stmt.StartPosition = root_blk.CurrentCol;
        relate elif_stmt to val across R659;
      end if;
    end if;
  end if;

return param.a3_ruleid_name;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4888,
	4887,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4889,
	4887,
	'a2_upper_ruleid_name',
	296,
	0,
	'',
	4888,
	'');
INSERT INTO S_SPARM
	VALUES (4890,
	4887,
	'a3_ruleid_name',
	296,
	0,
	'',
	4889,
	'');
INSERT INTO S_SPARM
	VALUES (4891,
	4887,
	'a4_loop_id_name',
	296,
	0,
	'',
	4890,
	'');
INSERT INTO S_SPARM
	VALUES (4892,
	4887,
	'b1_expr1_id',
	296,
	0,
	'',
	4891,
	'');
INSERT INTO S_SPARM
	VALUES (4893,
	4887,
	'b2_block2_id',
	296,
	0,
	'',
	4892,
	'');
INSERT INTO S_SPARM
	VALUES (4894,
	4887,
	'b3_expr3_id',
	296,
	0,
	'',
	4893,
	'');
INSERT INTO S_SPARM
	VALUES (4895,
	4887,
	'b4_block4_id',
	296,
	0,
	'',
	4894,
	'');
INSERT INTO S_SPARM
	VALUES (4896,
	4887,
	'b5_block5_id',
	296,
	0,
	'',
	4895,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4897);
INSERT INTO S_SYNC
	VALUES (4897,
	1,
	'If_statement_end',
	'ParserValidateFunction: TRUE',
	'
select any if_stmt from instances of ACT_IF 
          where ( selected.Statement_ID == param.a3_rule_begin_id );
if ( empty if_stmt )
  select any val from instances of V_VAL where ( selected.Value_ID == param.b1_expr1_id );
  if ( not_empty val  )
    val.dispose();
  end if;
     ERR::reportParseError( msg: "If statement not found",
        token: param.a1_rule_token );
else
  select one stmt related by if_stmt->ACT_SMT[R603];
  select any val from instances of V_VAL where ( selected.Value_ID == param.b1_expr1_id );
  if ( empty val  )
    stmt.dispose();
    ERR::reportParseError( msg: "If expression not found",
        token: param.a1_rule_token );
  else
    select one val_dt related by val->S_DT[R820];
    if ( empty val_dt )
      stmt.dispose();
      val.dispose();
       ERR::reportParseError( msg: "If expression unknown data type",
          token: param.a1_rule_token );
    elif ( val_dt.Name != "boolean" )
      stmt.dispose();
      val.dispose();
       ERR::reportParseError( msg: "If expression data type is not boolean",
          token: param.a1_rule_token );
    else
      relate if_stmt to val across R625;
      if ( param.b5_block5_id != GD::NULL_UNIQUE_ID() )
        select any if_blk from instances of ACT_BLK where selected.Block_ID == param.b2_block2_id;
        select any else_blk from instances of ACT_BLK where selected.Block_ID == param.b5_block5_id;
        select one existingBlk related by if_stmt->ACT_BLK[R607];
        if (not_empty existingBlk)
          unrelate if_stmt from existingBlk across R607;
        end if;
        relate if_stmt to if_blk across R607;
        // create the Else statement instance
        stmt_id =  ::statement_create();
        select any stmt from instances of ACT_SMT where selected.Statement_ID == stmt_id;
        create object instance else_stmt of ACT_E;
        relate else_stmt to stmt across R603;
        relate else_stmt to else_blk across R606;
        relate else_stmt to if_stmt across R683;
        select any root_blk from instances of ACT_BLK where selected.Block_ID == param.a2_upper_rule_id;
		stmt.LineNumber = root_blk.CurrentLine;
		stmt.StartPosition = root_blk.CurrentCol;
      end if;
    end if;
  end if;
end if;
return param.a3_rule_begin_id;













































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4898,
	4897,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4899,
	4897,
	'a2_upper_rule_id',
	296,
	0,
	'',
	4898,
	'');
INSERT INTO S_SPARM
	VALUES (4900,
	4897,
	'a3_rule_begin_id',
	296,
	0,
	'',
	4899,
	'');
INSERT INTO S_SPARM
	VALUES (4901,
	4897,
	'a4_rule_id',
	296,
	0,
	'',
	4900,
	'');
INSERT INTO S_SPARM
	VALUES (4902,
	4897,
	'b1_expr1_id',
	296,
	0,
	'',
	4901,
	'');
INSERT INTO S_SPARM
	VALUES (4903,
	4897,
	'b2_block2_id',
	296,
	0,
	'',
	4902,
	'');
INSERT INTO S_SPARM
	VALUES (4904,
	4897,
	'b3_expr3_id',
	296,
	0,
	'',
	4903,
	'');
INSERT INTO S_SPARM
	VALUES (4905,
	4897,
	'b4_block4_id',
	296,
	0,
	'',
	4904,
	'');
INSERT INTO S_SPARM
	VALUES (4906,
	4897,
	'b5_block5_id',
	296,
	0,
	'',
	4905,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4907);
INSERT INTO S_SYNC
	VALUES (4907,
	1,
	'Implicit_assignment_statement_start',
	'ParserValidateFunction: TRUE',
	'return ::Assignment_statement_start(a1_ruleid_name: param.a1_ruleid_name);












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4908,
	4907,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4909);
INSERT INTO S_SYNC
	VALUES (4909,
	1,
	'Implicit_assignment_statement_end',
	'ParserValidateFunction: TRUE',
	'return ::Assignment_statement_end(a1_rule_token: param.a1_rule_token,
  a2_upper_rule_id: param.a2_upper_rule_id, a3_rule_begin_id: param.a3_rule_begin_id,
  a4_rule_id: param.a4_rule_id, b1_assignment_expr1_id: param.b1_assignment_expr1_id );












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4910,
	4909,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4911,
	4909,
	'a2_upper_rule_id',
	296,
	0,
	'',
	4910,
	'');
INSERT INTO S_SPARM
	VALUES (4912,
	4909,
	'a3_rule_begin_id',
	296,
	0,
	'',
	4911,
	'');
INSERT INTO S_SPARM
	VALUES (4913,
	4909,
	'a4_rule_id',
	296,
	0,
	'',
	4912,
	'');
INSERT INTO S_SPARM
	VALUES (4914,
	4909,
	'b1_assignment_expr1_id',
	296,
	0,
	'',
	4913,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4915);
INSERT INTO S_SYNC
	VALUES (4915,
	1,
	'Implicit_invocation_statement_start',
	'ParserValidateFunction: TRUE',
	'return ::statement_create();

',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4916,
	4915,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4917);
INSERT INTO S_SYNC
	VALUES (4917,
	1,
	'Invocation_validate',
	'ParserValidateFunction: TRUE',
	'// ::Bridge_or_transform_function_validate()
if param.a6_current_rule_id != GD::NULL_UNIQUE_ID()
  select any val from instances of V_VAL where
                                  selected.Value_ID == param.a6_current_rule_id;
  if not_empty val
    select one sdt related by val->S_DT[R820];
    if empty sdt
      ERR::reportParseError( msg: "Value has unknown data type",
           token: param.a1_rule_token );
    else
      select one tfr related by val->V_TRV[R801]->O_TFR[R829];
      if not_empty tfr
        return ::is_valid_invocation( a1_type: sdt.Name,
                                   a2_isRval: param.a2_isRval,
                                     a3_id: param.a6_current_rule_id,
                                       a4_name: "Operation ->"  + tfr.Name,
                                           a5_rule_token: param.a1_rule_token );
      else
        select one brg related by val->V_BRV[R801]->S_BRG[R828];
        if ( not_empty brg )
          return ::is_valid_invocation( a1_type: sdt.Name,
                                   a2_isRval: param.a2_isRval,
                                     a3_id: param.a6_current_rule_id,
                                          a4_name: "Bridge ->"  + brg.Name,
                                           a5_rule_token: param.a1_rule_token );
        else
          select one msv related by val->V_MSV[R801];
          select one ep related by msv->SPR_PEP[R841]->C_EP[R4501]; 
          if(empty ep)
            // if the executable property was not found
            // search for a required executable property
            select one ep related by msv->SPR_REP[R845]->C_EP[R4500];
          end if;
          if not_empty ep
            select one io related by ep->C_IO[R4004];
            if not_empty io
                return ::is_valid_invocation(a1_type: sdt.Name,
                                      a2_isRval: param.a2_isRval,
                                     a3_id: param.a6_current_rule_id,
                             a4_name: "Interface Operation ->"  + io.Name,
                                           a5_rule_token: param.a1_rule_token );
            else
              select one sig related by ep->C_AS[R4004];
              if param.a2_isRval
                token = param.a1_rule_token;
                ::set_token(a1_token:token, a2_line: val.LineNumber,
                               a3_column: val.StartPosition, a4_text: sig.Name);
                ERR::reportParseError( msg: "Signal ->" + sig.Name +
                           "<- cannot be used in an expression", token: token );
              else
                  return ::is_valid_invocation(a1_type: sdt.Name,
                                        a2_isRval: param.a2_isRval,
                                       a3_id: param.a6_current_rule_id,
                                          a4_name: "Signal ->"  + sig.Name,
                                           a5_rule_token: param.a1_rule_token );
                end if;
              end if;
            end if;
          end if;
        end if;
      end if;
    end if;
  end if;
return GD::NULL_UNIQUE_ID();',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4918,
	4917,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4919,
	4917,
	'a2_isRval',
	316,
	0,
	'',
	4918,
	'');
INSERT INTO S_SPARM
	VALUES (4920,
	4917,
	'a3_text',
	322,
	0,
	'',
	4919,
	'');
INSERT INTO S_SPARM
	VALUES (4921,
	4917,
	'a4_rule_ref_id',
	296,
	0,
	'',
	4920,
	'');
INSERT INTO S_SPARM
	VALUES (4922,
	4917,
	'a5_upper_rule_id',
	296,
	0,
	'',
	4921,
	'');
INSERT INTO S_SPARM
	VALUES (4923,
	4917,
	'a6_current_rule_id',
	296,
	0,
	'',
	4922,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4924);
INSERT INTO S_SYNC
	VALUES (4924,
	1,
	'Implicit_invocation_statement_end',
	'ParserValidateFunction: TRUE',
	'// validate parameters

select any brv from instances of V_BRV 
   where selected.Value_ID == param.b1_bridge_or_transform_invocation1_id;
if ( not_empty brv )
  return ::Bridge_statement_end( a1_rule_token: param.a1_rule_token, 
      a2_upper_rule_id: param.a2_upper_rule_id,
      a3_rule_begin_id: param.a3_rule_begin_id,
      a4_rule_id: param.a4_rule_id,
      b1_member1_id:GD::NULL_UNIQUE_ID(),
      b3_param_data_access3_id: GD::NULL_UNIQUE_ID(),
      b4_bridge_invocation4_id: GD::NULL_UNIQUE_ID(),
      b5_bridge_invocation5_id: param.b1_bridge_or_transform_invocation1_id );
else
  select any trv from instances of V_TRV 
     where selected.Value_ID == param.b1_bridge_or_transform_invocation1_id;
  if ( not_empty trv )
    return ::Implicit_ib_transform_statement_end( a1_rule_token: param.a1_rule_token, 
        a2_upper_rule_id: param.a2_upper_rule_id,
        a3_rule_begin_id:  param.a3_rule_begin_id,
        a4_rule_id: param.a4_rule_id,
        b1_transform_ib_invocation1_id: param.b1_bridge_or_transform_invocation1_id );
  else
    select any msv from instances of V_MSV
           where selected.Value_ID == param.b1_bridge_or_transform_invocation1_id;
    if not_empty msv
      return ::Send_statement_end( a1_rule_token: param.a1_rule_token, 
      a2_upper_rule: param.a2_upper_rule_id,
      a3_start_rule: param.a3_rule_begin_id,
      a4_current_rule: param.a4_rule_id,
      a5_member_access_id:GD::NULL_UNIQUE_ID(),
      a6_parameter_access_id: GD::NULL_UNIQUE_ID(),
      a7_message_result_id: GD::NULL_UNIQUE_ID(),
      a8_message_invocation_id: param.b1_bridge_or_transform_invocation1_id );
    end if;
  end if;
end if;

return param.a4_rule_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4925,
	4924,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4926,
	4924,
	'a2_upper_rule_id',
	296,
	0,
	'',
	4925,
	'');
INSERT INTO S_SPARM
	VALUES (4927,
	4924,
	'a3_rule_begin_id',
	296,
	0,
	'',
	4926,
	'');
INSERT INTO S_SPARM
	VALUES (4928,
	4924,
	'a4_rule_id',
	296,
	0,
	'',
	4927,
	'');
INSERT INTO S_SPARM
	VALUES (4929,
	4924,
	'b1_bridge_or_transform_invocation1_id',
	296,
	0,
	'',
	4928,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4930);
INSERT INTO S_SYNC
	VALUES (4930,
	1,
	'Implicit_ib_transform_statement_start',
	'ParserValidateFunction: TRUE',
	'return ::statement_create();











































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4931,
	4930,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4932);
INSERT INTO S_SYNC
	VALUES (4932,
	1,
	'Transform_ib_invocation_validate',
	'ParserValidateFunction: TRUE',
	'if ( param.a6_current_rule_id != GD::NULL_UNIQUE_ID() )
  select any val from instances of V_VAL where selected.Value_ID == param.a6_current_rule_id;
  if ( not_empty val )
    select one sdt related by val->S_DT[R820];
    if ( empty sdt )
      ERR::reportParseError( msg: "Value has unknown data type",
           token: param.a1_rule_token );
    else
      select one tfr related by val->V_TRV[R801]->O_TFR[R829];
      if ( not_empty tfr )
        return ::is_valid_invocation( a1_type: sdt.Name, a2_isRval: param.a2_isRval, a3_id: param.a6_current_rule_id,
              a4_name: "Operation ->"  + tfr.Name, a5_rule_token: param.a1_rule_token );
      end if;
    end if;
  end if;
end if;
return GD::NULL_UNIQUE_ID();












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4933,
	4932,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4934,
	4932,
	'a2_isRval',
	316,
	0,
	'',
	4933,
	'');
INSERT INTO S_SPARM
	VALUES (4935,
	4932,
	'a3_text',
	322,
	0,
	'',
	4934,
	'');
INSERT INTO S_SPARM
	VALUES (4936,
	4932,
	'a4_rule_ref_id',
	296,
	0,
	'',
	4935,
	'');
INSERT INTO S_SPARM
	VALUES (4937,
	4932,
	'a5_upper_rule_id',
	296,
	0,
	'',
	4936,
	'');
INSERT INTO S_SPARM
	VALUES (4938,
	4932,
	'a6_current_rule_id',
	296,
	0,
	'',
	4937,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4939);
INSERT INTO S_SYNC
	VALUES (4939,
	1,
	'Implicit_ib_transform_statement_end',
	'ParserValidateFunction: TRUE',
	'select any val from instances of V_VAL 
       where ( selected.Value_ID == param.b1_transform_ib_invocation1_id );

if ( empty val )
  // there was a problem with parsing the value
  select any stmt from instances of ACT_SMT 
        where selected.Statement_ID == param.a3_rule_begin_id;
  stmt.dispose();
  return GD::NULL_UNIQUE_ID();
end if;

select any stmt from instances of ACT_SMT 
    where ( selected.Statement_ID == param.a3_rule_begin_id );
create object instance act_tfm of ACT_TFM;
relate stmt to act_tfm across R603;
select one trv related by val->V_TRV[R801];
select one tfr related by trv->O_TFR[R829];
select many parm_set related by trv->V_PAR[R811];
unrelate tfr from trv across R829;
relate tfr to act_tfm across R673;

// store the textual position of the operation name
act_tfm.operationNameLineNumber = val.LineNumber;
act_tfm.operationNameColumn = val.StartPosition;

// if the operation is class-based
if (tfr.Instance_Based == Scope::Class)
	// store the textual position of the class key-letters; use the 
	// value that is in the operation-value instance that was created 
	// when the operation''''s named was parsed, rather than the value in the 
	// current block, since the latter may have been overwritten
	// during the parsing of the operation''''s parameters 
	act_tfm.modelClassKeyLettersLineNumber = trv.modelClassKeyLettersLineNumber;
	act_tfm.modelClassKeyLettersColumn = trv.modelClassKeyLettersColumn;
end if;

select one var related by trv->V_VAR[R830];
if ( not_empty var )
  unrelate trv from var across R830;
  relate act_tfm to var across R667;
end if;

for each parm in parm_set
  unrelate parm from trv across R811;
  relate parm to act_tfm across R627;
end for;

val.dispose();

return stmt.Statement_ID;













































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4940,
	4939,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4941,
	4939,
	'a2_upper_rule_id',
	296,
	0,
	'',
	4940,
	'');
INSERT INTO S_SPARM
	VALUES (4942,
	4939,
	'a3_rule_begin_id',
	296,
	0,
	'',
	4941,
	'');
INSERT INTO S_SPARM
	VALUES (4943,
	4939,
	'a4_rule_id',
	296,
	0,
	'',
	4942,
	'');
INSERT INTO S_SPARM
	VALUES (4944,
	4939,
	'b1_transform_ib_invocation1_id',
	296,
	0,
	'',
	4943,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4945);
INSERT INTO S_SYNC
	VALUES (4945,
	1,
	'Relate_statement_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4946,
	4945,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4947);
INSERT INTO S_SYNC
	VALUES (4947,
	1,
	'Relationship_validate',
	'ParserValidateFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
current_scope = ::get_current_scope();
select any block from instances of ACT_BLK where
                                             selected.Block_ID == current_scope;
select one body related by block->ACT_ACT[R612];
isInGenericPackage = body.associateWithContainer();
if isInGenericPackage
  // store the textual position of the association number
  block.currentAssociationNumberLineNumber =
                               ::getLineNumber(rule_token: param.a1_rule_token);
  block.currentAssociationNumberColumn =
                                   ::getColumn(rule_token: param.a1_rule_token);
  select one containingElem related by body->ACT_BIE[R640]->PE_PE[R640];
  select one component related by containingElem->C_C[R8001];
  select one package related by containingElem->EP_PKG[R8001];

  // Check for Class keyletter match for token
  if not_empty component
    component.collectVisibleElementsForName(name:param.a3_text,
         type:ElementTypeConstants::ASSOCIATION,
                          originatingContainerID:component.Id,
                                   delegatingContainerID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:false);
  else
    package.collectVisibleElementsForName(name:param.a3_text,
         type:ElementTypeConstants::ASSOCIATION, descending:false,
                           originatingContainerID:package.Package_ID,
                                          delegatingPkgID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:false);
  end if;
  select any resultSet related by component->PE_CRS[R8007] where
                                     selected.Name == param.a3_text and 
                             selected.Type == ElementTypeConstants::ASSOCIATION; 
  select many results related by resultSet->PE_CVS[R8008]->PE_PE[R8004];
  if not_empty package
    select any pkgResultSet related by package->PE_SRS[R8005] where
                                     selected.Name == param.a3_text and 
                             selected.Type == ElementTypeConstants::ASSOCIATION; 
    select many results related by pkgResultSet->PE_VIS[R8006]->PE_PE[R8002];
  end if;
  if empty results
    ERR::reportParseError( msg: "Cannot find specified association ->%s<-",
          token: param.a1_rule_token );
  elif cardinality results > 1
    ERR::reportParseError( msg:
      "More than one association with number ->%s<- You will need to eventually clear this up",
          token: param.a1_rule_token );
  else
    result = GD::NULL_UNIQUE_ID();
    for each rel in results
      // will iterate only once
      result = rel.Element_ID;
    end for;
    return result;
  end if;
  return param.a6_current_rule_id;
else
  rel_num = OS::convert_relationship_string( rel: param.a3_text );
  // store the textual position of the association number
  block.currentAssociationNumberLineNumber =
                               ::getLineNumber(rule_token: param.a1_rule_token);
  block.currentAssociationNumberColumn =
                                   ::getColumn(rule_token: param.a1_rule_token);
  select many rel_set from instances of R_REL where ( selected.Numb == rel_num );
  body.associateWithOwningComponent();
  select one component related by body->ACT_BIC[R694]->C_C[R694];
  if not_empty component
    // If we''re in a component, we just look for the association locally
    select many rel_set related by component->CN_DC[R4204]->S_DOM[R4204]->
                             S_SS[R1]->R_REL[R4] where selected.Numb == rel_num;
  end if;
  if empty rel_set
    ERR::reportParseError( msg: "Cannot find specified association ->%s<-",
          token: param.a1_rule_token );
  elif cardinality rel_set > 1
    ERR::reportParseError( msg:
      "More than one association with number ->%s<- You will need to eventually clear this up",
          token: param.a1_rule_token );
  else
    result = GD::NULL_UNIQUE_ID();
    for each rel in rel_set
      // will iterate only once
      result = rel.Rel_ID;
    end for;
    return result;
  end if;
  return param.a6_current_rule_id;
end if;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4948,
	4947,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4949,
	4947,
	'a3_text',
	322,
	0,
	'',
	4948,
	'');
INSERT INTO S_SPARM
	VALUES (4950,
	4947,
	'a4_rule_ref_id',
	296,
	0,
	'',
	4949,
	'');
INSERT INTO S_SPARM
	VALUES (4951,
	4947,
	'a5_upper_rule_id',
	296,
	0,
	'',
	4950,
	'');
INSERT INTO S_SPARM
	VALUES (4952,
	4947,
	'a6_current_rule_id',
	296,
	0,
	'',
	4951,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4953);
INSERT INTO S_SYNC
	VALUES (4953,
	1,
	'Phrase_validate',
	'ParserValidateFunction: TRUE',
	'// store the textual position of the phrase
current_scope = ::get_current_scope();
select any block from instances of ACT_BLK where (selected.Block_ID == current_scope);
block.currentAssociationPhraseLineNumber = ::getLineNumber(rule_token: param.a1_rule_token);
block.currentAssociationPhraseColumn = ::getColumn(rule_token: param.a1_rule_token);

block.TempBuffer = param.a3_text;
return param.a6_current_rule_id;











































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4954,
	4953,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4955,
	4953,
	'a3_text',
	322,
	0,
	'',
	4954,
	'');
INSERT INTO S_SPARM
	VALUES (4956,
	4953,
	'a4_rule_ref_id',
	296,
	0,
	'',
	4955,
	'');
INSERT INTO S_SPARM
	VALUES (4957,
	4953,
	'a5_upper_rule_id',
	296,
	0,
	'',
	4956,
	'');
INSERT INTO S_SPARM
	VALUES (4958,
	4953,
	'a6_current_rule_id',
	296,
	0,
	'',
	4957,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4959);
INSERT INTO S_SYNC
	VALUES (4959,
	1,
	'Assoc_obj_inst_ref_var_validate',
	'ParserValidateFunction: TRUE',
	'return ::Inst_ref_var_validate( a1_rule_token: param.a1_rule_token,a3_text: param.a3_text,
    a4_rule_ref_id: param.a4_rule_ref_id, a5_upper_rule_id: param.a5_upper_rule_id, 
    a6_current_rule_id: param.a6_current_rule_id );













































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4960,
	4959,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4961,
	4959,
	'a3_text',
	322,
	0,
	'',
	4960,
	'');
INSERT INTO S_SPARM
	VALUES (4962,
	4959,
	'a4_rule_ref_id',
	296,
	0,
	'',
	4961,
	'');
INSERT INTO S_SPARM
	VALUES (4963,
	4959,
	'a5_upper_rule_id',
	296,
	0,
	'',
	4962,
	'');
INSERT INTO S_SPARM
	VALUES (4964,
	4959,
	'a6_current_rule_id',
	296,
	0,
	'',
	4963,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4965);
INSERT INTO S_SYNC
	VALUES (4965,
	1,
	'Relate_statement_end',
	'ParserValidateFunction: TRUE',
	'if ( param.b5_assoc_obj_inst_ref_var5_id == GD::NULL_UNIQUE_ID() )
  select any r_rel from instances of R_REL where ( selected.Rel_ID == param.b3_relationship3_id );
  select one r_assoc related by r_rel->R_ASSOC[R206];
  if ( not_empty r_assoc )
    ::clear_rel_data( a1_chain_start_val: GD::NULL_UNIQUE_ID(), a2_chain_id: GD::NULL_UNIQUE_ID(), a3_where_val: GD::NULL_UNIQUE_ID() );
     ERR::reportParseError( msg: 
       "Need USING clause for link classes in association ->R" + 
            GD::int_to_string(value: r_rel.Numb) + "<-",
            token: param.a1_rule_token );
  else
    select any one_var from instances of V_VAR 
        where ( selected.Var_ID == param.b1_inst_ref_var1_id );
    select any other_var from instances of V_VAR 
        where ( selected.Var_ID == param.b2_inst_ref_var2_id );
    select one left_obj related by one_var->V_INT[R814]->O_OBJ[R818];
    select one right_obj related by other_var->V_INT[R814]->O_OBJ[R818];
	if (empty left_obj)
	  ERR::reportParseError( msg:  "Variable ->" + one_var.Name + 
	        "<- does not exist in scope as an object instance variable",
            token: param.a1_rule_token );
    elif (empty right_obj)
      ERR::reportParseError( msg:  "Variable ->" + other_var.Name + 
	        "<- does not exist in scope as an object instance variable",
            token: param.a1_rule_token );
    else
      rel_mult = ::is_valid_relationship(a1_left: left_obj.Obj_ID, a2_right: right_obj.Obj_ID,
      a3_rel: param.b3_relationship3_id, a4_phrase: param.b4_phrase4_id, a5_rule_token: param.a1_rule_token,
      a6_chain_start_val: GD::NULL_UNIQUE_ID(), a7_chain_id: GD::NULL_UNIQUE_ID()  );
      if ( rel_mult != Multiplicity::Unknown )
        stmt_id =  ::statement_create();
        select any stmt from instances of ACT_SMT where selected.Statement_ID == stmt_id;
        create object instance rel of ACT_REL;
        relate stmt to rel across R603;

        current_scope = ::get_current_scope();
        select any block from instances of ACT_BLK where (selected.Block_ID == current_scope);

		// store the textual position of the association number
		rel.associationNumberLineNumber = block.currentAssociationNumberLineNumber;
		rel.associationNumberColumn = block.currentAssociationNumberColumn;

        if ( param.b4_phrase4_id == GD::NULL_UNIQUE_ID() )
          rel.relationship_phrase = "";
          else
            rel.relationship_phrase = block.TempBuffer;
            
			// store the textual position of the association phrase
			rel.associationPhraseLineNumber = block.currentAssociationPhraseLineNumber;
			rel.associationPhraseColumn = block.currentAssociationPhraseColumn;
          end if;
          relate rel to one_var across R615;
          relate rel to other_var across R616;
          select any r_rel from instances of R_REL where ( selected.Rel_ID == param.b3_relationship3_id );
          relate rel to r_rel across R653;
          return stmt.Statement_ID;
       else
        // association error -- fall through
       end if;
    end if;
    
  end if;
else
  select any one_var from instances of V_VAR 
        where ( selected.Var_ID == param.b1_inst_ref_var1_id );
  select any other_var from instances of V_VAR 
        where ( selected.Var_ID == param.b2_inst_ref_var2_id );
  select any assoc_var from instances of V_VAR 
        where ( selected.Var_ID == param.b5_assoc_obj_inst_ref_var5_id );
  select one left_obj related by one_var->V_INT[R814]->O_OBJ[R818];
  select one right_obj related by other_var->V_INT[R814]->O_OBJ[R818];
  select one assoc_obj related by assoc_var->V_INT[R814]->O_OBJ[R818];
  if (empty left_obj)
	ERR::reportParseError( msg:  "Variable ->" + one_var.Name + 
	        "<- does not exist in scope as an object instance variable",
            token: param.a1_rule_token );
  elif (empty right_obj)
    ERR::reportParseError( msg:  "Variable ->" + other_var.Name + 
	        "<- does not exist in scope as an object instance variable",
            token: param.a1_rule_token );  
  elif (empty assoc_obj)
    ERR::reportParseError( msg:  "Variable ->" + assoc_var.Name + 
	        "<- does not exist in scope as an object instance variable",
            token: param.a1_rule_token );  
  else
    if ( ::is_valid_assoc_relationship(a1_left: left_obj.Obj_ID, a2_right: right_obj.Obj_ID,
      a3_assoc: assoc_obj.Obj_ID,
      a4_rel: param.b3_relationship3_id, a5_phrase: param.b4_phrase4_id, a6_rule_token: param.a1_rule_token,
      a7_chain_start_val: GD::NULL_UNIQUE_ID(), a8_chain_id: GD::NULL_UNIQUE_ID() ) )
      
      stmt_id =  ::statement_create();
      select any stmt from instances of ACT_SMT where selected.Statement_ID == stmt_id;
      create object instance rel of ACT_RU;
      relate stmt to rel across R603;

        current_scope = ::get_current_scope();
        select any block from instances of ACT_BLK where (selected.Block_ID == current_scope);

		// store the textual position of the association number
		rel.associationNumberLineNumber = block.currentAssociationNumberLineNumber;
		rel.associationNumberColumn = block.currentAssociationNumberColumn;

      if ( param.b4_phrase4_id == GD::NULL_UNIQUE_ID() )
        rel.relationship_phrase = "";
      else
        rel.relationship_phrase = block.TempBuffer;
            
		// store the textual position of the association phrase
		rel.associationPhraseLineNumber = block.currentAssociationPhraseLineNumber;
		rel.associationPhraseColumn = block.currentAssociationPhraseColumn;
      end if;
      relate rel to one_var across R617;
      relate rel to other_var across R618;
      relate rel to assoc_var across R619;
      select any r_rel from instances of R_REL where ( selected.Rel_ID == param.b3_relationship3_id );
      relate rel to r_rel across R654;
      return stmt.Statement_ID;
    end if;            
  end if;
end if;

return param.a4_rule_id;























































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4966,
	4965,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4967,
	4965,
	'a2_upper_rule_id',
	296,
	0,
	'',
	4966,
	'');
INSERT INTO S_SPARM
	VALUES (4968,
	4965,
	'a3_rule_begin_id',
	296,
	0,
	'',
	4967,
	'');
INSERT INTO S_SPARM
	VALUES (4969,
	4965,
	'a4_rule_id',
	296,
	0,
	'',
	4968,
	'');
INSERT INTO S_SPARM
	VALUES (4970,
	4965,
	'b1_inst_ref_var1_id',
	296,
	0,
	'',
	4969,
	'');
INSERT INTO S_SPARM
	VALUES (4971,
	4965,
	'b2_inst_ref_var2_id',
	296,
	0,
	'',
	4970,
	'');
INSERT INTO S_SPARM
	VALUES (4972,
	4965,
	'b3_relationship3_id',
	296,
	0,
	'',
	4971,
	'');
INSERT INTO S_SPARM
	VALUES (4973,
	4965,
	'b4_phrase4_id',
	296,
	0,
	'',
	4972,
	'');
INSERT INTO S_SPARM
	VALUES (4974,
	4965,
	'b5_assoc_obj_inst_ref_var5_id',
	296,
	0,
	'',
	4973,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4975);
INSERT INTO S_SYNC
	VALUES (4975,
	1,
	'Return_statement_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;

',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4976,
	4975,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4977);
INSERT INTO S_SYNC
	VALUES (4977,
	1,
	'Return_statement_end',
	'ParserValidateFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// ::Return_statement_end()
current_scope = ::get_current_scope();
select any blk from instances of ACT_BLK where
                                             selected.Block_ID == current_scope;
if ( not_empty blk )
  select one act related by blk->ACT_ACT[R612];
  select one func related by act->ACT_FNB[R698]->S_SYNC[R695];
  select any ret_dt from instances of S_DT;
  // Get empty list
  select many dims from instances of S_DIM where selected.elementCount==-1000;

  if ( not_empty func )
    select one ret_dt related by func->S_DT[R25];
    select many dims related by func->S_DIM[R51];
  else
    select one op related by act->ACT_OPB[R698]->O_TFR[R696];
    if ( not_empty op )
      select one ret_dt related by op->S_DT[R116];
      select many dims related by op->S_DIM[R122];
    else
      select one brg related by act->ACT_BRB[R698]->S_BRG[R697];
      if ( not_empty brg )
        select one ret_dt related by brg->S_DT[R20];
        select many dims related by brg->S_DIM[R50];
      else
        select one reqOp related by act->ACT_ROB[R698]->SPR_RO[R685];
        if not_empty reqOp
          select one ret_dt related by reqOp->SPR_REP[R4502]->
                                          C_EP[R4500]->C_IO[R4004]->S_DT[R4008];
          select many dims related by reqOp->SPR_REP[R4502]->
                                         C_EP[R4500]->C_IO[R4004]->S_DIM[R4018];
        else
          select one provOp related by act->ACT_POB[R698]->SPR_PO[R687];
          if not_empty provOp
            select one ret_dt related by provOp->SPR_PEP[R4503]->
                                          C_EP[R4501]->C_IO[R4004]->S_DT[R4008];
            select many dims related by provOp->SPR_PEP[R4503]->
                                         C_EP[R4501]->C_IO[R4004]->S_DIM[R4018];
          else
            // MDA returns are always void
            select any dom from instances of S_DOM where
                                     selected.Dom_ID == ::getValidationDomain();
            select any ret_dt related by dom->S_DT[R14] where
                                                        selected.Name == "void";
            if empty ret_dt
              // if the return dt was not found, check the
              // system level
              sysName = ::getSystemName();
              select any system from instances of S_SYS
                                               where (selected.Name == sysName);
              dt_id = GD::NULL_UNIQUE_ID();
              if not_empty system
                dt_id = system.getCoreTypeId(name:"void");
              end if;
              select any pe from instances of PE_PE where
                                                   selected.Element_ID == dt_id;
              select one ret_dt related by pe->S_DT[R8001]; 
            end if;
          end if;
        end if;
      end if;
    end if;
  end if;

  if ( param.b1_expr1_id == GD::NULL_UNIQUE_ID() )
    if ( ret_dt.Name != "void" )
      ERR::reportParseError( msg: "Return value required by " + act.Type,
                                                   token: param.a1_rule_token );
    else
      act.ReturnFound = true;
      stmt_id =  ::statement_create();
      select any stmt from instances of ACT_SMT where
                                               selected.Statement_ID == stmt_id;
      create object instance ret of ACT_RET;
      relate stmt to ret across R603;
      return stmt.Statement_ID;
    end if;
  else
    select any val from instances of V_VAL where
                                         selected.Value_ID == param.b1_expr1_id;
    if ( ret_dt.Name == "void" )
      if ( not_empty val )
        val.dispose();
      end if;
      ERR::reportParseError( msg: "Return value not required by " + act.Type,
                                                   token: param.a1_rule_token );
    else
      select one val_dt related by val->S_DT[R820];
      dt = GD::NULL_UNIQUE_ID();
      if ( not_empty val_dt )
        dt = ::data_types_compatible( dt1: ret_dt.DT_ID,
                                              dt2: val_dt.DT_ID, op: "assign" );
      end if;
      if ( dt == GD::NULL_UNIQUE_ID() )
        if ( not_empty val )
          val.dispose();
        end if;
        ERR::reportParseError( msg: "Invalid data type returned for " +
                                         act.Type, token: param.a1_rule_token );
      else
        arrayErrorEncountered = false;
        if (not_empty dims)
          returnDimensions = cardinality dims;
          valDimensions = val.getDimensions();
          if (returnDimensions != valDimensions)
            arrayErrorEncountered = true;
            val.dispose();
            ERR::reportParseError(msg:
                        "Return type has incompatible array depth.",
                                                    token: param.a1_rule_token);
          else
            for each dim in dims
              valueDimSize = val.getArrayLength(dimension:dim.dimensionCount);
              if (valueDimSize != -1  and dim.elementCount != valueDimSize)
                // array size is fixed and does not match the expected size
                arrayErrorEncountered = true;
                val.dispose();
                dimStrValue = GD::int_to_string(value:dim.dimensionCount);
                ERR::reportParseError(msg:
                 "Return type has an incompatible array length for dimension " +
                                                             dimStrValue + ".",
                                                    token: param.a1_rule_token);
                break;
              end if;
            end for;
          end if;
        end if;
        if (not arrayErrorEncountered)
          act.ReturnFound = true;
          stmt_id =  ::statement_create();
          select any stmt from instances of ACT_SMT where
                                               selected.Statement_ID == stmt_id;
          create object instance ret of ACT_RET;
          relate stmt to ret across R603;
          relate ret to val across R668;
          return stmt.Statement_ID;
        end if;
      end if;
    end if;
  end if;
end if;
return param.a4_rule_id;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4978,
	4977,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4979,
	4977,
	'a2_upper_rule_id',
	296,
	0,
	'',
	4978,
	'');
INSERT INTO S_SPARM
	VALUES (4980,
	4977,
	'a3_rule_begin_id',
	296,
	0,
	'',
	4979,
	'');
INSERT INTO S_SPARM
	VALUES (4981,
	4977,
	'a4_rule_id',
	296,
	0,
	'',
	4980,
	'');
INSERT INTO S_SPARM
	VALUES (4982,
	4977,
	'b1_expr1_id',
	296,
	0,
	'',
	4981,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4983);
INSERT INTO S_SYNC
	VALUES (4983,
	1,
	'Select_statement_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4984,
	4983,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4985);
INSERT INTO S_SYNC
	VALUES (4985,
	1,
	'Object_spec_validate',
	'ParserValidateFunction: TRUE',
	'return param.a6_current_rule_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4986,
	4985,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4987,
	4985,
	'a3_text',
	322,
	0,
	'',
	4986,
	'');
INSERT INTO S_SPARM
	VALUES (4988,
	4985,
	'a4_rule_ref_id',
	296,
	0,
	'',
	4987,
	'');
INSERT INTO S_SPARM
	VALUES (4989,
	4985,
	'a5_upper_rule_id',
	296,
	0,
	'',
	4988,
	'');
INSERT INTO S_SPARM
	VALUES (4990,
	4985,
	'a6_current_rule_id',
	296,
	0,
	'',
	4989,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	4991);
INSERT INTO S_SYNC
	VALUES (4991,
	1,
	'Select_statement_end',
	'ParserValidateFunction: TRUE',
	'if ( param.b1_local_variable1_id != GD::NULL_UNIQUE_ID() )
  if ( param.b2_object_spec2_id == GD::NULL_UNIQUE_ID() )
    ::clear_select( var_id: param.b1_local_variable1_id );
    // object_spec error - return zero
    return GD::NULL_UNIQUE_ID();
  end if;
  // one
  select any stmt from instances of ACT_SMT 
          where (selected.Statement_ID ==   param.b2_object_spec2_id );
  select one fio related by stmt->ACT_FIO[R603];
  select one fiw related by stmt->ACT_FIW[R603];
  if ( not_empty fio or not_empty fiw )
    ::clear_select( var_id: param.b1_local_variable1_id );
    if ( not_empty fiw )
      select one val related by fiw->V_VAL[R610];
      val.dispose();
    end if;
    stmt.dispose();
    ERR::reportParseError( msg: "SELECT ONE cannot be used with FROM INSTANCES OF. Use SELECT ANY or SELECT MANY",
        token: param.a1_rule_token );
  else
    return ::process_related_by( a1_local_var: param.b1_local_variable1_id, a2_stmt_id: param.b2_object_spec2_id, 
        a3_mult:"one", a4_rule_token: param.a1_rule_token );
  end if;
elif ( param.b3_local_variable3_id != GD::NULL_UNIQUE_ID() )
  if ( param.b4_object_spec4_id == GD::NULL_UNIQUE_ID() )
    // object_spec error - return zero
    ::clear_select(  var_id: param.b3_local_variable3_id );
    return GD::NULL_UNIQUE_ID();
  end if;
  // any
  select any stmt from instances of ACT_SMT 
          where (selected.Statement_ID ==   param.b4_object_spec4_id );
  select one fio related by stmt->ACT_FIO[R603];
  if ( not_empty fio )
    return ::process_from_instances( a1_local_var: param.b3_local_variable3_id, a2_stmt_id: param.b4_object_spec4_id, 
        a3_mult:"any", a4_rule_token: param.a1_rule_token, a5_has_where: false );
  else
    select one fiw related by stmt->ACT_FIW[R603];
    if ( not_empty fiw )
      return ::process_from_instances( a1_local_var: param.b3_local_variable3_id, a2_stmt_id: param.b4_object_spec4_id, 
        a3_mult:"any", a4_rule_token: param.a1_rule_token, a5_has_where: true );
    else
      return ::process_related_by( a1_local_var: param.b3_local_variable3_id, a2_stmt_id: param.b4_object_spec4_id, 
          a3_mult:"any", a4_rule_token: param.a1_rule_token );
    end if;
  end if;
elif ( param.b5_local_variable5_id != GD::NULL_UNIQUE_ID() )
  if ( param.b6_object_spec6_id == GD::NULL_UNIQUE_ID() )
    ::clear_select(var_id: param.b1_local_variable1_id );
    // object_spec error - return zero
    return GD::NULL_UNIQUE_ID();
  end if;
  // many
  select any stmt from instances of ACT_SMT 
          where (selected.Statement_ID ==   param.b6_object_spec6_id );
  select one fio related by stmt->ACT_FIO[R603];
  if ( not_empty fio )
    return ::process_from_instances( a1_local_var: param.b5_local_variable5_id, a2_stmt_id: param.b6_object_spec6_id, 
        a3_mult:"many", a4_rule_token: param.a1_rule_token, a5_has_where: false );
  else
    select one fiw related by stmt->ACT_FIW[R603];
    if ( not_empty fiw )
      return ::process_from_instances( a1_local_var: param.b5_local_variable5_id, a2_stmt_id: param.b6_object_spec6_id, 
        a3_mult:"many", a4_rule_token: param.a1_rule_token, a5_has_where: true );
    else
      return ::process_related_by( a1_local_var: param.b5_local_variable5_id, a2_stmt_id: param.b6_object_spec6_id, 
          a3_mult:"many", a4_rule_token: param.a1_rule_token );
    end if;
  end if;
else
  // internal error -- should have been caught as a syntax error
  return GD::NULL_UNIQUE_ID();
end if;
return param.a4_rule_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (4992,
	4991,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (4993,
	4991,
	'a2_upper_rule_id',
	296,
	0,
	'',
	4992,
	'');
INSERT INTO S_SPARM
	VALUES (4994,
	4991,
	'a3_rule_begin_id',
	296,
	0,
	'',
	4993,
	'');
INSERT INTO S_SPARM
	VALUES (4995,
	4991,
	'a4_rule_id',
	296,
	0,
	'',
	4994,
	'');
INSERT INTO S_SPARM
	VALUES (4996,
	4991,
	'b1_local_variable1_id',
	296,
	0,
	'',
	4995,
	'');
INSERT INTO S_SPARM
	VALUES (4997,
	4991,
	'b2_object_spec2_id',
	296,
	0,
	'',
	4996,
	'');
INSERT INTO S_SPARM
	VALUES (4998,
	4991,
	'b3_local_variable3_id',
	296,
	0,
	'',
	4997,
	'');
INSERT INTO S_SPARM
	VALUES (4999,
	4991,
	'b4_object_spec4_id',
	296,
	0,
	'',
	4998,
	'');
INSERT INTO S_SPARM
	VALUES (5000,
	4991,
	'b5_local_variable5_id',
	296,
	0,
	'',
	4999,
	'');
INSERT INTO S_SPARM
	VALUES (5001,
	4991,
	'b6_object_spec6_id',
	296,
	0,
	'',
	5000,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5002);
INSERT INTO S_SYNC
	VALUES (5002,
	1,
	'Transform_statement_start',
	'ParserValidateFunction: TRUE',
	'return ::statement_create();


',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5003,
	5002,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5004);
INSERT INTO S_SYNC
	VALUES (5004,
	1,
	'Transform_invocation_validate',
	'ParserValidateFunction: TRUE',
	'if ( param.a6_current_rule_id != GD::NULL_UNIQUE_ID() )
  select any val from instances of V_VAL where selected.Value_ID == param.a6_current_rule_id;
  if ( not_empty val )
    select one sdt related by val->S_DT[R820];
    if ( empty sdt )
      ERR::reportParseError( msg: "Value has unknown data type",
           token: param.a1_rule_token );
    else
      select one op related by val->V_TRV[R801]->O_TFR[R829];
      if ( not_empty op )
        return ::is_valid_invocation( a1_type: sdt.Name, a2_isRval: param.a2_isRval, a3_id: param.a6_current_rule_id,
            a4_name: "Transform ->"  + op.Name, a5_rule_token: param.a1_rule_token );
      end if;
    end if;
  end if;
end if;

return GD::NULL_UNIQUE_ID();


',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5005,
	5004,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5006,
	5004,
	'a2_isRval',
	316,
	0,
	'',
	5005,
	'');
INSERT INTO S_SPARM
	VALUES (5007,
	5004,
	'a3_text',
	322,
	0,
	'',
	5006,
	'');
INSERT INTO S_SPARM
	VALUES (5008,
	5004,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5007,
	'');
INSERT INTO S_SPARM
	VALUES (5009,
	5004,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5008,
	'');
INSERT INTO S_SPARM
	VALUES (5010,
	5004,
	'a6_current_rule_id',
	296,
	0,
	'',
	5009,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5011);
INSERT INTO S_SYNC
	VALUES (5011,
	1,
	'Transform_statement_end',
	'ParserValidateFunction: TRUE',
	'// ::Transform_statement_end()
select any val from instances of V_VAL 
       where ( selected.Value_ID == param.b4_transform_invocation4_id );
if ( empty val )
  select any val from instances of V_VAL 
         where ( selected.Value_ID == param.b5_transform_invocation5_id );
end if;

if ( empty val )
  // there was a problem with parsing the value
  select any stmt from instances of ACT_SMT 
        where selected.Statement_ID == param.a3_rule_begin_id;
  stmt.dispose();
  return GD::NULL_UNIQUE_ID();
end if;

if (  param.b5_transform_invocation5_id != GD::NULL_UNIQUE_ID() )
  // the statement (returning void) variation
  select any stmt from instances of ACT_SMT 
        where selected.Statement_ID == param.a3_rule_begin_id;

  create object instance atfr of ACT_TFM;
  relate stmt to atfr across R603;
  select one trv related by val->V_TRV[R801];
  select one op related by trv->O_TFR[R829];
  select many parm_set related by trv->V_PAR[R811];
  unrelate op from trv across R829;
  relate op to atfr across R673;

	// store the textual position of the operation name
	atfr.operationNameLineNumber = val.LineNumber;
	atfr.operationNameColumn = val.StartPosition;

	// if the operation is class-based
	if (op.Instance_Based == Scope::Class)
		// store the textual position of the class key-letters; use the 
		// value that is in the operation-value instance that was created 
		// when the operation''''s named was parsed, rather than the value in the 
		// current block, since the latter may have been overwritten
		// during the parsing of the operation''''s parameters 
		atfr.modelClassKeyLettersLineNumber = trv.modelClassKeyLettersLineNumber;
		atfr.modelClassKeyLettersColumn = trv.modelClassKeyLettersColumn;
	end if;

  for each parm in parm_set
    unrelate parm from trv across R811;
    relate parm to atfr across R627;
  end for;

  val.dispose();

  return stmt.Statement_ID;
elif (  param.b2_member_id != GD::NULL_UNIQUE_ID() )
  return ::Assignment_expr_end( a1_rule_token: param.a1_rule_token, 
      a2_upper_rule_id: param.a3_rule_begin_id,
      a3_rule_begin_id: param.a3_rule_begin_id,
      a4_rule_id: param.a4_rule_id,
      b1_member_id: param.b2_member_id,
      b2_expr2_id: param.b4_transform_invocation4_id,
      b3_param_data_access3_id: GD::NULL_UNIQUE_ID(),
      b4_expr4_id: GD::NULL_UNIQUE_ID()
  );
elif (  param.b3_param_data_access3_id != GD::NULL_UNIQUE_ID() )
  // this creates a statement with an AssignToParameter subtype
  return ::Assignment_expr_end( a1_rule_token: param.a1_rule_token, 
        a2_upper_rule_id: param.a3_rule_begin_id,
        a3_rule_begin_id: param.a3_rule_begin_id,
        a4_rule_id: param.a4_rule_id,
        b1_member_id: GD::NULL_UNIQUE_ID(),
        b2_expr2_id: GD::NULL_UNIQUE_ID(),
        b3_param_data_access3_id: param.b3_param_data_access3_id,
        b4_expr4_id: param.b4_transform_invocation4_id
  );
end if;

return GD::NULL_UNIQUE_ID();

',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5012,
	5011,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5013,
	5011,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5012,
	'');
INSERT INTO S_SPARM
	VALUES (5014,
	5011,
	'a3_rule_begin_id',
	296,
	0,
	'',
	5013,
	'');
INSERT INTO S_SPARM
	VALUES (5015,
	5011,
	'a4_rule_id',
	296,
	0,
	'',
	5014,
	'');
INSERT INTO S_SPARM
	VALUES (5016,
	5011,
	'b2_member_id',
	296,
	0,
	'',
	5015,
	'');
INSERT INTO S_SPARM
	VALUES (5017,
	5011,
	'b3_param_data_access3_id',
	296,
	0,
	'',
	5016,
	'');
INSERT INTO S_SPARM
	VALUES (5018,
	5011,
	'b4_transform_invocation4_id',
	296,
	0,
	'',
	5017,
	'');
INSERT INTO S_SPARM
	VALUES (5019,
	5011,
	'b5_transform_invocation5_id',
	296,
	0,
	'',
	5018,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5020);
INSERT INTO S_SYNC
	VALUES (5020,
	1,
	'Function_statement_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5021,
	5020,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5022);
INSERT INTO S_SYNC
	VALUES (5022,
	1,
	'Function_invocation_validate',
	'ParserValidateFunction: TRUE',
	'if ( param.a6_current_rule_id != GD::NULL_UNIQUE_ID() )
  select any val from instances of V_VAL where selected.Value_ID == param.a6_current_rule_id;
  if ( not_empty val )
    select one sdt related by val->S_DT[R820];
    if ( empty sdt )
      ERR::reportParseError( msg: "Value has unknown data type",
           token: param.a1_rule_token );
    else
      select one sync related by val->V_FNV[R801]->S_SYNC[R827];
      if ( not_empty sync )
        return ::is_valid_invocation( a1_type: sdt.Name, a2_isRval: param.a2_isRval, a3_id: param.a6_current_rule_id,
           a4_name: "Function ->"  + sync.Name, a5_rule_token: param.a1_rule_token );
      end if;
    end if;
  end if;
end if;

return param.a6_current_rule_id;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5023,
	5022,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5024,
	5022,
	'a2_isRval',
	316,
	0,
	'',
	5023,
	'');
INSERT INTO S_SPARM
	VALUES (5025,
	5022,
	'a3_text',
	322,
	0,
	'',
	5024,
	'');
INSERT INTO S_SPARM
	VALUES (5026,
	5022,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5025,
	'');
INSERT INTO S_SPARM
	VALUES (5027,
	5022,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5026,
	'');
INSERT INTO S_SPARM
	VALUES (5028,
	5022,
	'a6_current_rule_id',
	296,
	0,
	'',
	5027,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5029);
INSERT INTO S_SYNC
	VALUES (5029,
	1,
	'Function_statement_end',
	'ParserValidateFunction: TRUE',
	'if ( param.b1_function_invocation1_id != GD::NULL_UNIQUE_ID() )
  select any V_FNV from instances of V_FNV 
     where ( selected.Value_ID == param.b1_function_invocation1_id );

  stmt_id =  ::statement_create();
  select any stmt from instances of ACT_SMT where selected.Statement_ID == stmt_id;

  create object instance act_fnc of ACT_FNC;
  relate act_fnc to stmt across R603;

  select one sync related by V_FNV->S_SYNC[R827];
  select many parm_set related by V_FNV->V_PAR[R817];

  unrelate sync from V_FNV across R827;
  relate sync to act_fnc across R675;

	// store the textual position of the function name
	select one val related by V_FNV->V_VAL[R801];
	act_fnc.functionNameLineNumber = val.LineNumber;
	act_fnc.functionNameColumn = val.StartPosition;

  for each parm in parm_set
    unrelate parm from V_FNV across R817;
    relate parm to act_fnc across R669;
  end for;

  val.dispose();

  return stmt.Statement_ID;
end if;

return GD::NULL_UNIQUE_ID();









































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5030,
	5029,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5031,
	5029,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5030,
	'');
INSERT INTO S_SPARM
	VALUES (5032,
	5029,
	'a3_rule_begin_id',
	296,
	0,
	'',
	5031,
	'');
INSERT INTO S_SPARM
	VALUES (5033,
	5029,
	'a4_rule_id',
	296,
	0,
	'',
	5032,
	'');
INSERT INTO S_SPARM
	VALUES (5034,
	5029,
	'b1_function_invocation1_id',
	296,
	0,
	'',
	5033,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5035);
INSERT INTO S_SYNC
	VALUES (5035,
	1,
	'Unrelate_statement_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;

',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5036,
	5035,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5037);
INSERT INTO S_SYNC
	VALUES (5037,
	1,
	'Unrelate_statement_end',
	'ParserValidateFunction: TRUE',
	'if ( param.b5_assoc_obj_inst_ref_var5_id == GD::NULL_UNIQUE_ID() )
  select any r_rel from instances of R_REL where ( selected.Rel_ID == param.b3_relationship3_id );
  select one r_assoc related by r_rel->R_ASSOC[R206];
  if ( not_empty r_assoc )
     ERR::reportParseError( msg: 
       "Need USING clause for link classes in association ->R" + 
            GD::int_to_string(value: r_rel.Numb) + "<-",
            token: param.a1_rule_token );
  else
    select any one_var from instances of V_VAR 
        where ( selected.Var_ID == param.b1_inst_ref_var1_id );
    select any other_var from instances of V_VAR 
        where ( selected.Var_ID == param.b2_inst_ref_var2_id );
    select one left_obj related by one_var->V_INT[R814]->O_OBJ[R818];
    select one right_obj related by other_var->V_INT[R814]->O_OBJ[R818];
    if (empty left_obj)
	  ERR::reportParseError( msg:  "Variable ->" + one_var.Name + 
	        "<- does not exist in scope as an object instance variable",
            token: param.a1_rule_token );
    elif (empty right_obj)
      ERR::reportParseError( msg:  "Variable ->" + other_var.Name + 
	        "<- does not exist in scope as an object instance variable",
            token: param.a1_rule_token );  
    else 
      rel_mult = ::is_valid_relationship(a1_left: left_obj.Obj_ID, a2_right: right_obj.Obj_ID,
        a3_rel: param.b3_relationship3_id, a4_phrase: param.b4_phrase4_id, a5_rule_token: param.a1_rule_token,
        a6_chain_start_val: GD::NULL_UNIQUE_ID(), a7_chain_id: GD::NULL_UNIQUE_ID()  );
      if ( rel_mult != Multiplicity::Unknown )
        stmt_id =  ::statement_create();
        select any stmt from instances of ACT_SMT where selected.Statement_ID == stmt_id;
        create object instance rel of ACT_UNR;
        relate stmt to rel across R603;

        current_scope = ::get_current_scope();
        select any block from instances of ACT_BLK where (selected.Block_ID == current_scope);

		// store the textual position of the association number
		rel.associationNumberLineNumber = block.currentAssociationNumberLineNumber;
		rel.associationNumberColumn = block.currentAssociationNumberColumn;

        if ( param.b4_phrase4_id == GD::NULL_UNIQUE_ID() )
          rel.relationship_phrase = "";
        else
          rel.relationship_phrase = block.TempBuffer;
            
			// store the textual position of the association phrase
			rel.associationPhraseLineNumber = block.currentAssociationPhraseLineNumber;
			rel.associationPhraseColumn = block.currentAssociationPhraseColumn;
        end if;
        relate rel to one_var across R620;
        relate rel to other_var across R621;
        select any r_rel from instances of R_REL where ( selected.Rel_ID == param.b3_relationship3_id ); 
        relate rel to r_rel across R655;
        return stmt.Statement_ID;
      else
        // association error -- fall through
      end if;
    end if;
  end if;
else
  select any one_var from instances of V_VAR 
        where ( selected.Var_ID == param.b1_inst_ref_var1_id );
  select any other_var from instances of V_VAR 
        where ( selected.Var_ID == param.b2_inst_ref_var2_id );
  select any assoc_var from instances of V_VAR 
        where ( selected.Var_ID == param.b5_assoc_obj_inst_ref_var5_id );
  select one left_obj related by one_var->V_INT[R814]->O_OBJ[R818];
  select one right_obj related by other_var->V_INT[R814]->O_OBJ[R818];
  select one assoc_obj related by assoc_var->V_INT[R814]->O_OBJ[R818];
  if (empty left_obj)
	ERR::reportParseError( msg:  "Variable ->" + one_var.Name + 
	        "<- does not exist in scope as an object instance variable",
            token: param.a1_rule_token );
  elif (empty right_obj)
    ERR::reportParseError( msg:  "Variable ->" + other_var.Name + 
	        "<- does not exist in scope as an object instance variable",
            token: param.a1_rule_token );  
  elif (empty assoc_obj)
    ERR::reportParseError( msg:  "Variable ->" + assoc_var.Name + 
	        "<- does not exist in scope as an object instance variable",
            token: param.a1_rule_token );  
  else 
    if ( ::is_valid_assoc_relationship(a1_left: left_obj.Obj_ID, a2_right: right_obj.Obj_ID,
        a3_assoc: assoc_obj.Obj_ID,
        a4_rel: param.b3_relationship3_id, a5_phrase: param.b4_phrase4_id, a6_rule_token: param.a1_rule_token,
        a7_chain_start_val: GD::NULL_UNIQUE_ID(), a8_chain_id: GD::NULL_UNIQUE_ID() ) )
        
      current_scope = ::get_current_scope();
      select any blk from instances of ACT_BLK where (selected.Block_ID == current_scope);
      if ( not_empty blk )
        stmt_id =  ::statement_create();
        select any stmt from instances of ACT_SMT where selected.Statement_ID == stmt_id;
        create object instance rel of ACT_URU;
        relate stmt to rel across R603;

        current_scope = ::get_current_scope();
        select any block from instances of ACT_BLK where (selected.Block_ID == current_scope);

		// store the textual position of the association number
		rel.associationNumberLineNumber = block.currentAssociationNumberLineNumber;
		rel.associationNumberColumn = block.currentAssociationNumberColumn;

        if ( param.b4_phrase4_id == GD::NULL_UNIQUE_ID() )
          rel.relationship_phrase = "";
        else
          rel.relationship_phrase = block.TempBuffer;
            
			// store the textual position of the association phrase
			rel.associationPhraseLineNumber = block.currentAssociationPhraseLineNumber;
			rel.associationPhraseColumn = block.currentAssociationPhraseColumn;
        end if;
        select any one_var from instances of V_VAR where ( selected.Var_ID == param.b1_inst_ref_var1_id );
        relate rel to one_var across R622;
        select any other_var from instances of V_VAR where ( selected.Var_ID == param.b2_inst_ref_var2_id );
        relate rel to other_var across R623;
        select any assoc_var from instances of V_VAR where ( selected.Var_ID == param.b5_assoc_obj_inst_ref_var5_id );
        relate rel to assoc_var across R624;
        select any r_rel from instances of R_REL where ( selected.Rel_ID == param.b3_relationship3_id );
        relate rel to r_rel across R656;
        return stmt.Statement_ID;
      end if;
    end if;
  end if;
end if;

return param.a4_rule_id;
























































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5038,
	5037,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5039,
	5037,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5038,
	'');
INSERT INTO S_SPARM
	VALUES (5040,
	5037,
	'a3_rule_begin_id',
	296,
	0,
	'',
	5039,
	'');
INSERT INTO S_SPARM
	VALUES (5041,
	5037,
	'a4_rule_id',
	296,
	0,
	'',
	5040,
	'');
INSERT INTO S_SPARM
	VALUES (5042,
	5037,
	'b1_inst_ref_var1_id',
	296,
	0,
	'',
	5041,
	'');
INSERT INTO S_SPARM
	VALUES (5043,
	5037,
	'b2_inst_ref_var2_id',
	296,
	0,
	'',
	5042,
	'');
INSERT INTO S_SPARM
	VALUES (5044,
	5037,
	'b3_relationship3_id',
	296,
	0,
	'',
	5043,
	'');
INSERT INTO S_SPARM
	VALUES (5045,
	5037,
	'b4_phrase4_id',
	296,
	0,
	'',
	5044,
	'');
INSERT INTO S_SPARM
	VALUES (5046,
	5037,
	'b5_assoc_obj_inst_ref_var5_id',
	296,
	0,
	'',
	5045,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5047);
INSERT INTO S_SYNC
	VALUES (5047,
	1,
	'While_statement_start',
	'ParserValidateFunction: TRUE',
	'stmt_id =  ::statement_create();
select any stmt from instances of ACT_SMT where selected.Statement_ID == stmt_id;

create object instance w of ACT_WHL;
relate w to stmt across R603;

select one act related by stmt->ACT_BLK[R602]->ACT_ACT[R612];
act.entered_loop();

return stmt.Statement_ID;

',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5048,
	5047,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5049);
INSERT INTO S_SYNC
	VALUES (5049,
	1,
	'While_statement_end',
	'ParserValidateFunction: TRUE',
	'current_scope = ::get_current_scope();
select any blk from instances of ACT_BLK where (selected.Block_ID == current_scope);
select one act related by blk->ACT_ACT[R612];
act.exitted_loop();

select any wstmt from instances of ACT_WHL 
          where ( selected.Statement_ID == param.a3_rule_begin_id );
if ( empty wstmt )
  select any val from instances of V_VAL where ( selected.Value_ID == param.b1_expr1_id );
  if ( not_empty val  )
    val.dispose();
  end if;
     ERR::reportParseError( msg: "While statement not found",
        token: param.a1_rule_token );
else
  select one stmt related by wstmt->ACT_SMT[R603];
  select any val from instances of V_VAL where ( selected.Value_ID == param.b1_expr1_id );
  if ( empty val  )
    stmt.dispose();
    ERR::reportParseError( msg: "While expression not found",
        token: param.a1_rule_token );
  else
    select one val_dt related by val->S_DT[R820];
    if ( empty val_dt )
      stmt.dispose();
      val.dispose();
       ERR::reportParseError( msg: "While expression unknown data type",
          token: param.a1_rule_token );
    elif ( val_dt.Name != "boolean" )
      stmt.dispose();
      val.dispose();
       ERR::reportParseError( msg: "While expression data type is not boolean",
          token: param.a1_rule_token );
    else
      relate wstmt to val across R626;
    end if;
  end if;
end if;
return param.a3_rule_begin_id;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5050,
	5049,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5051,
	5049,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5050,
	'');
INSERT INTO S_SPARM
	VALUES (5052,
	5049,
	'a3_rule_begin_id',
	296,
	0,
	'',
	5051,
	'');
INSERT INTO S_SPARM
	VALUES (5053,
	5049,
	'a4_rule_id',
	296,
	0,
	'',
	5052,
	'');
INSERT INTO S_SPARM
	VALUES (5054,
	5049,
	'b1_expr1_id',
	296,
	0,
	'',
	5053,
	'');
INSERT INTO S_SPARM
	VALUES (5055,
	5049,
	'b2_block2_id',
	296,
	0,
	'',
	5054,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5056);
INSERT INTO S_SYNC
	VALUES (5056,
	1,
	'Assignment_expr_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5057,
	5056,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5058);
INSERT INTO S_SYNC
	VALUES (5058,
	1,
	'Assignment_expr_end',
	'ParserValidateFunction: TRUE',
	'// ::Assignment_expr_end()
select any rval from instances of V_VAL where
                                         selected.Value_ID == param.b2_expr2_id;
if ( empty rval )
  if ( param.b4_expr4_id != GD::NULL_UNIQUE_ID() )
    select any rval from instances of V_VAL where
                                         selected.Value_ID == param.b4_expr4_id;
  end if;
end if;
if ( empty rval )
  // there was a problem with parsing the r-value
  ::clear_assignment_data( stmt_id: param.a2_upper_rule_id,
                                                   var_id: param.b1_member_id );
  return param.a4_rule_id;
end if;

if (  param.b1_member_id != GD::NULL_UNIQUE_ID() )
  select any lval from instances of V_VAL where
                                        selected.Value_ID == param.b1_member_id;
  if empty lval
    // there was a problem with parsing the l-value
    ::clear_assignment_data( stmt_id: param.a2_upper_rule_id,
                                                   var_id: param.b1_member_id );
    return param.a4_rule_id;
  end if;
  rval_end_ID = ::get_value_chain_end(start_value_ID:rval.Value_ID);
  select any rval from instances of V_VAL where
                                               selected.Value_ID == rval_end_ID;
  lval_end_ID = ::get_value_chain_end(start_value_ID:lval.Value_ID);
  select any lval from instances of V_VAL where
                                               selected.Value_ID == lval_end_ID;
  assign_ok = true;
  if empty lval or empty rval
    // there was a problem with finding the values
    ::clear_assignment_data(stmt_id: param.a2_upper_rule_id,
                                                   var_id: param.b1_member_id );
    return param.a4_rule_id;
  end if;
  err_msg = "";
  select one tvl related by lval->V_TVL[R801];
  select one irf related by lval->V_IRF[R801];
  select one isrf related by lval->V_ISR[R801];
  select one avl related by lval->V_AVL[R801];
  select one scv related by lval->V_SCV[R801];
  // This may not be the right lvar, but if it isn''t,
  // the correct one will be selected in the logic below.
  select one lvar related by lval->V_TVL[R801]->V_VAR[R805];
  if not_empty tvl
    select one trn_dt related by lval->S_DT[R820];
    select one val_dt related by rval->S_DT[R820];
    if empty trn_dt
      // no data type - first assignment
      // make sure there wasnt a typing problem for the value
      if not_empty val_dt
        select one obj_thru_irdt related by val_dt->S_IRDT[R17]->O_OBJ[R123];
        obj_id = GD::NULL_UNIQUE_ID();
        if ( not_empty obj_thru_irdt )
          obj_id = obj_thru_irdt.Obj_ID;
        end if;
        // Set up the dimensions.
        numDimensions = rval.getDimensions();
		if (  numDimensions < 0 )
		  assign_ok = false;
		  if ( numDimensions == -1)
            err_msg = "The rvalue has one more dimension than the definition";
          else
            numDimensions = numDimensions * -1;
            err_msg = "The rvalue has " + GD::int_to_string(value:numDimensions) 
                        + " more dimensions than the definition";
          end if;
        elif ( rval.isElementCountValid() )
          // Its a simple data type. Hook up the data type to the correct
          relate lvar to val_dt across R848;
          relate lval to val_dt across R820;
          i = 0;
          while ( i < numDimensions )
            // Resize each dimension
            elementCount = rval.getArrayLength(dimension:i);
            lvar.resizeDimensions(dimension:i, elementCount:elementCount, numDimensions:numDimensions);
            i = i + 1;
          end while;
        else
          assign_ok = false;
          err_msg = "The rvalue contains an Array Index Out of Bounds.";
        end if;
          
        select one irdt related by val_dt->S_IRDT[R17];
        if ( not ::has_substring(p1_base: val_dt.Name, p2_str: "inst_ref<Timer>", p3_fromIndex: 0) and
             not ::has_substring(p1_base: val_dt.Name, p2_str: "inst_ref<Mapping>", p3_fromIndex: 0) and ((not_empty irdt and not irdt.isSet) or
             ::has_substring(p1_base: val_dt.Name, p2_str: "inst_ref<Object>", p3_fromIndex: 0)) )
          lvar.migrate_to_int();
          select one new_inst_var related by lvar->V_INT[R814];
          select one obj related by rval->V_IRF[R801]->V_VAR[R808]->
                                                       V_INT[R814]->O_OBJ[R818];
          if ( empty obj_thru_irdt )
            if ( not_empty obj )
              obj_id = obj.Obj_ID;
              relate new_inst_var to obj across R818;
            end if;
          else
            relate new_inst_var to obj_thru_irdt across R818;
          end if;
          
          // migrate the value to an instance reference
          unrelate lval from tvl across R801;
          unrelate lvar from tvl across R805;
          delete object instance tvl;
          create object instance int of V_IRF;
          relate lval to int across R801;
          relate int to lvar across R808;
          ::connect_inst_ref_var_to_datatype(p1_is_set:false, p2_var_id:lvar.Var_ID, p3_obj_id:obj_id);
        elif ( ::has_substring(p1_base: val_dt.Name, p2_str: "inst_ref_set<Object>", p3_fromIndex: 0) or (not_empty irdt and irdt.isSet))
          lvar.migrate_to_ins();
          select one new_inst_set_var related by lvar->V_INS[R814];
          select one obj related by rval->V_ISR[R801]->V_VAR[R809]->
                                                       V_INS[R814]->O_OBJ[R819];
          if ( empty obj_thru_irdt )
            if ( not_empty obj )
              obj_id = obj.Obj_ID;
              relate new_inst_set_var to obj across R819;
            end if;
          else
            relate new_inst_set_var to obj_thru_irdt across R819;
          end if;
          // migrate the value to an instance set reference
          unrelate lval from tvl across R801;
          unrelate lvar from tvl across R805;
          delete object instance tvl;
          create object instance ins of V_ISR;
          relate lval to ins across R801;
          relate ins to lvar across R809;
          ::connect_inst_ref_var_to_datatype(p1_is_set:true, p2_var_id:lvar.Var_ID, p3_obj_id:obj_id);
        else
			// Transient Variable
        end if;
      end if;
    elif not_empty trn_dt and not_empty val_dt
      // data type is known, check compatibility
      dt = ::data_types_compatible ( dt1: trn_dt.DT_ID,
                                              dt2: val_dt.DT_ID, op: "assign" );
      if ( dt == GD::NULL_UNIQUE_ID() )
        assign_ok = false;
        err_msg = "Variable ->"+ lvar.Name +
                                        "<- already exists as a different type";
      end if;
      if (lval.getDimensions() != rval.getDimensions())
        assign_ok = false;
        err_msg = "Variable ->"+ lvar.Name + "<- has incompatible array depth.";
      elif ( not lval.isElementCountValid() )
        assign_ok = false;
        err_msg = "Variable ->"+ lvar.Name + "<- contains an Array Index Out of Bounds.";
      elif ( not rval.isElementCountValid() )
        assign_ok = false;
        err_msg = "The rvalue contains an Array Index Out of Bounds.";
      end if;
      if (not lval.isElementCountCompatible(rVal:rval.Value_ID))
        assign_ok = false;
        err_msg = "Variable ->"+ lvar.Name + "<- has incompatible dimension size with the rvalue.";
      end if;
    else
      assign_ok = false;
      err_msg = "Unexpected token.";
    end if;
  elif not_empty irf
    select one lvar related by irf->V_VAR[R808];
    select one l_obj related by lvar->V_INT[R814]->O_OBJ[R818];
    select one val_dt related by rval->S_DT[R820];
    select one r_irdt related by val_dt->S_IRDT[R17];
    select one r_obj related by rval->V_IRF[R801]->V_VAR[R808]->
                                                       V_INT[R814]->O_OBJ[R818];
	if(not_empty r_irdt)
	  // if this is a true instance reference data type
	  // then select the right object related
	  select one r_obj related by r_irdt->O_OBJ[R123];
	end if;
    if ( empty r_obj )
      assign_ok = false;
      err_msg = "Variable ->" + lvar.Name +
                                        "<- already exists as a different type";
    elif ( l_obj.Obj_ID != r_obj.Obj_ID )
      assign_ok = false;
      err_msg = "Variable ->" + lvar.Name +
                                        "<- already exists as a different type";
    end if;
    
    select one left_val_dt related by lval->S_DT[R820];
                         
    if ( val_dt.Name != left_val_dt.Name )
      assign_ok = false;
      err_msg = "Variable ->" + lvar.Name +
                                        "<- already exists as a different type";
    end if;	
                 
    
  elif not_empty isrf
    select one lvar related by isrf->V_VAR[R809];
    select one l_obj related by lvar->V_INS[R814]->O_OBJ[R819];
    select one val_dt related by rval->S_DT[R820];
    select one r_irdt related by val_dt->S_IRDT[R17];
    select one r_obj related by rval->V_ISR[R801]->V_VAR[R809]->
                                                       V_INS[R814]->O_OBJ[R819];
	if(not_empty r_irdt and r_irdt.isSet)
	  select one r_obj related by r_irdt->O_OBJ[R123];
	end if;
    if ( empty r_obj )
      assign_ok = false;
      err_msg = "Variable ->" + lvar.Name +
                                        "<- already exists as a different type";
    elif ( l_obj.Obj_ID != r_obj.Obj_ID )
      assign_ok = false;
      err_msg = "Variable ->" + lvar.Name +
                                        "<- already exists as a different type";
    end if;
  elif not_empty avl
    select one attr related by avl->O_ATTR[R806];
    select one r_dt related by attr->S_DT[R114];
    if ( r_dt.Name == "state<State_Model>" and attr.Name == "current_state" )
      assign_ok = false;
      err_msg = "Cannot assign to the current_state attribute";
    else
      select one rval_dt related by rval->S_DT[R820];
      dt = GD::NULL_UNIQUE_ID();
      if not_empty r_dt and not_empty rval_dt
        dt = ::data_types_compatible ( dt1: r_dt.DT_ID, dt2: rval_dt.DT_ID,
                                    op: "assign" );
      end if;
      if ( dt == GD::NULL_UNIQUE_ID() )
        assign_ok = false;
        err_msg = "Attribute ->"+ attr.Name + "<- is a different type";
      elif ( r_dt.Name == "unique_id" )
        select any oida related by attr->O_OIDA[R105];
        if ( not_empty oida )
          assign_ok = false;
          err_msg = "Cannot assign to an attribute ->" + attr.Name +
                         "<- which is of type unique_id and also an identifier";
        end if;
      else
        select one ref_attr related by attr->O_RATTR[R106];
        if ( not_empty ref_attr )
          assign_ok = false;
          err_msg = "Cannot assign to a referential attribute ->" +
                         attr.Name + "<-";
        else
          select one db_attr related by attr->O_BATTR[R106]->O_DBATTR[R107];
          if ( not_empty db_attr )
            // are we parsing an MDA?
            scope_ID = ::get_current_context();
            select any body from instances of ACT_ACT where
                                                 selected.Action_ID == scope_ID;
            select one dab related by body->ACT_DAB[R698];
            if ( empty dab )
              if ( db_attr.Suc_Pars != ParseStatus::doNotParse )
                assign_ok = false;
                err_msg = "Cannot assign to a derived attribute ->" +
                                                               attr.Name + "<-";
               // else parse on apply not set, so let them treat it like a
               // normal attribute
             end if;
            else
              select one mdattr related by dab->O_DBATTR[R693]->
                                                    O_BATTR[R107]->O_ATTR[R106];
              if ( mdattr.Name != attr.Name )
                // it''s a derived attribute, but not
                // the one we''re currently parsing
                assign_ok = false;
                err_msg = "Cannot assign to a derived attribute ->" +
                                                               attr.Name + "<-";
              else
                dab.AttributeWritten = true;
              end if;
            end if;  // empty dab
          end if;  // not_empty db_attr
        end if;
      end if;
      if assign_ok
        if (lval.getDimensions() != rval.getDimensions())
          assign_ok = false;
          err_msg = "Attribute ->"+ attr.Name +
                                             "<- has incompatible array depth.";
        elif ( not lval.isElementCountValid() )
          assign_ok = false;
          err_msg = "Variable ->"+ attr.Name + "<- contains an Array Index Out of Bounds.";
        elif ( not rval.isElementCountValid() )
          assign_ok = false;
          err_msg = "The rvalue contains an Array Index Out of Bounds.";
        end if;
        if (not lval.isElementCountCompatible(rVal:rval.Value_ID))
          assign_ok = false;
          err_msg = "Variable ->"+ attr.Name + "<- has incompatible dimension size with the rvalue.";
        end if; 
      end if;
    end if; // not current state
  elif not_empty scv
    assign_ok = false;
    err_msg = "Variable ->" + lval.Text + "<- is a constant and is therefore read only.";
  else // all other cases . . .
    array_root_val_ID = ::get_array_value_root(start_value_ID:lval.Value_ID);
    select any val from instances of V_VAL where
                                         selected.Value_ID == array_root_val_ID;
    select one ldt related by lval->S_DT[R820];
    select one rdt related by rval->S_DT[R820];
    if not_empty rdt and empty ldt and val.isImplicit == true;
      // First assignment, set up the data type for all value chain members
      select one vvar related by val->V_TVL[R801]->V_VAR[R805];
      relate rdt to vvar across R848;
      cursorVal = val;
      while not_empty cursorVal
        relate cursorVal to rdt across R820;
        select one cursorVal related by cursorVal->V_AER[R838]->V_VAL[R801];
      end while;
      ldt = rdt;
    end if;
    dt = GD::NULL_UNIQUE_ID();
    if not_empty ldt and not_empty rdt
      dt = ::data_types_compatible ( dt1: ldt.DT_ID,
                                              dt2: rdt.DT_ID, op: "assign" );
    end if;
    if ( dt == GD::NULL_UNIQUE_ID() )
      assign_ok = false;
      err_msg = "Variable ->"+ val.Text +
                                        "<- already exists as a different type";
    end if;
    if (lval.getDimensions() != rval.getDimensions())
      if val.isImplicit
        trnUpdated = lval.setRank(dimension:0, rval_id:rval.Value_ID);
      else
        assign_ok = false;
        err_msg = "Variable ->"+ val.Text + "<- has incompatible array depth.";
      end if;
    elif ( not lval.isElementCountValid() )
        assign_ok = false;
        err_msg = "Variable ->"+ val.Text + "<- contains an Array Index Out of Bounds.";
    elif ( not rval.isElementCountValid() )
        assign_ok = false;
        err_msg = "The rvalue contains an Array Index Out of Bounds.";
    end if;
    if (not lval.isElementCountCompatible(rVal:rval.Value_ID))
      assign_ok = false;
      err_msg = "Variable ->"+ val.Text + "<- has incompatible dimension size with the rvalue.";
    end if;
  end if;
  if (not assign_ok)
    ::clear_assignment_data( stmt_id: param.a2_upper_rule_id,
                                          var_id: param.b1_member_id );
    rval.dispose();
    ::clear_value_data();
    ERR::reportParseError( msg: err_msg, token: param.a1_rule_token );
  else
    if not_empty rval and not_empty lval
      create object instance atm of ACT_AI;
      select any stmt from instances of ACT_SMT where
                                selected.Statement_ID == param.a2_upper_rule_id;
      relate atm to stmt across R603;
      relate lval to atm across R689;
      relate rval to atm across R609;
    end if;
  end if;
  if not_empty lvar
    lvar.Declared = true;
  end if;
elif param.b3_param_data_access3_id != GD::NULL_UNIQUE_ID()
  select any lval from instances of V_VAL where
                            selected.Value_ID == param.b3_param_data_access3_id;
  select one val_dt related by rval->S_DT[R820];
  select one parm_dt related by lval->S_DT[R820];

  assign_ok = true;
  err_msg = "";
  dt = GD::NULL_UNIQUE_ID();
  if not_empty parm_dt and not_empty val_dt
    dt = ::data_types_compatible ( dt1: parm_dt.DT_ID,
                                              dt2: val_dt.DT_ID, op: "assign" );
  end if;
  if ( dt == GD::NULL_UNIQUE_ID() )
    err_msg = "Data types are not assignable or " +
                                       "compatible across assignment statement";
    lval.dispose();
    rval.dispose();
    ::clear_value_data();
    ERR::reportParseError( msg: err_msg, token: param.a1_rule_token );
  else
	if (lval.getDimensions() !=rval.getDimensions())
		assign_ok = false;
		err_msg = "Parameter has incompatible array depth.";
	elif (not lval.isElementCountValid())
		assign_ok = false;
		err_msg = "Parameter contains an Array Index Out of Bounds.";
	else
	    create object instance atm of ACT_AI;
	    select any stmt from instances of ACT_SMT where
	                                selected.Statement_ID == param.a2_upper_rule_id;
	    relate atm to stmt across R603;
	    relate lval to atm across R689;
	    relate rval to atm across R609;
	end if;
	if (not assign_ok)
		lval.dispose();
		::clear_value_data();
		ERR::reportParseError( msg: err_msg, token: param.a1_rule_token );
	end if;
  end if;
end if;
return param.a2_upper_rule_id;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5059,
	5058,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5060,
	5058,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5059,
	'');
INSERT INTO S_SPARM
	VALUES (5061,
	5058,
	'a3_rule_begin_id',
	296,
	0,
	'',
	5060,
	'');
INSERT INTO S_SPARM
	VALUES (5062,
	5058,
	'a4_rule_id',
	296,
	0,
	'',
	5061,
	'');
INSERT INTO S_SPARM
	VALUES (5063,
	5058,
	'b1_member_id',
	296,
	0,
	'',
	5062,
	'');
INSERT INTO S_SPARM
	VALUES (5064,
	5058,
	'b2_expr2_id',
	296,
	0,
	'',
	5063,
	'');
INSERT INTO S_SPARM
	VALUES (5065,
	5058,
	'b3_param_data_access3_id',
	296,
	0,
	'',
	5064,
	'');
INSERT INTO S_SPARM
	VALUES (5066,
	5058,
	'b4_expr4_id',
	296,
	0,
	'',
	5065,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5067);
INSERT INTO S_SYNC
	VALUES (5067,
	1,
	'Bridge_invocation_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;

',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5068,
	5067,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5069,
	5067,
	'a2_isRval',
	316,
	0,
	'',
	5068,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5070);
INSERT INTO S_SYNC
	VALUES (5070,
	1,
	'Ee_keyletters_validate',
	'ParserValidateFunction: TRUE',
	'current_scope = ::get_current_scope();
select any block from instances of ACT_BLK where (selected.Block_ID == current_scope);
select one body related by block->ACT_ACT[R612];
isInGenericPackage = body.associateWithContainer();
if isInGenericPackage
  select one containingElem related by body->ACT_BIE[R640]->PE_PE[R640];
  select one component related by containingElem->C_C[R8001];
  select one package related by containingElem->EP_PKG[R8001];
  // Check for EE keyletter match for token
  if not_empty component
    component.collectVisibleElementsForName(name:param.a3_text,
         type:ElementTypeConstants::EE,
                          originatingContainerID:component.Id,
                                   delegatingContainerID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:true);
  else
    package.collectVisibleElementsForName(name:param.a3_text,
         type:ElementTypeConstants::EE, descending:false,
                           originatingContainerID:package.Package_ID,
                                          delegatingPkgID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:true);
  end if;
  select any resultSet related by component->PE_CRS[R8007] where
                                 selected.Name == param.a3_text and 
                                      selected.Type == ElementTypeConstants::EE; 
  select many results related by resultSet->PE_CVS[R8008]->PE_PE[R8004];
  if not_empty package
    select any pkgResultSet related by package->PE_SRS[R8005] where
                                    selected.Name == param.a3_text and 
                                      selected.Type == ElementTypeConstants::EE; 
    select many results related by pkgResultSet->PE_VIS[R8006]->PE_PE[R8002];
  end if;
  EECount = cardinality results;
  if EECount == 0
    ERR::reportParseError( 
        msg: "Cannot find specified external entity key letters ->%s<-.", 
        token: param.a1_rule_token );
  elif EECount >= 1
    // store the textual position of the key letters for the first match
    // found   
    block.currentKeyLettersLineNumber = ::getLineNumber(rule_token: param.a1_rule_token);
    block.currentKeyLettersColumn = ::getColumn(rule_token: param.a1_rule_token);
    select any ee related by results->S_EE[R8001];
    return ee.EE_ID;
  end if;
  return GD::NULL_UNIQUE_ID();
else
  select any ee from instances of S_EE where ( selected.Key_Lett == param.a3_text );
  if ( empty ee )
    ERR::reportParseError( 
        msg: "Cannot find specified external entity key letters ->%s<-.", 
        token: param.a1_rule_token );
  end if;

  // store the textual position of the key letters
  block.currentKeyLettersLineNumber = ::getLineNumber(rule_token: param.a1_rule_token);
  block.currentKeyLettersColumn = ::getColumn(rule_token: param.a1_rule_token);

  return ee.EE_ID;
end if;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5071,
	5070,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5072,
	5070,
	'a3_text',
	322,
	0,
	'',
	5071,
	'');
INSERT INTO S_SPARM
	VALUES (5073,
	5070,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5072,
	'');
INSERT INTO S_SPARM
	VALUES (5074,
	5070,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5073,
	'');
INSERT INTO S_SPARM
	VALUES (5075,
	5070,
	'a6_current_rule_id',
	296,
	0,
	'',
	5074,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5076);
INSERT INTO S_SYNC
	VALUES (5076,
	1,
	'Bridge_function_validate',
	'ParserValidateFunction: TRUE',
	'select any ee from instances of S_EE where ( selected.EE_ID == param.a6_current_rule_id );
return ::is_valid_bridge( key_lett: ee.Key_Lett, name: param.a3_text, rule_token: param.a1_rule_token );












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5077,
	5076,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5078,
	5076,
	'a3_text',
	322,
	0,
	'',
	5077,
	'');
INSERT INTO S_SPARM
	VALUES (5079,
	5076,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5078,
	'');
INSERT INTO S_SPARM
	VALUES (5080,
	5076,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5079,
	'');
INSERT INTO S_SPARM
	VALUES (5081,
	5076,
	'a6_current_rule_id',
	296,
	0,
	'',
	5080,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5082);
INSERT INTO S_SYNC
	VALUES (5082,
	1,
	'Invocation_parameters_validate',
	'ParserValidateFunction: TRUE',
	'return param.a6_current_rule_id;







































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5083,
	5082,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5084,
	5082,
	'a3_text',
	322,
	0,
	'',
	5083,
	'');
INSERT INTO S_SPARM
	VALUES (5085,
	5082,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5084,
	'');
INSERT INTO S_SPARM
	VALUES (5086,
	5082,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5085,
	'');
INSERT INTO S_SPARM
	VALUES (5087,
	5082,
	'a6_current_rule_id',
	296,
	0,
	'',
	5086,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5088);
INSERT INTO S_SYNC
	VALUES (5088,
	1,
	'Bridge_invocation_end',
	'ParserValidateFunction: TRUE',
	'
// validate parameters

select any brv from instances of V_BRV 
   where selected.Value_ID == param.b2_bridge_function2_id;

if ( not brv.ParmListOK )
  // error already output, still need to clean up
  select one val related by brv->V_VAL[R801];
  val.dispose();
  return GD::NULL_UNIQUE_ID();
end if;

select one brg related by brv->S_BRG[R828];
select many vparm_set related by brv->V_PAR[R810];
select many bparm_set related by brg->S_BPARM[R21];
if ( cardinality vparm_set < cardinality bparm_set )
  select one val related by brv->V_VAL[R801];
  val.dispose();
  ERR::reportParseError( msg: "Bridge ->"+brg.Name+
      "<- is missing corresponding parameter(s)",
          token: param.a1_rule_token );
else
  for each bparm in bparm_set
    found = false;
    for each vparm in vparm_set
      if ( bparm.Name == vparm.Name )
        found = true;
        err_msg = "";
        select one parm_val related by vparm->V_VAL[R800];
        select one vdt related by parm_val->S_DT[R820];
        if ( empty vdt or ::data_types_compatible( dt1: bparm.DT_ID, dt2: vdt.DT_ID, op: "assign")  == GD::NULL_UNIQUE_ID() )
          select one val related by brv->V_VAL[R801];
          err_msg = "Parameter ->"+ bparm.Name +"<- has been assigned value of different type";
        end if;
        if ( bparm.By_Ref == 1 )
          if ( ::is_readonly_value( val_id: vparm.Value_ID ) )
            err_msg = "Cannot pass read-only value to pass-by-reference parameter ->"+ bparm.Name + "<-";
          end if;
        end if;
        if (bparm.getDimensionsCnt()!= parm_val.getDimensions())
          err_msg = "Parameter ->"+ bparm.Name +"<- has incompatible array depth.";
        elif ( not parm_val.isElementCountValid() )
          err_msg = "Parameter ->"+ bparm.Name + "<- contains an Array Index Out of Bounds.";
        end if;      
        if (err_msg == "")
          break;
        else 
          select one val related by brv->V_VAL[R801];
          val.dispose();        
          ERR::reportParseError( msg: err_msg, token: param.a1_rule_token );
        end if;
      end if;
    end for;
    if ( not found )
      select one val related by brv->V_VAL[R801];
      val.dispose();
      ERR::reportParseError( msg: "Bridge ->"+brg.Name+
          "<- is missing corresponding parameter(s)",
             token: param.a1_rule_token );
    end if;
  end for;

      // If execution gets here, all the data items from the database
      // were found in the parse data items.

      // If there are more data items in the parse then were found in the
      // database, that means there were redundant or extra data items in the
      // parameter list found by the parse.  Generate an error.

  if ( cardinality vparm_set > cardinality bparm_set )
    for each vparm in vparm_set
      found = false;
      for each bparm in bparm_set
        if ( bparm.Name == vparm.Name )
          found = true;
          break;
        end if;
      end for;
      if ( not found )
      select one val related by brv->V_VAL[R801];
      val.dispose();
      ERR::reportParseError( msg: "Parameter ->"+ vparm.Name +
          "<- is not associated with bridge ->"+ brg.Name +"<-",
             token: param.a1_rule_token );
      end if;
    end for;

      // If it gets out of the loop without error, there must be
      // a redundant data item, so report the error
    select one val related by brv->V_VAL[R801];
    val.dispose();
    ERR::reportParseError( msg: "Bridge ->"+brg.Name+
      "<- has redundant parameters",
          token: param.a1_rule_token );
    
  end if;
end if;
return param.b2_bridge_function2_id;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5089,
	5088,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5090,
	5088,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5089,
	'');
INSERT INTO S_SPARM
	VALUES (5091,
	5088,
	'a3_rule_begin_id',
	296,
	0,
	'',
	5090,
	'');
INSERT INTO S_SPARM
	VALUES (5092,
	5088,
	'a4_rule_id',
	296,
	0,
	'',
	5091,
	'');
INSERT INTO S_SPARM
	VALUES (5093,
	5088,
	'b1_ee_keyletters1_id',
	296,
	0,
	'',
	5092,
	'');
INSERT INTO S_SPARM
	VALUES (5094,
	5088,
	'b2_bridge_function2_id',
	296,
	0,
	'',
	5093,
	'');
INSERT INTO S_SPARM
	VALUES (5095,
	5088,
	'b3_invocation_parameters3_id',
	296,
	0,
	'',
	5094,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5096);
INSERT INTO S_SYNC
	VALUES (5096,
	1,
	'Invocation_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;

',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5097,
	5096,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5098,
	5096,
	'a2_isRval',
	316,
	0,
	'',
	5097,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5099);
INSERT INTO S_SYNC
	VALUES (5099,
	1,
	'Identifier_validate',
	'ParserValidateFunction: TRUE',
	'// ::Obj_or_ee_keyletters_validate()
current_scope = ::get_current_scope();
select any block from instances of ACT_BLK where
                                             selected.Block_ID == current_scope;
identifier_ok = false;
select one body related by block->ACT_ACT[R612];
isInGenericPackage = body.associateWithContainer();
if isInGenericPackage
  select one containingElem related by body->ACT_BIE[R640]->PE_PE[R640];
  select one comp related by containingElem->C_C[R8001];
  select one pkg related by containingElem->EP_PKG[R8001];
  // Check for class keyletter match for token
  if not_empty comp
    comp.collectVisibleElementsForName(name:param.a3_text,
         type:ElementTypeConstants::CLASS,
                          originatingContainerID:comp.Id,
                                   delegatingContainerID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:false);
  else
    pkg.collectVisibleElementsForName(name:param.a3_text,
         type:ElementTypeConstants::CLASS, descending:false,
                           originatingContainerID:pkg.Package_ID,
                                          delegatingPkgID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:false);
  end if;
  select any resultSet related by comp->PE_CRS[R8007] where
                                      selected.Name == param.a3_text and 
                                   selected.Type == ElementTypeConstants::CLASS; 
  select many results related by resultSet->PE_CVS[R8008]->PE_PE[R8004];
  if not_empty pkg
    select any pkgResultSet related by pkg->PE_SRS[R8005] where
                                      selected.Name == param.a3_text and 
                                   selected.Type == ElementTypeConstants::CLASS; 
    select many results related by pkgResultSet->PE_VIS[R8006]->PE_PE[R8002];
  end if;
  if cardinality results == 1
    identifier_ok = true;
  elif cardinality results > 1
    resultList = "";
    sep = "";
    for each result in results
      resultList = resultList + sep + result.getQualifiedName();
      sep = " ,";
    end for;
    ERR::reportParseError( msg: "Multiple classes found for ->%s<-: " +
                                        resultList, token: param.a1_rule_token); 
  else // No result found yet
    // Check for external entity keyletter match for token
    if not_empty comp
      comp.collectVisibleElementsForName(name:param.a3_text,
         type:ElementTypeConstants::EE,
                          originatingContainerID:comp.Id,
                                   delegatingContainerID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:true);
    else
      pkg.collectVisibleElementsForName(name:param.a3_text,
         type:ElementTypeConstants::EE, descending:false,
                           originatingContainerID:pkg.Package_ID,
                                          delegatingPkgID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:true);
    end if;
    select any resultSet related by comp->PE_CRS[R8007] where
                                        selected.Name == param.a3_text and 
                                      selected.Type == ElementTypeConstants::EE; 
    select many results related by resultSet->PE_CVS[R8008]->PE_PE[R8004];
    if not_empty pkg
      select any pkgResultSet related by pkg->PE_SRS[R8005] where
                                        selected.Name == param.a3_text and 
                                      selected.Type == ElementTypeConstants::EE; 
      select many results related by pkgResultSet->PE_VIS[R8006]->PE_PE[R8002];
    end if;
    if cardinality results >= 1
      identifier_ok = true;
    else // No result found yet
      // Check for Interface match for token
      if not_empty comp
        comp.collectVisibleElementsForName(name:param.a3_text,
            type:ElementTypeConstants::INTERFACE,
                          originatingContainerID:comp.Id,
                                delegatingContainerID:GD::NULL_UNIQUE_ID(),
                                                          collectGlobally:true);
        select any resultSet related by comp->PE_CRS[R8007] where
                                        selected.Name == param.a3_text and 
                               selected.Type == ElementTypeConstants::INTERFACE; 
        select many results related by resultSet->PE_CVS[R8008]->PE_PE[R8004];
      elif not_empty pkg
        pkg.collectVisibleElementsForName(name:param.a3_text,
            type:ElementTypeConstants::INTERFACE, descending:false,
                          originatingContainerID:pkg.Package_ID,
                                          delegatingPkgID:GD::NULL_UNIQUE_ID(),
                                                          collectGlobally:true);
        select any pkgResultSet related by pkg->PE_SRS[R8005] where
                                         selected.Name == param.a3_text and 
                               selected.Type == ElementTypeConstants::INTERFACE; 
        select many results related by pkgResultSet->
                                                    PE_VIS[R8006]->PE_PE[R8002];
      end if;
      if cardinality results == 1
        identifier_ok = true;
      elif cardinality results > 1
        resultList = "";
        sep = "";
        for each result in results
          resultList = resultList + sep + result.getQualifiedName();
          sep = " ,";
        end for;
        ERR::reportParseError( msg: "Multiple interfaces found for ->%s<-: " +
                                        resultList, token: param.a1_rule_token);
      else // No result found yet
        // Check for port match for token
        componentContainer = comp;
        if not_empty pkg
          compId = pkg.getContainingComponentId();
          select any componentContainer from instances of C_C where
                                                          selected.Id == compId;
        end if;
        if not_empty componentContainer
          select many interfaces related by componentContainer->C_PO[R4010]->
                   C_IR[R4016]->C_I[R4012] where selected.Name == param.a3_text;
          if cardinality interfaces == 1
            identifier_ok = true;
          elif cardinality interfaces > 1
            resultList = "";
            sep = "";
            for each interface in interfaces
              name = interface.Name;
              select one pe related by interface->PE_PE[R8001];
              if not_empty pe
                name = pe.getQualifiedName();
              end if;
              resultList = resultList + sep + name;
              sep = " ,";
            end for;
            ERR::reportParseError(msg:"Multiple interfaces found for ->%s<-: " +
                                        resultList, token: param.a1_rule_token);
          else
            select many ports related by componentContainer->C_PO[R4010] where
                                                 selected.Name == param.a3_text;
            if cardinality ports == 1
              identifier_ok = true;
            elif cardinality ports > 1
              ERR::reportParseError(msg:"Multiple ports found for ->%s<-",
                                                    token: param.a1_rule_token);
            end if;
          end if;
        end if;
      end if;
    end if;
  end if;
else
  select any obj from instances of O_OBJ where selected.Key_Lett == param.a3_text;
  if ( empty obj )
    select any ee from instances of S_EE where selected.Key_Lett == param.a3_text;
    if ( empty ee )
      body.associateWithOwningComponent();
      select one component related by body->ACT_BIC[R694]->C_C[R694];
      if not_empty component
        select many interfaces related by component->C_PO[R4010]->
                   C_IR[R4016]->C_I[R4012] where selected.Name == param.a3_text;
        if not_empty interfaces
          identifier_ok = true;
        else
          select many ports related by component->C_PO[R4010] where
                                                 selected.Name == param.a3_text;
          if not_empty ports
            identifier_ok = true;
          end if;
        end if;
      end if;
    else
      identifier_ok = true;
    end if;
  else
    identifier_ok = true;
  end if;
end if;
if identifier_ok
  // save keyletters for later use
  block.TempBuffer = param.a3_text;
  // store the textual position of the key letters
  block.currentKeyLettersLineNumber =
                               ::getLineNumber(rule_token: param.a1_rule_token);
  block.currentKeyLettersColumn = ::getColumn(rule_token: param.a1_rule_token);
  return param.a6_current_rule_id;
else
  ERR::reportParseError( msg: "Cannot find specified class, " +
                                 " external entity or interface ->%s<-.", 
                                                   token: param.a1_rule_token );
  return GD::NULL_UNIQUE_ID();
end if;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5100,
	5099,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5101,
	5099,
	'a3_text',
	322,
	0,
	'',
	5100,
	'');
INSERT INTO S_SPARM
	VALUES (5102,
	5099,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5101,
	'');
INSERT INTO S_SPARM
	VALUES (5103,
	5099,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5102,
	'');
INSERT INTO S_SPARM
	VALUES (5104,
	5099,
	'a6_current_rule_id',
	296,
	0,
	'',
	5103,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5105);
INSERT INTO S_SYNC
	VALUES (5105,
	1,
	'Invocation_function_validate',
	'ParserValidateFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
current_scope = ::get_current_scope();
select any block from instances of ACT_BLK where
                   selected.Block_ID == current_scope;
select one body related by block->ACT_ACT[R612];
isInGenericPackage = body.associateWithContainer();
if isInGenericPackage
  nullID = GD::NULL_UNIQUE_ID();
  // This holds the token before the "::" (class keyletters, EE name, port or interface name)
  identifier = block.TempBuffer; 
  tfr_found = false;
  bridge_found = false;
  message_found = false;
  numMatches = 0;
  dupErrString = "";
  select any obj from instances of O_OBJ;
  select one containingElem related by body->ACT_BIE[R640]->PE_PE[R640];
  select one component related by containingElem->C_C[R8001];
  select one package related by containingElem->EP_PKG[R8001];

  // If the following section we look to are looking to see if there are
  // duplicates names between EE, Class-based operations, and messages.
  // Note that we can NOT validate the parameters and other aspects of the
  // invocation yet (we do that at the end when we know there are no duplicates)
  //
  // Check for class keyletter match for token
  if not_empty component
    component.collectVisibleElementsForName(name:identifier,
         type:ElementTypeConstants::CLASS,
                          originatingContainerID:component.Id,
                                   delegatingContainerID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:false);
  else
    package.collectVisibleElementsForName(name:identifier,
         type:ElementTypeConstants::CLASS, descending:false,
                           originatingContainerID:package.Package_ID,
                                          delegatingPkgID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:false);
  end if;
  select any resultSet related by component->PE_CRS[R8007] where
                                   selected.Name == identifier and 
                                   selected.Type == ElementTypeConstants::CLASS; 
  select many results related by resultSet->PE_CVS[R8008]->PE_PE[R8004];
  if not_empty package
    select any pkgResultSet related by package->PE_SRS[R8005] where
                                      selected.Name == identifier and 
                                   selected.Type == ElementTypeConstants::CLASS; 
    select many results related by pkgResultSet->PE_VIS[R8006]->PE_PE[R8002];
  end if;
  if cardinality results == 1
    select any obj related by results->O_OBJ[R8001];
    if not_empty obj
      select any tfr related by obj->O_TFR[R115] where
                                                 selected.Name == param.a3_text; 
      if (not_empty tfr)
        tfr_found = true;
        dupErrString = dupErrString + "Class Based Operation";    
        numMatches = numMatches + 1;
      end if;
    end if;
  elif cardinality results > 1
    resultList = "";
    sep = "";
    for each result in results
      resultList = resultList + sep + result.getQualifiedName();
      sep = " ,";
    end for;
    ERR::reportParseError( msg: "Multiple classes found for ->%s<-: " +
                                        resultList, token: param.a1_rule_token); 
  end if; // obj  
  //
  if not_empty component
    component.collectVisibleElementsForName(name:identifier,
         type:ElementTypeConstants::EE,originatingContainerID:component.Id,
                                   delegatingContainerID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:true);
  else
    package.collectVisibleElementsForName(name:identifier,
         type:ElementTypeConstants::EE, descending:false,
                           originatingContainerID:package.Package_ID,
                                          delegatingPkgID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:true);
  end if;
  select any resultSet related by component->PE_CRS[R8007] where
                                  selected.Name == identifier and 
                                      selected.Type == ElementTypeConstants::EE; 
  select many results related by resultSet->PE_CVS[R8008]->PE_PE[R8004];
  if not_empty package
    select any pkgResultSet related by package->PE_SRS[R8005] where
                                       selected.Name == identifier and 
                                      selected.Type == ElementTypeConstants::EE; 
    select many results related by pkgResultSet->PE_VIS[R8006]->PE_PE[R8002];
  end if;
  if cardinality results >= 1
    select any ee related by results->S_EE[R8001];
    if not_empty ee
      select any brg related by ee->S_BRG[R19] where
                                                 selected.Name == param.a3_text;
      if (not_empty brg)
        bridge_found = true; 
        if (numMatches > 0)
          dupErrString = dupErrString + ", ";
        end if;
        dupErrString = dupErrString + "Bridge";    
        numMatches = numMatches + 1;
      end if;
    end if; // empty ee
  end if; // ee
  //    
  componentContainer = component;
  if not_empty package
    compId = package.getContainingComponentId();
    select any componentContainer from instances of C_C where
                                                          selected.Id == compId;
  end if;
  if not_empty componentContainer
    message_found = false;
    select many interfaces related by componentContainer->C_PO[R4010]->
                      C_IR[R4016]->C_I[R4012] where selected.Name == identifier;
    for each interface in interfaces
      select any io related by interface->C_EP[R4003]->C_IO[R4004] where
                                                 selected.Name == param.a3_text;
      select any sig related by interface->C_EP[R4003]->C_AS[R4004] where
                                                 selected.Name == param.a3_text;
      if not_empty io or not_empty sig
        message_found = true;
        break;
      end if;
    end for;
    if not message_found
      select many ports related by componentContainer->C_PO[R4010] where
                                                    selected.Name == identifier;
      for each port in ports
        select many interfaces related by port->C_IR[R4016]->C_I[R4012];
        for each interface in interfaces
          select any io related by interface->
                  C_EP[R4003]->C_IO[R4004] where selected.Name == param.a3_text;
          select any sig related by interface->
                  C_EP[R4003]->C_AS[R4004] where selected.Name == param.a3_text;
          if not_empty io or not_empty sig
            message_found = true;
            break;
          end if;
        end for;
      end for;
    end if;
    if message_found
      if (numMatches > 0)
        dupErrString = dupErrString + ", ";
      end if;
      dupErrString = dupErrString + "Message";
      numMatches = numMatches + 1;
    end if; // message found
  end if; // empty component

  resultInvocation = nullID;
  if (numMatches == 0)
    ERR::reportParseError( 
          msg: "Cannot find bridge, operation or message ->" + identifier +
                                         "::%s<-", token: param.a1_rule_token );
  elif (numMatches > 1) 
    ERR::reportParseError( 
            msg: "Duplicate implicit function signature for " + dupErrString + ".  ->" + identifier +
                                           "::%s<-" , token: param.a1_rule_token );
  elif (numMatches == 1)
    // We now know that there is a single matches across EE, Class-based operations,
    // and messages, so we can now validate that match.
  
    if ( message_found )
      resultInvocation =  ::Message_name_validate(
                 a1_rule_token: param.a1_rule_token,
                                   a2_text: param.a3_text,
                         a3_this_rule: param.a6_current_rule_id,
                                a4_upper_rule: param.a5_upper_rule_id,
                                      a5_upper_rule:param.a5_upper_rule_id);
    elif ( bridge_found )
      resultInvocation =  ::is_valid_bridge( key_lett: identifier,
                       name: param.a3_text, rule_token: param.a1_rule_token );
    elif ( tfr_found)
      resultInvocation =  ::is_valid_transform (a1_obj_id: obj.Obj_ID,
                                        a2_name: param.a3_text, 
                                     a3_rule_token: param.a1_rule_token,
                                                           a4_classBased: true);
    end if;
  end if;
  return resultInvocation;
else
  nullID = GD::NULL_UNIQUE_ID();
  // This holds the token before the "::" (class keyletters, EE name, port or interface name)
  identifier = block.TempBuffer; 
  tfr_found = false;
  bridge_found = false;
  message_found = false;
  numMatches = 0;
  dupErrString = "";
  body.associateWithOwningComponent();
  select one component related by body->ACT_BIC[R694]->C_C[R694];

  // If the following section we look to are looking to see if there are
  // duplicates names between EE, Class-based operations, and messages.
  // Note that we can NOT validate the parameters and other aspects of the
  // invocation yet (we do that at the end when we know there are no duplicates)
  //
  select any obj from instances of O_OBJ where selected.Key_Lett == identifier;
  if not_empty component
    // If we''re in a component, we just look for the class locally
    select any obj related by component->CN_DC[R4204]->S_DOM[R4204]->
                      S_SS[R1]->O_OBJ[R2] where selected.Key_Lett == identifier;
  end if;
  if not_empty obj
    select any tfr related by obj->O_TFR[R115] where
                                                 selected.Name == param.a3_text; 
    if (not_empty tfr)
      tfr_found = true;
      dupErrString = dupErrString + "Class Based Operation";    
      numMatches = numMatches + 1;
    end if;
  end if; // obj  
  //
  select any ee from instances of S_EE where selected.Key_Lett == identifier;
  if not_empty component
    // If we''re in a component, we just look for the external entity locally
    select any ee related by component->CN_DC[R4204]->
                   S_DOM[R4204]->S_EE[R8] where selected.Key_Lett == identifier;
  end if;
  if not_empty ee
    select any brg related by ee->S_BRG[R19] where
                                                 selected.Name == param.a3_text;
    if (not_empty brg)
      bridge_found = true; 
      if (numMatches > 0)
        dupErrString = dupErrString + ", ";
      end if;
      dupErrString = dupErrString + "Bridge";    
      numMatches = numMatches + 1;
    end if;
  end if; // empty ee
  //    
  if not_empty component
    message_found = false;
    select many interfaces related by component->C_PO[R4010]->
                    C_IR[R4016]->C_I[R4012] where selected.Name == identifier;
    for each interface in interfaces
      select any io related by interface->C_EP[R4003]->C_IO[R4004] where
                                               selected.Name == param.a3_text;
      select any sig related by interface->C_EP[R4003]->C_AS[R4004] where
                                               selected.Name == param.a3_text;
      if not_empty io or not_empty sig
        message_found = true;
        break;
      end if;
    end for;
    if not message_found
      select many ports related by component->C_PO[R4010] where
                                                  selected.Name == identifier;
      for each port in ports
        select many interfaces related by port->C_IR[R4016]->C_I[R4012];
        for each interface in interfaces
          select any io related by interface->
                  C_EP[R4003]->C_IO[R4004] where selected.Name == param.a3_text;
          select any sig related by interface->
                  C_EP[R4003]->C_AS[R4004] where selected.Name == param.a3_text;
          if not_empty io or not_empty sig
            message_found = true;
            break;
          end if;
        end for;
      end for;
    end if;
    if message_found
      if (numMatches > 0)
        dupErrString = dupErrString + ", ";
      end if;
      dupErrString = dupErrString + "Message";
      numMatches = numMatches + 1;
    end if; // message found
  end if; // empty component

  resultInvocation = nullID;
  if (numMatches == 0)
    ERR::reportParseError( 
          msg: "Cannot find bridge, operation or message ->" + identifier +
                                         "::%s<-", token: param.a1_rule_token );
  elif (numMatches > 1) 
    ERR::reportParseError( 
            msg: "Duplicate implicit function signature for " + dupErrString + ".  ->" + identifier +
                                           "::%s<-" , token: param.a1_rule_token );
  elif (numMatches == 1)
    // We now know that there is a single matches across EE, Class-based operations,
    // and messages, so we can now validate that match.
  
    if ( message_found )
      resultInvocation =  ::Message_name_validate(
                 a1_rule_token: param.a1_rule_token,
                                   a2_text: param.a3_text,
                         a3_this_rule: param.a6_current_rule_id,
                                a4_upper_rule: param.a5_upper_rule_id,
                                      a5_upper_rule:param.a5_upper_rule_id);
    elif ( bridge_found )
      resultInvocation =  ::is_valid_bridge( key_lett: identifier,
                       name: param.a3_text, rule_token: param.a1_rule_token );
    elif ( tfr_found)
      resultInvocation =  ::is_valid_transform (a1_obj_id: obj.Obj_ID,
                                        a2_name: param.a3_text, 
                                     a3_rule_token: param.a1_rule_token,
                                                           a4_classBased: true);
    end if;
  end if;
  return resultInvocation;
end if;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5106,
	5105,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5107,
	5105,
	'a3_text',
	322,
	0,
	'',
	5106,
	'');
INSERT INTO S_SPARM
	VALUES (5108,
	5105,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5107,
	'');
INSERT INTO S_SPARM
	VALUES (5109,
	5105,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5108,
	'');
INSERT INTO S_SPARM
	VALUES (5110,
	5105,
	'a6_current_rule_id',
	296,
	0,
	'',
	5109,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5111);
INSERT INTO S_SYNC
	VALUES (5111,
	1,
	'Invocation_end',
	'ParserValidateFunction: TRUE',
	'// validate parameters
//
select any brv from instances of V_BRV 
           where selected.Value_ID == param.b2_bridge_or_transform_function2_id;
if not_empty brv
  return ::Bridge_invocation_end( a1_rule_token: param.a1_rule_token, 
      a2_upper_rule_id: param.a2_upper_rule_id,
      a3_rule_begin_id: param.a3_rule_begin_id,
      a4_rule_id: param.a4_rule_id,
      b1_ee_keyletters1_id:GD::NULL_UNIQUE_ID(),
      b2_bridge_function2_id: param.b2_bridge_or_transform_function2_id,
      b3_invocation_parameters3_id: param.b3_invocation_parameters3_id );
else
  select any trv from instances of V_TRV 
           where selected.Value_ID == param.b2_bridge_or_transform_function2_id;
  if not_empty trv
    return ::Transform_invocation_end( a1_rule_token: param.a1_rule_token, 
        a2_upper_rule_id: param.a2_upper_rule_id,
        a3_rule_begin_id: param.a3_rule_begin_id,
        a4_rule_id: param.a4_rule_id,
        b1_object_keyletters1_id:GD::NULL_UNIQUE_ID(),
        b2_transformer_function2_id: param.b2_bridge_or_transform_function2_id,
       b3_invocation_parameters3_id: param.b3_invocation_parameters3_id );
  else
    select any msv from instances of V_MSV
           where selected.Value_ID == param.b2_bridge_or_transform_function2_id;
    if not_empty msv
      return ::Message_invocation_end( a1_rule_token: param.a1_rule_token, 
        a2_upper_rule: param.a2_upper_rule_id,
        a3_start_rule: param.a3_rule_begin_id,
        a4_current_rule: param.a4_rule_id,
        a5_interface:GD::NULL_UNIQUE_ID(),
        a6_message: param.b2_bridge_or_transform_function2_id,
        a7_parameters: param.b3_invocation_parameters3_id,
        a8_variable: GD::NULL_UNIQUE_ID() );
    end if;
  end if;
end if;

return param.a4_rule_id;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5112,
	5111,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5113,
	5111,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5112,
	'');
INSERT INTO S_SPARM
	VALUES (5114,
	5111,
	'a3_rule_begin_id',
	296,
	0,
	'',
	5113,
	'');
INSERT INTO S_SPARM
	VALUES (5115,
	5111,
	'a4_rule_id',
	296,
	0,
	'',
	5114,
	'');
INSERT INTO S_SPARM
	VALUES (5116,
	5111,
	'b1_obj_or_ee_keyletters1_id',
	296,
	0,
	'',
	5115,
	'');
INSERT INTO S_SPARM
	VALUES (5117,
	5111,
	'b2_bridge_or_transform_function2_id',
	296,
	0,
	'',
	5116,
	'');
INSERT INTO S_SPARM
	VALUES (5118,
	5111,
	'b3_invocation_parameters3_id',
	296,
	0,
	'',
	5117,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5119);
INSERT INTO S_SYNC
	VALUES (5119,
	1,
	'Invocation_expr_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;

',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5120,
	5119,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5121);
INSERT INTO S_SYNC
	VALUES (5121,
	1,
	'Invocation_expr_end',
	'ParserValidateFunction: TRUE',
	'return param.a4_rule_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5122,
	5121,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5123,
	5121,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5122,
	'');
INSERT INTO S_SPARM
	VALUES (5124,
	5121,
	'a3_rule_begin_id',
	296,
	0,
	'',
	5123,
	'');
INSERT INTO S_SPARM
	VALUES (5125,
	5121,
	'a4_rule_id',
	296,
	0,
	'',
	5124,
	'');
INSERT INTO S_SPARM
	VALUES (5126,
	5121,
	'b1_bridge_or_transform_invocation1_id',
	296,
	0,
	'',
	5125,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5127);
INSERT INTO S_SYNC
	VALUES (5127,
	1,
	'Enumerator_access_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5128,
	5127,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5129);
INSERT INTO S_SYNC
	VALUES (5129,
	1,
	'Enum_data_type_validate',
	'ParserValidateFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
current_scope = ::get_current_scope();
select any block from instances of ACT_BLK where (selected.Block_ID == current_scope);
select one body related by block->ACT_ACT[R612];
isInGenericPackage = body.associateWithContainer();
if isInGenericPackage
  select one containingElem related by body->ACT_BIE[R640]->PE_PE[R640];
  select one component related by containingElem->C_C[R8001];
  select one package related by containingElem->EP_PKG[R8001];

  // Check for Enumeration match for token
  if not_empty component
    component.collectVisibleElementsForName(name:param.a3_text,
         type:ElementTypeConstants::DATATYPE,
                          originatingContainerID:component.Id,
                                   delegatingContainerID:GD::NULL_UNIQUE_ID(),
                                                          collectGlobally:true);
  else
    package.collectVisibleElementsForName(name:param.a3_text,
         type:ElementTypeConstants::DATATYPE, descending:false,
                           originatingContainerID:package.Package_ID,
                                          delegatingPkgID:GD::NULL_UNIQUE_ID(),
                                                          collectGlobally:true);
  end if;
  select any resultSet related by component->PE_CRS[R8007] where
                                  selected.Name == param.a3_text and 
                                selected.Type == ElementTypeConstants::DATATYPE; 
  select many results related by resultSet->PE_CVS[R8008]->PE_PE[R8004];
  if not_empty package
    select any pkgResultSet related by package->PE_SRS[R8005] where
                                  selected.Name == param.a3_text and 
                                selected.Type == ElementTypeConstants::DATATYPE; 
    select many results related by pkgResultSet->PE_VIS[R8006]->PE_PE[R8002];
  end if;
  select many edts related by results->S_DT[R8001]->S_EDT[R17];
  select many udts related by results->S_DT[R8001]->S_UDT[R17];
  UDTCount = 0;
  for each udt in udts
    baseId = udt.getCoreType();
    select any pe from instances of PE_PE where (selected.Element_ID == baseId);
    if(not_empty pe)
      select one baseTypeEDT related by pe->S_DT[R8001]->S_EDT[R17];
      if(not_empty baseTypeEDT)
        UDTCount = UDTCount + 1;
      end if;
    end if;
  end for;
  EDTCount = cardinality edts;
  EDTCount = EDTCount + UDTCount;
  if EDTCount == 0
    ERR::reportParseError( 
        msg: "Cannot find specified enumeration ->%s<-.", 
                                                   token: param.a1_rule_token );
  elif EDTCount == 1
    // store the textual position of the data type name 
    block.currentDataTypeNameLineNumber = ::getLineNumber(rule_token: param.a1_rule_token);
    block.currentDataTypeNameColumn = ::getColumn(rule_token: param.a1_rule_token);
    select any dt related by results->S_DT[R8001];
    return dt.DT_ID;
  elif EDTCount > 1
    resultList = "";
    sep = "";
    for each edt in edts
      select one result related by edt->S_DT[R17]->PE_PE[R8001];
      resultList = resultList + sep + result.getQualifiedName();
      sep = " ,";
    end for;
    for each udt in udts
      select one result related by udt->S_DT[R17]->PE_PE[R8001];
      resultList = resultList + sep + result.getQualifiedName();
      sep = " ,";
    end for;
    ERR::reportParseError(msg: "Multiple enumerations found for ->%s<-: " +
                                           resultList, token: param.a1_rule_token);
  end if;
  return GD::NULL_UNIQUE_ID();
else
  select any dom from instances of S_DOM where selected.Dom_ID == ::getValidationDomain();
  select many dt related by dom->S_DT[R14] where selected.Name == param.a3_text;
  if empty dt
    // see if any enumerations are located at the system level
    cur_sys_name = ::getSystemName();
    select any sys from instances of S_SYS where selected.Name == cur_sys_name;
    select many dt related by sys->SLD_SDINP[R4402]->S_DT[R4401] where
                                                 selected.Name == param.a3_text;
    if empty dt and not_empty sys and sys.useGlobals
      select many dt related by sys->G_EIS[R9100]->PE_PE[R9100]->S_DT[R8001] where
                                                 selected.Name == param.a3_text;
  end if;
  end if;
  select many edt related by dt->S_EDT[R17];
  if ( empty edt )
    ERR::reportParseError( msg: "Cannot find enumeration data type ->%s<-",
          token: param.a1_rule_token );
  elif ( cardinality edt > 1 )
    ERR::reportParseError( msg: "More than one enumeration data type named ->%s<-",
          token: param.a1_rule_token );
  else
    // store the textual position of the data type name 
    block.currentDataTypeNameLineNumber = ::getLineNumber(rule_token: param.a1_rule_token);
    block.currentDataTypeNameColumn = ::getColumn(rule_token: param.a1_rule_token);

    select any the_edt related by dt->S_EDT[R17];
    return the_edt.DT_ID;
  end if;

  return param.a6_current_rule_id;
end if;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5130,
	5129,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5131,
	5129,
	'a3_text',
	322,
	0,
	'',
	5130,
	'');
INSERT INTO S_SPARM
	VALUES (5132,
	5129,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5131,
	'');
INSERT INTO S_SPARM
	VALUES (5133,
	5129,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5132,
	'');
INSERT INTO S_SPARM
	VALUES (5134,
	5129,
	'a6_current_rule_id',
	296,
	0,
	'',
	5133,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5135);
INSERT INTO S_SYNC
	VALUES (5135,
	1,
	'Enumerator_validate',
	'ParserValidateFunction: TRUE',
	'select any pe from instances of PE_PE where selected.Element_ID ==
                                                       param.a6_current_rule_id;
select one edt related by pe->S_DT[R8001]->S_EDT[R17];
if(empty edt)
  select one udt related by pe->S_DT[R8001]->S_UDT[R17];
  if(not_empty udt)
    baseId = udt.getCoreType();
    select any basePe from instances of PE_PE
                                          where (selected.Element_ID == baseId);
    if(not_empty basePe)
      select one edt related by basePe->S_DT[R8001]->S_EDT[R17];
    end if;
  end if;
end if;
isInGenericPackage = not_empty edt;
if isInGenericPackage
  select any enum related by edt->S_ENUM[R27] 
                                       where ( selected.Name == param.a3_text );
  if ( empty enum )
    if(empty edt)
      // here we just log an error, as there is
      // something wrong in the system.  Not
      // necessarily having to do with the OAL
      USER::logError(msg:"Unable to locate enumeration data type.",path:"");
    else
      select one dt related by edt->S_DT[R17];
      ERR::reportParseError( msg: 
      "Cannot find enumerator ->%s<- for enumeration data type ->"+dt.Name+"<-",
            token: param.a1_rule_token );  
    end if;
  else
    return enum.Enum_ID;
  end if;
else
  select any edt from instances of S_EDT 
                            where ( selected.DT_ID == param.a6_current_rule_id);
  if(empty edt)
    // if the enumeration dt was not found, it is
    // probably in a different root at the system
    // level
    sysName = ::getSystemName();
    select any system from instances of S_SYS where (selected.Name == sysName);
    if(not_empty system)
      select any edt related by system->SLD_SDINP[R4402]->
                                            S_DT[R4401]->S_EDT[R17] where
                                   (selected.DT_ID == param.a6_current_rule_id);
      if empty edt and not_empty system and system.useGlobals
        select any edt related by system->G_EIS[R9100]->PE_PE[R9100]->
                                            S_DT[R8001]->S_EDT[R17] where
                                   (selected.DT_ID == param.a6_current_rule_id);
      end if;
    end if;
  end if;
  select any enum related by edt->S_ENUM[R27] 
                                       where ( selected.Name == param.a3_text );
  if ( empty enum )
    if(empty edt)
      // here we just log an error, as there is
      // something wrong in the system.  Not
      // necessarily having to do with the OAL
      USER::logError(msg:"Unable to locate enumeration data type.",path:"");
    else
      select one dt related by edt->S_DT[R17];
      ERR::reportParseError( msg: 
      "Cannot find enumerator ->%s<- for enumeration data type ->"+dt.Name+"<-",
            token: param.a1_rule_token );  
    end if;
  else
    return enum.Enum_ID;
  end if;
end if;
return param.a6_current_rule_id;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5136,
	5135,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5137,
	5135,
	'a3_text',
	322,
	0,
	'',
	5136,
	'');
INSERT INTO S_SPARM
	VALUES (5138,
	5135,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5137,
	'');
INSERT INTO S_SPARM
	VALUES (5139,
	5135,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5138,
	'');
INSERT INTO S_SPARM
	VALUES (5140,
	5135,
	'a6_current_rule_id',
	296,
	0,
	'',
	5139,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5141);
INSERT INTO S_SYNC
	VALUES (5141,
	1,
	'Enumerator_access_end',
	'ParserValidateFunction: TRUE',
	'select any enum from instances of S_ENUM 
    where (selected.Enum_ID == param.b2_enumerator2_id );
if(empty enum)
  // if the enumerator was not found
  // check the system level
  sysName = ::getSystemName();
  select any system from instances of S_SYS where (selected.Name == sysName);
  select any enum related by system->SLD_SDINP[R4402]->S_DT[R4401]->S_EDT[R17]
              ->S_ENUM[R27] where (selected.Enum_ID == param.b2_enumerator2_id);
  if empty enum and not_empty system and system.useGlobals
    select any enum related by system->G_EIS[R9100]->PE_PE[R9100]->S_DT[R8001]->
    S_EDT[R17]->S_ENUM[R27] where (selected.Enum_ID == param.b2_enumerator2_id);
end if;
end if;

create object instance len of V_LEN;
relate len to enum across R824;

create object instance val of V_VAL;
relate val to len  across R801;
current_scope = ::get_current_scope();
select any block from instances of ACT_BLK where
                                           (selected.Block_ID == current_scope);
relate val to block across R826;

select one dt related by enum->S_EDT[R27]->S_DT[R17];
relate val to dt across R820;

val.LineNumber = ::getLineNumber(rule_token: param.a1_rule_token);
val.StartPosition = ::getColumn(rule_token: param.a1_rule_token);
val.setEndPosition();

// store the textual position of the data type name
len.dataTypeNameLineNumber = block.currentDataTypeNameLineNumber;
len.dataTypeNameColumn = block.currentDataTypeNameColumn;

return val.Value_ID;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5142,
	5141,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5143,
	5141,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5142,
	'');
INSERT INTO S_SPARM
	VALUES (5144,
	5141,
	'a3_rule_begin_id',
	296,
	0,
	'',
	5143,
	'');
INSERT INTO S_SPARM
	VALUES (5145,
	5141,
	'a4_rule_id',
	296,
	0,
	'',
	5144,
	'');
INSERT INTO S_SPARM
	VALUES (5146,
	5141,
	'b1_enum_data_type1_id',
	296,
	0,
	'',
	5145,
	'');
INSERT INTO S_SPARM
	VALUES (5147,
	5141,
	'b2_enumerator2_id',
	296,
	0,
	'',
	5146,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5148);
INSERT INTO S_SYNC
	VALUES (5148,
	1,
	'Debug_operand_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5149,
	5148,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5150);
INSERT INTO S_SYNC
	VALUES (5150,
	1,
	'Debug_operand_end',
	'ParserValidateFunction: TRUE',
	'return param.a4_rule_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5151,
	5150,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5152,
	5150,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5151,
	'');
INSERT INTO S_SPARM
	VALUES (5153,
	5150,
	'a3_rule_begin_id',
	296,
	0,
	'',
	5152,
	'');
INSERT INTO S_SPARM
	VALUES (5154,
	5150,
	'a4_rule_id',
	296,
	0,
	'',
	5153,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5155);
INSERT INTO S_SYNC
	VALUES (5155,
	1,
	'Event_spec_start',
	'ParserValidateFunction: TRUE',
	'
stmt_id =  ::statement_create();
select any stmt from instances of ACT_SMT where selected.Statement_ID == stmt_id;
create object instance ess of E_ESS;
relate stmt to ess across R603;
ess.PEIndicated = false;
ess.ParmListOK = true;

// assume it''s a generate statement
create object instance ges of E_GES;
relate ges to ess across R701;

return stmt.Statement_ID;

',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5156,
	5155,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5157);
INSERT INTO S_SYNC
	VALUES (5157,
	1,
	'Event_label_validate',
	'ParserValidateFunction: TRUE',
	'select any stmt from instances of ACT_SMT 
    where selected.Statement_ID == param.a6_current_rule_id;
current_scope = ::get_current_scope();
select any block from instances of ACT_BLK where
                                            selected.Block_ID == current_scope;
select one body related by block->ACT_ACT[R612];
isInGenericPackage = body.associateWithContainer();
if isInGenericPackage
  select one containingElem related by body->ACT_BIE[R640]->PE_PE[R640];
  select one component related by containingElem->C_C[R8001];
  select one package related by containingElem->EP_PKG[R8001];
  // Find visible EE''s and Classes
  if not_empty component
    component.collectVisibleElementsForName(name:"",
        type:ElementTypeConstants::EE,
                          originatingContainerID:component.Id,
                                  delegatingContainerID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:false);
    component.collectVisibleElementsForName(name:"",
        type:ElementTypeConstants::CLASS,
                          originatingContainerID:component.Id,
                                  delegatingContainerID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:false);
  else
    package.collectVisibleElementsForName(name:"",
        type:ElementTypeConstants::EE, descending:false,
                          originatingContainerID:package.Package_ID,
                                          delegatingPkgID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:false);
    package.collectVisibleElementsForName(name:"",
        type:ElementTypeConstants::CLASS, descending:false,
                          originatingContainerID:package.Package_ID,
                                          delegatingPkgID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:false);
  end if;
  select any resultSet related by component->PE_CRS[R8007] where
                                selected.Name == "" and 
                                      selected.Type == ElementTypeConstants::EE; 
  select many EEResults related by resultSet->PE_CVS[R8008]->PE_PE[R8004];
  select any resultSet related by component->PE_CRS[R8007] where
                                    selected.Name == "" and 
                                  selected.Type == ElementTypeConstants::CLASS; 
  select many classResults related by resultSet->PE_CVS[R8008]->PE_PE[R8004];
  if not_empty package
    select any pkgResultSet related by package->PE_SRS[R8005] where
                                    selected.Name == "" and 
                                      selected.Type == ElementTypeConstants::EE; 
    select many EEResults related by pkgResultSet->PE_VIS[R8006]->PE_PE[R8002];
    select any pkgResultSet related by package->PE_SRS[R8005] where
                                    selected.Name == "" and 
                                  selected.Type == ElementTypeConstants::CLASS; 
    select many classResults related by pkgResultSet->PE_VIS[R8006]->PE_PE[R8002];
  end if;
  select many evt_set related by classResults->O_OBJ[R8001]->
                          SM_ISM[R518]->SM_SM[R517]->SM_EVT[R502] where
                                              selected.Drv_Lbl == param.a3_text;
  select many classEvt_set related by classResults->O_OBJ[R8001]->
                          SM_ASM[R519]->SM_SM[R517]->SM_EVT[R502] where
                                              selected.Drv_Lbl == param.a3_text;
  select many eeevt_set related by EEResults->S_EE[R8001]->S_EEEVT[R10] where
                                              selected.Drv_Lbl == param.a3_text;
  if ( empty evt_set and empty classEvt_set)
    if ( empty eeevt_set )
      stmt.dispose();
      ERR::reportParseError( msg: "Cannot find event for event label ->%s<-",
            token: param.a1_rule_token );
    elif ( cardinality eeevt_set > 1 )
      stmt.dispose();
      ERR::reportParseError( msg:
"More than one event with label ->%s<- You will need to eventually run the audit and/or clear this up",
          token: param.a1_rule_token );
    else
      select any eeevt related by EEResults->S_EE[R8001]->S_EEEVT[R10] where
                                              selected.Drv_Lbl == param.a3_text;
      select one ges related by stmt->E_ESS[R603]->E_GES[R701];
      create object instance gee of E_GEE;
      relate gee to ges across R703;
      relate gee to eeevt across R709;  
      return stmt.Statement_ID;
    end if;
  elif ( (cardinality evt_set + cardinality classEvt_set) > 1 )
    stmt.dispose();
    ERR::reportParseError( msg:
"More than one event with label ->%s<- You will need to eventually run the audit and/or clear this up",
          token: param.a1_rule_token );
  else
    select any evt related by classResults->O_OBJ[R8001]->
                          SM_ISM[R518]->SM_SM[R517]->SM_EVT[R502] where
                                              selected.Drv_Lbl == param.a3_text;
    if empty evt
      select any evt related by classResults->O_OBJ[R8001]->
                          SM_ASM[R519]->SM_SM[R517]->SM_EVT[R502] where
                                              selected.Drv_Lbl == param.a3_text;
    end if;
    select one ges related by stmt->E_ESS[R603]->E_GES[R701];
    create object instance gsme of E_GSME;
    relate gsme to ges across R703;
    relate gsme to evt across R707;  
  
    // store the textual position of the event derived-label
    select one eventSpec related by stmt->E_ESS[R603];
    eventSpec.eventDerivedLabelLineNumber = ::getLineNumber(rule_token: param.a1_rule_token);
    eventSpec.eventDerivedLabelColumn = ::getColumn(rule_token: param.a1_rule_token);
      
    return stmt.Statement_ID;
  end if;
else // not in generic package
  select many classes from instances of O_OBJ;
  select many evt_set related by classes->
                          SM_ISM[R518]->SM_SM[R517]->SM_EVT[R502] where
                                              selected.Drv_Lbl == param.a3_text;
  select many classEvt_set related by classes->
                          SM_ASM[R519]->SM_SM[R517]->SM_EVT[R502] where
                                              selected.Drv_Lbl == param.a3_text;
  select many eeevt_set from instances of S_EEEVT where
                                          ( selected.Drv_Lbl == param.a3_text );
  body.associateWithOwningComponent();
  select one component related by body->ACT_BIC[R694]->C_C[R694];
  if not_empty component
    // If we''re in a component, we just look for the class locally
    select many classes related by component->CN_DC[R4204]->S_DOM[R4204]->
                                                            S_SS[R1]->O_OBJ[R2];
    select many evt_set related by classes->
                          SM_ISM[R518]->SM_SM[R517]->SM_EVT[R502] where
                                              selected.Drv_Lbl == param.a3_text;
    select many classEvt_set related by classes->
                          SM_ASM[R519]->SM_SM[R517]->SM_EVT[R502] where
                                              selected.Drv_Lbl == param.a3_text;
  end if;
  if ( empty evt_set and empty classEvt_set)
    if ( empty eeevt_set )
      stmt.dispose();
      ERR::reportParseError( msg: "Cannot find event for event label ->%s<-",
            token: param.a1_rule_token );
    elif ( cardinality eeevt_set > 1 )
      stmt.dispose();
      ERR::reportParseError( msg:
"More than one event with label ->%s<- You will need to eventually run the audit and/or clear this up",
          token: param.a1_rule_token );
    else
      select any eeevt from instances of S_EEEVT where
                                          ( selected.Drv_Lbl == param.a3_text );
      select one ges related by stmt->E_ESS[R603]->E_GES[R701];
      create object instance gee of E_GEE;
      relate gee to ges across R703;
      relate gee to eeevt across R709;  
      return stmt.Statement_ID;
    end if;
  elif ( (cardinality evt_set + cardinality classEvt_set) > 1 )
    stmt.dispose();
    ERR::reportParseError( msg:
"More than one event with label ->%s<- You will need to eventually run the audit and/or clear this up",
          token: param.a1_rule_token );
  else
    select any evt related by classes->
                          SM_ISM[R518]->SM_SM[R517]->SM_EVT[R502] where
                                              selected.Drv_Lbl == param.a3_text;
    if empty evt
      select any evt related by classes->
                          SM_ASM[R519]->SM_SM[R517]->SM_EVT[R502] where
                                              selected.Drv_Lbl == param.a3_text;
    end if;
    select one ges related by stmt->E_ESS[R603]->E_GES[R701];
    create object instance gsme of E_GSME;
    relate gsme to ges across R703;
    relate gsme to evt across R707;  
    // store the textual position of the event derived-label
    select one eventSpec related by stmt->E_ESS[R603];
    eventSpec.eventDerivedLabelLineNumber =
                               ::getLineNumber(rule_token: param.a1_rule_token);
    eventSpec.eventDerivedLabelColumn =
                                   ::getColumn(rule_token: param.a1_rule_token);
    return stmt.Statement_ID;
  end if;
end if;
return GD::NULL_UNIQUE_ID();',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5158,
	5157,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5159,
	5157,
	'a3_text',
	322,
	0,
	'',
	5158,
	'');
INSERT INTO S_SPARM
	VALUES (5160,
	5157,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5159,
	'');
INSERT INTO S_SPARM
	VALUES (5161,
	5157,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5160,
	'');
INSERT INTO S_SPARM
	VALUES (5162,
	5157,
	'a6_current_rule_id',
	296,
	0,
	'',
	5161,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5163);
INSERT INTO S_SYNC
	VALUES (5163,
	1,
	'Terminal_tok_times_validate',
	'ParserValidateFunction: TRUE',
	'select any ess from instances of E_ESS where selected.Statement_ID == param.a4_current_rule_id;
if ( not_empty ess )
  ess.PEIndicated = true;
end if;

return param.a4_current_rule_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5164,
	5163,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5165,
	5163,
	'a2_text',
	322,
	0,
	'',
	5164,
	'');
INSERT INTO S_SPARM
	VALUES (5166,
	5163,
	'a3_upper_rule_id',
	296,
	0,
	'',
	5165,
	'');
INSERT INTO S_SPARM
	VALUES (5167,
	5163,
	'a4_current_rule_id',
	296,
	0,
	'',
	5166,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5168);
INSERT INTO S_SYNC
	VALUES (5168,
	1,
	'Event_meaning_validate',
	'ParserValidateFunction: TRUE',
	'select any stmt from instances of ACT_SMT 
    where selected.Statement_ID == param.a6_current_rule_id;

evt_meaning = OS::remove_ticks( ticked_string: param.a3_text );
select one gsme related by stmt->E_ESS[R603]->E_GES[R701]->E_GSME[R703];
if ( not_empty gsme )
  select one evt related by gsme->SM_EVT[R707];
  if ( evt.Mning != evt_meaning )
    stmt.dispose();
    ERR::reportParseError( msg: "Event meaning ->%s<- is not associated with event label ->"+ evt.Drv_Lbl+"<-",
            token: param.a1_rule_token );
  end if;
else
  select one cee related by stmt->E_ESS[R603]->E_GES[R701]->E_GEE[R703];
  select one eeevt related by cee->S_EEEVT[R709];
  if ( eeevt.Mning != evt_meaning )
    stmt.dispose();
    ERR::reportParseError( msg: "Event meaning ->%s<- is not associated with event label ->"+ eeevt.Drv_Lbl+"<-",
            token: param.a1_rule_token );
  end if;
end if;

// store the textual position of the event meaning
select one eventSpec related by stmt->E_ESS[R603];
eventSpec.eventMeaningLineNumber = ::getLineNumber(rule_token: param.a1_rule_token);
eventSpec.eventMeaningColumn = ::getColumn(rule_token: param.a1_rule_token);
	  
return param.a6_current_rule_id;









































































































































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5169,
	5168,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5170,
	5168,
	'a3_text',
	322,
	0,
	'',
	5169,
	'');
INSERT INTO S_SPARM
	VALUES (5171,
	5168,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5170,
	'');
INSERT INTO S_SPARM
	VALUES (5172,
	5168,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5171,
	'');
INSERT INTO S_SPARM
	VALUES (5173,
	5168,
	'a6_current_rule_id',
	296,
	0,
	'',
	5172,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5174);
INSERT INTO S_SYNC
	VALUES (5174,
	1,
	'Supp_data_validate',
	'ParserValidateFunction: TRUE',
	'return param.a6_current_rule_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5175,
	5174,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5176,
	5174,
	'a3_text',
	322,
	0,
	'',
	5175,
	'');
INSERT INTO S_SPARM
	VALUES (5177,
	5174,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5176,
	'');
INSERT INTO S_SPARM
	VALUES (5178,
	5174,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5177,
	'');
INSERT INTO S_SPARM
	VALUES (5179,
	5174,
	'a6_current_rule_id',
	296,
	0,
	'',
	5178,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5180);
INSERT INTO S_SYNC
	VALUES (5180,
	1,
	'String_literal_assigner_validate',
	'ParserValidateFunction: TRUE',
	'return param.a3_current_rule_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5181,
	5180,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5182,
	5180,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5181,
	'');
INSERT INTO S_SPARM
	VALUES (5183,
	5180,
	'a3_current_rule_id',
	296,
	0,
	'',
	5182,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5184);
INSERT INTO S_SYNC
	VALUES (5184,
	1,
	'String_literal_class_validate',
	'ParserValidateFunction: TRUE',
	'return param.a3_current_rule_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5185,
	5184,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5186,
	5184,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5185,
	'');
INSERT INTO S_SPARM
	VALUES (5187,
	5184,
	'a3_current_rule_id',
	296,
	0,
	'',
	5186,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5188);
INSERT INTO S_SYNC
	VALUES (5188,
	1,
	'String_literal_creator_validate',
	'ParserValidateFunction: TRUE',
	'return param.a3_current_rule_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5189,
	5188,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5190,
	5188,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5189,
	'');
INSERT INTO S_SPARM
	VALUES (5191,
	5188,
	'a3_current_rule_id',
	296,
	0,
	'',
	5190,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5192);
INSERT INTO S_SYNC
	VALUES (5192,
	1,
	'Inst_ref_var_or_ee_keyletters_validate',
	'ParserValidateFunction: TRUE',
	'::self_validate( a1_text: param.a3_text, a2_isLval: false, a3_token: param.a1_rule_token );
select any stmt from instances of ACT_SMT 
    where selected.Statement_ID == param.a6_current_rule_id;
select one blk related by stmt->ACT_BLK[R602];
blk.TempBuffer = "";

var_id = ::get_var_in_scope( name: param.a3_text, rule_token: param.a1_rule_token );

if ( var_id != GD::NULL_UNIQUE_ID() )
  select any var from instances of V_VAR where ( selected.Var_ID == var_id );
  if ( not_empty var )
    // make sure we know which class this is a variable for
    select one mc related by var->V_INT[R814]->O_OBJ[R818];
    if ( not_empty mc )
      blk.TempBuffer = "V_VAR.Var_ID";
      var.addLocation(line: ::getLineNumber(rule_token: param.a1_rule_token), 
            col: ::getColumn(rule_token: param.a1_rule_token) );
      return var_id;
    end if;
  end if;
else
  select any ee from instances of S_EE where ( selected.Key_Lett == param.a3_text );
  if ( not_empty ee )
    blk.TempBuffer = "S_EE.EE_ID";
    return ee.EE_ID;
  end if;
end if;

// there was a problem
stmt.dispose();
ERR::reportParseError( 
   msg:"Token ->%s<- must be a variable in current scope and per instance, or be external entity keyletters",
    token: param.a1_rule_token );

return GD::NULL_UNIQUE_ID();
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5193,
	5192,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5194,
	5192,
	'a3_text',
	322,
	0,
	'',
	5193,
	'');
INSERT INTO S_SPARM
	VALUES (5195,
	5192,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5194,
	'');
INSERT INTO S_SPARM
	VALUES (5196,
	5192,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5195,
	'');
INSERT INTO S_SPARM
	VALUES (5197,
	5192,
	'a6_current_rule_id',
	296,
	0,
	'',
	5196,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5198);
INSERT INTO S_SYNC
	VALUES (5198,
	1,
	'Event_spec_end',
	'ParserValidateFunction: TRUE',
	'if ( param.b4_object_keyletters4_id != GD::NULL_UNIQUE_ID() )
  // class based event
  return ::process_class_event( a1_stmt_id: param.b1_event_label1_id, 
      a2_obj_id: param.b4_object_keyletters4_id,
      a3_rule_token: param.a1_rule_token );
elif ( param.b5_object_keyletters5_id != GD::NULL_UNIQUE_ID() )
  // creation event
  return ::process_creation_event( a1_stmt_id: param.b1_event_label1_id, 
      a2_obj_id: param.b5_object_keyletters5_id,
      a3_rule_token: param.a1_rule_token );
elif ( param.b6_inst_ref_var_or_ee_keyletters6_id != GD::NULL_UNIQUE_ID() )
  // instance based event or EE event
  select any stmt from instances of ACT_SMT 
      where selected.Statement_ID == param.b1_event_label1_id;
  select one blk related by stmt->ACT_BLK[R602];
  if ( blk.TempBuffer == "V_VAR.Var_ID" )
    // instance-based event
    return ::process_instance_event( a1_stmt_id: param.b1_event_label1_id, 
        a2_var_id: param.b6_inst_ref_var_or_ee_keyletters6_id,
        a3_rule_token: param.a1_rule_token );
  else
    // EE event
    return ::process_ee_event( a1_stmt_id: param.b1_event_label1_id, 
        a2_ee_id: param.b6_inst_ref_var_or_ee_keyletters6_id,
        a3_rule_token: param.a1_rule_token );
  end if;
end if;

return param.a4_rule_id;










































































































































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5199,
	5198,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5200,
	5198,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5199,
	'');
INSERT INTO S_SPARM
	VALUES (5201,
	5198,
	'a3_rule_begin_id',
	296,
	0,
	'',
	5200,
	'');
INSERT INTO S_SPARM
	VALUES (5202,
	5198,
	'a4_rule_id',
	296,
	0,
	'',
	5201,
	'');
INSERT INTO S_SPARM
	VALUES (5203,
	5198,
	'b1_event_label1_id',
	296,
	0,
	'',
	5202,
	'');
INSERT INTO S_SPARM
	VALUES (5204,
	5198,
	'b2_event_meaning2_id',
	296,
	0,
	'',
	5203,
	'');
INSERT INTO S_SPARM
	VALUES (5205,
	5198,
	'b3_supp_data3_id',
	296,
	0,
	'',
	5204,
	'');
INSERT INTO S_SPARM
	VALUES (5206,
	5198,
	'b4_object_keyletters4_id',
	296,
	0,
	'',
	5205,
	'');
INSERT INTO S_SPARM
	VALUES (5207,
	5198,
	'b5_object_keyletters5_id',
	296,
	0,
	'',
	5206,
	'');
INSERT INTO S_SPARM
	VALUES (5208,
	5198,
	'b6_inst_ref_var_or_ee_keyletters6_id',
	296,
	0,
	'',
	5207,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5209);
INSERT INTO S_SYNC
	VALUES (5209,
	1,
	'Invocation_parameters_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5210,
	5209,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5211);
INSERT INTO S_SYNC
	VALUES (5211,
	1,
	'Data_item_validate',
	'ParserValidateFunction: TRUE',
	'if ( param.a2_isAccess )
  // store the textual position of the parameter name
  current_scope = ::get_current_scope();
  select any block from instances of ACT_BLK where
                                             selected.Block_ID == current_scope;
  block.currentParameterAssignmentNameLineNumber =
                               ::getLineNumber(rule_token: param.a1_rule_token);
  block.currentParameterAssignmentNameColumn =
                                   ::getColumn(rule_token: param.a1_rule_token);
  select any val from instances of V_VAL where
                                  selected.Value_ID == param.a6_current_rule_id;
  if (not_empty val)
    // Now we know the name of the parameter, hook it up to the value
    select one pvl related by val->V_PVL[R801];
    select any fnParm related by block->ACT_ACT[R612]->ACT_FNB[R698]->
                S_SYNC[R695]->S_SPARM[R24] where selected.Name == param.a3_text;
    if (not_empty fnParm)
      relate pvl to fnParm across R832;
      select one dt related by fnParm->S_DT[R26];
      relate val to dt across R820;
    else
      select any brParm related by block->ACT_ACT[R612]->ACT_BRB[R698]->
                 S_BRG[R697]->S_BPARM[R21] where selected.Name == param.a3_text;
      if (not_empty brParm)
        relate pvl to brParm across R831;
        select one dt related by brParm->S_DT[R22];
        relate val to dt across R820;
      else
        select any opParm related by block->ACT_ACT[R612]->ACT_OPB[R698]->
                O_TFR[R696]->O_TPARM[R117] where selected.Name == param.a3_text;
        if (not_empty opParm)
          relate pvl to opParm across R833;
          select one dt related by opParm->S_DT[R118];
          relate val to dt across R820;
        else
          select one act related by block->ACT_ACT[R612];
          select one reqSig related by act->ACT_RSB[R698]->SPR_RS[R684];
          select one reqOp related by act->ACT_ROB[R698]->SPR_RO[R685];
          select one provSig related by act->ACT_PSB[R698]->SPR_PS[R686];
          select one provOp related by act->ACT_POB[R698]->SPR_PO[R687];
          select any msgParm related by reqSig->SPR_REP[R4502]->
                  C_EP[R4500]->C_PP[R4006] where selected.Name == param.a3_text; 
          if not_empty reqOp
            select any msgParm related by reqOp->SPR_REP[R4502]->
                  C_EP[R4500]->C_PP[R4006] where selected.Name == param.a3_text; 
          elif not_empty provSig
            select any msgParm related by provSig->SPR_PEP[R4503]->
                  C_EP[R4501]->C_PP[R4006] where selected.Name == param.a3_text; 
          elif not_empty provOp
            select any msgParm related by provOp->SPR_PEP[R4503]->
                  C_EP[R4501]->C_PP[R4006] where selected.Name == param.a3_text; 
          end if;
          if not_empty msgParm
            relate pvl to msgParm across R843;
            select one dt related by msgParm->S_DT[R4007];
            relate val to dt across R820;
          end if;
        end if;
      end if;
    end if;
  end if;
  // parameter will be further verified by by param_data_access
  return param.a6_current_rule_id;
else
  select any val from instances of V_VAL where
                                    selected.Value_ID == param.a5_upper_rule_id;
  // store the textual position of the data-item label
  lineNumber = ::getLineNumber(rule_token: param.a1_rule_token);
  column = ::getColumn(rule_token: param.a1_rule_token);
  if not_empty val and val.firstParameterLabelLineNumber == 0 and
                                              val.firstParameterLabelColumn == 0
	val.firstParameterLabelLineNumber = lineNumber;
	val.firstParameterLabelColumn = column;
  elif (not_empty val)
	val.currentLaterParameterLabelLineNumber = lineNumber;
	val.currentLaterParameterLabelColumn = column;
  end if;
  select one fnc related by val->V_FNV[R801];
  if ( not_empty fnc )
    select one sync related by fnc->S_SYNC[R827];
    select many sparm_set related by sync->S_SPARM[R24]
                                           where selected.Name == param.a3_text;
    if ( empty sparm_set )
      fnc.ParmListOK = false;
      ERR::reportParseError( msg: "Parameter ->%s" +
              "<- is not associated with function ->" + sync.Name +"<-",
                                                   token: param.a1_rule_token );
    elif ( cardinality sparm_set > 1 )
      fnc.ParmListOK = false;
      ERR::reportParseError(msg: "More than one parameter with name ->%s" +
           "<- for function ->" + sync.Name + "<-", token: param.a1_rule_token);
    else
      select any sparm related by sync->S_SPARM[R24] where
                                                 selected.Name == param.a3_text;
      return sparm.SParm_ID;
    end if;
  else
    select one brv related by val->V_BRV[R801];
    if ( not_empty brv )
      select one brg related by brv->S_BRG[R828];
      select many bparm_set related by brg->S_BPARM[R21]
                                           where selected.Name == param.a3_text;
      if ( empty bparm_set )
        brv.ParmListOK = false;
        ERR::reportParseError(msg: "Parameter ->%s" +
             "<- is not associated with bridge ->" + brg.Name +"<-",
                                                   token: param.a1_rule_token );
      elif ( cardinality bparm_set > 1 )
        brv.ParmListOK = false;
        ERR::reportParseError(msg: "More than one parameter with name ->%s" +
                                         "<- for bridge ->" + brg.Name + "<-",
                                                    token: param.a1_rule_token);
      else
        select any bparm related by brg->S_BPARM[R21] where
                                                 selected.Name == param.a3_text;
        return bparm.BParm_ID;
      end if;
    else
      select one trv related by val->V_TRV[R801];
      if ( not_empty trv )
        select one tfr related by trv->O_TFR[R829];
        select many tparm_set related by tfr->O_TPARM[R117]
                                           where selected.Name == param.a3_text;
        if ( empty tparm_set )
          trv.ParmListOK = false;
          ERR::reportParseError( msg: "Parameter ->%s" +
                  "<- is not associated with operation ->" + tfr.Name + "<-",
                                                    token: param.a1_rule_token);
        elif ( cardinality tparm_set > 1 )
          trv.ParmListOK = false;
          ERR::reportParseError(msg: "More than one parameter with name ->%s" +
                                        "<- for operation ->" + tfr.Name + "<-",
                                                   token: param.a1_rule_token );
        else
          select any tparm related by tfr->O_TPARM[R117] where
                                                 selected.Name == param.a3_text;
          return tparm.TParm_ID;
        end if;
      else
        select one msv related by val->V_MSV[R801];
        if not_empty msv
          select one ep related by msv->SPR_PEP[R841]->C_EP[R4501];
          if(empty ep)
            // if the executable property was not found
            // search for a required executable property
            select one ep related by msv->SPR_REP[R845]->C_EP[R4500];
          end if;
          select many pparm_set related by ep->C_PP[R4006]
                                           where selected.Name == param.a3_text;
          name = "";
          select one sig related by ep->C_AS[R4004];
          if not_empty sig
            name = sig.Name;
          else
            select one iop related by ep->C_IO[R4004];
            name = iop.Name;
          end if;
          if empty pparm_set
            msv.ParmListOK = false;
            ERR::reportParseError( msg: "Parameter ->%s" +
                  "<- is not associated with message ->"+ name +"<-",
                                                   token: param.a1_rule_token );
          elif ( cardinality pparm_set > 1 )
            msv.ParmListOK = false;
            ERR::reportParseError( msg: "More than one parameter with name ->" +
                                      "%s<- for message ->" + name + "<-",
                                                   token: param.a1_rule_token );
          else
            select any pparm related by ep->C_PP[R4006] where
                                                 selected.Name == param.a3_text;
            return pparm.PP_Id;
          end if;
        end if;
      end if;
    end if;
  end if;
  return param.a6_current_rule_id;
end if;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5212,
	5211,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5213,
	5211,
	'a2_isAccess',
	316,
	0,
	'',
	5212,
	'');
INSERT INTO S_SPARM
	VALUES (5214,
	5211,
	'a3_text',
	322,
	0,
	'',
	5213,
	'');
INSERT INTO S_SPARM
	VALUES (5215,
	5211,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5214,
	'');
INSERT INTO S_SPARM
	VALUES (5216,
	5211,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5215,
	'');
INSERT INTO S_SPARM
	VALUES (5217,
	5211,
	'a6_current_rule_id',
	296,
	0,
	'',
	5216,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5218);
INSERT INTO S_SYNC
	VALUES (5218,
	1,
	'Invocation_parameters_loop4_start',
	'ParserValidateFunction: TRUE',
	'return GD::NULL_UNIQUE_ID();







































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5219,
	5218,
	'a1_upper_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5220,
	5218,
	'a2_rule_begin_id',
	296,
	0,
	'',
	5219,
	'');
INSERT INTO S_SPARM
	VALUES (5221,
	5218,
	'a3_current_rule_id',
	296,
	0,
	'',
	5220,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5222);
INSERT INTO S_SYNC
	VALUES (5222,
	1,
	'Invocation_parameters_loop4_end',
	'ParserValidateFunction: TRUE',
	'select any val from instances of V_VAL where selected.Value_ID == param.a2_upper_ruleid_name;

parmName = "";
parmType = "";
if ( not_empty val )
  select one fnc related by val->V_FNV[R801];
  select one brv related by val->V_BRV[R801];
  select one trv related by val->V_TRV[R801];
  select one msv related by val->V_MSV[R801];
  if ( not_empty fnc )
    if ( param.b4_expr4_id == GD::NULL_UNIQUE_ID() )
	  val.dispose();
	  return GD::NULL_UNIQUE_ID();
    elif ( fnc.ParmListOK )
      select one sync related by fnc->S_SYNC[R827];
      select any sparm related by sync->S_SPARM[R24] 
           where selected.SParm_ID == param.b3_data_item3_id;
      if ( not_empty sparm )
        parmName = sparm.Name;
        parmType = "fnc";
      end if;
    end if;
  elif ( not_empty brv )
    if ( param.b4_expr4_id == GD::NULL_UNIQUE_ID() )
	  val.dispose();
	  return GD::NULL_UNIQUE_ID();
    elif ( brv.ParmListOK )
      select one brg related by brv->S_BRG[R828];
      select any bparm related by brg->S_BPARM[R21] 
         where selected.BParm_ID == param.b3_data_item3_id;
      if ( not_empty bparm )
        parmName = bparm.Name;
        parmType = "brv";
      end if;
    end if;
  elif ( not_empty trv )
    if ( param.b4_expr4_id == GD::NULL_UNIQUE_ID() )
	  val.dispose();
	  return GD::NULL_UNIQUE_ID();
    elif ( trv.ParmListOK )
      select one tfr related by trv->O_TFR[R829];
      select any tparm related by tfr->O_TPARM[R117]
         where selected.TParm_ID == param.b3_data_item3_id;
      if ( not_empty tparm )
        parmName = tparm.Name;
        parmType = "trv";
      end if;
    end if;
  elif not_empty msv
    if ( param.b4_expr4_id == GD::NULL_UNIQUE_ID() )
	  val.dispose();
	  return GD::NULL_UNIQUE_ID();
    elif ( msv.ParmListOK )
      select one ep related by msv->SPR_PEP[R841]->C_EP[R4501]; 
      if(empty ep)
        // if the executable property was not found
        // search for a required executable property
        select one ep related by msv->SPR_REP[R845]->C_EP[R4500];
      end if;
      select any pparm related by ep->C_PP[R4006]
                                    where selected.PP_Id == param.b3_data_item3_id;
      if ( not_empty pparm )
        parmName = pparm.Name;
        parmType = "msv";
      end if;
    end if;
  end if;

  if ( parmName != "" )
    select any expr from instances of V_VAL where selected.Value_ID == param.b4_expr4_id;
    if ( empty expr )
     ERR::reportParseError( msg: "Cannot find r-value for parameter ->"+parmName+"<-",
            token: param.a1_rule_token );
    else
      create object instance parm of V_PAR;
      relate parm to expr across R800;
      if ( parmType == "fnc" )
        relate parm to fnc across R817;
      elif ( parmType == "brv" )
        relate parm to brv across R810;
      elif ( parmType == "trv" )
        relate parm to trv across R811;
      elif ( parmType == "msv" )
        relate parm to msv across R842;
      end if;
      parm.Name = parmName;
      if ( param.a3_ruleid_name != param.b4_expr4_id )
        // nth (n > 1) time through the loop
        select any prev_parm from instances of V_PAR 
            where selected.Value_ID == param.a3_ruleid_name;
        if ( not_empty prev_parm and prev_parm != parm)
          relate prev_parm to parm across R816.''precedes'';
        end if;
      end if;
      
      // store the textual position of the parameter label
      parm.labelLineNumber = val.currentLaterParameterLabelLineNumber;
      parm.labelColumn = val.currentLaterParameterLabelColumn;

      return parm.Value_ID;
    end if;
  end if;
end if;
return param.a3_ruleid_name;

',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5223,
	5222,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5224,
	5222,
	'a2_upper_ruleid_name',
	296,
	0,
	'',
	5223,
	'');
INSERT INTO S_SPARM
	VALUES (5225,
	5222,
	'a3_ruleid_name',
	296,
	0,
	'',
	5224,
	'');
INSERT INTO S_SPARM
	VALUES (5226,
	5222,
	'a4_loop_id_name',
	296,
	0,
	'',
	5225,
	'');
INSERT INTO S_SPARM
	VALUES (5227,
	5222,
	'b1_data_item1_id',
	296,
	0,
	'',
	5226,
	'');
INSERT INTO S_SPARM
	VALUES (5228,
	5222,
	'b2_expr2_id',
	296,
	0,
	'',
	5227,
	'');
INSERT INTO S_SPARM
	VALUES (5229,
	5222,
	'b3_data_item3_id',
	296,
	0,
	'',
	5228,
	'');
INSERT INTO S_SPARM
	VALUES (5230,
	5222,
	'b4_expr4_id',
	296,
	0,
	'',
	5229,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5231);
INSERT INTO S_SYNC
	VALUES (5231,
	1,
	'Invocation_parameters_end',
	'ParserValidateFunction: TRUE',
	'select any val from instances of V_VAL where selected.Value_ID == param.a2_upper_rule_id;

parmName = "";
parmType = "";
select one fnc related by val->V_FNV[R801];
if ( not_empty fnc and fnc.ParmListOK )
  if ( param.b2_expr2_id == GD::NULL_UNIQUE_ID() )
    fnc.ParmListOK = false;
  else
    select one sync related by fnc->S_SYNC[R827];
    select any sparm related by sync->S_SPARM[R24] 
         where selected.SParm_ID == param.b1_data_item1_id;
    parmName = sparm.Name;
    parmType = "fnc";
  end if;
else
  select one brv related by val->V_BRV[R801];
  if ( not_empty brv and brv.ParmListOK )
    if ( param.b2_expr2_id == GD::NULL_UNIQUE_ID() )
      brv.ParmListOK = false;
    else
      select one brg related by brv->S_BRG[R828];
      select any bparm related by brg->S_BPARM[R21] 
         where selected.BParm_ID == param.b1_data_item1_id;
      parmName = bparm.Name;
      parmType = "brv";
    end if;
  else
    select one trv related by val->V_TRV[R801];
    if ( not_empty trv and trv.ParmListOK )
      if ( param.b2_expr2_id == GD::NULL_UNIQUE_ID() )
        trv.ParmListOK = false;
      else
        select one tfr related by trv->O_TFR[R829];
        select any tparm related by tfr->O_TPARM[R117]
           where selected.TParm_ID == param.b1_data_item1_id;
        parmName = tparm.Name;
        parmType = "trv";
      end if;
    else
      select one msv related by val->V_MSV[R801];
      if not_empty msv and msv.ParmListOK
        if ( param.b2_expr2_id == GD::NULL_UNIQUE_ID() )
          msv.ParmListOK = false;
        else
          select one msg related by msv->SPR_PEP[R841]->C_EP[R4501];
          if(empty msg)
            // if the executable property was not found
            // search for a required executable property
            select one msg related by msv->SPR_REP[R845]->C_EP[R4500];
          end if;
          select any pparm related by msg->C_PP[R4006]
                                    where selected.PP_Id == param.b1_data_item1_id;
          parmName = pparm.Name;
          parmType = "msv";
        end if;
      end if;
    end if;
  end if;
end if;

if ( parmName != "" )
  select any expr from instances of V_VAL where selected.Value_ID == param.b2_expr2_id;
  create object instance parm of V_PAR;
  relate parm to expr across R800;
  if ( parmType == "fnc" )
    relate parm to fnc across R817;
  elif ( parmType == "brv" )
    select one brv related by val->V_BRV[R801];
    relate parm to brv across R810;
  elif ( parmType == "trv" )
    select one trv related by val->V_TRV[R801];
    relate parm to trv across R811;
  else
    select one msv related by val->V_MSV[R801];
    relate parm to msv across R842;
  end if;
  parm.Name = parmName;
  if ( param.b4_expr4_id != GD::NULL_UNIQUE_ID() )
    // this is the last in the list, get first in list
    select any next_parm from instances of V_PAR 
         where selected.Value_ID == param.b4_expr4_id;
    select one prev_parm related by next_parm->V_PAR[R816.''succeeds''];
    while ( not_empty prev_parm )
      next_parm = prev_parm;
      select one prev_parm related by next_parm->V_PAR[R816.''succeeds''];
    end while;
  
    relate parm to next_parm across R816.''precedes'';
  end if;

  // store the textual position of the parameter label
  parm.labelLineNumber = val.firstParameterLabelLineNumber;
  parm.labelColumn = val.firstParameterLabelColumn;

  return param.a2_upper_rule_id;
end if;
return param.a4_rule_id;









































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5232,
	5231,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5233,
	5231,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5232,
	'');
INSERT INTO S_SPARM
	VALUES (5234,
	5231,
	'a3_rule_begin_id',
	296,
	0,
	'',
	5233,
	'');
INSERT INTO S_SPARM
	VALUES (5235,
	5231,
	'a4_rule_id',
	296,
	0,
	'',
	5234,
	'');
INSERT INTO S_SPARM
	VALUES (5236,
	5231,
	'b1_data_item1_id',
	296,
	0,
	'',
	5235,
	'');
INSERT INTO S_SPARM
	VALUES (5237,
	5231,
	'b2_expr2_id',
	296,
	0,
	'',
	5236,
	'');
INSERT INTO S_SPARM
	VALUES (5238,
	5231,
	'b3_data_item3_id',
	296,
	0,
	'',
	5237,
	'');
INSERT INTO S_SPARM
	VALUES (5239,
	5231,
	'b4_expr4_id',
	296,
	0,
	'',
	5238,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5240);
INSERT INTO S_SYNC
	VALUES (5240,
	1,
	'Instance_chain_start',
	'ParserValidateFunction: TRUE',
	'return GD::NULL_UNIQUE_ID();
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5241,
	5240,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5242);
INSERT INTO S_SYNC
	VALUES (5242,
	1,
	'Instance_chain_loop5_start',
	'ParserValidateFunction: TRUE',
	'return param.a2_rule_begin_id;










































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5243,
	5242,
	'a1_upper_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5244,
	5242,
	'a2_rule_begin_id',
	296,
	0,
	'',
	5243,
	'');
INSERT INTO S_SPARM
	VALUES (5245,
	5242,
	'a3_current_rule_id',
	296,
	0,
	'',
	5244,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5246);
INSERT INTO S_SYNC
	VALUES (5246,
	1,
	'Instance_chain_loop5_end',
	'ParserValidateFunction: TRUE',
	'select any right_obj from instances of O_OBJ 
    where ( selected.Obj_ID == param.b1_object_keyletters1_id );
rel_mult = Multiplicity::One;
mult = Multiplicity::One;
if ( param.a3_ruleid_name == GD::NULL_UNIQUE_ID() )
  // we are the first one
  select any val from instances of V_VAL 
       where ( selected.Value_ID == param.a2_upper_ruleid_name );
  select one left_obj  related by val->V_IRF[R801]->V_VAR[R808]->V_INT[R814]->O_OBJ[R818];
  if ( empty left_obj )
    select one left_obj related by val->V_ISR[R801]->V_VAR[R809]->V_INS[R814]->O_OBJ[R819];
    mult = Multiplicity::Many;
  end if;
  rel_mult =  ::is_valid_relationship( a1_left: left_obj.Obj_ID, a2_right:right_obj.Obj_ID,
         a3_rel: param.b2_relationship2_id, 
         a4_phrase: param.b3_phrase3_id, a5_rule_token: param.a1_rule_token,
       a6_chain_start_val: param.a2_upper_ruleid_name, a7_chain_id: GD::NULL_UNIQUE_ID() );
else
  select any prior_link from instances of ACT_LNK 
        where ( selected.Link_ID == param.a3_ruleid_name );
  select one left_obj related by prior_link->O_OBJ[R678];
  rel_mult =  ::is_valid_relationship( a1_left: left_obj.Obj_ID, a2_right:right_obj.Obj_ID,
         a3_rel: param.b2_relationship2_id, 
         a4_phrase: param.b3_phrase3_id, a5_rule_token: param.a1_rule_token,
        a6_chain_start_val: param.a2_upper_ruleid_name, a7_chain_id: prior_link.Link_ID );
end if;

if ( rel_mult == Multiplicity::Many and mult == Multiplicity::One )
  mult = Multiplicity::Many;
  // the other case where they are different (rel_mult == Multiplicity::One and mult == Multiplicity::Many) 
  // mult already has the correct value
end if;

create object instance link of ACT_LNK;
relate link to right_obj across R678;

select any rel from instances of R_REL where ( selected.Rel_ID == param.b2_relationship2_id );
relate link to rel across R681;
link.Mult = mult;

if ( param.b3_phrase3_id != GD::NULL_UNIQUE_ID() )
  current_scope = ::get_current_scope();
  select any block from instances of ACT_BLK where (selected.Block_ID == current_scope);
  link.Rel_Phrase = block.TempBuffer;

	// store the textual position of the phrase
	link.phraseLineNumber = block.currentAssociationPhraseLineNumber;
	link.phraseColumn = block.currentAssociationPhraseColumn;

  // clear the TempBuffer so that if there''s not a phrase on the next link
  // we don''t use the current one by mistake
  block.TempBuffer = "";
end if;

if ( param.a3_ruleid_name != GD::NULL_UNIQUE_ID() )
  select any prior_link from instances of ACT_LNK where ( selected.Link_ID == param.a3_ruleid_name );
  relate prior_link to link across R604.''precedes'';
end if;

// store the textual position of the class key-letters
current_scope = ::get_current_scope();
select any block from instances of ACT_BLK 
	where (selected.Block_ID == current_scope);
link.modelClassKeyLettersLineNumber = block.currentKeyLettersLineNumber;
link.modelClassKeyLettersColumn = block.currentKeyLettersColumn;

// store the textual position of the association number
link.associationNumberLineNumber = block.currentAssociationNumberLineNumber;
link.associationNumberColumn = block.currentAssociationNumberColumn;

return link.Link_ID;











































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5247,
	5246,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5248,
	5246,
	'a2_upper_ruleid_name',
	296,
	0,
	'',
	5247,
	'');
INSERT INTO S_SPARM
	VALUES (5249,
	5246,
	'a3_ruleid_name',
	296,
	0,
	'',
	5248,
	'');
INSERT INTO S_SPARM
	VALUES (5250,
	5246,
	'a4_loop_id_name',
	296,
	0,
	'',
	5249,
	'');
INSERT INTO S_SPARM
	VALUES (5251,
	5246,
	'b1_object_keyletters1_id',
	296,
	0,
	'',
	5250,
	'');
INSERT INTO S_SPARM
	VALUES (5252,
	5246,
	'b2_relationship2_id',
	296,
	0,
	'',
	5251,
	'');
INSERT INTO S_SPARM
	VALUES (5253,
	5246,
	'b3_phrase3_id',
	296,
	0,
	'',
	5252,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5254);
INSERT INTO S_SYNC
	VALUES (5254,
	1,
	'Instance_chain_end',
	'ParserValidateFunction: TRUE',
	'return param.a4_rule_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5255,
	5254,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5256,
	5254,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5255,
	'');
INSERT INTO S_SPARM
	VALUES (5257,
	5254,
	'a3_rule_begin_id',
	296,
	0,
	'',
	5256,
	'');
INSERT INTO S_SPARM
	VALUES (5258,
	5254,
	'a4_rule_id',
	296,
	0,
	'',
	5257,
	'');
INSERT INTO S_SPARM
	VALUES (5259,
	5254,
	'b1_object_keyletters1_id',
	296,
	0,
	'',
	5258,
	'');
INSERT INTO S_SPARM
	VALUES (5260,
	5254,
	'b2_relationship2_id',
	296,
	0,
	'',
	5259,
	'');
INSERT INTO S_SPARM
	VALUES (5261,
	5254,
	'b3_phrase3_id',
	296,
	0,
	'',
	5260,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5262);
INSERT INTO S_SYNC
	VALUES (5262,
	1,
	'Object_spec_start',
	'ParserValidateFunction: TRUE',
	'// need to make sure this is true for statements without a where clause
current_scope = ::get_current_scope();
select any blk from instances of ACT_BLK where (selected.Block_ID == current_scope);
blk.WhereSpecOK = true;
return param.a1_ruleid_name;



',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5263,
	5262,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5264);
INSERT INTO S_SYNC
	VALUES (5264,
	1,
	'Instance_chain_validate',
	'ParserValidateFunction: TRUE',
	'return param.a6_current_rule_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5265,
	5264,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5266,
	5264,
	'a3_text',
	322,
	0,
	'',
	5265,
	'');
INSERT INTO S_SPARM
	VALUES (5267,
	5264,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5266,
	'');
INSERT INTO S_SPARM
	VALUES (5268,
	5264,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5267,
	'');
INSERT INTO S_SPARM
	VALUES (5269,
	5264,
	'a6_current_rule_id',
	296,
	0,
	'',
	5268,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5270);
INSERT INTO S_SYNC
	VALUES (5270,
	1,
	'Where_spec_validate',
	'ParserValidateFunction: TRUE',
	'current_scope = ::get_current_scope();
select any blk from instances of ACT_BLK where (selected.Block_ID == current_scope);
if ( param.a6_current_rule_id == GD::NULL_UNIQUE_ID() )
  blk.WhereSpecOK =  false;
else
  blk.WhereSpecOK = true;
end if;
return param.a6_current_rule_id;











































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5271,
	5270,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5272,
	5270,
	'a2_isChain',
	316,
	0,
	'',
	5271,
	'');
INSERT INTO S_SPARM
	VALUES (5273,
	5270,
	'a3_text',
	322,
	0,
	'',
	5272,
	'');
INSERT INTO S_SPARM
	VALUES (5274,
	5270,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5273,
	'');
INSERT INTO S_SPARM
	VALUES (5275,
	5270,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5274,
	'');
INSERT INTO S_SPARM
	VALUES (5276,
	5270,
	'a6_current_rule_id',
	296,
	0,
	'',
	5275,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5277);
INSERT INTO S_SYNC
	VALUES (5277,
	1,
	'Object_spec_end',
	'ParserValidateFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// ::Object_spec_end()
current_scope = ::get_current_scope();
select any blk from instances of ACT_BLK where (selected.Block_ID == current_scope);

where_spec_id = param.b3_where_spec3_id;
if ( param.b5_where_spec5_id != GD::NULL_UNIQUE_ID() )
  where_spec_id = param.b5_where_spec5_id;
end if;
if ( where_spec_id != GD::NULL_UNIQUE_ID() )
  select any val from instances of V_VAL where ( selected.Value_ID == where_spec_id );
  select one where_dt related by val->S_DT[R820];
  if ( empty where_dt or where_dt.Name != "boolean" )
    ::clear_rel_data( a1_chain_start_val: param.b1_local_variable1_id, 
        a2_chain_id: param.b2_instance_chain2_id, a3_where_val: where_spec_id );
    ERR::reportParseError( msg: "Expression within Select Where clause does not yield boolean result",
      token: param.a1_rule_token );
  end if;
end if;

if ( param.b2_instance_chain2_id != GD::NULL_UNIQUE_ID() )
  // related by

  select any link from instances of ACT_LNK 
       where ( selected.Link_ID == param.b2_instance_chain2_id );
  //  follow links back to beginning
  first_link = link;
  while ( not_empty link )
    first_link = link;
    select one link related by first_link->ACT_LNK[R604.''succeeds''];
  end while;

  create object instance sel of ACT_SEL;
  if ( param.b3_where_spec3_id != GD::NULL_UNIQUE_ID() )
    create object instance srw of ACT_SRW;
    relate sel to srw across R664;
    select any where_val from instances of V_VAL 
       where ( selected.Value_ID == param.b3_where_spec3_id );
    relate srw to where_val across R611;
  elif ( blk.WhereSpecOK )
    create object instance sr of ACT_SR;
    relate sel to sr across R664;
  else
    // there was an error in the where clause
    delete object instance sel;
    ::clear_rel_data( a1_chain_start_val: param.b1_local_variable1_id, 
        a2_chain_id: param.b2_instance_chain2_id, a3_where_val: param.b3_where_spec3_id );
    return GD::NULL_UNIQUE_ID();
  end if;
  select any start_point_ref from instances of V_VAL
     where ( selected.Value_ID == param.b1_local_variable1_id );
  relate sel to start_point_ref across R613;
  relate sel to first_link across R637;
  stmt_id =  ::statement_create();
  select any stmt from instances of ACT_SMT where selected.Statement_ID == stmt_id;
  relate stmt to sel across R603;
  return stmt.Statement_ID;
elif ( param.b4_object_keyletters4_id != GD::NULL_UNIQUE_ID() )
  // from instances of
  select any objPe from instances of PE_PE  where
                          selected.Element_ID == param.b4_object_keyletters4_id;
  select one obj related by objPe->O_OBJ[R8001];
  isInGenericPackage = not_empty obj;
  if not isInGenericPackage
    // Specialized package class
    select any obj from instances of O_OBJ where
                              selected.Obj_ID == param.b4_object_keyletters4_id;
  end if;
  if ( param.b5_where_spec5_id != GD::NULL_UNIQUE_ID() )
    select any val from instances of V_VAL where ( selected.Value_ID == param.b5_where_spec5_id );
    stmt_id =  ::statement_create();
    select any stmt from instances of ACT_SMT where selected.Statement_ID == stmt_id;
    create object instance fiw of ACT_FIW;
    relate fiw to obj across R676;
    relate val to fiw across R610;
    relate stmt to fiw across R603;

    // store the textual position of the extent
    fiw.extentLineNumber = blk.currentKeyLettersLineNumber;
    fiw.extentColumn = blk.currentKeyLettersColumn;

    return stmt.Statement_ID;
  elif ( blk.WhereSpecOK )
    stmt_id =  ::statement_create();
    select any stmt from instances of ACT_SMT where selected.Statement_ID == stmt_id;
    create object instance fio of ACT_FIO;
    relate fio to obj across R677;
    relate stmt to fio across R603;

    // store the textual position of the extent
    fio.extentLineNumber = blk.currentKeyLettersLineNumber;
    fio.extentColumn = blk.currentKeyLettersColumn;

    return stmt.Statement_ID;
  else
    // there was an error in the where clause
    ::clear_rel_data( a1_chain_start_val: param.b1_local_variable1_id, 
        a2_chain_id: param.b2_instance_chain2_id, a3_where_val: param.b3_where_spec3_id );
    return GD::NULL_UNIQUE_ID();
  end if;
else
  // there was an error in the sub rules - delete any leftovers
  if ( param.b5_where_spec5_id != GD::NULL_UNIQUE_ID() )
    ::clear_rel_data( a1_chain_start_val: param.b1_local_variable1_id, 
        a2_chain_id: param.b2_instance_chain2_id, a3_where_val: param.b5_where_spec5_id  );
  else
    ::clear_rel_data( a1_chain_start_val: param.b1_local_variable1_id, 
        a2_chain_id: param.b2_instance_chain2_id, a3_where_val: param.b3_where_spec3_id  );
  end if;
  return GD::NULL_UNIQUE_ID();
end if;

',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5278,
	5277,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5279,
	5277,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5278,
	'');
INSERT INTO S_SPARM
	VALUES (5280,
	5277,
	'a3_rule_begin_id',
	296,
	0,
	'',
	5279,
	'');
INSERT INTO S_SPARM
	VALUES (5281,
	5277,
	'a4_rule_id',
	296,
	0,
	'',
	5280,
	'');
INSERT INTO S_SPARM
	VALUES (5282,
	5277,
	'b1_local_variable1_id',
	296,
	0,
	'',
	5281,
	'');
INSERT INTO S_SPARM
	VALUES (5283,
	5277,
	'b2_instance_chain2_id',
	296,
	0,
	'',
	5282,
	'');
INSERT INTO S_SPARM
	VALUES (5284,
	5277,
	'b3_where_spec3_id',
	296,
	0,
	'',
	5283,
	'');
INSERT INTO S_SPARM
	VALUES (5285,
	5277,
	'b4_object_keyletters4_id',
	296,
	0,
	'',
	5284,
	'');
INSERT INTO S_SPARM
	VALUES (5286,
	5277,
	'b5_where_spec5_id',
	296,
	0,
	'',
	5285,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5287);
INSERT INTO S_SYNC
	VALUES (5287,
	1,
	'Param_data_access_start',
	'ParserValidateFunction: TRUE',
	'//::Param_data_access_start()
current_scope = ::get_current_scope();
select any blk from instances of ACT_BLK where
                                             selected.Block_ID == current_scope;
select one act related by blk->ACT_ACT[R612];
select one sab related by act->ACT_SAB[R698];
select one tab related by act->ACT_TAB[R698];
create object instance val of V_VAL;
if empty sab and empty tab
  // If this is not a state machine activity,
  // initialize as a parameter value
  create object instance pvl of V_PVL;
  relate pvl to val across R801;
else
  // If this _is_ a state machine activity,
  // initialize as an event datum value
  create object instance edv of V_EDV;
  relate edv to val across R801;
end if;
val.isLValue = param.a2_isLval;
return val.Value_ID;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5288,
	5287,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5289,
	5287,
	'a2_isLval',
	316,
	0,
	'',
	5288,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5290);
INSERT INTO S_SYNC
	VALUES (5290,
	1,
	'Param_data_access_end',
	'ParserValidateFunction: TRUE',
	'// ::Param_data_access_end()
result = param.a4_rule_id;
if ( param.b2_member_id == GD::NULL_UNIQUE_ID() and
                                param.a3_rule_begin_id ==  GD::NULL_UNIQUE_ID())
  // There is neither a field, nor a parameter reference,
  // dispose incompletely created value instances . . .
  ::clear_value_data();
  // ... and report an error
  ERR::reportParseError( msg:
                     "Field or parameter %s not found for parameter access",
                                                   token: param.a1_rule_token );
else
  current_scope = ::get_current_scope();
  select any blk from instances of ACT_BLK where
                                           (selected.Block_ID == current_scope);
  if (empty blk)
    ::clear_value_data();
    ERR::reportParseError(msg:"Block not found", token: param.a1_rule_token );
  end if;
  select many vals from instances of V_VAL where
                                      selected.Block_ID == GD::NULL_UNIQUE_ID();
  for each val in vals
    relate val to blk across R826;
  end for;
end if;
return result;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5291,
	5290,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5292,
	5290,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5291,
	'');
INSERT INTO S_SPARM
	VALUES (5293,
	5290,
	'a3_rule_begin_id',
	296,
	0,
	'',
	5292,
	'');
INSERT INTO S_SPARM
	VALUES (5294,
	5290,
	'a4_rule_id',
	296,
	0,
	'',
	5293,
	'');
INSERT INTO S_SPARM
	VALUES (5295,
	5290,
	'b2_member_id',
	296,
	0,
	'',
	5294,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5296);
INSERT INTO S_SYNC
	VALUES (5296,
	1,
	'Supp_data_start',
	'ParserValidateFunction: TRUE',
	'current_scope = ::get_current_scope();
select any blk from instances of ACT_BLK where (selected.Block_ID == current_scope);
blk.SupData1 = "";
blk.SupData2 = "";
return param.a1_ruleid_name;




',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5297,
	5296,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5298);
INSERT INTO S_SYNC
	VALUES (5298,
	1,
	'Supp_data_item_validate',
	'ParserValidateFunction: TRUE',
	'current_scope = ::get_current_scope();
select any blk from instances of ACT_BLK where
                                             selected.Block_ID == current_scope;
blk.SupData2 = param.a3_text;
if ( blk.SupData1 == "" )
  // this is the first time, save value in both buffers
  blk.SupData1 = blk.SupData2;
end if;

// store the textual position of the data-item label
select any ess from instances of E_ESS where
                                selected.Statement_ID == param.a5_upper_rule_id;
if (not_empty ess)
  lineNumber = ::getLineNumber(rule_token: param.a1_rule_token);
  column = ::getColumn(rule_token: param.a1_rule_token);
  if (ess.firstEventDataItemNameLineNumber == 0 and
                                          ess.firstEventDataItemNameColumn == 0)
	ess.firstEventDataItemNameLineNumber = lineNumber;
	ess.firstEventDataItemNameColumn = column;
  else 
	ess.currentLaterEventDataItemNameLineNumber = lineNumber;
	ess.currentLaterEventDataItemNameColumn = column;
  end if;
end if;

return param.a6_current_rule_id;




',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5299,
	5298,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5300,
	5298,
	'a3_text',
	322,
	0,
	'',
	5299,
	'');
INSERT INTO S_SPARM
	VALUES (5301,
	5298,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5300,
	'');
INSERT INTO S_SPARM
	VALUES (5302,
	5298,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5301,
	'');
INSERT INTO S_SPARM
	VALUES (5303,
	5298,
	'a6_current_rule_id',
	296,
	0,
	'',
	5302,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5304);
INSERT INTO S_SYNC
	VALUES (5304,
	1,
	'Supp_data_loop6_start',
	'ParserValidateFunction: TRUE',
	'return GD::NULL_UNIQUE_ID();












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5305,
	5304,
	'a1_upper_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5306,
	5304,
	'a2_rule_begin_id',
	296,
	0,
	'',
	5305,
	'');
INSERT INTO S_SPARM
	VALUES (5307,
	5304,
	'a3_current_rule_id',
	296,
	0,
	'',
	5306,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5308);
INSERT INTO S_SYNC
	VALUES (5308,
	1,
	'Supp_data_loop6_end',
	'ParserValidateFunction: TRUE',
	'select any stmt from instances of ACT_SMT 
    where selected.Statement_ID == param.a2_upper_ruleid_name;
if ( empty stmt )
  ERR::reportParseError( msg: "Cannot find Statement instance",
       token: param.a1_rule_token );
else
  select one ess related by stmt->E_ESS[R603];
  if ( empty ess )
    ERR::reportParseError( msg: "Statement is not an Event Specification Statement",
         token: param.a1_rule_token );
  else
    if ( ess.ParmListOK )
        if ( param.b4_expr4_id == GD::NULL_UNIQUE_ID() )
          ess.ParmListOK = false;
        end if;
    end if;

    if ( ess.ParmListOK )
      select any expr from instances of V_VAL where selected.Value_ID == param.b4_expr4_id;
      if ( empty expr )
        ERR::reportParseError( msg: "Cannot find r-value for ->%s<-",
            token: param.a1_rule_token );
      else  
        create object instance parm of V_PAR;
        relate parm to expr across R800;
        relate parm to ess across R700;

        select one blk related by stmt->ACT_BLK[R602];
        parm.Name = blk.SupData2;

        if ( param.a3_ruleid_name != param.b2_expr2_id )
          // nth (n > 1) time through the loop
          select any prev_parm from instances of V_PAR 
               where selected.Value_ID == param.a3_ruleid_name;
          if ( not_empty prev_parm and prev_parm != parm)
            relate prev_parm to parm across R816.''precedes'';
          end if;
        end if;

	      // store the textual position of the event data item label
	      parm.labelLineNumber = ess.currentLaterEventDataItemNameLineNumber;
	      parm.labelColumn = ess.currentLaterEventDataItemNameColumn;

        return parm.Value_ID;
      end if;
    end if;
  end if;
end if;
return GD::NULL_UNIQUE_ID();
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5309,
	5308,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5310,
	5308,
	'a2_upper_ruleid_name',
	296,
	0,
	'',
	5309,
	'');
INSERT INTO S_SPARM
	VALUES (5311,
	5308,
	'a3_ruleid_name',
	296,
	0,
	'',
	5310,
	'');
INSERT INTO S_SPARM
	VALUES (5312,
	5308,
	'a4_loop_id_name',
	296,
	0,
	'',
	5311,
	'');
INSERT INTO S_SPARM
	VALUES (5313,
	5308,
	'b1_supp_data_item1_id',
	296,
	0,
	'',
	5312,
	'');
INSERT INTO S_SPARM
	VALUES (5314,
	5308,
	'b2_expr2_id',
	296,
	0,
	'',
	5313,
	'');
INSERT INTO S_SPARM
	VALUES (5315,
	5308,
	'b3_supp_data_item3_id',
	296,
	0,
	'',
	5314,
	'');
INSERT INTO S_SPARM
	VALUES (5316,
	5308,
	'b4_expr4_id',
	296,
	0,
	'',
	5315,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5317);
INSERT INTO S_SYNC
	VALUES (5317,
	1,
	'Supp_data_end',
	'ParserValidateFunction: TRUE',
	'select any stmt from instances of ACT_SMT 
    where selected.Statement_ID == param.a2_upper_rule_id;
select one ess related by stmt->E_ESS[R603];

if ( ess.ParmListOK )
    if ( param.b2_expr2_id == GD::NULL_UNIQUE_ID() )
      ess.ParmListOK = false;
    end if;
end if;

if ( ess.ParmListOK )
  select any expr from instances of V_VAL where selected.Value_ID == param.b2_expr2_id;
  create object instance parm of V_PAR;
  relate parm to expr across R800;
  relate parm to ess across R700;

  select one blk related by stmt->ACT_BLK[R602];
  parm.Name = blk.SupData1;

  if ( param.b4_expr4_id != GD::NULL_UNIQUE_ID() )
    // this is the last in the list, get first in list
    select any next_parm from instances of V_PAR 
         where selected.Value_ID == param.b4_expr4_id;
    select one prev_parm related by next_parm->V_PAR[R816.''succeeds''];
    while ( not_empty prev_parm )
      next_parm = prev_parm;
      select one prev_parm related by next_parm->V_PAR[R816.''succeeds''];
    end while;
  
    relate parm to next_parm across R816.''precedes'';
  end if;

  // store the textual position of the event data item label
  parm.labelLineNumber = ess.firstEventDataItemNameLineNumber;
  parm.labelColumn = ess.firstEventDataItemNameColumn;

  return param.a2_upper_rule_id;
else
  // there was a problem, clean up
  stmt.dispose();
  if ( param.b2_expr2_id != GD::NULL_UNIQUE_ID() )
    select any expr from instances of V_VAL where selected.Value_ID == param.b2_expr2_id;
    expr.dispose();
  end if;
  return GD::NULL_UNIQUE_ID();
end if;




',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5318,
	5317,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5319,
	5317,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5318,
	'');
INSERT INTO S_SPARM
	VALUES (5320,
	5317,
	'a3_rule_begin_id',
	296,
	0,
	'',
	5319,
	'');
INSERT INTO S_SPARM
	VALUES (5321,
	5317,
	'a4_rule_id',
	296,
	0,
	'',
	5320,
	'');
INSERT INTO S_SPARM
	VALUES (5322,
	5317,
	'b1_supp_data_item1_id',
	296,
	0,
	'',
	5321,
	'');
INSERT INTO S_SPARM
	VALUES (5323,
	5317,
	'b2_expr2_id',
	296,
	0,
	'',
	5322,
	'');
INSERT INTO S_SPARM
	VALUES (5324,
	5317,
	'b3_supp_data_item3_id',
	296,
	0,
	'',
	5323,
	'');
INSERT INTO S_SPARM
	VALUES (5325,
	5317,
	'b4_expr4_id',
	296,
	0,
	'',
	5324,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5326);
INSERT INTO S_SYNC
	VALUES (5326,
	1,
	'Function_invocation_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;

',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5327,
	5326,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5328,
	5326,
	'a2_isRval',
	316,
	0,
	'',
	5327,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5329);
INSERT INTO S_SYNC
	VALUES (5329,
	1,
	'Function_function_validate',
	'ParserValidateFunction: TRUE',
	'current_scope = ::get_current_scope();
select any block from instances of ACT_BLK where (selected.Block_ID == current_scope);
select one body related by block->ACT_ACT[R612];
isInGenericPackage = body.associateWithContainer();
if isInGenericPackage
  select one containingElem related by body->ACT_BIE[R640]->PE_PE[R640];
  select one component related by containingElem->C_C[R8001];
  select one package related by containingElem->EP_PKG[R8001];
  // Check for function match for token
  if not_empty component
    component.collectVisibleElementsForName(name:param.a3_text,
         type:ElementTypeConstants::FUNCTION,
                          originatingContainerID:component.Id,
                                   delegatingContainerID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:false);
  else
    package.collectVisibleElementsForName(name:param.a3_text,
         type:ElementTypeConstants::FUNCTION, descending:false,
                           originatingContainerID:package.Package_ID,
                                          delegatingPkgID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:false);
  end if;
  select any resultSet related by component->PE_CRS[R8007] where
                                 selected.Name == param.a3_text and 
                                selected.Type == ElementTypeConstants::FUNCTION; 
  select many results related by resultSet->PE_CVS[R8008]->PE_PE[R8004];
  if not_empty package
    select any pkgResultSet related by package->PE_SRS[R8005] where
                                    selected.Name == param.a3_text and 
                                selected.Type == ElementTypeConstants::FUNCTION; 
    select many results related by pkgResultSet->PE_VIS[R8006]->PE_PE[R8002];
  end if;
  FNCount = cardinality results;
  if FNCount == 0
    ERR::reportParseError( 
        msg: "Cannot find specified function ->%s<-", 
        token: param.a1_rule_token );
  elif FNCount == 1
    select any fn related by results->S_SYNC[R8001];
    create object instance fnc of V_FNV;
    fnc.ParmListOK = true;
    create object instance val of V_VAL;
    current_scope = ::get_current_scope();
    select any block from instances of ACT_BLK where
                                             selected.Block_ID == current_scope;
    relate val to block across R826;
    relate val to fnc across R801;

    relate fn to fnc across R827;
    select one sdt related by fn->S_DT[R25];
    relate val to sdt across R820;

    val.LineNumber = ::getLineNumber(rule_token: param.a1_rule_token);
    val.StartPosition = ::getColumn(rule_token: param.a1_rule_token);
    val.setEndPosition();
	
    return val.Value_ID;
  elif FNCount > 1
    resultList = "";
    sep = "";
    for each result in results
      resultList = resultList + sep + result.getQualifiedName();
      sep = " ,";
    end for;
    ERR::reportParseError(msg: "Multiple functions found for ->%s<-: " +
                                           resultList, token: param.a1_rule_token);
  end if;
  return GD::NULL_UNIQUE_ID();
else
  select many sync_set from instances of S_SYNC where ( selected.Name == param.a3_text );
  if ( empty sync_set )
    ERR::reportParseError( msg: "Cannot find specified function ->%s<-",
          token: param.a1_rule_token );
  elif ( cardinality sync_set > 1 )
     ERR::reportParseError( msg:
"More than one function with name ->%s<- You will need to eventually run the audit and/or clear this up",
          token: param.a1_rule_token );
  else
    select any sync from instances of S_SYNC where ( selected.Name == param.a3_text );
    create object instance fnc of V_FNV;
    fnc.ParmListOK = true;
    create object instance val of V_VAL;
    current_scope = ::get_current_scope();
    select any block from instances of ACT_BLK where (selected.Block_ID == current_scope);
    relate val to block across R826;
    relate val to fnc across R801;

    relate sync to fnc across R827;
    select one sdt related by sync->S_DT[R25];
    relate val to sdt across R820;

    val.LineNumber = ::getLineNumber(rule_token: param.a1_rule_token);
    val.StartPosition = ::getColumn(rule_token: param.a1_rule_token);
    val.setEndPosition();
	
    return val.Value_ID;
  end if;
end if;
return param.a6_current_rule_id;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5330,
	5329,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5331,
	5329,
	'a3_text',
	322,
	0,
	'',
	5330,
	'');
INSERT INTO S_SPARM
	VALUES (5332,
	5329,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5331,
	'');
INSERT INTO S_SPARM
	VALUES (5333,
	5329,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5332,
	'');
INSERT INTO S_SPARM
	VALUES (5334,
	5329,
	'a6_current_rule_id',
	296,
	0,
	'',
	5333,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5335);
INSERT INTO S_SYNC
	VALUES (5335,
	1,
	'Function_invocation_end',
	'ParserValidateFunction: TRUE',
	'
// validate parameters

select any fnc from instances of V_FNV 
   where selected.Value_ID == param.b1_function_function1_id;

if (empty fnc)
  // an error has already been output and the
  // function value has been cleaned up
  return GD::NULL_UNIQUE_ID();
end if;

if ( not fnc.ParmListOK )
  // error already output, still need to clean up
  select one val related by fnc->V_VAL[R801];
  val.dispose();
  return GD::NULL_UNIQUE_ID();
end if;

select one sync related by fnc->S_SYNC[R827];
select many vparm_set related by fnc->V_PAR[R817];
select many sparm_set related by sync->S_SPARM[R24];
if ( cardinality vparm_set < cardinality sparm_set )
  select one val related by fnc->V_VAL[R801];
  val.dispose();
  ERR::reportParseError( msg: "Function ->"+sync.Name+
      "<- is missing corresponding parameter(s)",
          token: param.a1_rule_token );
else
  for each sparm in sparm_set
    found = false;
    for each vparm in vparm_set
      if ( sparm.Name == vparm.Name )
        found = true;
        err_msg="";
        select one parm_val related by vparm->V_VAL[R800];
        select one vdt related by parm_val->S_DT[R820];
        if (empty vdt)
          err_msg = "Parameter ->"+ sparm.Name +"<- value has an unknown data type.";
        elif ( ::data_types_compatible( dt1: sparm.DT_ID, dt2: vdt.DT_ID, op: "assign")  == GD::NULL_UNIQUE_ID() )
          err_msg = "Parameter ->"+ sparm.Name +"<- has been assigned value of different type";
        end if;
        if ( sparm.By_Ref == 1 )
          if ( ::is_readonly_value( val_id: vparm.Value_ID ) )
            err_msg = "Cannot pass read-only value to pass-by-reference parameter ->"+ sparm.Name + "<-";
          end if;
        end if;
        if (sparm.getDimensionsCnt()!= parm_val.getDimensions())
          err_msg = "Parameter ->"+ sparm.Name +"<- has incompatible array depth.";
        elif ( not parm_val.isElementCountValid() )
          err_msg = "Parameter ->"+ sparm.Name + "<- contains an Array Index Out of Bounds.";
        end if;
        if (err_msg == "")
          break;
        else 
          select one val related by fnc->V_VAL[R801];
          val.dispose();        
          ERR::reportParseError( msg: err_msg, token: param.a1_rule_token );
        end if;
      end if;
    end for;
    if ( not found )
      select one val related by fnc->V_VAL[R801];
      val.dispose();
      ERR::reportParseError( msg: "Function ->"+sync.Name+
          "<- is missing corresponding parameter(s)",
             token: param.a1_rule_token );
    end if;
  end for;

      // If execution gets here, all the data items from the database
      // were found in the parse data items.

      // If there are more data items in the parse then were found in the
      // database, that means there were redundant or extra data items in the
      // parameter list found by the parse.  Generate an error.

  if ( cardinality vparm_set > cardinality sparm_set )
    for each vparm in vparm_set
      found = false;
      for each sparm in sparm_set
        if ( sparm.Name == vparm.Name )
          found = true;
          break;
        end if;
      end for;
      if ( not found )
      select one val related by fnc->V_VAL[R801];
      val.dispose();
      ERR::reportParseError( msg: "Parameter ->"+ vparm.Name +
          "<- is not associated with function ->"+ sync.Name +"<-",
             token: param.a1_rule_token );
      end if;
    end for;

      // If it gets out of the loop without error, there must be
      // a redundant data item, so report the error
    select one val related by fnc->V_VAL[R801];
    val.dispose();
    ERR::reportParseError( msg: "Function ->"+sync.Name+
      "<- has redundant parameters",
          token: param.a1_rule_token );
    
  end if;
end if;
return param.b1_function_function1_id;


',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5336,
	5335,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5337,
	5335,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5336,
	'');
INSERT INTO S_SPARM
	VALUES (5338,
	5335,
	'a3_rule_begin_id',
	296,
	0,
	'',
	5337,
	'');
INSERT INTO S_SPARM
	VALUES (5339,
	5335,
	'a4_rule_id',
	296,
	0,
	'',
	5338,
	'');
INSERT INTO S_SPARM
	VALUES (5340,
	5335,
	'b1_function_function1_id',
	296,
	0,
	'',
	5339,
	'');
INSERT INTO S_SPARM
	VALUES (5341,
	5335,
	'b2_invocation_parameters2_id',
	296,
	0,
	'',
	5340,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5342);
INSERT INTO S_SYNC
	VALUES (5342,
	1,
	'Transform_ib_invocation_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;

',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5343,
	5342,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5344,
	5342,
	'a2_isRval',
	316,
	0,
	'',
	5343,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5345);
INSERT INTO S_SYNC
	VALUES (5345,
	1,
	'Transformer_function_validate',
	'ParserValidateFunction: TRUE',
	'if ( param.a2_isKeyLett )
  select any obj from instances of O_OBJ where  selected.Obj_ID == param.a6_current_rule_id;

  return ::is_valid_transform( 
      a1_obj_id: obj.Obj_ID, a2_name: param.a3_text, a3_rule_token: param.a1_rule_token, 
      a4_classBased:  true );
else
  select any var from instances of V_VAR
          where (selected.Var_ID == param.a6_current_rule_id );
  select one irv related by var->V_INT[R814];
  select one obj related by irv->O_OBJ[R818];
  if (not_empty obj)
    return ::is_valid_transform( 
        a1_obj_id: obj.Obj_ID, a2_name: param.a3_text, a3_rule_token: param.a1_rule_token,
        a4_classBased: false );
  else
      return GD::NULL_UNIQUE_ID(); 
  end if;
end if;










































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5346,
	5345,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5347,
	5345,
	'a2_isKeyLett',
	316,
	0,
	'',
	5346,
	'');
INSERT INTO S_SPARM
	VALUES (5348,
	5345,
	'a3_text',
	322,
	0,
	'',
	5347,
	'');
INSERT INTO S_SPARM
	VALUES (5349,
	5345,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5348,
	'');
INSERT INTO S_SPARM
	VALUES (5350,
	5345,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5349,
	'');
INSERT INTO S_SPARM
	VALUES (5351,
	5345,
	'a6_current_rule_id',
	296,
	0,
	'',
	5350,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5352);
INSERT INTO S_SYNC
	VALUES (5352,
	1,
	'Transform_ib_invocation_end',
	'ParserValidateFunction: TRUE',
	'  select any trv from instances of V_TRV 
     where selected.Value_ID == param.b2_transformer_function2_id;
  select any var from instances of V_VAR
          where (selected.Var_ID == param.b1_inst_ref_var1_id );
  if ( ::selected_validate( name:var.Name, rule_token: param.a1_rule_token ) )
    current_scope = ::get_current_scope();
    select any blk from instances of ACT_BLK where (selected.Block_ID == current_scope);
    if ( not_empty blk )
      blk.SelectedFound = true;
    end if;
  end if;
  select one irv related by var->V_INT[R814];
  select one obj related by irv->O_OBJ[R818];
  if (empty obj)
    ERR::reportParseError( msg:  "Variable ->" + var.Name + 
	        "<- does not exist in scope as an object instance variable",
            token: param.a1_rule_token );
  elif ( not_empty trv )
    ret_val =  ::Transform_invocation_end( a1_rule_token: param.a1_rule_token, 
        a2_upper_rule_id: param.a2_upper_rule_id,
        a3_rule_begin_id: param.a3_rule_begin_id,
        a4_rule_id: param.a4_rule_id,
        b1_object_keyletters1_id: obj.Obj_ID,
        b2_transformer_function2_id: param.b2_transformer_function2_id,
        b3_invocation_parameters3_id: param. b3_invocation_parameters3_id );
    if ( ret_val != GD::NULL_UNIQUE_ID() )
      relate trv to var across R830;
    end if;
    return ret_val;  
  end if;
return param.a4_rule_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5353,
	5352,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5354,
	5352,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5353,
	'');
INSERT INTO S_SPARM
	VALUES (5355,
	5352,
	'a3_rule_begin_id',
	296,
	0,
	'',
	5354,
	'');
INSERT INTO S_SPARM
	VALUES (5356,
	5352,
	'a4_rule_id',
	296,
	0,
	'',
	5355,
	'');
INSERT INTO S_SPARM
	VALUES (5357,
	5352,
	'b1_inst_ref_var1_id',
	296,
	0,
	'',
	5356,
	'');
INSERT INTO S_SPARM
	VALUES (5358,
	5352,
	'b2_transformer_function2_id',
	296,
	0,
	'',
	5357,
	'');
INSERT INTO S_SPARM
	VALUES (5359,
	5352,
	'b3_invocation_parameters3_id',
	296,
	0,
	'',
	5358,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5360);
INSERT INTO S_SYNC
	VALUES (5360,
	1,
	'Transform_invocation_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5361,
	5360,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5362,
	5360,
	'a2_isRval',
	316,
	0,
	'',
	5361,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5363);
INSERT INTO S_SYNC
	VALUES (5363,
	1,
	'Transform_invocation_end',
	'ParserValidateFunction: TRUE',
	'
// validate parameters

select any trv from instances of V_TRV 
   where selected.Value_ID == param.b2_transformer_function2_id;

if ( not trv.ParmListOK )
  // error already output, still need to clean up
  select one val related by trv->V_VAL[R801];
  val.dispose();
  return GD::NULL_UNIQUE_ID();
end if;

select one tfr related by trv->O_TFR[R829];
select many vparm_set related by trv->V_PAR[R811];
select many tparm_set related by tfr->O_TPARM[R117];
if ( cardinality vparm_set < cardinality tparm_set )
  select one val related by trv->V_VAL[R801];
  val.dispose();
  ERR::reportParseError( msg: "Operation ->"+tfr.Name+
      "<- is missing corresponding parameter(s)",
          token: param.a1_rule_token );
else
  for each tparm in tparm_set
    found = false;
    for each vparm in vparm_set
      if ( tparm.Name == vparm.Name )
        found = true;
        err_msg = "";
        select one parm_val related by vparm->V_VAL[R800];
        select one vdt related by parm_val->S_DT[R820];
        if (empty vdt)
          err_msg = "Parameter ->"+ tparm.Name +"<- value has an unknown data type.";
        elif ( ::data_types_compatible( dt1: tparm.DT_ID, dt2: vdt.DT_ID, op: "assign")  == GD::NULL_UNIQUE_ID() )
          err_msg = "Parameter ->"+ tparm.Name +"<- has been assigned value of different type";
        end if;
        if ( tparm.By_Ref == 1 )
          if ( ::is_readonly_value( val_id: vparm.Value_ID ) )
            err_msg = "Cannot pass read-only value to pass-by-reference parameter ->"+ tparm.Name + "<-";
          end if;
        end if;
        if (tparm.getDimensionsCnt()!= parm_val.getDimensions())
          err_msg = "Parameter ->"+ tparm.Name +"<- has incompatible array depth.";
        elif ( not parm_val.isElementCountValid() )
          err_msg = "Parameter ->"+ tparm.Name + "<- contains an Array Index Out of Bounds.";
        end if;      
        if (err_msg == "")
          break;
        else 
          select one val related by trv->V_VAL[R801];
          val.dispose();        
          ERR::reportParseError( msg: err_msg, token: param.a1_rule_token );
        end if;
      end if;
    end for;
    if ( not found )
      select one val related by trv->V_VAL[R801];
      val.dispose();
      ERR::reportParseError( msg: "Operation ->"+tfr.Name+
          "<- is missing corresponding parameter(s)",
             token: param.a1_rule_token );
    end if;
  end for;

      // If execution gets here, all the data items from the database
      // were found in the parse data items.

      // If there are more data items in the parse then were found in the
      // database, that means there were redundant or extra data items in the
      // parameter list found by the parse.  Generate an error.

  if ( cardinality vparm_set > cardinality tparm_set )
    for each vparm in vparm_set
      found = false;
      for each tparm in tparm_set
        if ( tparm.Name == vparm.Name )
          found = true;
          break;
        end if;
      end for;
      if ( not found )
      select one val related by trv->V_VAL[R801];
      val.dispose();
      ERR::reportParseError( msg: "Parameter ->"+ vparm.Name +
          "<- is not associated with operation ->"+ tfr.Name +"<-",
             token: param.a1_rule_token );
      end if;
    end for;

      // If it gets out of the loop without error, there must be
      // a redundant data item, so report the error
    select one val related by trv->V_VAL[R801];
    val.dispose();
    ERR::reportParseError( msg: "Operation ->"+tfr.Name+
      "<- has redundant parameters",
          token: param.a1_rule_token );
    
  end if;
end if;
return param.b2_transformer_function2_id;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5364,
	5363,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5365,
	5363,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5364,
	'');
INSERT INTO S_SPARM
	VALUES (5366,
	5363,
	'a3_rule_begin_id',
	296,
	0,
	'',
	5365,
	'');
INSERT INTO S_SPARM
	VALUES (5367,
	5363,
	'a4_rule_id',
	296,
	0,
	'',
	5366,
	'');
INSERT INTO S_SPARM
	VALUES (5368,
	5363,
	'b1_object_keyletters1_id',
	296,
	0,
	'',
	5367,
	'');
INSERT INTO S_SPARM
	VALUES (5369,
	5363,
	'b2_transformer_function2_id',
	296,
	0,
	'',
	5368,
	'');
INSERT INTO S_SPARM
	VALUES (5370,
	5363,
	'b3_invocation_parameters3_id',
	296,
	0,
	'',
	5369,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5371);
INSERT INTO S_SYNC
	VALUES (5371,
	1,
	'Where_spec_start',
	'ParserValidateFunction: TRUE',
	'current_scope = ::get_current_scope();
select any blk from instances of ACT_BLK where (selected.Block_ID == current_scope);

select any obj from instances of O_OBJ where ( selected.Obj_ID == param.a1_ruleid_name );
if ( param.a2_isChain )
  select any link from instances of ACT_LNK
       where ( selected.Link_ID == param.a1_ruleid_name );
  select one obj related by link->O_OBJ[R678];
end if;

if ( empty obj )
  // If obj is empty, something went wrong preceeding this function.  Just bail
  // instead of continuing and crashing.
  return GD::NULL_UNIQUE_ID();
end if;

create object instance inst_ref of V_INT;
create object instance var_inst of V_VAR;
var_inst.Name = "Selected";
var_inst.Declared = true;
relate inst_ref to var_inst across R814;
relate inst_ref to obj across R818;
relate var_inst to blk across R823;

create object instance inst_ref of V_INT;
create object instance var_inst of V_VAR;
var_inst.Name = "SELECTED";
var_inst.Declared = true;
relate inst_ref to var_inst across R814;
relate inst_ref to obj across R818;
relate var_inst to blk across R823;

create object instance inst_ref of V_INT;
create object instance var_inst of V_VAR;
var_inst.Name = "selected";
var_inst.Declared = true;
relate inst_ref to var_inst across R814;
relate inst_ref to obj across R818;
relate var_inst to blk across R823;

::connect_inst_ref_var_to_datatype(p1_is_set:false, p2_var_id:var_inst.Var_ID, p3_obj_id:obj.Obj_ID);

current_scope = ::get_current_scope();
select any blk from instances of ACT_BLK where (selected.Block_ID == current_scope);
blk.SelectedFound = false;
blk.InWhereSpec = true;
blk.WhereSpecOK = true;

return param.a1_ruleid_name;



',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5372,
	5371,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5373,
	5371,
	'a2_isChain',
	316,
	0,
	'',
	5372,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5374);
INSERT INTO S_SYNC
	VALUES (5374,
	1,
	'Where_spec_end',
	'ParserValidateFunction: TRUE',
	's1 = ::get_var_in_scope( name:"Selected", rule_token: param.a1_rule_token );
select any var from instances of V_VAR where (selected.Var_ID == s1 );
var.dispose();

s2 = ::get_var_in_scope( name:"SELECTED", rule_token: param.a1_rule_token );
select any var from instances of V_VAR where (selected.Var_ID == s2 );
var.dispose();

s3 = ::get_var_in_scope( name:"selected", rule_token: param.a1_rule_token );
select any var from instances of V_VAR where (selected.Var_ID == s3 );
var.dispose();

current_scope = ::get_current_scope();
select any blk from instances of ACT_BLK where (selected.Block_ID == current_scope);
blk.InWhereSpec = false;

if ( param.b1_expr1_id == GD::NULL_UNIQUE_ID() )
  blk.WhereSpecOK =  false;
end if;
return param.a4_rule_id;























































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5375,
	5374,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5376,
	5374,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5375,
	'');
INSERT INTO S_SPARM
	VALUES (5377,
	5374,
	'a3_rule_begin_id',
	296,
	0,
	'',
	5376,
	'');
INSERT INTO S_SPARM
	VALUES (5378,
	5374,
	'a4_rule_id',
	296,
	0,
	'',
	5377,
	'');
INSERT INTO S_SPARM
	VALUES (5379,
	5374,
	'b1_expr1_id',
	296,
	0,
	'',
	5378,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5380);
INSERT INTO S_SYNC
	VALUES (5380,
	1,
	'Data_item_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;



',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5381,
	5380,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5382,
	5380,
	'a2_isAccess',
	316,
	0,
	'',
	5381,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5383);
INSERT INTO S_SYNC
	VALUES (5383,
	1,
	'Data_item_name_validate',
	'ParserValidateFunction: TRUE',
	'return param.a6_current_rule_id;



',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5384,
	5383,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5385,
	5383,
	'a3_text',
	322,
	0,
	'',
	5384,
	'');
INSERT INTO S_SPARM
	VALUES (5386,
	5383,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5385,
	'');
INSERT INTO S_SPARM
	VALUES (5387,
	5383,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5386,
	'');
INSERT INTO S_SPARM
	VALUES (5388,
	5383,
	'a6_current_rule_id',
	296,
	0,
	'',
	5387,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5389);
INSERT INTO S_SYNC
	VALUES (5389,
	1,
	'Data_item_end',
	'ParserValidateFunction: TRUE',
	'return param.a4_rule_id;



',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5390,
	5389,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5391,
	5389,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5390,
	'');
INSERT INTO S_SPARM
	VALUES (5392,
	5389,
	'a3_rule_begin_id',
	296,
	0,
	'',
	5391,
	'');
INSERT INTO S_SPARM
	VALUES (5393,
	5389,
	'a4_rule_id',
	296,
	0,
	'',
	5392,
	'');
INSERT INTO S_SPARM
	VALUES (5394,
	5389,
	'b1_data_item_name1_id',
	296,
	0,
	'',
	5393,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5395);
INSERT INTO S_SYNC
	VALUES (5395,
	1,
	'Transformer_function_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5396,
	5395,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5397,
	5395,
	'a2_isKeyLett',
	316,
	0,
	'',
	5396,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5398);
INSERT INTO S_SYNC
	VALUES (5398,
	1,
	'Function_name_validate',
	'ParserValidateFunction: TRUE',
	'return param.a6_current_rule_id;



































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5399,
	5398,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5400,
	5398,
	'a3_text',
	322,
	0,
	'',
	5399,
	'');
INSERT INTO S_SPARM
	VALUES (5401,
	5398,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5400,
	'');
INSERT INTO S_SPARM
	VALUES (5402,
	5398,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5401,
	'');
INSERT INTO S_SPARM
	VALUES (5403,
	5398,
	'a6_current_rule_id',
	296,
	0,
	'',
	5402,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5404);
INSERT INTO S_SYNC
	VALUES (5404,
	1,
	'Transformer_function_end',
	'ParserValidateFunction: TRUE',
	'return param.a4_rule_id;



































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5405,
	5404,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5406,
	5404,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5405,
	'');
INSERT INTO S_SPARM
	VALUES (5407,
	5404,
	'a3_rule_begin_id',
	296,
	0,
	'',
	5406,
	'');
INSERT INTO S_SPARM
	VALUES (5408,
	5404,
	'a4_rule_id',
	296,
	0,
	'',
	5407,
	'');
INSERT INTO S_SPARM
	VALUES (5409,
	5404,
	'b1_function_name1_id',
	296,
	0,
	'',
	5408,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5410);
INSERT INTO S_SYNC
	VALUES (5410,
	1,
	'Sub_expr_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5411,
	5410,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5412);
INSERT INTO S_SYNC
	VALUES (5412,
	1,
	'Conjunction_validate',
	'ParserValidateFunction: TRUE',
	'return param.a6_current_rule_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5413,
	5412,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5414,
	5412,
	'a3_text',
	322,
	0,
	'',
	5413,
	'');
INSERT INTO S_SPARM
	VALUES (5415,
	5412,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5414,
	'');
INSERT INTO S_SPARM
	VALUES (5416,
	5412,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5415,
	'');
INSERT INTO S_SPARM
	VALUES (5417,
	5412,
	'a6_current_rule_id',
	296,
	0,
	'',
	5416,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5418);
INSERT INTO S_SYNC
	VALUES (5418,
	1,
	'Sub_expr_loop7_start',
	'ParserValidateFunction: TRUE',
	'return param.a2_rule_begin_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5419,
	5418,
	'a1_upper_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5420,
	5418,
	'a2_rule_begin_id',
	296,
	0,
	'',
	5419,
	'');
INSERT INTO S_SPARM
	VALUES (5421,
	5418,
	'a3_current_rule_id',
	296,
	0,
	'',
	5420,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5422);
INSERT INTO S_SYNC
	VALUES (5422,
	1,
	'Sub_expr_loop7_end',
	'ParserValidateFunction: TRUE',
	'if (param.b2_conjunction2_id != GD::NULL_UNIQUE_ID() )
  op_id = ::binary_operator_create( a1_text: "or", a2_dt_name: "boolean" );
  lhs_id = param.b1_conjunction1_id;
  if ( param.a3_ruleid_name != param.b1_conjunction1_id )
    lhs_id = param.a3_ruleid_name;
  end if;
  return  ::binary_operation_validate( a1_left_op: lhs_id, 
              a2_operator: op_id, 
              a3_right_op: param.b2_conjunction2_id, 
              a4_op_type: "boolean or expression",
              a5_set_dt: false, a6_rule_token: param.a1_rule_token, a7_rule_id:param.a3_ruleid_name );

end if;
return param.a3_ruleid_name;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5423,
	5422,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5424,
	5422,
	'a2_upper_ruleid_name',
	296,
	0,
	'',
	5423,
	'');
INSERT INTO S_SPARM
	VALUES (5425,
	5422,
	'a3_ruleid_name',
	296,
	0,
	'',
	5424,
	'');
INSERT INTO S_SPARM
	VALUES (5426,
	5422,
	'a4_loop_id_name',
	296,
	0,
	'',
	5425,
	'');
INSERT INTO S_SPARM
	VALUES (5427,
	5422,
	'b1_conjunction1_id',
	296,
	0,
	'',
	5426,
	'');
INSERT INTO S_SPARM
	VALUES (5428,
	5422,
	'b2_conjunction2_id',
	296,
	0,
	'',
	5427,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5429);
INSERT INTO S_SYNC
	VALUES (5429,
	1,
	'Sub_expr_end',
	'ParserValidateFunction: TRUE',
	'return param.a4_rule_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5430,
	5429,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5431,
	5429,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5430,
	'');
INSERT INTO S_SPARM
	VALUES (5432,
	5429,
	'a3_rule_begin_id',
	296,
	0,
	'',
	5431,
	'');
INSERT INTO S_SPARM
	VALUES (5433,
	5429,
	'a4_rule_id',
	296,
	0,
	'',
	5432,
	'');
INSERT INTO S_SPARM
	VALUES (5434,
	5429,
	'b1_conjunction1_id',
	296,
	0,
	'',
	5433,
	'');
INSERT INTO S_SPARM
	VALUES (5435,
	5429,
	'b2_conjunction2_id',
	296,
	0,
	'',
	5434,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5436);
INSERT INTO S_SYNC
	VALUES (5436,
	1,
	'Conjunction_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;

',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5437,
	5436,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5438);
INSERT INTO S_SYNC
	VALUES (5438,
	1,
	'Relational_expr_validate',
	'ParserValidateFunction: TRUE',
	'return param.a6_current_rule_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5439,
	5438,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5440,
	5438,
	'a3_text',
	322,
	0,
	'',
	5439,
	'');
INSERT INTO S_SPARM
	VALUES (5441,
	5438,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5440,
	'');
INSERT INTO S_SPARM
	VALUES (5442,
	5438,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5441,
	'');
INSERT INTO S_SPARM
	VALUES (5443,
	5438,
	'a6_current_rule_id',
	296,
	0,
	'',
	5442,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5444);
INSERT INTO S_SYNC
	VALUES (5444,
	1,
	'Conjunction_loop8_start',
	'ParserValidateFunction: TRUE',
	'return param.a2_rule_begin_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5445,
	5444,
	'a1_upper_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5446,
	5444,
	'a2_rule_begin_id',
	296,
	0,
	'',
	5445,
	'');
INSERT INTO S_SPARM
	VALUES (5447,
	5444,
	'a3_current_rule_id',
	296,
	0,
	'',
	5446,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5448);
INSERT INTO S_SYNC
	VALUES (5448,
	1,
	'Conjunction_loop8_end',
	'ParserValidateFunction: TRUE',
	'if (param.b2_relational_expr2_id != GD::NULL_UNIQUE_ID() )
  op_id = ::binary_operator_create( a1_text: "and", a2_dt_name: "boolean" );
  lhs_id = param.b1_relational_expr1_id;
  if ( param.a3_ruleid_name != param.b1_relational_expr1_id )
    lhs_id = param.a3_ruleid_name;
  end if;
  return  ::binary_operation_validate( a1_left_op: lhs_id, 
              a2_operator: op_id, 
              a3_right_op: param.b2_relational_expr2_id, 
              a4_op_type: "boolean and expression",
              a5_set_dt: false, a6_rule_token: param.a1_rule_token, a7_rule_id:param.a3_ruleid_name );

end if;
return param.a3_ruleid_name;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5449,
	5448,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5450,
	5448,
	'a2_upper_ruleid_name',
	296,
	0,
	'',
	5449,
	'');
INSERT INTO S_SPARM
	VALUES (5451,
	5448,
	'a3_ruleid_name',
	296,
	0,
	'',
	5450,
	'');
INSERT INTO S_SPARM
	VALUES (5452,
	5448,
	'a4_loop_id_name',
	296,
	0,
	'',
	5451,
	'');
INSERT INTO S_SPARM
	VALUES (5453,
	5448,
	'b1_relational_expr1_id',
	296,
	0,
	'',
	5452,
	'');
INSERT INTO S_SPARM
	VALUES (5454,
	5448,
	'b2_relational_expr2_id',
	296,
	0,
	'',
	5453,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5455);
INSERT INTO S_SYNC
	VALUES (5455,
	1,
	'Conjunction_end',
	'ParserValidateFunction: TRUE',
	'return param.a4_rule_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5456,
	5455,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5457,
	5455,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5456,
	'');
INSERT INTO S_SPARM
	VALUES (5458,
	5455,
	'a3_rule_begin_id',
	296,
	0,
	'',
	5457,
	'');
INSERT INTO S_SPARM
	VALUES (5459,
	5455,
	'a4_rule_id',
	296,
	0,
	'',
	5458,
	'');
INSERT INTO S_SPARM
	VALUES (5460,
	5455,
	'b1_relational_expr1_id',
	296,
	0,
	'',
	5459,
	'');
INSERT INTO S_SPARM
	VALUES (5461,
	5455,
	'b2_relational_expr2_id',
	296,
	0,
	'',
	5460,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5462);
INSERT INTO S_SYNC
	VALUES (5462,
	1,
	'Relational_expr_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;

',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5463,
	5462,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5464);
INSERT INTO S_SYNC
	VALUES (5464,
	1,
	'Addition_validate',
	'ParserValidateFunction: TRUE',
	'return param.a6_current_rule_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5465,
	5464,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5466,
	5464,
	'a3_text',
	322,
	0,
	'',
	5465,
	'');
INSERT INTO S_SPARM
	VALUES (5467,
	5464,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5466,
	'');
INSERT INTO S_SPARM
	VALUES (5468,
	5464,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5467,
	'');
INSERT INTO S_SPARM
	VALUES (5469,
	5464,
	'a6_current_rule_id',
	296,
	0,
	'',
	5468,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5470);
INSERT INTO S_SYNC
	VALUES (5470,
	1,
	'Comparison_operator_validate',
	'ParserValidateFunction: TRUE',
	'
return ::binary_operator_create( a1_text: param.a3_text, a2_dt_name: "boolean" );










































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5471,
	5470,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5472,
	5470,
	'a3_text',
	322,
	0,
	'',
	5471,
	'');
INSERT INTO S_SPARM
	VALUES (5473,
	5470,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5472,
	'');
INSERT INTO S_SPARM
	VALUES (5474,
	5470,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5473,
	'');
INSERT INTO S_SPARM
	VALUES (5475,
	5470,
	'a6_current_rule_id',
	296,
	0,
	'',
	5474,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5476);
INSERT INTO S_SYNC
	VALUES (5476,
	1,
	'Relational_expr_end',
	'ParserValidateFunction: TRUE',
	'if ( param.b2_comparison_operator2_id != GD::NULL_UNIQUE_ID() )

  return  ::binary_operation_validate( a1_left_op: param.b1_addition1_id, 
              a2_operator: param.b2_comparison_operator2_id, 
              a3_right_op: param.b3_addition3_id, 
              a4_op_type: "relational expression",
              a5_set_dt: FALSE, a6_rule_token: param.a1_rule_token, a7_rule_id:param.a4_rule_id );

end if;

return param.a4_rule_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5477,
	5476,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5478,
	5476,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5477,
	'');
INSERT INTO S_SPARM
	VALUES (5479,
	5476,
	'a3_rule_begin_id',
	296,
	0,
	'',
	5478,
	'');
INSERT INTO S_SPARM
	VALUES (5480,
	5476,
	'a4_rule_id',
	296,
	0,
	'',
	5479,
	'');
INSERT INTO S_SPARM
	VALUES (5481,
	5476,
	'b1_addition1_id',
	296,
	0,
	'',
	5480,
	'');
INSERT INTO S_SPARM
	VALUES (5482,
	5476,
	'b2_comparison_operator2_id',
	296,
	0,
	'',
	5481,
	'');
INSERT INTO S_SPARM
	VALUES (5483,
	5476,
	'b3_addition3_id',
	296,
	0,
	'',
	5482,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5484);
INSERT INTO S_SYNC
	VALUES (5484,
	1,
	'Addition_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;



',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5485,
	5484,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5486);
INSERT INTO S_SYNC
	VALUES (5486,
	1,
	'Multiplication_validate',
	'ParserValidateFunction: TRUE',
	'return param.a6_current_rule_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5487,
	5486,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5488,
	5486,
	'a3_text',
	322,
	0,
	'',
	5487,
	'');
INSERT INTO S_SPARM
	VALUES (5489,
	5486,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5488,
	'');
INSERT INTO S_SPARM
	VALUES (5490,
	5486,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5489,
	'');
INSERT INTO S_SPARM
	VALUES (5491,
	5486,
	'a6_current_rule_id',
	296,
	0,
	'',
	5490,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5492);
INSERT INTO S_SYNC
	VALUES (5492,
	1,
	'Addition_loop9_start',
	'ParserValidateFunction: TRUE',
	'return param.a2_rule_begin_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5493,
	5492,
	'a1_upper_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5494,
	5492,
	'a2_rule_begin_id',
	296,
	0,
	'',
	5493,
	'');
INSERT INTO S_SPARM
	VALUES (5495,
	5492,
	'a3_current_rule_id',
	296,
	0,
	'',
	5494,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5496);
INSERT INTO S_SYNC
	VALUES (5496,
	1,
	'Plus_or_minus_validate',
	'ParserValidateFunction: TRUE',
	'
return ::binary_operator_create( a1_text: param.a3_text, a2_dt_name: "" );











































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5497,
	5496,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5498,
	5496,
	'a3_text',
	322,
	0,
	'',
	5497,
	'');
INSERT INTO S_SPARM
	VALUES (5499,
	5496,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5498,
	'');
INSERT INTO S_SPARM
	VALUES (5500,
	5496,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5499,
	'');
INSERT INTO S_SPARM
	VALUES (5501,
	5496,
	'a6_current_rule_id',
	296,
	0,
	'',
	5500,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5502);
INSERT INTO S_SYNC
	VALUES (5502,
	1,
	'Addition_loop9_end',
	'ParserValidateFunction: TRUE',
	'if (param.b2_plus_or_minus2_id != GD::NULL_UNIQUE_ID() )
  lhs_id = param.b1_multiplication1_id;
  if ( param.a3_ruleid_name != param.b1_multiplication1_id )
    lhs_id = param.a3_ruleid_name;
  end if;
  return  ::binary_operation_validate( a1_left_op: lhs_id, 
              a2_operator: param.b2_plus_or_minus2_id, 
              a3_right_op: param.b3_multiplication3_id, 
              a4_op_type: "addition expression",
              a5_set_dt: TRUE, a6_rule_token: param.a1_rule_token, a7_rule_id:param.a3_ruleid_name );

end if;
return param.a3_ruleid_name;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5503,
	5502,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5504,
	5502,
	'a2_upper_ruleid_name',
	296,
	0,
	'',
	5503,
	'');
INSERT INTO S_SPARM
	VALUES (5505,
	5502,
	'a3_ruleid_name',
	296,
	0,
	'',
	5504,
	'');
INSERT INTO S_SPARM
	VALUES (5506,
	5502,
	'a4_loop_id_name',
	296,
	0,
	'',
	5505,
	'');
INSERT INTO S_SPARM
	VALUES (5507,
	5502,
	'b1_multiplication1_id',
	296,
	0,
	'',
	5506,
	'');
INSERT INTO S_SPARM
	VALUES (5508,
	5502,
	'b2_plus_or_minus2_id',
	296,
	0,
	'',
	5507,
	'');
INSERT INTO S_SPARM
	VALUES (5509,
	5502,
	'b3_multiplication3_id',
	296,
	0,
	'',
	5508,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5510);
INSERT INTO S_SYNC
	VALUES (5510,
	1,
	'Addition_end',
	'ParserValidateFunction: TRUE',
	'
return param.a4_rule_id;









































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5511,
	5510,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5512,
	5510,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5511,
	'');
INSERT INTO S_SPARM
	VALUES (5513,
	5510,
	'a3_rule_begin_id',
	296,
	0,
	'',
	5512,
	'');
INSERT INTO S_SPARM
	VALUES (5514,
	5510,
	'a4_rule_id',
	296,
	0,
	'',
	5513,
	'');
INSERT INTO S_SPARM
	VALUES (5515,
	5510,
	'b1_multiplication1_id',
	296,
	0,
	'',
	5514,
	'');
INSERT INTO S_SPARM
	VALUES (5516,
	5510,
	'b2_plus_or_minus2_id',
	296,
	0,
	'',
	5515,
	'');
INSERT INTO S_SPARM
	VALUES (5517,
	5510,
	'b3_multiplication3_id',
	296,
	0,
	'',
	5516,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5518);
INSERT INTO S_SYNC
	VALUES (5518,
	1,
	'Multiplication_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5519,
	5518,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5520);
INSERT INTO S_SYNC
	VALUES (5520,
	1,
	'Boolean_negation_validate',
	'ParserValidateFunction: TRUE',
	'
return ::unary_operation_validate( a1_rule_token: param.a1_rule_token, 
    a2_op_type: "boolean negation", a3_op_dt_name: "boolean",
    a4_dt_name: "boolean", a5_val_id: param.a6_current_rule_id,
    a6_text: "not", a7_rule_id: param.a6_current_rule_id );













































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5521,
	5520,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5522,
	5520,
	'a3_text',
	322,
	0,
	'',
	5521,
	'');
INSERT INTO S_SPARM
	VALUES (5523,
	5520,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5522,
	'');
INSERT INTO S_SPARM
	VALUES (5524,
	5520,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5523,
	'');
INSERT INTO S_SPARM
	VALUES (5525,
	5520,
	'a6_current_rule_id',
	296,
	0,
	'',
	5524,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5526);
INSERT INTO S_SYNC
	VALUES (5526,
	1,
	'Sign_expr_validate',
	'ParserValidateFunction: TRUE',
	'return param.a6_current_rule_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5527,
	5526,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5528,
	5526,
	'a3_text',
	322,
	0,
	'',
	5527,
	'');
INSERT INTO S_SPARM
	VALUES (5529,
	5526,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5528,
	'');
INSERT INTO S_SPARM
	VALUES (5530,
	5526,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5529,
	'');
INSERT INTO S_SPARM
	VALUES (5531,
	5526,
	'a6_current_rule_id',
	296,
	0,
	'',
	5530,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5532);
INSERT INTO S_SYNC
	VALUES (5532,
	1,
	'Multiplication_loop10_start',
	'ParserValidateFunction: TRUE',
	'return param.a2_rule_begin_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5533,
	5532,
	'a1_upper_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5534,
	5532,
	'a2_rule_begin_id',
	296,
	0,
	'',
	5533,
	'');
INSERT INTO S_SPARM
	VALUES (5535,
	5532,
	'a3_current_rule_id',
	296,
	0,
	'',
	5534,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5536);
INSERT INTO S_SYNC
	VALUES (5536,
	1,
	'Mult_op_validate',
	'ParserValidateFunction: TRUE',
	'
return ::binary_operator_create( a1_text: param.a3_text, a2_dt_name: "" );










































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5537,
	5536,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5538,
	5536,
	'a3_text',
	322,
	0,
	'',
	5537,
	'');
INSERT INTO S_SPARM
	VALUES (5539,
	5536,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5538,
	'');
INSERT INTO S_SPARM
	VALUES (5540,
	5536,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5539,
	'');
INSERT INTO S_SPARM
	VALUES (5541,
	5536,
	'a6_current_rule_id',
	296,
	0,
	'',
	5540,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5542);
INSERT INTO S_SYNC
	VALUES (5542,
	1,
	'Multiplication_loop10_end',
	'ParserValidateFunction: TRUE',
	'if (param.b3_mult_op3_id != GD::NULL_UNIQUE_ID() )
  lhs_id = param.b2_sign_expr2_id;
  if ( param.a3_ruleid_name != param.b2_sign_expr2_id )
    lhs_id = param.a3_ruleid_name;
  end if;
  return  ::binary_operation_validate( a1_left_op: lhs_id, 
              a2_operator: param.b3_mult_op3_id, 
              a3_right_op: param.b4_sign_expr4_id, 
              a4_op_type: "multiplication expression",
              a5_set_dt: TRUE, a6_rule_token: param.a1_rule_token, a7_rule_id:param.a3_ruleid_name );

end if;
return param.a3_ruleid_name;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5543,
	5542,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5544,
	5542,
	'a2_upper_ruleid_name',
	296,
	0,
	'',
	5543,
	'');
INSERT INTO S_SPARM
	VALUES (5545,
	5542,
	'a3_ruleid_name',
	296,
	0,
	'',
	5544,
	'');
INSERT INTO S_SPARM
	VALUES (5546,
	5542,
	'a4_loop_id_name',
	296,
	0,
	'',
	5545,
	'');
INSERT INTO S_SPARM
	VALUES (5547,
	5542,
	'b1_boolean_negation1_id',
	296,
	0,
	'',
	5546,
	'');
INSERT INTO S_SPARM
	VALUES (5548,
	5542,
	'b2_sign_expr2_id',
	296,
	0,
	'',
	5547,
	'');
INSERT INTO S_SPARM
	VALUES (5549,
	5542,
	'b3_mult_op3_id',
	296,
	0,
	'',
	5548,
	'');
INSERT INTO S_SPARM
	VALUES (5550,
	5542,
	'b4_sign_expr4_id',
	296,
	0,
	'',
	5549,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5551);
INSERT INTO S_SYNC
	VALUES (5551,
	1,
	'Multiplication_end',
	'ParserValidateFunction: TRUE',
	'return param.a4_rule_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5552,
	5551,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5553,
	5551,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5552,
	'');
INSERT INTO S_SPARM
	VALUES (5554,
	5551,
	'a3_rule_begin_id',
	296,
	0,
	'',
	5553,
	'');
INSERT INTO S_SPARM
	VALUES (5555,
	5551,
	'a4_rule_id',
	296,
	0,
	'',
	5554,
	'');
INSERT INTO S_SPARM
	VALUES (5556,
	5551,
	'b1_boolean_negation1_id',
	296,
	0,
	'',
	5555,
	'');
INSERT INTO S_SPARM
	VALUES (5557,
	5551,
	'b2_sign_expr2_id',
	296,
	0,
	'',
	5556,
	'');
INSERT INTO S_SPARM
	VALUES (5558,
	5551,
	'b3_mult_op3_id',
	296,
	0,
	'',
	5557,
	'');
INSERT INTO S_SPARM
	VALUES (5559,
	5551,
	'b4_sign_expr4_id',
	296,
	0,
	'',
	5558,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5560);
INSERT INTO S_SYNC
	VALUES (5560,
	1,
	'Sign_expr_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5561,
	5560,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5562);
INSERT INTO S_SYNC
	VALUES (5562,
	1,
	'Term_validate',
	'ParserValidateFunction: TRUE',
	'return param.a6_current_rule_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5563,
	5562,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5564,
	5562,
	'a3_text',
	322,
	0,
	'',
	5563,
	'');
INSERT INTO S_SPARM
	VALUES (5565,
	5562,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5564,
	'');
INSERT INTO S_SPARM
	VALUES (5566,
	5562,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5565,
	'');
INSERT INTO S_SPARM
	VALUES (5567,
	5562,
	'a6_current_rule_id',
	296,
	0,
	'',
	5566,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5568);
INSERT INTO S_SYNC
	VALUES (5568,
	1,
	'Sign_expr_end',
	'ParserValidateFunction: TRUE',
	'
if ( param.b1_plus_or_minus1_id != GD::NULL_UNIQUE_ID() )
  select any val from instances of V_VAL 
    where ( selected.Value_ID == param.b1_plus_or_minus1_id );
  select one bin related by val->V_BIN[R801];

  select any operand from instances of V_VAL 
        where ( selected.Value_ID == param.b2_term2_id );
  if ( empty operand  )
    val.dispose();
    ERR::reportParseError( msg: "Operand not found for unary" + bin.Operator,
        token: param.a1_rule_token );
  else
    select one op_dt related by operand->S_DT[R820];
    if ( empty op_dt )
      val.dispose();
      operand.dispose();
      ERR::reportParseError( msg: "Operand for unary "+bin.Operator+"  has unknown data type.",
            token: param.a1_rule_token );
    else
      select one op_udt related by op_dt->S_UDT[R17];
      if ( not_empty op_udt )
        core_id = op_udt.getCoreType();
        select any op_dt_pe from instances of PE_PE
                                       where (selected.Element_ID == core_id);
        select one op_dt related by op_dt_pe->S_DT[R8001];
      end if;
      if ( op_dt.Name != "integer" and op_dt.Name != "real" )
        val.dispose();
        operand.dispose();
        ERR::reportParseError( msg: "Incompatible operand for unary " + bin.Operator,
              token: param.a1_rule_token );
      else
        // migrate to unary op
        create object instance u of V_UNY;
        u.Operator = bin.Operator;
        unrelate bin from val across R801;
        bin.dispose();
        relate val to op_dt across R820;
        relate val to u across R801;
        relate u to operand across R804;
        return val.Value_ID;
      end if;
    end if;
  end if;
end if;
return param.a4_rule_id;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5569,
	5568,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5570,
	5568,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5569,
	'');
INSERT INTO S_SPARM
	VALUES (5571,
	5568,
	'a3_rule_begin_id',
	296,
	0,
	'',
	5570,
	'');
INSERT INTO S_SPARM
	VALUES (5572,
	5568,
	'a4_rule_id',
	296,
	0,
	'',
	5571,
	'');
INSERT INTO S_SPARM
	VALUES (5573,
	5568,
	'b1_plus_or_minus1_id',
	296,
	0,
	'',
	5572,
	'');
INSERT INTO S_SPARM
	VALUES (5574,
	5568,
	'b2_term2_id',
	296,
	0,
	'',
	5573,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5575);
INSERT INTO S_SYNC
	VALUES (5575,
	1,
	'Term_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5576,
	5575,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5577);
INSERT INTO S_SYNC
	VALUES (5577,
	1,
	'Cardinality_op_validate',
	'ParserValidateFunction: TRUE',
	'return param.a6_current_rule_id;


































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5578,
	5577,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5579,
	5577,
	'a3_text',
	322,
	0,
	'',
	5578,
	'');
INSERT INTO S_SPARM
	VALUES (5580,
	5577,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5579,
	'');
INSERT INTO S_SPARM
	VALUES (5581,
	5577,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5580,
	'');
INSERT INTO S_SPARM
	VALUES (5582,
	5577,
	'a6_current_rule_id',
	296,
	0,
	'',
	5581,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5583);
INSERT INTO S_SYNC
	VALUES (5583,
	1,
	'Empty_op_validate',
	'ParserValidateFunction: TRUE',
	'return param.a6_current_rule_id;

































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5584,
	5583,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5585,
	5583,
	'a3_text',
	322,
	0,
	'',
	5584,
	'');
INSERT INTO S_SPARM
	VALUES (5586,
	5583,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5585,
	'');
INSERT INTO S_SPARM
	VALUES (5587,
	5583,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5586,
	'');
INSERT INTO S_SPARM
	VALUES (5588,
	5583,
	'a6_current_rule_id',
	296,
	0,
	'',
	5587,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5589);
INSERT INTO S_SYNC
	VALUES (5589,
	1,
	'Not_empty_op_validate',
	'ParserValidateFunction: TRUE',
	'return param.a6_current_rule_id;

































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5590,
	5589,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5591,
	5589,
	'a3_text',
	322,
	0,
	'',
	5590,
	'');
INSERT INTO S_SPARM
	VALUES (5592,
	5589,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5591,
	'');
INSERT INTO S_SPARM
	VALUES (5593,
	5589,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5592,
	'');
INSERT INTO S_SPARM
	VALUES (5594,
	5589,
	'a6_current_rule_id',
	296,
	0,
	'',
	5593,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5595);
INSERT INTO S_SYNC
	VALUES (5595,
	1,
	'Rval_validate',
	'ParserValidateFunction: TRUE',
	'// Get the block that is currently being parsed
current_scope = ::get_current_scope();
select any block from instances of ACT_BLK where (selected.Block_ID == current_scope);

allowOps = PREF::getBoolean( name:"bridgepoint_prefs_allow_operations_in_where" );

// Now we check for elements that are illegal inside a select...where... clause
if ( (allowOps == false ) and (block.InWhereSpec == true) ) 
  // Get the value instance out of this block that we are currently validating
  select any val related by block->V_VAL[R826] where ( selected.Value_ID == param.a4_rule_ref_id );
  if ( empty val )
    // an error has already been output and the value has been cleaned up
    return GD::NULL_UNIQUE_ID();
  end if;

  // If we get here, the value is part of a where clause, so check for disallowed actions
  select one fnv related by val->V_FNV[R801];  // Function Value
  select one trv related by val->V_TRV[R801];  // Operation Value
  select one msv related by val->V_MSV[R801];  // Message Value
  select one brv related by val->V_BRV[R801];  // Bridge Value
  select one avl related by val->V_AVL[R801];  // Attribute Value Reference

  if ( not_empty fnv )
    ERR::reportParseError( 
      msg: "Function calls are not allowed inside a where condition.", 
      token: param.a1_rule_token );
  elif ( not_empty trv )
    ERR::reportParseError( 
      msg: "Operation calls are not allowed inside a where condition.", 
      token: param.a1_rule_token );
  elif ( not_empty msv )
    ERR::reportParseError( 
      msg: "Message calls are not allowed inside a where condition.", 
      token: param.a1_rule_token );
  elif ( not_empty brv )
    ERR::reportParseError( 
      msg: "Bridge calls are not allowed inside a where condition.", 
      token: param.a1_rule_token );
  elif ( not_empty avl )
    select one dbattr related by avl->O_ATTR[R806]->O_BATTR[R106]->O_DBATTR[R107];
    if ( not_empty dbattr )
      ERR::reportParseError( 
        msg: "Accessing a derived base attribute value is not allowed inside a where condition.", 
        token: param.a1_rule_token );
    end if;
  end if;
end if;

return param.a6_current_rule_id;







































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5596,
	5595,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5597,
	5595,
	'a3_text',
	322,
	0,
	'',
	5596,
	'');
INSERT INTO S_SPARM
	VALUES (5598,
	5595,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5597,
	'');
INSERT INTO S_SPARM
	VALUES (5599,
	5595,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5598,
	'');
INSERT INTO S_SPARM
	VALUES (5600,
	5595,
	'a6_current_rule_id',
	296,
	0,
	'',
	5599,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5601);
INSERT INTO S_SYNC
	VALUES (5601,
	1,
	'Term_end',
	'ParserValidateFunction: TRUE',
	'if ( param.b1_cardinality_op1_id != GD::NULL_UNIQUE_ID() )
  return param.b1_cardinality_op1_id;
end if;

if ( param.b2_empty_op2_id != GD::NULL_UNIQUE_ID() )
  // create unary op for empty
  return param.b2_empty_op2_id;
end if;

if ( param.b3_not_empty_op3_id != GD::NULL_UNIQUE_ID() )
  // create unary op for not_empty
  return param.b3_not_empty_op3_id;
end if;

return param.a4_rule_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5602,
	5601,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5603,
	5601,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5602,
	'');
INSERT INTO S_SPARM
	VALUES (5604,
	5601,
	'a3_rule_begin_id',
	296,
	0,
	'',
	5603,
	'');
INSERT INTO S_SPARM
	VALUES (5605,
	5601,
	'a4_rule_id',
	296,
	0,
	'',
	5604,
	'');
INSERT INTO S_SPARM
	VALUES (5606,
	5601,
	'b1_cardinality_op1_id',
	296,
	0,
	'',
	5605,
	'');
INSERT INTO S_SPARM
	VALUES (5607,
	5601,
	'b2_empty_op2_id',
	296,
	0,
	'',
	5606,
	'');
INSERT INTO S_SPARM
	VALUES (5608,
	5601,
	'b3_not_empty_op3_id',
	296,
	0,
	'',
	5607,
	'');
INSERT INTO S_SPARM
	VALUES (5609,
	5601,
	'b4_rval4_id',
	296,
	0,
	'',
	5608,
	'');
INSERT INTO S_SPARM
	VALUES (5610,
	5601,
	'b5_assignment_expr5_id',
	296,
	0,
	'',
	5609,
	'');
INSERT INTO S_SPARM
	VALUES (5611,
	5601,
	'b6_expr6_id',
	296,
	0,
	'',
	5610,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5612);
INSERT INTO S_SYNC
	VALUES (5612,
	1,
	'Cardinality_op_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5613,
	5612,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5614);
INSERT INTO S_SYNC
	VALUES (5614,
	1,
	'Cardinality_op_end',
	'ParserValidateFunction: TRUE',
	'return ::inst_ref_operator_validate( a1_variable_id: param.b1_local_variable1_id,
      a2_operator_name: "cardinality", a3_op_dt: "integer", a4_rule_token: param.a1_rule_token,
      a5_rule_id: param.a4_rule_id );


































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5615,
	5614,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5616,
	5614,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5615,
	'');
INSERT INTO S_SPARM
	VALUES (5617,
	5614,
	'a3_rule_begin_id',
	296,
	0,
	'',
	5616,
	'');
INSERT INTO S_SPARM
	VALUES (5618,
	5614,
	'a4_rule_id',
	296,
	0,
	'',
	5617,
	'');
INSERT INTO S_SPARM
	VALUES (5619,
	5614,
	'b1_local_variable1_id',
	296,
	0,
	'',
	5618,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5620);
INSERT INTO S_SYNC
	VALUES (5620,
	1,
	'Empty_op_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5621,
	5620,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5622);
INSERT INTO S_SYNC
	VALUES (5622,
	1,
	'Empty_op_end',
	'ParserValidateFunction: TRUE',
	'return ::inst_ref_operator_validate( a1_variable_id: param.b1_local_variable1_id,
      a2_operator_name: "empty", a3_op_dt: "boolean", a4_rule_token: param.a1_rule_token,
      a5_rule_id: param.a4_rule_id );

































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5623,
	5622,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5624,
	5622,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5623,
	'');
INSERT INTO S_SPARM
	VALUES (5625,
	5622,
	'a3_rule_begin_id',
	296,
	0,
	'',
	5624,
	'');
INSERT INTO S_SPARM
	VALUES (5626,
	5622,
	'a4_rule_id',
	296,
	0,
	'',
	5625,
	'');
INSERT INTO S_SPARM
	VALUES (5627,
	5622,
	'b1_local_variable1_id',
	296,
	0,
	'',
	5626,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5628);
INSERT INTO S_SYNC
	VALUES (5628,
	1,
	'Not_empty_op_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5629,
	5628,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5630);
INSERT INTO S_SYNC
	VALUES (5630,
	1,
	'Not_empty_op_end',
	'ParserValidateFunction: TRUE',
	'return ::inst_ref_operator_validate( a1_variable_id: param.b1_local_variable1_id,
      a2_operator_name: "not_empty", a3_op_dt: "boolean", a4_rule_token: param.a1_rule_token,
      a5_rule_id: param.a4_rule_id );


































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5631,
	5630,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5632,
	5630,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5631,
	'');
INSERT INTO S_SPARM
	VALUES (5633,
	5630,
	'a3_rule_begin_id',
	296,
	0,
	'',
	5632,
	'');
INSERT INTO S_SPARM
	VALUES (5634,
	5630,
	'a4_rule_id',
	296,
	0,
	'',
	5633,
	'');
INSERT INTO S_SPARM
	VALUES (5635,
	5630,
	'b1_local_variable1_id',
	296,
	0,
	'',
	5634,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5636);
INSERT INTO S_SYNC
	VALUES (5636,
	1,
	'Rval_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5637,
	5636,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5638);
INSERT INTO S_SYNC
	VALUES (5638,
	1,
	'Invocation_expr_validate',
	'ParserValidateFunction: TRUE',
	'return ::Invocation_validate(  a1_rule_token: param.a1_rule_token,
  a2_isRval: true, a3_text: param.a3_text, a4_rule_ref_id: param.a4_rule_ref_id,
  a5_upper_rule_id: param.a5_upper_rule_id, a6_current_rule_id: param.a6_current_rule_id );












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5639,
	5638,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5640,
	5638,
	'a3_text',
	322,
	0,
	'',
	5639,
	'');
INSERT INTO S_SPARM
	VALUES (5641,
	5638,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5640,
	'');
INSERT INTO S_SPARM
	VALUES (5642,
	5638,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5641,
	'');
INSERT INTO S_SPARM
	VALUES (5643,
	5638,
	'a6_current_rule_id',
	296,
	0,
	'',
	5642,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5644);
INSERT INTO S_SYNC
	VALUES (5644,
	1,
	'Enumerator_access_validate',
	'ParserValidateFunction: TRUE',
	'return param.a6_current_rule_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5645,
	5644,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5646,
	5644,
	'a3_text',
	322,
	0,
	'',
	5645,
	'');
INSERT INTO S_SPARM
	VALUES (5647,
	5644,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5646,
	'');
INSERT INTO S_SPARM
	VALUES (5648,
	5644,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5647,
	'');
INSERT INTO S_SPARM
	VALUES (5649,
	5644,
	'a6_current_rule_id',
	296,
	0,
	'',
	5648,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5650);
INSERT INTO S_SYNC
	VALUES (5650,
	1,
	'Constant_value_validate',
	'ParserValidateFunction: TRUE',
	'return param.a6_current_rule_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5651,
	5650,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5652,
	5650,
	'a3_text',
	322,
	0,
	'',
	5651,
	'');
INSERT INTO S_SPARM
	VALUES (5653,
	5650,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5652,
	'');
INSERT INTO S_SPARM
	VALUES (5654,
	5650,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5653,
	'');
INSERT INTO S_SPARM
	VALUES (5655,
	5650,
	'a6_current_rule_id',
	296,
	0,
	'',
	5654,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5656);
INSERT INTO S_SYNC
	VALUES (5656,
	1,
	'Event_data_access_validate',
	'ParserValidateFunction: TRUE',
	'// ::Event_data_access_validate
return param.a6_current_rule_id;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5657,
	5656,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5658,
	5656,
	'a3_text',
	322,
	0,
	'',
	5657,
	'');
INSERT INTO S_SPARM
	VALUES (5659,
	5656,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5658,
	'');
INSERT INTO S_SPARM
	VALUES (5660,
	5656,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5659,
	'');
INSERT INTO S_SPARM
	VALUES (5661,
	5656,
	'a6_current_rule_id',
	296,
	0,
	'',
	5660,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5662);
INSERT INTO S_SYNC
	VALUES (5662,
	1,
	'Bridge_expr_validate',
	'ParserValidateFunction: TRUE',
	'return ::Bridge_invocation_validate(  a1_rule_token: param.a1_rule_token,
  a2_isRval: true, a3_text: param.a3_text, a4_rule_ref_id: param.a4_rule_ref_id,
  a5_upper_rule_id: param.a5_upper_rule_id, a6_current_rule_id: param.a6_current_rule_id );












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5663,
	5662,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5664,
	5662,
	'a3_text',
	322,
	0,
	'',
	5663,
	'');
INSERT INTO S_SPARM
	VALUES (5665,
	5662,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5664,
	'');
INSERT INTO S_SPARM
	VALUES (5666,
	5662,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5665,
	'');
INSERT INTO S_SPARM
	VALUES (5667,
	5662,
	'a6_current_rule_id',
	296,
	0,
	'',
	5666,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5668);
INSERT INTO S_SYNC
	VALUES (5668,
	1,
	'Terminal_tok_qmark_validate',
	'ParserValidateFunction: TRUE',
	'return param.a4_current_rule_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5669,
	5668,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5670,
	5668,
	'a2_text',
	322,
	0,
	'',
	5669,
	'');
INSERT INTO S_SPARM
	VALUES (5671,
	5668,
	'a3_upper_rule_id',
	296,
	0,
	'',
	5670,
	'');
INSERT INTO S_SPARM
	VALUES (5672,
	5668,
	'a4_current_rule_id',
	296,
	0,
	'',
	5671,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5673);
INSERT INTO S_SYNC
	VALUES (5673,
	1,
	'Rval_end',
	'ParserValidateFunction: TRUE',
	'return param.a4_rule_id;












































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5674,
	5673,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5675,
	5673,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5674,
	'');
INSERT INTO S_SPARM
	VALUES (5676,
	5673,
	'a3_rule_begin_id',
	296,
	0,
	'',
	5675,
	'');
INSERT INTO S_SPARM
	VALUES (5677,
	5673,
	'a4_rule_id',
	296,
	0,
	'',
	5676,
	'');
INSERT INTO S_SPARM
	VALUES (5678,
	5673,
	'b1_function_invocation1_id',
	296,
	0,
	'',
	5677,
	'');
INSERT INTO S_SPARM
	VALUES (5679,
	5673,
	'b2_transform_ib_invocation2_id',
	296,
	0,
	'',
	5678,
	'');
INSERT INTO S_SPARM
	VALUES (5680,
	5673,
	'b3_bridge_or_transform_expr3_id',
	296,
	0,
	'',
	5679,
	'');
INSERT INTO S_SPARM
	VALUES (5681,
	5673,
	'b4_enumerator_access4_id',
	296,
	0,
	'',
	5680,
	'');
INSERT INTO S_SPARM
	VALUES (5682,
	5673,
	'b6_constant_value6_id',
	296,
	0,
	'',
	5683,
	'');
INSERT INTO S_SPARM
	VALUES (5684,
	5673,
	'b7_event_data_access7_id',
	296,
	0,
	'',
	5682,
	'');
INSERT INTO S_SPARM
	VALUES (5685,
	5673,
	'b8_bridge_expr8_id',
	296,
	0,
	'',
	5684,
	'');
INSERT INTO S_SPARM
	VALUES (5686,
	5673,
	'b9_param_data_access9_id',
	296,
	0,
	'',
	5685,
	'');
INSERT INTO S_SPARM
	VALUES (5683,
	5673,
	'b5_member_access5_id',
	296,
	0,
	'',
	5681,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5687);
INSERT INTO S_SYNC
	VALUES (5687,
	1,
	'Constant_value_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5688,
	5687,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5689);
INSERT INTO S_SYNC
	VALUES (5689,
	1,
	'Terminal_tok_fraction_validate',
	'ParserValidateFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
create object instance lrl of V_LRL;
lrl.Value = param.a2_text;
create object instance val of V_VAL;
current_scope = ::get_current_scope();
select any blk from instances of ACT_BLK where (selected.Block_ID == current_scope);
relate val to blk across R826;
select any dom from instances of S_DOM where selected.Dom_ID == ::getValidationDomain();
select any dt related by dom->S_DT[R14] where selected.Name == "real";
if empty dt
  cur_sys_name = ::getSystemName();
  select any sys from instances of S_SYS where (selected.Name == cur_sys_name);
  dt_id = GD::NULL_UNIQUE_ID();
  if not_empty sys
    dt_id = sys.getCoreTypeId(name:"real");
  end if;
  select any pe from instances of PE_PE where selected.Element_ID == dt_id;
  select one dt related by pe->S_DT[R8001]; 
end if;
if ( not_empty dt )
  relate val to dt across R820;
else
  USER::logError(msg: "Internal Error in OAL Validation Function " +
    "Terminal_tok_fraction_validate().  Variable <dt> is empty.",path:"PathNotProvided");
end if;
relate val to lrl across R801;
val.LineNumber = ::getLineNumber(rule_token: param.a1_rule_token);
val.StartPosition = ::getColumn(rule_token: param.a1_rule_token);
val.setEndPosition();
return val.Value_ID;













































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5690,
	5689,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5691,
	5689,
	'a2_text',
	322,
	0,
	'',
	5690,
	'');
INSERT INTO S_SPARM
	VALUES (5692,
	5689,
	'a3_upper_rule_id',
	296,
	0,
	'',
	5691,
	'');
INSERT INTO S_SPARM
	VALUES (5693,
	5689,
	'a4_current_rule_id',
	296,
	0,
	'',
	5692,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5694);
INSERT INTO S_SYNC
	VALUES (5694,
	1,
	'Terminal_tok_number_validate',
	'ParserValidateFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
create object instance lin of V_LIN;
lin.Value = param.a2_text;
create object instance val of V_VAL;
current_scope = ::get_current_scope();
select any blk from instances of ACT_BLK where (selected.Block_ID == current_scope);
relate val to blk across R826;
select any dom from instances of S_DOM where selected.Dom_ID == ::getValidationDomain();
select any dt related by dom->S_DT[R14] where selected.Name == "integer";
if empty dt
  cur_sys_name = ::getSystemName();
  select any sys from instances of S_SYS where selected.Name == cur_sys_name;
  dt_id = GD::NULL_UNIQUE_ID();
  if not_empty sys
    dt_id = sys.getCoreTypeId(name:"integer");
  end if;
  select any pe from instances of PE_PE where selected.Element_ID == dt_id;
  select one dt related by pe->S_DT[R8001]; 
end if;
if ( not_empty dt )
  relate val to dt across R820;
else
  USER::logError(msg: "Internal Error in OAL Validation Function " +
    "Terminal_tok_number_validate().  Variable <dt> is empty.",path:"PathNotProvided");
end if;
relate val to lin across R801;
val.LineNumber = ::getLineNumber(rule_token: param.a1_rule_token);
val.StartPosition = ::getColumn(rule_token: param.a1_rule_token);
val.setEndPosition();
return val.Value_ID;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5695,
	5694,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5696,
	5694,
	'a2_text',
	322,
	0,
	'',
	5695,
	'');
INSERT INTO S_SPARM
	VALUES (5697,
	5694,
	'a3_upper_rule_id',
	296,
	0,
	'',
	5696,
	'');
INSERT INTO S_SPARM
	VALUES (5698,
	5694,
	'a4_current_rule_id',
	296,
	0,
	'',
	5697,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5699);
INSERT INTO S_SYNC
	VALUES (5699,
	1,
	'Terminal_tok_string_validate',
	'ParserValidateFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
create object instance lst of V_LST;
lst.Value = lst.removeQuotes(s: param.a2_text);
create object instance val of V_VAL;
current_scope = ::get_current_scope();
select any blk from instances of ACT_BLK where (selected.Block_ID == current_scope);
relate val to blk across R826;
select any dom from instances of S_DOM where selected.Dom_ID == ::getValidationDomain();
select any dt related by dom->S_DT[R14] where selected.Name == "string";
if empty dt
  cur_sys_name = ::getSystemName();
  select any sys from instances of S_SYS where selected.Name == cur_sys_name;
  dt_id = GD::NULL_UNIQUE_ID();
  if not_empty sys
    dt_id = sys.getCoreTypeId(name:"string");
  end if;
  select any pe from instances of PE_PE where selected.Element_ID == dt_id;
  select one dt related by pe->S_DT[R8001]; 
end if;
if ( not_empty dt )
  relate val to dt across R820;
else
  USER::logError(msg: "Internal Error in OAL Validation Function " +
    "Terminal_tok_string_validate().  Variable <dt> is empty.",path:"PathNotProvided");
end if;
relate val to lst across R801;
val.LineNumber = ::getLineNumber(rule_token: param.a1_rule_token);
val.StartPosition = ::getColumn(rule_token: param.a1_rule_token);
val.setEndPosition();
return val.Value_ID;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5700,
	5699,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5701,
	5699,
	'a2_text',
	322,
	0,
	'',
	5700,
	'');
INSERT INTO S_SPARM
	VALUES (5702,
	5699,
	'a3_upper_rule_id',
	296,
	0,
	'',
	5701,
	'');
INSERT INTO S_SPARM
	VALUES (5703,
	5699,
	'a4_current_rule_id',
	296,
	0,
	'',
	5702,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5704);
INSERT INTO S_SYNC
	VALUES (5704,
	1,
	'String_literal_true_validate',
	'ParserValidateFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
create object instance lbo of V_LBO;
lbo.Value = "TRUE";

create object instance val of V_VAL;
current_scope = ::get_current_scope();
select any blk from instances of ACT_BLK where (selected.Block_ID == current_scope);
relate val to blk across R826;
select any dom from instances of S_DOM where selected.Dom_ID == ::getValidationDomain();
select any dt related by dom->S_DT[R14] where selected.Name == "boolean";
if empty dt
  cur_sys_name = ::getSystemName();
  select any sys from instances of S_SYS where selected.Name == cur_sys_name;
  dt_id = GD::NULL_UNIQUE_ID();
  if not_empty sys
    dt_id = sys.getCoreTypeId(name:"boolean");
  end if;
  select any pe from instances of PE_PE where selected.Element_ID == dt_id;
  select one dt related by pe->S_DT[R8001]; 
end if;
if ( not_empty dt )
  relate val to dt across R820;
else
  USER::logError(msg: "Internal Error in OAL Validation Function " +
    "String_literal_true_validate().  Variable <dt> is empty.",path:"PathNotProvided");
end if;

relate val to lbo across R801;

return val.Value_ID;
',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5705,
	5704,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5706,
	5704,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5705,
	'');
INSERT INTO S_SPARM
	VALUES (5707,
	5704,
	'a3_current_rule_id',
	296,
	0,
	'',
	5706,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5708);
INSERT INTO S_SYNC
	VALUES (5708,
	1,
	'String_literal_false_validate',
	'ParserValidateFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
create object instance lbo of V_LBO;
lbo.Value = "FALSE";

create object instance val of V_VAL;
current_scope = ::get_current_scope();
select any blk from instances of ACT_BLK where (selected.Block_ID == current_scope);
relate val to blk across R826;
select any dom from instances of S_DOM where selected.Dom_ID == ::getValidationDomain();
select any dt related by dom->S_DT[R14] where selected.Name == "boolean";
if empty dt
  cur_sys_name = ::getSystemName();
  select any sys from instances of S_SYS where selected.Name == cur_sys_name;
  dt_id = GD::NULL_UNIQUE_ID();
  if not_empty sys
    dt_id = sys.getCoreTypeId(name:"boolean");
  end if;
  select any pe from instances of PE_PE where selected.Element_ID == dt_id;
  select one dt related by pe->S_DT[R8001]; 
end if;
if ( not_empty dt )
  relate val to dt across R820;
else
  USER::logError(msg: "Internal Error in OAL Validation Function " +
    "String_literal_false_validate().  Variable <dt> is empty.",path:"PathNotProvided");
end if;

relate val to lbo across R801;

return val.Value_ID;













































































































',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5709,
	5708,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5710,
	5708,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5709,
	'');
INSERT INTO S_SPARM
	VALUES (5711,
	5708,
	'a3_current_rule_id',
	296,
	0,
	'',
	5710,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5712);
INSERT INTO S_SYNC
	VALUES (5712,
	1,
	'Constant_value_end',
	'ParserValidateFunction: TRUE',
	'return param.a4_rule_id;

',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5713,
	5712,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5714,
	5712,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5713,
	'');
INSERT INTO S_SPARM
	VALUES (5715,
	5712,
	'a3_rule_begin_id',
	296,
	0,
	'',
	5714,
	'');
INSERT INTO S_SPARM
	VALUES (5716,
	5712,
	'a4_rule_id',
	296,
	0,
	'',
	5715,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5717);
INSERT INTO S_SYNC
	VALUES (5717,
	1,
	'Member_access_end',
	'ParserValidateFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// ::Member_access_end()
if ( param.b1_root_inst_access_id == GD::NULL_UNIQUE_ID())
  // There is no field, dispose incompletely created value instances . . .
  ::clear_value_data();
  // ... and report an error
  select any val from instances of V_VAL where
                              selected.Value_ID == param.b1_root_inst_access_id;
  if ( not_empty val )
    select one obj related by val->V_IRF[R801]->V_VAR[R808]->
                                                       V_INT[R814]->O_OBJ[R818];
    if ( not_empty obj )
      ERR::reportParseError( msg: "Field %s not found for class " + obj.Name,
                                                   token: param.a1_rule_token );
    else
      ERR::reportParseError( msg: "Field %s not found for class",
                                                   token: param.a1_rule_token );
    end if;
  else
    ERR::reportParseError( msg: "Field %s not found for class",
                                                   token: param.a1_rule_token );
  end if;
else
  current_scope = ::get_current_scope();
  if ( current_scope == GD::NULL_UNIQUE_ID() )
    ERR::reportParseError( msg: "Internal Error: Unable to determine " +
             "context to define variable ->%s<-.", token: param.a1_rule_token );
  else
    select any block from instances of ACT_BLK where
                                             selected.Block_ID == current_scope;
    // This code is a close copy of what is in Member_access_loop11_end.
    // Need to look and see if this can be refactored.
    select any dom from instances of S_DOM where selected.Dom_ID == ::getValidationDomain();
    select any instRefDt related by dom->S_DT[R14] where
                                            selected.Name == "inst_ref<Object>";
    if empty instRefDt
      cur_sys_name = ::getSystemName();
      select any sys from instances of S_SYS where selected.Name == cur_sys_name;
      dt_id = GD::NULL_UNIQUE_ID();
      if not_empty sys
        dt_id = sys.getCoreTypeId(name:"inst_ref<Object>");
      end if;
      select any pe from instances of PE_PE where selected.Element_ID == dt_id;
      select one instRefDt related by pe->S_DT[R8001];
    end if;
    if empty instRefDt
      USER::logError(msg: "Internal Error in OAL Validation " +
        "Member_access_end().  Variable <instRefDt> is empty.",path:"PathNotProvided");
    end if;
    select any rootVal from instances of V_VAL where
                              selected.Value_ID == param.b1_root_inst_access_id;
    if (not_empty rootVal)
      name = rootVal.Text;
      if (not rootVal.hasSubtype())
        if (::constant_validate(a1_name:name, a2_ruleToken:param.a1_rule_token,
          a3_reportError:false, a4_valID:rootVal.Value_ID) != GD::NULL_UNIQUE_ID())
          return rootVal.Value_ID;
        end if;
        // Initialize the root value instance
        ::self_validate(a1_text: name,
                     a2_isLval:rootVal.isLValue, a3_token: param.a1_rule_token);
        ::sender_validate( a1_name: name, a2_isLval: rootVal.isLValue,
                                                a3_token: param.a1_rule_token );
        if ( ::selected_validate( name: name, rule_token: param.a1_rule_token ))
          // selected is always an r-value
          block.SelectedFound = true;
          create object instance slr of V_SLR;
          relate slr to rootVal across R801;
          relate rootVal to instRefDt across R820;
          relate rootVal to block across R826;
          return rootVal.Value_ID;
        end if;
        // Is the root value an argument ?
        select any parmVal from instances of V_PVL where
                                    selected.Value_ID == param.a2_upper_rule_id;
        select one preCreatedVal related by parmVal->V_VAL[R801];
        select any evtVal from instances of V_EDV where
                                    selected.Value_ID == param.a2_upper_rule_id;
        if not_empty evtVal
          select one preCreatedVal related by evtVal->V_VAL[R801];
        end if;
        if not_empty parmVal and preCreatedVal.Text == ""
          unrelate preCreatedVal from parmVal across R801;
          preCreatedVal.dispose();
          relate rootVal to parmVal across R801;
          ::param_root_value_validate(a1_name:name, a2_token:param.a1_rule_token,
                           a3_value_id: rootVal.Value_ID, a4_isRootAccess:true);
        elif not_empty evtVal and preCreatedVal.Text == ""
          unrelate preCreatedVal from evtVal across R801;
          preCreatedVal.dispose();
          relate rootVal to evtVal across R801;
              ::event_root_value_validate(name:name,
                         token:param.a1_rule_token, value_id: rootVal.Value_ID);
        else
          var_id = ::get_var_in_scope(name: name,
                                               rule_token: param.a1_rule_token);
          select any varInst from instances of V_VAR where
                                                      selected.Var_ID == var_id;
          if empty varInst
            // We didn''''t see this value before in this action
            if not rootVal.isLValue
              // We''''re reading from it - Error
              ::clear_value_data();
              ERR::reportParseError( msg: "Variable ->%s<- used in " +
                                    "context where it must already exist.",
                                                   token: param.a1_rule_token );
            else
              // We''''re writing it
              // Create variable implicitly
              current_scope = ::get_current_scope();
              if current_scope == GD::NULL_UNIQUE_ID()
                ::clear_value_data();
                ERR::reportParseError( msg: "Internal Error: Unable to " +
                              "determine context to define variable ->%s<-.",
                                                   token: param.a1_rule_token );
              else
                select any block from instances of ACT_BLK where
                                             selected.Block_ID == current_scope;
                create object instance trn of V_TRN;
                create object instance varInst of V_VAR;
                varInst.Name = name;
                relate trn to varInst across R814;
                relate varInst to block across R823;
                var_id = varInst.Var_ID;
                rootVal.isImplicit = true;
              end if;
            end if;
          end if;
          if (not_empty varInst)
            varInst.addLocation(line: rootVal.LineNumber,
                                                    col: rootVal.StartPosition);
            if not rootVal.hasSubtype()
              // We''''re now ready to establish the Value subtype
              select one inst related by varInst->V_INT[R814];
              select one instSet related by varInst->V_INS[R814];
              select one tran related by varInst->V_TRN[R814];
              if empty inst and empty instSet and empty tran
                ::clear_value_data();
                ERR::reportParseError( msg: "Internal Error: Variable " +
                                  "subtype instance not found for token %s.",
                                                   token: param.a1_rule_token );
              else
                if not_empty inst
                  select one instRefDt2 related by varInst->S_DT[R848]->S_IRDT[R17];
                  create object instance instRef of V_IRF;
                  relate instRef to varInst across R808;
                  relate instRef to rootVal across R801;
                  relate instRefDt to rootVal across R820;
                  if (empty instRefDt2)
                    relate instRefDt to rootVal across R820;
                  else
                    select one instRefDt2super related by instRefDt2->S_DT[R17];
                    relate instRefDt2super to rootVal across R820;
                  end if;
                elif not_empty instSet
                  create object instance instSetRef of V_ISR;
                  relate instSetRef to varInst across R809;
                  relate instSetRef to rootVal across R801;
                  select any instSetDt related by dom->S_DT[R14]
                                  where selected.Name == "inst_ref_set<Object>";
                  select one instSetDt2 related by varInst->S_DT[R848]->S_IRDT[R17];
                  if empty instSetDt2
                    if empty instSetDt
                      cur_sys_name = ::getSystemName();
                      select any sys from instances of S_SYS where
                                                  selected.Name == cur_sys_name;
                      dt_id = GD::NULL_UNIQUE_ID();
                      if not_empty sys
                        dt_id = sys.getCoreTypeId(name:"inst_ref_set<Object>");
                      end if;
                      select any pe from instances of PE_PE where
                                                   selected.Element_ID == dt_id;
                      select one instSetDt related by pe->S_DT[R8001];
                    end if;
                    if empty instSetDt
                      USER::logError(msg: "Internal Error in OAL Validation " +
                        "Member_access_end().  Variable <instSetDt> is empty.",path:"PathNotProvided");
                    end if;
                  end if;
                  if empty instSetDt2
                    relate instSetDt to rootVal across R820;
                  else
                    select one instSetDt2super related by instSetDt2->S_DT[R17];
                    relate instSetDt2super to rootVal across R820;
                  end if;
                else // transient
                  create object instance tranRef of V_TVL;
                  relate tranRef to varInst across R805;
                  relate tranRef to rootVal across R801;
                  select one dt related by varInst->S_DT[R848];
                  if (not_empty dt)
                    relate rootVal to dt across R820;
                  else
                    // if no dt is found, it is because this transient is being
                    // created implicitly. Data type cannot be determined until
                    // the whole assignment is parsed. See Assignment_expr_end
                    // for data type assignment handling in this case.
                    varInst.resizeDimensions(dimension:0,elementCount:0,numDimensions:0);
                  end if;
                end if;
                rootVal.setEndPosition();
              end if;
            end if;
          end if;
        end if;
      end if;
    end if;
    select many values from instances of V_VAL where
                                      selected.Block_ID == GD::NULL_UNIQUE_ID();
    for each value in values
      relate value to block across R826;
    end for;
  end if;
end if;
return param.a4_rule_id;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5718,
	5717,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5719,
	5717,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5718,
	'');
INSERT INTO S_SPARM
	VALUES (5720,
	5717,
	'a3_rule_begin_id',
	296,
	0,
	'',
	5719,
	'');
INSERT INTO S_SPARM
	VALUES (5721,
	5717,
	'a4_rule_id',
	296,
	0,
	'',
	5720,
	'');
INSERT INTO S_SPARM
	VALUES (5722,
	5717,
	'b1_root_inst_access_id',
	296,
	0,
	'',
	5721,
	'');
INSERT INTO S_SPARM
	VALUES (5723,
	5717,
	'b2_final_inst_access_id',
	296,
	0,
	'',
	5722,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5724);
INSERT INTO S_SYNC
	VALUES (5724,
	1,
	'Member_access_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_ruleid_name;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5725,
	5724,
	'a1_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5726,
	5724,
	'a2_isLval',
	316,
	0,
	'',
	5725,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5727);
INSERT INTO S_SYNC
	VALUES (5727,
	1,
	'Member_access_validate',
	'ParserValidateFunction: TRUE',
	'// ::Member_access_validate()
// return the last member of the value chain
return ::get_value_chain_end(start_value_ID:param.a6_current_rule_id);',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5728,
	5727,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5729,
	5727,
	'a2_isLval',
	316,
	0,
	'',
	5728,
	'');
INSERT INTO S_SPARM
	VALUES (5730,
	5727,
	'a3_text',
	322,
	0,
	'',
	5729,
	'');
INSERT INTO S_SPARM
	VALUES (5731,
	5727,
	'a4_rule_ref_id',
	296,
	0,
	'',
	5730,
	'');
INSERT INTO S_SPARM
	VALUES (5732,
	5727,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5731,
	'');
INSERT INTO S_SPARM
	VALUES (5733,
	5727,
	'a6_current_rule_id',
	296,
	0,
	'',
	5732,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5734);
INSERT INTO S_SYNC
	VALUES (5734,
	1,
	'Member_access_loop11_start',
	'ParserValidateFunction: TRUE',
	'// ::Member_access_loop11_start()
return param.a3_current_rule_id;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5735,
	5734,
	'a1_upper_ruleid_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5736,
	5734,
	'a3_current_rule_id',
	296,
	0,
	'',
	5737,
	'');
INSERT INTO S_SPARM
	VALUES (5737,
	5734,
	'a2_rule_begin_id',
	296,
	0,
	'',
	5735,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5738);
INSERT INTO S_SYNC
	VALUES (5738,
	1,
	'Member_access_loop11_end',
	'ParserValidateFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Member_access_loop_11_end()
select any rootVal from instances of V_VAL where
                              selected.Value_ID == param.b1_root_inst_access_id;
if (empty rootVal)
  // There was a problem with parsing the value . ..
  ::clear_value_data();
else
  select any dom from instances of S_DOM where selected.Dom_ID == ::getValidationDomain();
  select any instRefDt related by dom->S_DT[R14] where
                                            selected.Name == "inst_ref<Object>";
  if empty instRefDt
    cur_sys_name = ::getSystemName();
    select any sys from instances of S_SYS where selected.Name == cur_sys_name;
    dt_id = GD::NULL_UNIQUE_ID();
    if not_empty sys
      dt_id = sys.getCoreTypeId(name:"inst_ref<Object>");
    end if;
    select any pe from instances of PE_PE where selected.Element_ID == dt_id;
    select one instRefDt related by pe->S_DT[R8001];
  end if;
  if empty instRefDt
    USER::logError(msg: "Internal Error in OAL Validation Function " +
                 "Member_access_loop11_end().  Variable <instRefDt> is empty.",path:"PathNotProvided");
  end if;
  name = rootVal.Text;
  var_id = ::get_var_in_scope( name: name, rule_token: param.a1_rule_token );
  select any varInst from instances of V_VAR where selected.Var_ID == var_id;
  if (not rootVal.hasSubtype())
    // This is the first iteration of the repeating instance access
    // syntax pattern; x.y.z etc.
    // Initialize the root value instance
    ::self_validate(a1_text: name,
                                a2_isLval:false, a3_token: param.a1_rule_token);
    if ( ::selected_validate( name: name, rule_token: param.a1_rule_token ))
      // selected is always an r-value
      current_scope = ::get_current_scope();
      if ( current_scope == GD::NULL_UNIQUE_ID() )
        ::clear_value_data();
        ERR::reportParseError( msg: "Internal Error: Unable to determine " +
                                     "context to define variable ->selected<-.",
                                                   token: param.a1_rule_token );
      else
        select any blk from instances of ACT_BLK where
                                             selected.Block_ID == current_scope;
        blk.SelectedFound = true;
        create object instance slr of V_SLR;
        relate slr to rootVal across R801;
        relate rootVal to instRefDt across R820;
        relate rootVal to blk across R826;
      end if;
    end if;
    var_id = ::get_var_in_scope( name: name, rule_token: param.a1_rule_token );
    select any varInst from instances of V_VAR where selected.Var_ID == var_id;
    if empty varInst
      // Either we didn''''t see this value before in this action,
      // or the root value is an argument
      select any parmVal from instances of V_PVL where
                                selected.Value_ID == param.a2_upper_ruleid_name;
      select any evtVal from instances of V_EDV where
                                selected.Value_ID == param.a2_upper_ruleid_name;
      if not_empty parmVal
        select one preCreatedVal related by parmVal->V_VAL[R801];
        unrelate preCreatedVal from parmVal across R801;
        preCreatedVal.dispose();
        relate rootVal to parmVal across R801;
        ::param_root_value_validate(a1_name:name, a2_token:param.a1_rule_token,
                           a3_value_id: rootVal.Value_ID,a4_isRootAccess:false);
      elif not_empty evtVal
        select one preCreatedVal related by evtVal->V_VAL[R801];
        unrelate preCreatedVal from evtVal across R801;
        preCreatedVal.dispose();
        relate rootVal to evtVal across R801;
            ::event_root_value_validate(name:name,
                         token:param.a1_rule_token, value_id: rootVal.Value_ID);
      else
        // We didn''''t see this value before in this action
        if not rootVal.isLValue
          // We''''re reading from it - Error
          ::clear_value_data();
          ::set_token(a1_token:param.a1_rule_token, a2_line:rootVal.LineNumber,
                         a3_column:rootVal.StartPosition, a4_text:rootVal.Text);
          ERR::reportParseError( msg: "Variable ->%s<- used in context where " +
                         "it must already exist.", token: param.a1_rule_token );
        else
          // We''''re writing it
          // Create variable implicitly
          current_scope = ::get_current_scope();
          if ( current_scope == GD::NULL_UNIQUE_ID() )
            ::clear_value_data();
            ERR::reportParseError( msg: "Internal Error: Unable to determine " +
             "context to define variable ->%s<-.", token: param.a1_rule_token );
          else
            select any block from instances of ACT_BLK where
                                             selected.Block_ID == current_scope;
            create object instance trn of V_TRN;
            create object instance varInst of V_VAR;
            varInst.Name = name;
            relate trn to varInst across R814;
            relate varInst to block across R823;
            var_id = varInst.Var_ID;
            rootVal.isImplicit = true;
          end if;
        end if;
      end if;
    end if;
    if (not_empty varInst)
      varInst.addLocation(line:rootVal.LineNumber, col:rootVal.StartPosition );
      // We''''re now ready to establish the Value subtype . . . .
      // . . . . unless it was already established (in the param
      // and rcvd event cases)
      if (not rootVal.hasSubtype())
        select one inst related by varInst->V_INT[R814];
        select one tran related by varInst->V_TRN[R814];
        if not_empty inst and not_empty tran
          ::clear_value_data();
          ERR::reportParseError( msg:
                  "Internal Error: Variable subtype instance " +
                        "not found for token %s.", token: param.a1_rule_token );
        else
          if not_empty inst
            select one instRefDt2 related by varInst->S_DT[R848]->S_IRDT[R17];
            create object instance instRef of V_IRF;
            relate instRef to varInst across R808;
            relate instRef to rootVal across R801;
            if (empty instRefDt2)
              relate instRefDt to rootVal across R820;
            else
              select one instRefDt2super related by instRefDt2->S_DT[R17];
              relate instRefDt2super to rootVal across R820;
            end if;
          else // transient
            create object instance tranRef of V_TVL;
            relate tranRef to varInst across R805;
            relate tranRef to rootVal across R801;
            select one dt related by varInst->S_DT[R848];
            if (empty dt)
              ::clear_value_data();
              ERR::reportParseError( msg: "->" + name +
                                     "<- is not a class or " +
                          "structured data type.", token: param.a1_rule_token );
            else
              relate rootVal to dt across R820;
            end if;
          end if;
          rootVal.setEndPosition();
        end if;
      end if;
    end if;
  end if;
  // Root Value is initialized, now handle current value
  // Iterate down the value chain leaving prevVal at the last link
  select any curVal from instances of V_VAL where
                                     selected.Value_ID == param.a4_loop_id_name;
  if (not empty curVal)
    name = curVal.Text;
    endVal_ID = ::get_value_chain_end(start_value_ID:rootVal.Value_ID);
    select any endVal from instances of V_VAL where
                                                 selected.Value_ID == endVal_ID;
    select one instRef related by endVal->V_IRF[R801];
    select one attrVal related by endVal->V_AVL[R801];
    select one membrVal related by endVal->V_MVL[R801];
    select one tranVal related by endVal->V_TVL[R801];
    select one arrayVal related by endVal->V_AER[R801];
    select one paramVal related by endVal->V_PVL[R801];
    select one evtVal related by endVal->V_EDV[R801];
    select one selVal related by endVal->V_SLR[R801];
    if (not_empty instRef)
      select one instVar related by instRef->V_VAR[R808];
      if (empty instVar)
        ::clear_value_data();
        ERR::reportParseError( msg: "Internal Error: Variable not found for " +
                "instance reference at token %s.", token: param.a1_rule_token );
      else
        select one inst related by instVar->V_INT[R814];
        select one tran related by instVar->V_TRN[R814];
        if (not_empty inst) // Variable refers to an instance
          select one modelClass related by inst->O_OBJ[R818];
          if (empty modelClass)
            ::clear_value_data();
            ERR::reportParseError( msg: "Internal Error: Class not found for " +
                      "variable " + instVar.Name, token: param.a1_rule_token );
          else
            select any attr related by inst->O_OBJ[R818]->O_ATTR[R102] where
                                                          selected.Name == name;
            if (empty attr)
              ::clear_value_data();
              ERR::reportParseError( msg: "->%s<- is not an attribute of " +
                                         "class ->" + modelClass.Name + "<-.",
                                                   token: param.a1_rule_token );
            else
              // Successfully recognized an attribute reference
              create object instance attrVal of V_AVL;
              relate attrVal to curVal across R801;
              relate attrVal to attr across R806;
              select one dt related by attr->S_DT[R114];
              select one rattr related by attr->O_RATTR[R106];
              if not_empty rattr
                select one dt related by rattr->O_BATTR[R113]->
                                                       O_ATTR[R106]->S_DT[R114];
              end if;
              relate curVal to dt across R820;
              relate endVal to attrVal across R807;
            end if;
          end if;
        elif (not_empty tran)
          select one dt related by endVal->S_DT[R820];
          if (empty dt)
            ::clear_value_data();
            ERR::reportParseError( msg: "Internal Error: Data type not found " +
                                 " for token %s.", token: param.a1_rule_token );
          else
            select one sdt related by dt->S_SDT[R17];
            if (empty sdt)
              ::clear_value_data();
              ERR::reportParseError( msg: "->%s<- is not a structured data " +
                                          "type.", token: param.a1_rule_token );
            else
              select any member related by sdt->S_MBR[R44] where
                                                          selected.Name == name;
              if (empty member)
                ::clear_value_data();
                ERR::reportParseError( msg: "->%s<- is not a member of " +
                                    "structured data type ->" + dt.Name + "<-",
                                                   token: param.a1_rule_token );
              else
                // Successfully recognized a member reference
                create object instance membrVal of V_MVL;
                relate membrVal to curVal across R801;
                relate membrVal to member across R836;
                select one dt related by member->S_DT[R45];
                relate curVal to dt across R820;
                relate endVal to membrVal across R837;
              end if;
            end if;
          end if;
        else
          ::clear_value_data();
          ERR::reportParseError( msg: "Internal Error: Variable subtype not " +
                            "found for token %s.", token: param.a1_rule_token );
        end if;
      end if;  // instance variable found
    elif (not_empty selVal)
      if (empty varInst)
        ::clear_value_data();
        ERR::reportParseError( msg: "Internal Error: Variable not found for " +
                    "selected class at token %s.", token: param.a1_rule_token );
      else
        select one selClass related by varInst->V_INT[R814]->O_OBJ[R818];
        if empty selClass
          ::clear_value_data();
          ERR::reportParseError( msg: "Internal Error: selected class not " +
                            "found for token %s.", token: param.a1_rule_token );
        else
          select any attr related by selClass->O_ATTR[R102] where
                                                          selected.Name == name;
          if (empty attr)
            ::clear_value_data();
            ERR::reportParseError( msg: "->%s<- is not an attribute of " +
                                         "class ->" + selClass.Name + "<-.",
                                                   token: param.a1_rule_token );
          else
            // Successfully recognized an attribute reference
            create object instance attrVal of V_AVL;
            relate attrVal to curVal across R801;
            relate attrVal to attr across R806;
            select one dt related by attr->S_DT[R114];
            select one rattr related by attr->O_RATTR[R106];
            if not_empty rattr
              select one dt related by rattr->O_BATTR[R113]->
                                                       O_ATTR[R106]->S_DT[R114];
            end if;
            relate curVal to dt across R820;
            relate endVal to attrVal across R807;
          end if;
        end if;
      end if; // selected variable found
    elif (not_empty attrVal or not_empty membrVal or not_empty tranVal
                or not_empty arrayVal or not_empty paramVal or not_empty evtVal)
      select one dt related by endVal->S_DT[R820];
      if (empty dt)
        ::clear_value_data();
        ERR::reportParseError( msg: "Internal Error: Data type not found " +
                                 " for token %s.", token: param.a1_rule_token );
      else
        select one irdt related by dt->S_IRDT[R17];
        select one sdt related by dt->S_SDT[R17];
        select one udt related by dt->S_UDT[R17];
        if(not_empty udt)
          core_id = udt.getCoreType();
          select any dt_pe from instances of PE_PE
                                         where (selected.Element_ID == core_id);
          select one base_dt related by dt_pe->S_DT[R8001];
          select one sdt related by base_dt->S_SDT[R17];
          select one irdt related by base_dt->S_IRDT[R17];
        end if;
        if (empty sdt)
          if (empty irdt)
            if not ::array_length_validate(a1_name:name,
              a2_isArray:endVal.getDimensions() > 0, a3_curVal_ID:curVal.Value_ID,
                    a4_token:param.a1_rule_token, a5_endVal_ID:endVal.Value_ID);
              mbrName = "";
              if not_empty attrVal
                select one attr related by attrVal->O_ATTR[R806];
                mbrName = attr.Name;
              elif not_empty membrVal
                select one member related by membrVal->S_MBR[R836];
                mbrName = member.Name;
              elif not_empty tranVal
                select one var related by tranVal->V_VAR[R805];
                mbrName = var.Name;
              end if;
              ::clear_value_data();
              if (mbrName != "")
                ERR::reportParseError( msg: "->" + mbrName +
                      "<- is not a structured data type or instance reference.",
                                                   token: param.a1_rule_token );
              else
                ERR::reportParseError( msg: "The variable to the left of ->" +
                  name + "<- is not a structured data type or instance reference.",
                                                   token: param.a1_rule_token );
              end if;
            end if;
          else
            /* TODO - this should probably be refactored to "attribute_validate" along with
               earlier identical code*/
            select one modelClass related by irdt->O_OBJ[R123];
            if (empty modelClass)
              ::clear_value_data();
              ERR::reportParseError( msg: "Internal Error: Class not found for " +
                        "variable " + endVal.Text, token: param.a1_rule_token );
            else
              select any attr related by irdt->O_OBJ[R123]->O_ATTR[R102] where
                                                          selected.Name == name;
              if (empty attr)
                ::clear_value_data();
                ERR::reportParseError( msg: "->%s<- is not an attribute of " +
                                           "class ->" + modelClass.Name + "<-.",
                                                   token: param.a1_rule_token );
              else
                // Successfully recognized an attribute reference
                create object instance attrVal of V_AVL;
                relate attrVal to curVal across R801;
                relate attrVal to attr across R806;
                select one dt related by attr->S_DT[R114];
                select one rattr related by attr->O_RATTR[R106];
                if not_empty rattr
                  select one dt related by rattr->O_BATTR[R113]->
                                                       O_ATTR[R106]->S_DT[R114];
                end if;
                relate curVal to dt across R820;
                relate endVal to attrVal across R807;
              end if;
            end if;
          end if;
        else
          select any member related by sdt->S_MBR[R44] where
                                                          selected.Name == name;
          if (empty member)
            if not ::array_length_validate(a1_name:name,
               a2_isArray:endVal.getDimensions() > 0, a3_curVal_ID:curVal.Value_ID,
                    a4_token:param.a1_rule_token, a5_endVal_ID:endVal.Value_ID);
              ::set_token(a1_token:param.a1_rule_token,
                                      a2_line:curVal.LineNumber,
                           a3_column:curVal.StartPosition, a4_text:curVal.Text);
              ::clear_value_data();
              ERR::reportParseError( msg: "->%s<- is not a member of " +
                                "structured data type ->" + dt.Name + "<-.",
                                                   token: param.a1_rule_token );
            end if;
          else
            // Successfully recognized a member reference
            create object instance membrVal of V_MVL;
            relate membrVal to curVal across R801;
            relate membrVal to member across R836;
            select one dt related by member->S_DT[R45];
            relate curVal to dt across R820;
            relate endVal to membrVal across R837;
          end if;
        end if;
      end if;
    else
      ::clear_value_data();
      ERR::reportParseError( msg: "Internal Error: Value subtype instance " +
                        "not found for token %s.", token: param.a1_rule_token );
    end if;
    if (endVal.getDimensions() > 0)
       if not ::array_length_validate(a1_name:name,
                        a2_isArray:true, a3_curVal_ID:curVal.Value_ID,
           a4_token:param.a1_rule_token, a5_endVal_ID:endVal.Value_ID);
       array_root_val_ID =
                     ::get_array_value_root(start_value_ID:endVal.Value_ID);
           select any val from instances of V_VAL where
                                     selected.Value_ID == array_root_val_ID;
            ::clear_value_data();
            ERR::reportParseError( msg: "Variable ->" + val.Text +
                            "<- is an array.", token: param.a1_rule_token );
       end if;
    elif (endVal.getDimensions() < 0)
       array_root_val_ID =
                 ::get_array_value_root(start_value_ID:endVal.Value_ID);
       select any val from instances of V_VAL where
                                 selected.Value_ID == array_root_val_ID;
       ::clear_value_data();
       ERR::reportParseError( msg: "Variable ->" + val.Text +
         "<- has too many array indices.", token: param.a1_rule_token );
    elif ( not endVal.isElementCountValid() )
    	// one of the indexes is out of bounds.
    	   array_root_val_ID =
           ::get_array_value_root(start_value_ID:endVal.Value_ID);
   	   select any val from instances of V_VAL where
                                 selected.Value_ID == array_root_val_ID;
   	   ::clear_value_data();
   	   ERR::reportParseError( msg: "Variable ->" + val.Text +
       "<- has index out of bounds.", token: param.a1_rule_token );
    end if;
    curVal.setEndPosition();
  end if;
end if;
return param.a3_ruleid_name;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5739,
	5738,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5740,
	5738,
	'a2_upper_ruleid_name',
	296,
	0,
	'',
	5739,
	'');
INSERT INTO S_SPARM
	VALUES (5741,
	5738,
	'a3_ruleid_name',
	296,
	0,
	'',
	5740,
	'');
INSERT INTO S_SPARM
	VALUES (5742,
	5738,
	'a4_loop_id_name',
	296,
	0,
	'',
	5741,
	'');
INSERT INTO S_SPARM
	VALUES (5743,
	5738,
	'b1_root_inst_access_id',
	296,
	0,
	'',
	5742,
	'');
INSERT INTO S_SPARM
	VALUES (5744,
	5738,
	'b2_current_inst_access_id',
	296,
	0,
	'',
	5743,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5745);
INSERT INTO S_SYNC
	VALUES (5745,
	1,
	'Param_data_access_loop12_end',
	'ParserValidateFunction: TRUE',
	'// ::Param_data_access_loop12_end()
select any member from instances of S_MBR where
                              selected.Member_ID == param.b2_class_or_struct_id;
select any parmVal from instances of V_PVL where
                               selected.Value_ID == param.b2_class_or_struct_id;
if (empty member and empty parmVal)
  // TODO Log error
else
  if (not_empty member)
    discard = ::field_create(
                   new_attr_or_member_id:param.b2_class_or_struct_id,
                          prev_var_attr_or_member_id:param.a3_rule_id,
                                                     token:param.a1_rule_token);
  // In the parmVal case we already created the value
  end if;
end if;
return param.a4_loop_id;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5746,
	5745,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5747,
	5745,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5746,
	'');
INSERT INTO S_SPARM
	VALUES (5748,
	5745,
	'a3_rule_id',
	296,
	0,
	'',
	5747,
	'');
INSERT INTO S_SPARM
	VALUES (5749,
	5745,
	'a4_loop_id',
	296,
	0,
	'',
	5748,
	'');
INSERT INTO S_SPARM
	VALUES (5750,
	5745,
	'b1_data_item_id',
	296,
	0,
	'',
	5749,
	'');
INSERT INTO S_SPARM
	VALUES (5751,
	5745,
	'b2_class_or_struct_id',
	296,
	0,
	'',
	5750,
	'');
INSERT INTO S_SPARM
	VALUES (5752,
	5745,
	'b4_field_access_id',
	296,
	0,
	'',
	5751,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5753);
INSERT INTO S_SYNC
	VALUES (5753,
	1,
	'Param_data_access_loop12_start',
	'ParserValidateFunction: TRUE',
	'//::Param_data_access_loop12_start
return param.a3_this_rule;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5754,
	5753,
	'a1_upper_rule',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5755,
	5753,
	'a2_rule_begin',
	296,
	0,
	'',
	5754,
	'');
INSERT INTO S_SPARM
	VALUES (5756,
	5753,
	'a3_this_rule',
	296,
	0,
	'',
	5755,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5757);
INSERT INTO S_SYNC
	VALUES (5757,
	1,
	'Event_data_access_end',
	'ParserValidateFunction: TRUE',
	'// ::Event_data_access_end()
result = param.a4_rule_id;
if ( param.b1_member_id == GD::NULL_UNIQUE_ID() and
                                param.a3_rule_begin_id ==  GD::NULL_UNIQUE_ID())
  // There is neither a field, nor an event parameter reference,
  // dispose incompletely created value instances . . .
  ::clear_value_data();
  // ... and report an error
  ERR::reportParseError( msg:
                 "Field or parameter %s not found for event parameter access",
                                                   token: param.a1_rule_token );
else
  current_scope = ::get_current_scope();
  select any blk from instances of ACT_BLK where
                                           (selected.Block_ID == current_scope);
  if (empty blk)
    ::clear_value_data();
    ERR::reportParseError(msg:"Block not found",
                                                   token: param.a1_rule_token );
  else
    // TBD
  end if;
  select many vals from instances of V_VAL where
                                      selected.Block_ID == GD::NULL_UNIQUE_ID();
  for each val in vals
    relate val to blk across R826;
  end for;
end if;
return result;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5758,
	5757,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5759,
	5757,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5758,
	'');
INSERT INTO S_SPARM
	VALUES (5760,
	5757,
	'a3_rule_begin_id',
	296,
	0,
	'',
	5759,
	'');
INSERT INTO S_SPARM
	VALUES (5761,
	5757,
	'a4_rule_id',
	296,
	0,
	'',
	5760,
	'');
INSERT INTO S_SPARM
	VALUES (5762,
	5757,
	'b1_member_id',
	296,
	0,
	'',
	5761,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5763);
INSERT INTO S_SYNC
	VALUES (5763,
	1,
	'Event_data_access_loop13_end',
	'ParserValidateFunction: TRUE',
	'// ::Event_data_access_loop13_end()
select any member from instances of S_MBR where
                              selected.Member_ID == param.b2_class_or_struct_id;
select any evtVal from instances of V_EDV where
                               selected.Value_ID == param.b2_class_or_struct_id;
if (empty member and empty evtVal)
  // TODO Log error
else
  if (not_empty member)
    discard = ::field_create(
                   new_attr_or_member_id:param.b2_class_or_struct_id,
                          prev_var_attr_or_member_id:param.a3_rule_id,
                                                     token:param.a1_rule_token);
  // In the evtVal case we already created the value
  end if;
end if;
return param.a4_loop_id;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5764,
	5763,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5765,
	5763,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5764,
	'');
INSERT INTO S_SPARM
	VALUES (5766,
	5763,
	'a3_rule_id',
	296,
	0,
	'',
	5765,
	'');
INSERT INTO S_SPARM
	VALUES (5767,
	5763,
	'a4_loop_id',
	296,
	0,
	'',
	5766,
	'');
INSERT INTO S_SPARM
	VALUES (5768,
	5763,
	'b1_supp_data_item_id',
	296,
	0,
	'',
	5767,
	'');
INSERT INTO S_SPARM
	VALUES (5769,
	5763,
	'b2_class_or_struct_id',
	296,
	0,
	'',
	5768,
	'');
INSERT INTO S_SPARM
	VALUES (5770,
	5763,
	'b4_member_id',
	296,
	0,
	'',
	5769,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5771);
INSERT INTO S_SYNC
	VALUES (5771,
	1,
	'Event_data_access_loop13_start',
	'ParserValidateFunction: TRUE',
	'//::Event_data_access_loop13_start
return param.a3_this_rule_id;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5772,
	5771,
	'a1_upper_rule_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5773,
	5771,
	'a2_rule_begin_id',
	296,
	0,
	'',
	5772,
	'');
INSERT INTO S_SPARM
	VALUES (5774,
	5771,
	'a3_this_rule_id',
	296,
	0,
	'',
	5773,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5775);
INSERT INTO S_SYNC
	VALUES (5775,
	1,
	'Event_data_access_start',
	'ParserValidateFunction: TRUE',
	'//::Event_data_access_start()
create object instance val of V_VAL;
create object instance edv of V_EDV;
relate edv to val across R801;
val.isLValue = false;
return val.Value_ID;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5776,
	5775,
	'a1_rule_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5777);
INSERT INTO S_SYNC
	VALUES (5777,
	1,
	'Array_refs_validate',
	'ParserValidateFunction: TRUE',
	'return param.a5_current_rule_id;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5778,
	5777,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5779,
	5777,
	'a2_text',
	322,
	0,
	'',
	5778,
	'');
INSERT INTO S_SPARM
	VALUES (5780,
	5777,
	'a3_rule_id',
	296,
	0,
	'',
	5779,
	'');
INSERT INTO S_SPARM
	VALUES (5781,
	5777,
	'a4_upper_rule_id',
	296,
	0,
	'',
	5780,
	'');
INSERT INTO S_SPARM
	VALUES (5782,
	5777,
	'a5_current_rule_id',
	296,
	0,
	'',
	5781,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5783);
INSERT INTO S_SYNC
	VALUES (5783,
	1,
	'Array_refs_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_rule_id;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5784,
	5783,
	'a1_rule_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5785);
INSERT INTO S_SYNC
	VALUES (5785,
	1,
	'Array_refs_loop12_start',
	'ParserValidateFunction: TRUE',
	'return param.a3_current_rule_id;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5786,
	5785,
	'a1_rule_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5787,
	5785,
	'a2_start_rule_id',
	296,
	0,
	'',
	5786,
	'');
INSERT INTO S_SPARM
	VALUES (5788,
	5785,
	'a3_current_rule_id',
	296,
	0,
	'',
	5787,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5789);
INSERT INTO S_SYNC
	VALUES (5789,
	1,
	'Array_refs_loop12_end',
	'ParserValidateFunction: TRUE',
	'rootVal_ID = ::get_value_chain_end(start_value_ID:param.a3_outer_loop_id);
select any rootVal from instances of V_VAL where
                                    selected.Value_ID == rootVal_ID;
select any exprVal  from instances of V_VAL where
                                          selected.Value_ID == param.a5_expr_id;
select one dt related by exprVal->S_DT[R820];
if ( (empty dt) or (dt.Name != "integer") )
  ::clear_value_data();
  ERR::reportParseError( msg: "Array index must be an integer.",
                                                   token: param.a1_rule_token );
else
  create object instance val of V_VAL;
  create object instance arrayRef of V_AER;
  relate val to  arrayRef across R801;
  relate arrayRef to rootVal across R838;
  relate arrayRef to exprVal across R839;
end if;
return param.a3_outer_loop_id;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5790,
	5789,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5791,
	5789,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5790,
	'');
INSERT INTO S_SPARM
	VALUES (5792,
	5789,
	'a3_outer_loop_id',
	296,
	0,
	'',
	5791,
	'');
INSERT INTO S_SPARM
	VALUES (5793,
	5789,
	'a4_current_rule_id',
	296,
	0,
	'',
	5792,
	'');
INSERT INTO S_SPARM
	VALUES (5794,
	5789,
	'a5_expr_id',
	296,
	0,
	'',
	5793,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5795);
INSERT INTO S_SYNC
	VALUES (5795,
	1,
	'Array_refs_end',
	'ParserValidateFunction: TRUE',
	'return param.a4_current_rule_id;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5796,
	5795,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5797,
	5795,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5796,
	'');
INSERT INTO S_SPARM
	VALUES (5798,
	5795,
	'a3_start_rule_id',
	296,
	0,
	'',
	5797,
	'');
INSERT INTO S_SPARM
	VALUES (5799,
	5795,
	'a4_current_rule_id',
	296,
	0,
	'',
	5798,
	'');
INSERT INTO S_SPARM
	VALUES (5800,
	5795,
	'a5_expr_id',
	296,
	0,
	'',
	5799,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5801);
INSERT INTO S_SYNC
	VALUES (5801,
	1,
	'Instance_access_segment_end',
	'ParserValidateFunction: TRUE',
	'return param.a4_current_rule_id;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5802,
	5801,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5803,
	5801,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5802,
	'');
INSERT INTO S_SPARM
	VALUES (5804,
	5801,
	'a3_start_rule_id',
	296,
	0,
	'',
	5803,
	'');
INSERT INTO S_SPARM
	VALUES (5805,
	5801,
	'a4_current_rule_id',
	296,
	0,
	'',
	5804,
	'');
INSERT INTO S_SPARM
	VALUES (5806,
	5801,
	'b1_local_variable_id',
	296,
	0,
	'',
	5805,
	'');
INSERT INTO S_SPARM
	VALUES (5807,
	5801,
	'b2_array_refs_id',
	296,
	0,
	'',
	5806,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5808);
INSERT INTO S_SYNC
	VALUES (5808,
	1,
	'Instance_access_segment_start',
	'ParserValidateFunction: TRUE',
	'create object instance val of V_VAL;
val.isLValue = param.a2_isLval;
return val.Value_ID;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5809,
	5808,
	'a1_current_rule_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5810,
	5808,
	'a2_isLval',
	316,
	0,
	'',
	5809,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5811);
INSERT INTO S_SYNC
	VALUES (5811,
	1,
	'Instance_access_segment_validate',
	'ParserValidateFunction: TRUE',
	'return param.a6_current_rule_id;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5812,
	5811,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5813,
	5811,
	'a2_isLval',
	316,
	0,
	'',
	5812,
	'');
INSERT INTO S_SPARM
	VALUES (5814,
	5811,
	'a3_text',
	322,
	0,
	'',
	5813,
	'');
INSERT INTO S_SPARM
	VALUES (5815,
	5811,
	'a4_access_id',
	296,
	0,
	'',
	5814,
	'');
INSERT INTO S_SPARM
	VALUES (5816,
	5811,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5815,
	'');
INSERT INTO S_SPARM
	VALUES (5817,
	5811,
	'a6_current_rule_id',
	296,
	0,
	'',
	5816,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5818);
INSERT INTO S_SYNC
	VALUES (5818,
	1,
	'Element_label_validate',
	'ParserValidateFunction: TRUE',
	'select any value from instances of V_VAL where
                                  selected.Value_ID == param.c3_current_rule_id;
if (not_empty value)
  value.Text = ::getText(rule_token: param.a1_rule_token);
  value.LineNumber = ::getLineNumber(rule_token: param.a1_rule_token);
  value.StartPosition = ::getColumn(rule_token: param.a1_rule_token);
end if;
return param.c3_current_rule_id;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5819,
	5818,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5820,
	5818,
	'b1_isLval',
	316,
	0,
	'',
	5819,
	'');
INSERT INTO S_SPARM
	VALUES (5821,
	5818,
	'b2_rule_text',
	322,
	0,
	'',
	5820,
	'');
INSERT INTO S_SPARM
	VALUES (5822,
	5818,
	'c1_element_label_rule_id',
	296,
	0,
	'',
	5821,
	'');
INSERT INTO S_SPARM
	VALUES (5823,
	5818,
	'c2_upper_rule_id',
	296,
	0,
	'',
	5822,
	'');
INSERT INTO S_SPARM
	VALUES (5824,
	5818,
	'c3_current_rule_id',
	296,
	0,
	'',
	5823,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5825);
INSERT INTO S_SYNC
	VALUES (5825,
	1,
	'Instance_start_segment_validate',
	'ParserValidateFunction: TRUE',
	'// ::Instance_start_segment_validate()
// See also ::Instance_access_segment_validate()
return param.a6_current_rule_id;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5826,
	5825,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5827,
	5825,
	'a2_isLval',
	316,
	0,
	'',
	5826,
	'');
INSERT INTO S_SPARM
	VALUES (5828,
	5825,
	'a3_text',
	322,
	0,
	'',
	5827,
	'');
INSERT INTO S_SPARM
	VALUES (5829,
	5825,
	'a4_access_id',
	296,
	0,
	'',
	5828,
	'');
INSERT INTO S_SPARM
	VALUES (5830,
	5825,
	'a5_upper_rule_id',
	296,
	0,
	'',
	5829,
	'');
INSERT INTO S_SPARM
	VALUES (5831,
	5825,
	'a6_current_rule_id',
	296,
	0,
	'',
	5830,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5832);
INSERT INTO S_SYNC
	VALUES (5832,
	1,
	'Instance_start_segment_start',
	'ParserValidateFunction: TRUE',
	'// ::Instance_start_segment_start()
return ::Instance_access_segment_start(
        a1_current_rule_id:param.a1_current_rule_id, a2_isLval:param.a2_isLval);',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5833,
	5832,
	'a1_current_rule_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5834,
	5832,
	'a2_isLval',
	316,
	0,
	'',
	5833,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5835);
INSERT INTO S_SYNC
	VALUES (5835,
	1,
	'Instance_start_segment_end',
	'ParserValidateFunction: TRUE',
	'// ::Instance_start_segment_end()
// See also ::Instance_access_segment_end()
return param.a4_current_rule_id;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5836,
	5835,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5837,
	5835,
	'a2_upper_rule_id',
	296,
	0,
	'',
	5836,
	'');
INSERT INTO S_SPARM
	VALUES (5838,
	5835,
	'a3_start_rule_id',
	296,
	0,
	'',
	5837,
	'');
INSERT INTO S_SPARM
	VALUES (5839,
	5835,
	'a4_current_rule_id',
	296,
	0,
	'',
	5838,
	'');
INSERT INTO S_SPARM
	VALUES (5840,
	5835,
	'b1_local_variable_id',
	296,
	0,
	'',
	5839,
	'');
INSERT INTO S_SPARM
	VALUES (5841,
	5835,
	'b2_array_refs_id',
	296,
	0,
	'',
	5840,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5842);
INSERT INTO S_SYNC
	VALUES (5842,
	1,
	'Root_element_label_validate',
	'ParserValidateFunction: TRUE',
	'// ::Root_element_label_validate()
return ::Element_label_validate(a1_rule_token:param.a1_rule_token,
           b1_isLval:param.b1_isLval, b2_rule_text:param.b2_rule_text,
                 c1_element_label_rule_id:param.c1_element_label_rule_id,
                                    c2_upper_rule_id:param.c2_upper_rule_id,
                                   c3_current_rule_id:param.c3_current_rule_id);',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5843,
	5842,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5844,
	5842,
	'b1_isLval',
	316,
	0,
	'',
	5843,
	'');
INSERT INTO S_SPARM
	VALUES (5845,
	5842,
	'b2_rule_text',
	322,
	0,
	'',
	5844,
	'');
INSERT INTO S_SPARM
	VALUES (5846,
	5842,
	'c1_element_label_rule_id',
	296,
	0,
	'',
	5845,
	'');
INSERT INTO S_SPARM
	VALUES (5847,
	5842,
	'c2_upper_rule_id',
	296,
	0,
	'',
	5846,
	'');
INSERT INTO S_SPARM
	VALUES (5848,
	5842,
	'c3_current_rule_id',
	296,
	0,
	'',
	5847,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5849);
INSERT INTO S_SYNC
	VALUES (5849,
	1,
	'Send_statement_start',
	'ParserValidateFunction: TRUE',
	'return ::statement_create();',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5850,
	5849,
	'a1_rule_id_name',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5851);
INSERT INTO S_SYNC
	VALUES (5851,
	1,
	'Message_invocation_validate',
	'ParserValidateFunction: TRUE',
	'//::Message_invocation_validate()
if param.a6_current_rule != GD::NULL_UNIQUE_ID()
  select any val from instances of V_VAL where
                                     selected.Value_ID == param.a6_current_rule;
  if not_empty val
    select one sdt related by val->S_DT[R820];
    if ( empty sdt )
      ERR::reportParseError( msg: "Value has unknown data type",
                                                   token: param.a1_rule_token );
    else
      select one msg related by val->V_MSV[R801]->SPR_PEP[R841]->C_EP[R4501]; 
      if(empty msg)
        // if the executable property was not found
        // search for a required executable property
        select one msg related by val->V_MSV[R801]->SPR_REP[R845]->C_EP[R4500];
      end if;
      msgName = "";
      message_ok = true;
      if not_empty msg
        select one sig related by msg->C_AS[R4004];
        if not_empty sig
          if param.a2_isRVal
            message_ok = false;
            ERR::reportParseError( msg: "Signal ->" + sig.Name +
             "<- cannot be used in an expression", token: param.a1_rule_token );
          else
            msgName = sig.Name;
          end if;
        else
          select one io related by msg->C_IO[R4004];
          msgName = io.Name;
        end if;
      else
        message_ok = false;
      end if;
      if message_ok
        return ::is_valid_invocation( a1_type: sdt.Name,
                                a2_isRval: param.a2_isRVal,
                                a3_id: param.a6_current_rule,
                                a4_name: "Interface Operation ->"  + msgName,
                                           a5_rule_token: param.a1_rule_token );
      end if;
    end if;
  end if;
end if;

return GD::NULL_UNIQUE_ID();',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5852,
	5851,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5853,
	5851,
	'a2_isRVal',
	316,
	0,
	'',
	5852,
	'');
INSERT INTO S_SPARM
	VALUES (5854,
	5851,
	'a3_text',
	322,
	0,
	'',
	5853,
	'');
INSERT INTO S_SPARM
	VALUES (5855,
	5851,
	'a4_rule_ref',
	296,
	0,
	'',
	5854,
	'');
INSERT INTO S_SPARM
	VALUES (5856,
	5851,
	'a5_upper_rule',
	296,
	0,
	'',
	5855,
	'');
INSERT INTO S_SPARM
	VALUES (5857,
	5851,
	'a6_current_rule',
	296,
	0,
	'',
	5856,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5858);
INSERT INTO S_SYNC
	VALUES (5858,
	1,
	'Send_statement_end',
	'ParserValidateFunction: TRUE',
	'select any val from instances of V_VAL
                          where selected.Value_ID == param.a7_message_result_id;
if ( empty val )
  select any val from instances of V_VAL 
                      where selected.Value_ID == param.a8_message_invocation_id;
end if;
if ( empty val )
  // there was a problem with parsing the value
  select any stmt from instances of ACT_SMT 
        where selected.Statement_ID == param.a3_start_rule;
  stmt.dispose();
  return GD::NULL_UNIQUE_ID();
end if;
if (  param.a5_member_access_id != GD::NULL_UNIQUE_ID() )
  return ::Assignment_expr_end( a1_rule_token: param.a1_rule_token, 
      a2_upper_rule_id: param.a3_start_rule,
      a3_rule_begin_id: param.a3_start_rule,
      a4_rule_id: param.a4_current_rule,
      b1_member_id: param.a5_member_access_id,
      b2_expr2_id: param.a7_message_result_id,
      b3_param_data_access3_id: GD::NULL_UNIQUE_ID(),
      b4_expr4_id: GD::NULL_UNIQUE_ID()
  );
elif (  param.a6_parameter_access_id != GD::NULL_UNIQUE_ID() )
  // this creates a statement with an AssignToParameter subtype
  return ::Assignment_expr_end( a1_rule_token: param.a1_rule_token, 
        a2_upper_rule_id: param.a3_start_rule,
        a3_rule_begin_id: param.a3_start_rule,
        a4_rule_id: param.a4_current_rule,
        b1_member_id: GD::NULL_UNIQUE_ID(),
        b2_expr2_id: GD::NULL_UNIQUE_ID(),
        b3_param_data_access3_id: param.a6_parameter_access_id,
        b4_expr4_id: param.a7_message_result_id
  );
else
  select any stmt from instances of ACT_SMT 
where selected.Statement_ID == param.a3_start_rule;
  select one msv related by val->V_MSV[R801];
  select many parm_set related by msv->V_PAR[R842];
  select one reqOp related by msv->SPR_REP[R845]->SPR_RO[R4502];
  select one proOp related by msv->SPR_PEP[R841]->SPR_PO[R4503]; 
  select one reqSig related by msv->SPR_REP[R845]->SPR_RS[R4502];
  select one proSig related by msv->SPR_PEP[R841]->SPR_PS[R4503];
  if not_empty reqOp
    select one exProp related by reqOp->SPR_REP[R4502];
    create object instance aop of ACT_IOP;
    relate stmt to aop across R603;
    unrelate exProp from msv across R845;
    relate reqOp to aop across R657;
	// store the textual position of the op name
	aop.opNameLineNumber = val.LineNumber;
	aop.opNameColumn = val.StartPosition;
	// store the textual position of the owner name (i.e. the port or interface
	// name). Use the value that is in the message-value instance that was
	// created when the messages named was first parsed, rather than the value
	// in the current block, since the latter may have been overwritten
	// during the parsing of the messages parameters 
	aop.ownerNameLineNumber = msv.ownerNameLineNumber;
	aop.ownerNameColumn = msv.ownerNameColumn;
    for each parm in parm_set
      unrelate parm from msv across R842;
      relate parm to aop across R679;
    end for;
    // Migrate the target component reference
    select one targetCompRef related by msv->V_VAL[R851];
    unrelate msv from targetCompRef across R851;
    relate aop to targetCompRef across R629;
  elif(not_empty proOp)
    select one exProp related by proOp->SPR_PEP[R4503];
    create object instance aop of ACT_IOP;
    relate stmt to aop across R603;
    unrelate exProp from msv across R841;
    relate proOp to aop across R680;
	// store the textual position of the op name
	aop.opNameLineNumber = val.LineNumber;
	aop.opNameColumn = val.StartPosition;
	// store the textual position of the owner name (i.e. the port or interface
	// name). Use the value that is in the message-value instance that was
	// created when the messages named was first parsed, rather than the value
	// in the current block, since the latter may have been overwritten
	// during the parsing of the messages parameters 
	aop.ownerNameLineNumber = msv.ownerNameLineNumber;
	aop.ownerNameColumn = msv.ownerNameColumn;
    for each parm in parm_set
      unrelate parm from msv across R842;
      relate parm to aop across R679;
    end for;
    // Migrate the target component reference
    select one targetCompRef related by msv->V_VAL[R851];
    unrelate msv from targetCompRef across R851;
    relate aop to targetCompRef across R629;
  elif(not_empty reqSig)
    select one exProp related by reqSig->SPR_REP[R4502];
    create object instance asig of ACT_SGN;
    relate stmt to asig across R603;
    unrelate exProp from msv across R845;
    relate reqSig to asig across R660;
	// store the textual position of the signal name
	asig.sigNameLineNumber = val.LineNumber;
	asig.sigNameColumn = val.StartPosition;
	// See comment in block above
	asig.ownerNameLineNumber = msv.ownerNameLineNumber;
	asig.ownerNameColumn = msv.ownerNameColumn;
    for each parm in parm_set
      unrelate parm from msv across R842;
      relate parm to asig across R662;
    end for;
    // Migrate the target component reference
    select one targetCompRef related by msv->V_VAL[R851];
    unrelate msv from targetCompRef across R851;
    relate asig to targetCompRef across R630;
  elif(not_empty proSig)
    select one exProp related by proSig->SPR_PEP[R4503];
    create object instance asig of ACT_SGN;
    relate stmt to asig across R603;
    unrelate exProp from msv across R841;
    relate proSig to asig across R663;
	// store the textual position of the signal name
	asig.sigNameLineNumber = val.LineNumber;
	asig.sigNameColumn = val.StartPosition;
	// See comment in block above
	asig.ownerNameLineNumber = msv.ownerNameLineNumber;
	asig.ownerNameColumn = msv.ownerNameColumn;
    for each parm in parm_set
      unrelate parm from msv across R842;
      relate parm to asig across R662;
    end for;  
    // Migrate the target component reference
    select one targetCompRef related by msv->V_VAL[R851];
    unrelate msv from targetCompRef across R851;
    relate asig to targetCompRef across R630;
  end if;
  val.dispose();
  return stmt.Statement_ID;
end if;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5859,
	5858,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5860,
	5858,
	'a2_upper_rule',
	296,
	0,
	'',
	5859,
	'');
INSERT INTO S_SPARM
	VALUES (5861,
	5858,
	'a3_start_rule',
	296,
	0,
	'',
	5860,
	'');
INSERT INTO S_SPARM
	VALUES (5862,
	5858,
	'a4_current_rule',
	296,
	0,
	'',
	5861,
	'');
INSERT INTO S_SPARM
	VALUES (5863,
	5858,
	'a5_member_access_id',
	296,
	0,
	'',
	5862,
	'');
INSERT INTO S_SPARM
	VALUES (5864,
	5858,
	'a6_parameter_access_id',
	296,
	0,
	'',
	5863,
	'');
INSERT INTO S_SPARM
	VALUES (5865,
	5858,
	'a7_message_result_id',
	296,
	0,
	'',
	5864,
	'');
INSERT INTO S_SPARM
	VALUES (5866,
	5858,
	'a8_message_invocation_id',
	296,
	0,
	'',
	5865,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5867);
INSERT INTO S_SYNC
	VALUES (5867,
	1,
	'Message_invocation_start',
	'ParserValidateFunction: TRUE',
	'return param.a1_current_rule;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5868,
	5867,
	'a1_current_rule',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5869,
	5867,
	'a2_isRVal',
	316,
	0,
	'',
	5868,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5870);
INSERT INTO S_SYNC
	VALUES (5870,
	1,
	'Interface_or_port_name_validate',
	'ParserValidateFunction: TRUE',
	'current_scope = ::get_current_scope();
select any block from instances of ACT_BLK where
                                             selected.Block_ID == current_scope;
block.TempBuffer = param.a2_text;
// store the textual position of the name
block.currentKeyLettersLineNumber =
                               ::getLineNumber(rule_token: param.a1_rule_token);
block.currentKeyLettersColumn = ::getColumn(rule_token: param.a1_rule_token);
return param.a5_current_rule;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5871,
	5870,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5872,
	5870,
	'a2_text',
	322,
	0,
	'',
	5871,
	'');
INSERT INTO S_SPARM
	VALUES (5873,
	5870,
	'a3_this_rule',
	296,
	0,
	'',
	5872,
	'');
INSERT INTO S_SPARM
	VALUES (5874,
	5870,
	'a4_upper_rule',
	296,
	0,
	'',
	5873,
	'');
INSERT INTO S_SPARM
	VALUES (5875,
	5870,
	'a5_current_rule',
	296,
	0,
	'',
	5874,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5876);
INSERT INTO S_SYNC
	VALUES (5876,
	1,
	'Message_name_validate',
	'ParserValidateFunction: TRUE',
	'current_scope = ::get_current_scope();
select any block from instances of ACT_BLK where
                                             selected.Block_ID == current_scope;
select one body related by block->ACT_ACT[R612];
ownerName = block.TempBuffer;
isInGenericPackage = body.associateWithContainer();
if isInGenericPackage
  select one component related by body->ACT_BIE[R640]->PE_PE[R640]->C_C[R8001];
  select one package related by body->ACT_BIE[R640]->PE_PE[R640]->EP_PKG[R8001];
  if not_empty package
    compId = package.getContainingComponentId();
    select any component from instances of C_C where selected.Id == compId;
  end if;
  if empty component
    ERR::reportParseError( 
         msg: "Signalling syntax is valid only in the context of a component",
                                                   token: param.a1_rule_token ); 
  else
    select any ifRef from instances of C_IR;
    ifRef_found = false;
    portFound = false;
    select many ports related by component->C_PO[R4010];
    for each port in ports
      if port.Name == ownerName
        if not portFound
          portFound = true;
        else
          ERR::reportParseError( 
                      msg: "Found port with duplicate name ->" +
                                 ownerName + "<-", token: param.a1_rule_token ); 
        end if;
        select many ifRefs related by port->C_IR[R4016];
        if cardinality ifRefs > 1
          for each candidateIfRef in ifRefs
            select many messages related by candidateIfRef->
                                                        C_I[R4012]->C_EP[R4003];
            for each message in messages
              select one signal related by message->C_AS[R4004] where
                                                 selected.Name == param.a2_text;
              if not_empty signal
                if ifRef_found
                  ERR::reportParseError( 
                      msg: "Found signal with duplicate name ->" + ownerName +
                                         "::%s<-", token: param.a1_rule_token ); 
                else
                  ifRef = candidateIfRef;
                  ifRef_found = true;
                end if;
              else
                select one op related by message->C_IO[R4004] where
                                                 selected.Name == param.a2_text;
                if not_empty op
                  if ifRef_found
                    ERR::reportParseError( 
                     msg: "Found interface operation with duplicate name ->" +
                             ownerName + "::%s<-", token: param.a1_rule_token ); 
                  else
                    ifRef = candidateIfRef;
                    ifRef_found = true;
                  end if;
                else
                  ERR::reportParseError( 
                     msg: "Internal error: subtype not found for message ->" +
                             ownerName + "::%s<-", token: param.a1_rule_token ); 
                end if;
              end if;
            end for;
          end for;
        else // ifRef cardinality 0 (internal error) or 1
          if not ifRef_found
            select any ifRef related by port->C_IR[R4016];
            if not_empty ifRef
              select many ios related by ifRef->C_I[R4012]->C_EP[R4003]->
                               C_IO[R4004] where selected.Name == param.a2_text;
              select many sigs related by ifRef->C_I[R4012]->C_EP[R4003]->
                               C_AS[R4004] where selected.Name == param.a2_text;
              if (cardinality ios + cardinality sigs) > 1
                ERR::reportParseError( 
                     msg: "Ambiguous message reference found ->" +
                             ownerName + "::%s<-", token: param.a1_rule_token ); 
              end if;
              ifRef_found = true;
            else
              ERR::reportParseError( 
               msg: "Internal error: interface reference not found on Port " +
                                   port.Name + " for message ->" + ownerName +
                                         "::%s<-", token: param.a1_rule_token ); 
            end if;
          else
            ERR::reportParseError( 
                     msg: "Ambiguous port or interface reference found ->" +
                             ownerName + "::%s<-", token: param.a1_rule_token ); 
          end if;
        end if;
      else // port name does not match the owner name . . .
        //    see if the interface name matches
        select many ifRefs related by port->C_IR[R4016];
        for each candidateIfRef in ifRefs
          select one interface related by candidateIfRef->C_I[R4012];
          if not_empty interface
            if interface.Name == ownerName
              if not ifRef_found
                select many ios related by candidateIfRef->C_I[R4012]->C_EP[R4003]->
                               C_IO[R4004] where selected.Name == param.a2_text;
                select many sigs related by candidateIfRef->C_I[R4012]->C_EP[R4003]->
                               C_AS[R4004] where selected.Name == param.a2_text;
                if (cardinality ios + cardinality sigs) > 1
                  ERR::reportParseError( 
                     msg: "Ambiguous message reference found ->" +
                             ownerName + "::%s<-", token: param.a1_rule_token );
                else
                  ifRef = candidateIfRef;
                  ifRef_found = true;
                end if;
              else
                ERR::reportParseError( 
                     msg: "Ambiguous interface or port reference found ->" +
                             ownerName + "::%s<-", token: param.a1_rule_token );
              end if;
            end if;
          end if;
        end for;
      end if;
    end for;
    if ifRef_found
      select any iop related by ifRef->C_I[R4012]->C_EP[R4003]->C_IO[R4004] where
                                                 selected.Name == param.a2_text;
      if not_empty iop
        direction = iop.Direction;
        directionResult = ::is_message_direction_valid(direction:direction,
                                                         interface_id:ifRef.Id);
        if(directionResult)
          return ::is_valid_message(a1_ifRef: ifRef.Id, a2_msgName: param.a2_text,
                                           a3_rule_token: param.a1_rule_token );
        else
          if(direction == IFDirectionType::ServerClient)
            ERR::reportParseError( 
                        msg: "The message ->" + ownerName +
                                         "::%s<- is specified as Server to " 
                                     + "Client, yet the invocation is from the "
                                 + "client.", token: param.a1_rule_token );
          else
            ERR::reportParseError( 
                        msg: "The message ->" + ownerName +
                                         "::%s<- is specified as Client to " 
                                      + "Server, yet the invocation is from the"
                                 + " server.", token: param.a1_rule_token );
          end if;
        end if;
      else
        select any sig related by ifRef->C_I[R4012]->C_EP[R4003]->
                               C_AS[R4004] where selected.Name == param.a2_text;
        if not_empty sig
          direction = sig.Direction;
          directionResult = ::is_message_direction_valid(direction:direction,
                                                         interface_id:ifRef.Id);
          if(directionResult)
            return ::is_valid_message(a1_ifRef:ifRef.Id, a2_msgName: param.a2_text, 
                                            a3_rule_token: param.a1_rule_token);
          else
            if(direction == IFDirectionType::ServerClient)
              ERR::reportParseError( 
                        msg: "The message ->" + ownerName +
                                         "::%s<- is specified as Server to " 
                                      + "Client, yet the invocation is from the"
                                 + " client.", token: param.a1_rule_token );
            else
              ERR::reportParseError( 
                        msg: "The message ->" + ownerName +
                                         "::%s<- is specified as Client to " 
                                      + "Server, yet the invocation is from the"
                                 + " server.", token: param.a1_rule_token );
            end if;
          end if;
        else
          ERR::reportParseError( 
            msg: "Cannot find message with name ->" + ownerName + "::%s<-",
                                                   token: param.a1_rule_token ); 
        end if;
      end if; // not_empty iop
    else
      ERR::reportParseError( 
          msg: "Internal error, cannot find interface or port with name ->" +
                             ownerName + "::%s<-", token: param.a1_rule_token ); 
    end if;  // not_empty interface
  end if;
  return GD::NULL_UNIQUE_ID();
else
  body.associateWithOwningComponent();
  select one component related by body->ACT_BIC[R694]->C_C[R694];
  if empty component
    ERR::reportParseError( 
         msg: "Signalling syntax is valid only in the context of a component",
                                                   token: param.a1_rule_token ); 
  else
    select any ifRef from instances of C_IR;
    ifRef_found = false;
    portFound = false;
    select many ports related by component->C_PO[R4010];
    for each port in ports
      if port.Name == ownerName
        if not portFound
          portFound = true;
        else
          ERR::reportParseError( 
                      msg: "Found port with duplicate name ->" +
                                 ownerName + "<-", token: param.a1_rule_token ); 
        end if;
        select many ifRefs related by port->C_IR[R4016];
        if cardinality ifRefs > 1
          for each candidateIfRef in ifRefs
            select many messages related by candidateIfRef->
                                                        C_I[R4012]->C_EP[R4003];
            for each message in messages
              select one signal related by message->C_AS[R4004] where
                                                 selected.Name == param.a2_text;
              if not_empty signal
                if ifRef_found
                  ERR::reportParseError( 
                      msg: "Found signal with duplicate name ->" + ownerName +
                                         "::%s<-", token: param.a1_rule_token ); 
                else
                  ifRef = candidateIfRef;
                  ifRef_found = true;
                end if;
              else
                select one op related by message->C_IO[R4004] where
                                                 selected.Name == param.a2_text;
                if not_empty op
                  if ifRef_found
                    ERR::reportParseError( 
                     msg: "Found interface operation with duplicate name ->" +
                             ownerName + "::%s<-", token: param.a1_rule_token ); 
                  else
                    ifRef = candidateIfRef;
                    ifRef_found = true;
                  end if;
                else
                  ERR::reportParseError( 
                     msg: "Internal error: subtype not found for message ->" +
                             ownerName + "::%s<-", token: param.a1_rule_token ); 
                end if;
              end if;
            end for;
          end for;
        else // ifRef cardinality 0 (internal error) or 1
          if not ifRef_found
            select any ifRef related by port->C_IR[R4016];
            if not_empty ifRef
              select many ios related by ifRef->C_I[R4012]->C_EP[R4003]->
                               C_IO[R4004] where selected.Name == param.a2_text;
              select many sigs related by ifRef->C_I[R4012]->C_EP[R4003]->
                               C_AS[R4004] where selected.Name == param.a2_text;
              if (cardinality ios + cardinality sigs) > 1
                ERR::reportParseError( 
                     msg: "Ambiguous message reference found ->" +
                             ownerName + "::%s<-", token: param.a1_rule_token ); 
              end if;
              ifRef_found = true;
            else
              ERR::reportParseError( 
               msg: "Internal error: interface reference not found on Port " +
                                   port.Name + " for message ->" + ownerName +
                                         "::%s<-", token: param.a1_rule_token ); 
            end if;
          else
            ERR::reportParseError( 
                     msg: "Ambiguous port or interface reference found ->" +
                             ownerName + "::%s<-", token: param.a1_rule_token ); 
          end if;
        end if;
      else // port name does not match the owner name . . .
        //    see if the interface name matches
        select many ifRefs related by port->C_IR[R4016];
        for each candidateIfRef in ifRefs
          select one interface related by candidateIfRef->C_I[R4012];
          if not_empty interface
            if interface.Name == ownerName
              if not ifRef_found
                select many ios related by candidateIfRef->C_I[R4012]->C_EP[R4003]->
                               C_IO[R4004] where selected.Name == param.a2_text;
                select many sigs related by candidateIfRef->C_I[R4012]->C_EP[R4003]->
                               C_AS[R4004] where selected.Name == param.a2_text;
                if (cardinality ios + cardinality sigs) > 1
                  ERR::reportParseError( 
                     msg: "Ambiguous message reference found ->" +
                             ownerName + "::%s<-", token: param.a1_rule_token );
                else
                  ifRef = candidateIfRef;
                  ifRef_found = true;
                end if;
              else
                ERR::reportParseError( 
                     msg: "Ambiguous interface or port reference found ->" +
                             ownerName + "::%s<-", token: param.a1_rule_token );
              end if;
            end if;
          end if;
        end for;
      end if;
    end for;
    if ifRef_found
      select any iop related by ifRef->C_I[R4012]->C_EP[R4003]->C_IO[R4004] where
                                                 selected.Name == param.a2_text;
      if not_empty iop
        direction = iop.Direction;
        directionResult = ::is_message_direction_valid(direction:direction,
                                                         interface_id:ifRef.Id);
        if(directionResult)
          return ::is_valid_message(a1_ifRef: ifRef.Id, a2_msgName: param.a2_text,
                                           a3_rule_token: param.a1_rule_token );
        else
          if(direction == IFDirectionType::ServerClient)
            ERR::reportParseError( 
                        msg: "The message ->" + ownerName +
                                         "::%s<- is specified as Server to " 
                                     + "Client, yet the invocation is from the "
                                 + "client.", token: param.a1_rule_token );
          else
            ERR::reportParseError( 
                        msg: "The message ->" + ownerName +
                                         "::%s<- is specified as Client to " 
                                      + "Server, yet the invocation is from the"
                                 + " server.", token: param.a1_rule_token );
          end if;
        end if;
      else
        select any sig related by ifRef->C_I[R4012]->C_EP[R4003]->
                               C_AS[R4004] where selected.Name == param.a2_text;
        if not_empty sig
          direction = sig.Direction;
          directionResult = ::is_message_direction_valid(direction:direction,
                                                         interface_id:ifRef.Id);
          if(directionResult)
            return ::is_valid_message(a1_ifRef:ifRef.Id, a2_msgName: param.a2_text, 
                                            a3_rule_token: param.a1_rule_token);
          else
            if(direction == IFDirectionType::ServerClient)
              ERR::reportParseError( 
                        msg: "The message ->" + ownerName +
                                         "::%s<- is specified as Server to " 
                                      + "Client, yet the invocation is from the"
                                 + " client.", token: param.a1_rule_token );
            else
              ERR::reportParseError( 
                        msg: "The message ->" + ownerName +
                                         "::%s<- is specified as Client to " 
                                      + "Server, yet the invocation is from the"
                                 + " server.", token: param.a1_rule_token );
            end if;
          end if;
        else
          ERR::reportParseError( 
            msg: "Cannot find message with name ->" + ownerName + "::%s<-",
                                                   token: param.a1_rule_token ); 
        end if;
      end if; // not_empty iop
    else
      ERR::reportParseError( 
          msg: "Internal error, cannot find interface or port with name ->" +
                             ownerName + "::%s<-", token: param.a1_rule_token ); 
    end if;  // not_empty interface
  end if;
  return GD::NULL_UNIQUE_ID();
end if;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5877,
	5876,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5878,
	5876,
	'a2_text',
	322,
	0,
	'',
	5877,
	'');
INSERT INTO S_SPARM
	VALUES (5879,
	5876,
	'a3_this_rule',
	296,
	0,
	'',
	5878,
	'');
INSERT INTO S_SPARM
	VALUES (5880,
	5876,
	'a4_upper_rule',
	296,
	0,
	'',
	5879,
	'');
INSERT INTO S_SPARM
	VALUES (5881,
	5876,
	'a5_upper_rule',
	296,
	0,
	'',
	5880,
	'');
INSERT INTO S_FIP
	VALUES (4666,
	5882);
INSERT INTO S_SYNC
	VALUES (5882,
	1,
	'Message_invocation_end',
	'ParserValidateFunction: TRUE',
	'// ::Message_invocation_validate()
// validate the parameters
select any msv from instances of V_MSV 
                                    where selected.Value_ID == param.a6_message;
select one msg_val related by msv->V_VAL[R801];
if not msv.ParmListOK
  // error already output, still need to clean up
  msg_val.dispose();
  return GD::NULL_UNIQUE_ID();
end if;
select one exProp related by msv->SPR_PEP[R841]->C_EP[R4501]; 
if(empty exProp)
  // if the executable property was not found
  // search for a required executable property
  select one exProp related by msv->SPR_REP[R845]->C_EP[R4500];
end if;
msgName = "";
select one sig related by exProp->C_AS[R4004];
if not_empty sig
  msgName = sig.Name;
else
  select one op related by exProp->C_IO[R4004];
  if not_empty op
    msgName = op.Name;
  else
    // TODO: Internal Error no associated message
    // should have been trapped before this
  end if;
end if;
select many vparm_set related by msv->V_PAR[R842];
select many pparm_set related by exProp->C_PP[R4006];
if ( cardinality vparm_set < cardinality pparm_set )
  // arguments are missing
  msg_val.dispose();
  ERR::reportParseError( msg: "Message ->" + msgName +
        "<- is missing corresponding parameter(s)",token: param.a1_rule_token );
else
  for each pparm in pparm_set
    found = false;
    for each vparm in vparm_set
      if ( pparm.Name == vparm.Name )
        found = true;
        err_msg = "";
        select one parm_val related by vparm->V_VAL[R800];
        select one vdt related by parm_val->S_DT[R820];
        if ( empty vdt or ::data_types_compatible( dt1: pparm.DT_ID,
                                         dt2: vdt.DT_ID, op: "assign")  ==
                                                          GD::NULL_UNIQUE_ID() )
          err_msg = "Parameter ->" + pparm.Name +
                              "<- has been assigned value of different type";
        end if;
        if (pparm.getDimensionsCnt()!= parm_val.getDimensions())
          err_msg = "Parameter ->"+ pparm.Name + "<- has incompatible array depth.";
        elif ( not parm_val.isElementCountValid() )
          err_msg = "Parameter ->"+ pparm.Name + "<- contains an Array Index Out of Bounds.";
        end if;      
        if (err_msg == "")
          break;
        else 
          msg_val.dispose();        
          ERR::reportParseError( msg: err_msg, token: param.a1_rule_token );
        end if;
      end if;
    end for;
    if not found
      msg_val.dispose();
      ERR::reportParseError( msg: "Bridge ->" + msgName +
                                  "<- is missing corresponding parameter(s)",
                                                   token: param.a1_rule_token );
    end if;
  end for;
  // If execution gets here, all the data items from the database
  // were found in the parse data items . . . .
  if ( cardinality vparm_set > cardinality pparm_set )
    // If there are more data items in the parse then were found in the
    // database, that means there were redundant or extra data items in the
    // parameter list found by the parse.  Generate an error.
    for each vparm in vparm_set
      found = false;
      for each pparm in pparm_set
        if pparm.Name == vparm.Name
          found = true;
          break;
        end if;
      end for;
      if not found
        msg_val.dispose();
        ERR::reportParseError( msg: "Parameter ->" + pparm.Name +
                      "<- is not associated with message ->"+ msgName +"<-",
                                                   token: param.a1_rule_token );
      end if;
    end for;
    // If it gets out of the loop without error, there must be
    // a redundant data item, so report the error
    msg_val.dispose();
    ERR::reportParseError( msg: "Message ->" + msgName +
                    "<- has redundant parameters", token: param.a1_rule_token );
  end if;
end if;
// Now check the optional local variable reference
if param.a8_variable != GD::NULL_UNIQUE_ID()
  errorInToClause = false;
  select any val from instances of V_VAL where
                                         selected.Value_ID == param.a8_variable;
  select one dt related by val->S_DT[R820];
  if empty dt or dt.Name != "component_ref"
    ERR::reportParseError(msg:"->to<- variable must be of type component_ref",
                                                   token: param.a1_rule_token );
    errorInToClause = true;
  end if;
  if val.getDimensions() != 0
    ERR::reportParseError(msg:"->to<- variable cannot be an array",
                                                   token: param.a1_rule_token );
    errorInToClause = true;
  end if;
  if val.Text == "sender" or val.Text == "Sender" or val.Text == "SENDER"
    errMsg = ::is_valid_implicit_component_addressing();
    if errMsg != ""
      ERR::reportParseError( msg: errMsg, token: param.a1_rule_token );
      errorInToClause = true;
    end if;
  end if;
  if not errorInToClause
    relate msv to val across R851;
  end if;
end if;

return param.a6_message;',
	296,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5883,
	5882,
	'a1_rule_token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_SPARM
	VALUES (5884,
	5882,
	'a2_upper_rule',
	296,
	0,
	'',
	5883,
	'');
INSERT INTO S_SPARM
	VALUES (5885,
	5882,
	'a3_start_rule',
	296,
	0,
	'',
	5884,
	'');
INSERT INTO S_SPARM
	VALUES (5886,
	5882,
	'a4_current_rule',
	296,
	0,
	'',
	5885,
	'');
INSERT INTO S_SPARM
	VALUES (5887,
	5882,
	'a5_interface',
	296,
	0,
	'',
	5886,
	'');
INSERT INTO S_SPARM
	VALUES (5888,
	5882,
	'a6_message',
	296,
	0,
	'',
	5887,
	'');
INSERT INTO S_SPARM
	VALUES (5889,
	5882,
	'a7_parameters',
	296,
	0,
	'',
	5888,
	'');
INSERT INTO S_SPARM
	VALUES (5890,
	5882,
	'a8_variable',
	296,
	0,
	'',
	5889,
	'');
-- BP 7.1.6 content: FunctionPackage syschar: 3 persistence-version: 7.1.6

INSERT INTO S_FPK
	VALUES (5891,
	'Context Menu Entry Functions',
	0,
	4397);
INSERT INTO S_FPIP
	VALUES (5891);
INSERT INTO PL_FPID
	VALUES (5891,
	1);
INSERT INTO S_FIP
	VALUES (5891,
	5892);
INSERT INTO S_SYNC
	VALUES (5892,
	1,
	'S_SYS_Delete',
	'The System class is mapped to the IProject resource, so use
the Eclipse DeleteResourceAction.  If OAL allowed an inst_ref_set parameter
for functions we could define the deleteResourceAction as a function and
translate this function as OAL.  Someday....
ContextMenuFunction: TRUE
Translate:native
',
	'int SystemModelcount = 0;
for (Iterator iterator = selection.iterator(); iterator.hasNext();) {
    Object context = iterator.next();
	if (context instanceof SystemModel_c) {
		SystemModelcount++;
	}
}
SystemModel_c[] systems = new SystemModel_c[SystemModelcount];
SystemModelcount = 0;

// Assign the context selection variables with the action context
for (Iterator iterator = selection.iterator(); iterator.hasNext();) {
	Object context = iterator.next();
	if (context instanceof SystemModel_c) {
		systems[SystemModelcount] = ((SystemModel_c) context);
		SystemModelcount++;
	}
}
if ( SystemModelcount > 0 )
{
    DeleteResourceAction dra = new DeleteResourceAction(PlatformUI.getWorkbench()
					.getActiveWorkbenchWindow().getShell());
    dra.selectionChanged(new StructuredSelection(systems));
    dra.run();
}
',
	19,
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5893);
INSERT INTO S_SYNC
	VALUES (5893,
	1,
	'S_SYS_Rename',
	'ContextMenuFunction: TRUE
',
	'select any sys from instances of S_SYS where USER::selectOne(id:selected.Sys_ID);
sys.Name = param.new_name;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5894,
	5893,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5895);
INSERT INTO S_SYNC
	VALUES (5895,
	1,
	'S_DOM_Delete',
	'ContextMenuFunction: TRUE
',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many doms from instances of S_DOM where USER::selectOne(id:selected.Dom_ID);
for each dom in doms
  dom.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5896);
INSERT INTO S_SYNC
	VALUES (5896,
	1,
	'S_DOM_Rename',
	'ContextMenuFunction: TRUE
',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any dom from instances of S_DOM where USER::selectOne(id:selected.Dom_ID);
dom.Name = param.new_name;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5897,
	5896,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5898);
INSERT INTO S_SYNC
	VALUES (5898,
	1,
	'S_SS_Delete',
	'ContextMenuFunction: TRUE
',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many sss from instances of S_SS where USER::selectOne(id:selected.SS_ID);
for each ss in sss
  ss.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5899);
INSERT INTO S_SYNC
	VALUES (5899,
	1,
	'S_SS_Rename',
	'ContextMenuFunction: TRUE
',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any ss from instances of S_SS where USER::selectOne(id:selected.SS_ID);
ss.Name = param.new_name;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5900,
	5899,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5901);
INSERT INTO S_SYNC
	VALUES (5901,
	1,
	'S_SYNC_Delete',
	'ContextMenuFunction: TRUE
',
	'select many fns from instances of S_SYNC where USER::selectOne(id:selected.Sync_ID);
for each fn in fns
  fn.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5902);
INSERT INTO S_SYNC
	VALUES (5902,
	1,
	'S_SYNC_Rename',
	'ContextMenuFunction: TRUE
',
	'select any fn from instances of S_SYNC where USER::selectOne(id:selected.Sync_ID);
fn.Name = param.new_name;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5903,
	5902,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5904);
INSERT INTO S_SYNC
	VALUES (5904,
	1,
	'S_SYNC_NewParameter',
	'ContextMenuFunction: TRUE
',
	'select any fn from instances of S_SYNC where USER::selectOne(id:selected.Sync_ID);
fn.newParameter();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5905);
INSERT INTO S_SYNC
	VALUES (5905,
	1,
	'S_SPARM_Delete',
	'ContextMenuFunction: TRUE
',
	'select many fps from instances of S_SPARM where USER::selectOne(id:selected.SParm_ID);
for each fp in fps
  fp.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5906);
INSERT INTO S_SYNC
	VALUES (5906,
	1,
	'S_SPARM_Rename',
	'ContextMenuFunction: TRUE
',
	'select any fnp from instances of S_SPARM where USER::selectOne(id:selected.SParm_ID);
fnp.Name = param.new_name;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5907,
	5906,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5908);
INSERT INTO S_SYNC
	VALUES (5908,
	1,
	'O_OBJ_Delete',
	'ContextMenuFunction: TRUE
',
	'select many classes from instances of O_OBJ where USER::selectOne(id:selected.Obj_ID);
for each clazz in classes
  clazz.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5909);
INSERT INTO S_SYNC
	VALUES (5909,
	1,
	'O_OBJ_Rename',
	'ContextMenuFunction: TRUE
',
	'select any clazz from instances of O_OBJ where USER::selectOne(id:selected.Obj_ID);
clazz.rename(new_name: param.new_name);',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5910,
	5909,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5911);
INSERT INTO S_SYNC
	VALUES (5911,
	1,
	'O_OBJ_NewOperation',
	'ContextMenuFunction: TRUE
',
	'select any clazz from instances of O_OBJ where USER::selectMany(id:selected.Obj_ID);
clazz.newOperation();

',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5912);
INSERT INTO S_SYNC
	VALUES (5912,
	1,
	'O_TFR_Delete',
	'ContextMenuFunction: TRUE
',
	'select many ops from instances of O_TFR where USER::selectOne(id:selected.Tfr_ID);
for each op in ops
  op.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5913);
INSERT INTO S_SYNC
	VALUES (5913,
	1,
	'O_TFR_Rename',
	'ContextMenuFunction: TRUE
',
	'select any operation from instances of O_TFR where USER::selectOne(id:selected.Tfr_ID);
operation.Name = param.new_name;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5914,
	5913,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5915);
INSERT INTO S_SYNC
	VALUES (5915,
	1,
	'O_TFR_NewParameter',
	'ContextMenuFunction: TRUE
',
	'select any operation from instances of O_TFR where USER::selectOne(id:selected.Tfr_ID);
operation.newParameter();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5916);
INSERT INTO S_SYNC
	VALUES (5916,
	1,
	'O_TPARM_Delete',
	'ContextMenuFunction: TRUE
',
	'select many tparms from instances of O_TPARM where USER::selectOne(id:selected.TParm_ID);
for each tparm in tparms
  tparm.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5917);
INSERT INTO S_SYNC
	VALUES (5917,
	1,
	'O_TPARM_Rename',
	'ContextMenuFunction: TRUE
',
	'select any parm from instances of O_TPARM where USER::selectOne(id:selected.TParm_ID);
parm.Name = param.new_name;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5918,
	5917,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5919);
INSERT INTO S_SYNC
	VALUES (5919,
	1,
	'S_FPK_Delete',
	'ContextMenuFunction: TRUE
',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many fPkgs from instances of S_FPK where USER::selectOne(id:selected.FunPack_ID);
for each fPkg in fPkgs
  fPkg.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5920);
INSERT INTO S_SYNC
	VALUES (5920,
	1,
	'S_FPK_Rename',
	'ContextMenuFunction: TRUE
',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any fPkg from instances of S_FPK where USER::selectOne(id:selected.FunPack_ID);
fPkg.Name = param.new_name;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5921,
	5920,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5922);
INSERT INTO S_SYNC
	VALUES (5922,
	1,
	'S_FPK_NewFunction',
	'ContextMenuFunction: TRUE
',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any fPkg from instances of S_FPK where USER::selectOne(id:selected.FunPack_ID);
fPkg.newFunction();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5923);
INSERT INTO S_SYNC
	VALUES (5923,
	1,
	'S_DPK_Delete',
	'ContextMenuFunction: TRUE
',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many dPkgs from instances of S_DPK where USER::selectOne(id:selected.Package_ID);
for each dPkg in dPkgs
  dPkg.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5924);
INSERT INTO S_SYNC
	VALUES (5924,
	1,
	'S_DPK_Rename',
	'ContextMenuFunction: TRUE
',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any dPkg from instances of S_DPK where USER::selectOne(id:selected.Package_ID);
dPkg.Name = param.new_name;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5925,
	5924,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5926);
INSERT INTO S_SYNC
	VALUES (5926,
	1,
	'S_EEPK_Delete',
	'ContextMenuFunction: TRUE
',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many ePkgs from instances of S_EEPK where USER::selectOne(id:selected.EEPack_ID);
for each ePkg in ePkgs
  ePkg.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5927);
INSERT INTO S_SYNC
	VALUES (5927,
	1,
	'S_EEPK_Rename',
	'ContextMenuFunction: TRUE
',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any ePkg from instances of S_EEPK where USER::selectOne(id:selected.EEPack_ID);
ePkg.Name = param.new_name;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5928,
	5927,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5929);
INSERT INTO S_SYNC
	VALUES (5929,
	1,
	'S_UDT_Delete',
	'ContextMenuFunction: TRUE
',
	'select many udts from instances of S_UDT where USER::selectOne(id:selected.DT_ID);
for each udt in udts
  select one dt related by udt->S_DT[R17];
  dt.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5930);
INSERT INTO S_SYNC
	VALUES (5930,
	1,
	'S_UDT_Rename',
	'ContextMenuFunction: TRUE
',
	'select any udt from instances of S_UDT where USER::selectOne(id:selected.DT_ID);
udt.rename(new_name:param.new_name);
',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5931,
	5930,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5932);
INSERT INTO S_SYNC
	VALUES (5932,
	1,
	'S_EDT_Delete',
	'ContextMenuFunction: TRUE
',
	'select many edts from instances of S_EDT where USER::selectOne(id:selected.DT_ID);
for each edt in edts
  select one dt related by edt->S_DT[R17];
  dt.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5933);
INSERT INTO S_SYNC
	VALUES (5933,
	1,
	'S_EDT_Rename',
	'ContextMenuFunction: TRUE
',
	'select any edt from instances of S_EDT where USER::selectOne(id:selected.DT_ID);
edt.rename(new_name:param.new_name);',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5934,
	5933,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5935);
INSERT INTO S_SYNC
	VALUES (5935,
	1,
	'S_EDT_NewEnumerator',
	'ContextMenuFunction: TRUE
',
	'select any edt from instances of S_EDT where USER::selectOne(id:selected.DT_ID);
edt.newEnumerator();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5936);
INSERT INTO S_SYNC
	VALUES (5936,
	1,
	'S_ENUM_Delete',
	'ContextMenuFunction: TRUE
',
	'select many eNums from instances of S_ENUM where USER::selectOne(id:selected.Enum_ID);
for each eNum in eNums
  eNum.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5937);
INSERT INTO S_SYNC
	VALUES (5937,
	1,
	'S_ENUM_Rename',
	'ContextMenuFunction: TRUE
',
	'select any enumerator from instances of S_ENUM where USER::selectOne(id:selected.Enum_ID);
enumerator.Name = param.new_name;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5938,
	5937,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5939);
INSERT INTO S_SYNC
	VALUES (5939,
	1,
	'S_EE_Delete',
	'ContextMenuFunction: TRUE
',
	'select many ees from instances of S_EE where USER::selectOne(id:selected.EE_ID);
for each ee in ees
  ee.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5940);
INSERT INTO S_SYNC
	VALUES (5940,
	1,
	'S_EE_Rename',
	'ContextMenuFunction: TRUE
',
	'select any ee from instances of S_EE where USER::selectOne(id:selected.EE_ID);
ee.Name = param.new_name;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5941,
	5940,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5942);
INSERT INTO S_SYNC
	VALUES (5942,
	1,
	'S_EE_NewBridgeOperation',
	'ContextMenuFunction: TRUE
',
	'select any ee from instances of S_EE where USER::selectOne(id:selected.EE_ID);
ee.newBridgeOperation();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5943);
INSERT INTO S_SYNC
	VALUES (5943,
	1,
	'S_BRG_Delete',
	'ContextMenuFunction: TRUE
',
	'select many brgs from instances of S_BRG where USER::selectOne(id:selected.Brg_ID);
for each brg in brgs
  brg.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5944);
INSERT INTO S_SYNC
	VALUES (5944,
	1,
	'S_BRG_Rename',
	'ContextMenuFunction: TRUE
',
	'select any brg from instances of S_BRG where USER::selectOne(id:selected.Brg_ID);
brg.Name = param.new_name;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5945,
	5944,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5946);
INSERT INTO S_SYNC
	VALUES (5946,
	1,
	'S_BRG_NewParameter',
	'ContextMenuFunction: TRUE
',
	'select any brg from instances of S_BRG where USER::selectOne(id:selected.Brg_ID);
brg.newParameter();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5947);
INSERT INTO S_SYNC
	VALUES (5947,
	1,
	'S_BPARM_Delete',
	'ContextMenuFunction: TRUE
',
	'select many bparms from instances of S_BPARM where USER::selectOne(id:selected.BParm_ID);
for each bparm in bparms
  bparm.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5948);
INSERT INTO S_SYNC
	VALUES (5948,
	1,
	'S_BPARM_Rename',
	'ContextMenuFunction: TRUE
',
	'select any bparm from instances of S_BPARM where USER::selectOne(id:selected.BParm_ID);
bparm.Name = param.new_name;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5949,
	5948,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5950);
INSERT INTO S_SYNC
	VALUES (5950,
	1,
	'O_OBJ_NewAttribute',
	'ContextMenuFunction: TRUE
',
	'select any clazz from instances of O_OBJ where USER::selectOne(id:selected.Obj_ID);
newAttr_id = clazz.newAttribute();',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5951);
INSERT INTO S_SYNC
	VALUES (5951,
	1,
	'O_ATTR_Delete',
	'ContextMenuFunction: TRUE
',
	'select many attrs from instances of O_ATTR where USER::selectOne(id:selected.Attr_ID);
select many ref_attr_set related by attrs->O_RATTR[R106];
delete_allowed = true;
for each ref_attr in ref_attr_set
  if ( not ref_attr.isOrphaned() )
    delete_allowed = false;
    break;
  end if;
end for;
if (not delete_allowed)
    USER::warning( msg: "Operation not allowed. Referential attributes are deleted by unformalizing or deleting their association." );
else
    // for each class-identifier which employs at least one of the
    // attributes to be deleted
    select many identifiers related by attrs->O_OIDA[R105]->O_ID[R105];
    for each identifier in identifiers
        // if this class-identifier is referenced by any association
        select many references related by identifier->R_RTO[R109];
        if (not_empty references)
            // for each member attribute of this class-identifier
            select many members related by identifier->O_ATTR[R105];
            found = false;
            for each member in members
                // for each attribute to be deleted
                for each toDelete in attrs
                    // if this method attribute is the same as this
                    // attribute to be deleted
                    if (member == toDelete)
                        // this member belongs to the set of those
                        // attributes to be deleted
                        found = true;
                        break;
                    end if;
                end for;
            end for;
             // if this member attribute was not found to be one of
            // those to be deleted
            if (found)
                // we cannot allow the delete, as it would orphan the
                // attributes that are referencing this identifier
                delete_allowed = false;
                USER::warning( msg: "Operation not allowed.  The attribute is being used to formalize one or more associations." );
                break;
            end if;
        end if;
    end for;
end if;

if (delete_allowed)
  for each attr in attrs
    attr.dispose();
  end for;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5952);
INSERT INTO S_SYNC
	VALUES (5952,
	1,
	'O_ATTR_Rename',
	'ContextMenuFunction: TRUE
',
	'select any attr from instances of O_ATTR where USER::selectOne(id:selected.Attr_ID);
attr.Root_Nam = param.new_name;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5953,
	5952,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5954);
INSERT INTO S_SYNC
	VALUES (5954,
	1,
	'O_OBJ_NewInstanceStateMachine',
	'ContextMenuFunction: TRUE
',
	'select any clazz from instances of O_OBJ where USER::selectOne(id:selected.Obj_ID);
ignore = clazz.create_sm(sm_type:"ISM");
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5955);
INSERT INTO S_SYNC
	VALUES (5955,
	1,
	'SM_ISM_Delete',
	'ContextMenuFunction: TRUE
',
	'select many isms from instances of SM_ISM where USER::selectOne(id:selected.SM_ID);
for each ism in isms
  select one sm related by ism->SM_SM[R517];
  sm.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5956);
INSERT INTO S_SYNC
	VALUES (5956,
	1,
	'SM_STATE_Delete',
	'ContextMenuFunction: TRUE
',
	'select many smstates from instances of SM_STATE where USER::selectOne(id:selected.SMstt_ID);
for each smstate in smstates
  smstate.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5957);
INSERT INTO S_SYNC
	VALUES (5957,
	1,
	'SM_STATE_Rename',
	'ContextMenuFunction: TRUE
',
	'select any smstate from instances of SM_STATE where USER::selectOne(id:selected.SMstt_ID);
smstate.Name = param.new_name;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5958,
	5957,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5959);
INSERT INTO S_SYNC
	VALUES (5959,
	1,
	'SM_ISM_NewEvent',
	'ContextMenuFunction: TRUE
',
	'select any ism from instances of SM_ISM where USER::selectOne(id:selected.SM_ID);
ism.newEvent();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5960);
INSERT INTO S_SYNC
	VALUES (5960,
	1,
	'SM_EVT_Delete',
	'ContextMenuFunction: TRUE
',
	'select many evts from instances of SM_EVT where USER::selectOne(id:selected.SMevt_ID);
for each evt in evts
  evt.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5961);
INSERT INTO S_SYNC
	VALUES (5961,
	1,
	'SM_EVT_Rename',
	'ContextMenuFunction: TRUE
',
	'select any evt from instances of SM_EVT where USER::selectOne(id:selected.SMevt_ID);
select one pevt related by evt->SM_PEVT[R525];
// if this event is polymorphic, update all non-local
// event''s meanings
if(not_empty pevt)
  select many nlevts related by pevt->SM_NLEVT[R527];
  for each nlevt in nlevts
    select one childEvt related by nlevt->SM_SEVT[R526]->SM_EVT[R525];
    childEvt.Mning = param.new_name;
  end for;
end if;
evt.Mning = param.new_name;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5962,
	5961,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5963);
INSERT INTO S_SYNC
	VALUES (5963,
	1,
	'SM_EVTDI_Delete',
	'ContextMenuFunction: TRUE
',
	'select many evtdis from instances of SM_EVTDI where USER::selectOne(id:selected.SMedi_ID);
for each evtdi in evtdis
  evtdi.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5964);
INSERT INTO S_SYNC
	VALUES (5964,
	1,
	'SM_EVTDI_Rename',
	'ContextMenuFunction: TRUE
',
	'select any evtdi from instances of SM_EVTDI where USER::selectOne(id:selected.SMedi_ID);
evtdi.Name = param.new_name;
',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5965,
	5964,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5966);
INSERT INTO S_SYNC
	VALUES (5966,
	1,
	'O_OBJ_NewClassStateMachine',
	'ContextMenuFunction: TRUE
',
	'select any clazz from instances of O_OBJ where USER::selectOne(id:selected.Obj_ID);
ignore = clazz.create_sm(sm_type:"ASM");
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5967);
INSERT INTO S_SYNC
	VALUES (5967,
	1,
	'SM_ASM_Delete',
	'ContextMenuFunction: TRUE
',
	'select many asms from instances of SM_ASM where USER::selectOne(id:selected.SM_ID);
for each asm in asms
  select one sm related by asm->SM_SM[R517];
  sm.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5968);
INSERT INTO S_SYNC
	VALUES (5968,
	1,
	'SM_ASM_NewEvent',
	'ContextMenuFunction: TRUE
',
	'select any asm from instances of SM_ASM where USER::selectOne(id:selected.SM_ID);
asm.newEvent();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5969);
INSERT INTO S_SYNC
	VALUES (5969,
	1,
	'O_IOBJ_Delete',
	'ContextMenuFunction: TRUE',
	'select many classes from instances of O_IOBJ where USER::selectMany(id:selected.IObj_ID);
for each clazz in classes
  clazz.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5970);
INSERT INTO S_SYNC
	VALUES (5970,
	1,
	'R_REL_Delete',
	'ContextMenuFunction: TRUE',
	'select many rels from instances of R_REL where USER::selectMany(id:selected.Rel_ID);
for each rel in rels
  rel.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5971);
INSERT INTO S_SYNC
	VALUES (5971,
	1,
	'SM_TXN_Delete',
	'ContextMenuFunction: TRUE',
	'select many trans from instances of SM_TXN where USER::selectMany(id:selected.Trans_ID);
for each tran in trans
  tran.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5972);
INSERT INTO S_SYNC
	VALUES (5972,
	1,
	'R_ASSR_Delete',
	'ContextMenuFunction: TRUE',
	'select many links from instances of R_ASSR where USER::selectMany(id:selected.Obj_ID);
for each link in links
  select one cia related by link->R_RGO[R205]->R_OIR[R203];
  if (not_empty cia)
    cia.dispose();
  end if;
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5973);
INSERT INTO S_SYNC
	VALUES (5973,
	1,
	'R_SUB_Delete',
	'ContextMenuFunction: TRUE',
	'select many subs from instances of R_SUB where USER::selectMany(id:selected.Obj_ID);
for each sub in subs
  select one cia related by sub->R_RGO[R205]->R_OIR[R203];
  if (not_empty cia)
    cia.dispose();
  end if;
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5974);
INSERT INTO S_SYNC
	VALUES (5974,
	1,
	'SQ_S_Delete',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many sequences from instances of SQ_S where USER::selectOne(id:selected.Package_ID);
for each sequence in sequences
  sequence.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5975);
INSERT INTO S_SYNC
	VALUES (5975,
	1,
	'SQ_S_Rename',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any sequence from instances of SQ_S where USER::selectOne(id:selected.Package_ID);
if(not_empty sequence)
  sequence.Name = param.new_name;
end if;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5976,
	5975,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5977);
INSERT INTO S_SYNC
	VALUES (5977,
	1,
	'SQ_EEP_Delete',
	'ContextMenuFunction: TRUE',
	'select many participants from instances of SQ_EEP where USER::selectOne(id:selected.Part_ID);
for each participant in participants
  participant.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5978);
INSERT INTO S_SYNC
	VALUES (5978,
	1,
	'SQ_EEP_Rename',
	'ContextMenuFunction: TRUE',
	'select any participant from instances of SQ_EEP where USER::selectOne(id:selected.Part_ID);
if(not_empty participant)
  participant.InformalName = param.new_name;
end if;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5979,
	5978,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5980);
INSERT INTO S_SYNC
	VALUES (5980,
	1,
	'SQ_CP_Delete',
	'ContextMenuFunction: TRUE',
	'select many participants from instances of SQ_CP where USER::selectOne(id:selected.Part_ID);
for each participant in participants
  participant.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5981);
INSERT INTO S_SYNC
	VALUES (5981,
	1,
	'SQ_CP_Rename',
	'ContextMenuFunction: TRUE',
	'select any participant from instances of SQ_CP where USER::selectOne(id:selected.Part_ID);
if(not_empty participant)
  participant.InformalName = param.new_name;
end if;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5982,
	5981,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5983);
INSERT INTO S_SYNC
	VALUES (5983,
	1,
	'SQ_FPP_Delete',
	'ContextMenuFunction: TRUE',
	'select many participants from instances of SQ_FPP where USER::selectOne(id:selected.Part_ID);
for each participant in participants
  participant.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5984);
INSERT INTO S_SYNC
	VALUES (5984,
	1,
	'SQ_FPP_Rename',
	'ContextMenuFunction: TRUE',
	'select any participant from instances of SQ_FPP where USER::selectOne(id:selected.Part_ID);
if(not_empty participant)
  participant.InformalName = param.new_name;
end if;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5985,
	5984,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5986);
INSERT INTO S_SYNC
	VALUES (5986,
	1,
	'SQ_CIP_Delete',
	'ContextMenuFunction: TRUE',
	'select many participants from instances of SQ_CIP where USER::selectOne(id:selected.Part_ID);
for each participant in participants
  participant.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5987);
INSERT INTO S_SYNC
	VALUES (5987,
	1,
	'SQ_CIP_Rename',
	'ContextMenuFunction: TRUE',
	'select any participant from instances of SQ_CIP where USER::selectOne(id:selected.Part_ID);
if(not_empty participant)
  participant.Name = param.new_name;
end if;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5988,
	5987,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5989);
INSERT INTO S_SYNC
	VALUES (5989,
	1,
	'SQ_TM_Delete',
	'ContextMenuFunction: TRUE',
	'select many marks from instances of SQ_TM where USER::selectOne(id:selected.Mark_ID);
for each mark in marks
  mark.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5990);
INSERT INTO S_SYNC
	VALUES (5990,
	1,
	'SQ_TM_Rename',
	'ContextMenuFunction: TRUE',
	'select any mark from instances of SQ_TM where USER::selectOne(id:selected.Mark_ID);
if(not_empty mark)
  mark.Name = param.new_name;
end if;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5991,
	5990,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5992);
INSERT INTO S_SYNC
	VALUES (5992,
	1,
	'SQ_TS_Delete',
	'ContextMenuFunction: TRUE',
	'select many spans from instances of SQ_TS where USER::selectOne(id:selected.Span_ID);
for each span in spans
  span.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5993);
INSERT INTO S_SYNC
	VALUES (5993,
	1,
	'SQ_TS_Rename',
	'ContextMenuFunction: TRUE',
	'select any span from instances of SQ_TS where USER::selectOne(id:selected.Span_ID);
if(not_empty span)
  span.Name = param.new_name;
end if;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (5994,
	5993,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5995);
INSERT INTO S_SYNC
	VALUES (5995,
	1,
	'SQ_LS_Delete',
	'ContextMenuFunction: TRUE',
	'select many participants from instances of SQ_LS where USER::selectOne(id:selected.Part_ID);
for each participant in participants
  participant.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5996);
INSERT INTO S_SYNC
	VALUES (5996,
	1,
	'SQ_CIP_SpecializedPackageInstanceFormalize',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any cip from instances of SQ_CIP where USER::selectOne(id:selected.Part_ID);
select one mclass related by cip->O_OBJ[R934];
  existingId = GD::NULL_UNIQUE_ID();
  if(not_empty mclass)
    existingId = mclass.Obj_ID;
  end if;
select one participant related by cip->SQ_P[R930];
select one sequence related by participant->SQ_S[R929];
select one communication related by participant->COMM_COMM[R1126];
domName = "";
if(not_empty sequence)
  domName = sequence.getPath(domainNameOnly:true);
elif(not_empty communication)
  domName = communication.getPath(domainNameOnly:true);
end if;
select any domain from instances of S_DOM where (selected.Name == domName);
select any Subsystem related by domain->S_SS[R1] where USER::selectOne(id:selected.SS_ID);
if ( not_empty Subsystem )
  select any Class related by Subsystem->O_OBJ[R2]
               where USER::selectOne(id:selected.Obj_ID) and selected.Obj_ID != existingId;
  if ( not_empty Class )
    cip.formalize(classId:Class.Obj_ID); 
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5997);
INSERT INTO S_SYNC
	VALUES (5997,
	1,
	'MSG_SM_InstanceOperationFormalize',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any syncMessage from instances of MSG_SM where USER::selectOne(id:selected.Msg_ID);
select one operation related by syncMessage->MSG_O[R1020]->O_TFR[R1011];
existingId = GD::NULL_UNIQUE_ID();
if(not_empty operation)
  existingId = operation.Tfr_ID;
end if;
select one message related by syncMessage->MSG_M[R1018];
select one participant related by message->SQ_P[R1007];
select one ls related by participant->SQ_LS[R930];
select any mclass from instances of O_OBJ where (selected.Obj_ID == GD::NULL_UNIQUE_ID());
if(not_empty ls)
  select one cip related by ls->SQ_P[R940]->SQ_CIP[R930];
  if(not_empty cip)
    select one mclass related by cip->O_OBJ[R934];
  end if;
else
  // see if this message is on a communication
  select one cip related by message->SQ_P[R1007]->SQ_CIP[R930];

  if(not_empty cip)
    select one communication related by cip->SQ_P[R930]->COMM_PIC[R1126]->COMM_COMM[R1126];
    if(not_empty communication or message.participatesInCommunication)
      select one mclass related by cip->O_OBJ[R934];
    end if;
  end if;  
end if;
if(not_empty mclass)
  select any Message related by mclass->O_TFR[R115]
                                   where USER::selectOne(id:selected.Tfr_ID) and
     ((selected.Instance_Based == Scope::Instance) and (selected.Tfr_ID != existingId));
  if(not_empty Message)
    syncMessage.formalizeWithClassOperation(operationId:Message.Tfr_ID);
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5998);
INSERT INTO S_SYNC
	VALUES (5998,
	1,
	'MSG_AM_ClassEventFormalize',
	'ContextMenuFunction: TRUE',
	'select any asyncMessage from instances of MSG_AM where USER::selectOne(id:selected.Msg_ID);
select one message related by asyncMessage->MSG_M[R1018];
select one participant related by message->SQ_P[R1007];
select one cp related by participant->SQ_CP[R930];
if(empty cp)
  // try the communication line
  select one cp related by participant->SQ_LS[R930]->SQ_P[R940]->SQ_CP[R930];
end if;
select one mclass related by cp->O_OBJ[R939];
if(not_empty mclass)
  select one stateMachine related by mclass->SM_ASM[R519]->SM_SM[R517];
  select one asm related by mclass->SM_ASM[R519];
  select one ism related by mclass->SM_ISM[R518];
  // the action filter will guarantee that at least one state machine
  // exists, but not both
  asmId = GD::NULL_UNIQUE_ID(); 
  ismId = GD::NULL_UNIQUE_ID();
  if(not_empty asm)
    asmId = asm.SM_ID;
  end if;
  if(not_empty ism)
    ismId = ism.SM_ID;
  end if;
  select one evt related by asyncMessage->MSG_E[R1019]->SM_EVT[R1009];
  existingId = GD::NULL_UNIQUE_ID();
  if(not_empty evt)
    existingId = evt.SMevt_ID;
  end if;
  select many machines from instances of SM_SM where (selected.SM_ID == asmId) or (selected.SM_ID == ismId);
  select any Message related by machines->SM_EVT[R502] where USER::selectOne(id:selected.SMevt_ID) and
		  ((mclass.eventIsClassBased(eventId:selected.SMevt_ID, 
			 	  instanceStateMachineId:ismId,classStateMachineId:asmId)) and 
			 	  (selected.SMevt_ID != existingId));
  if(not_empty Message)
    asyncMessage.formalizeWithEvent(eventId:Message.SMevt_ID);
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	5999);
INSERT INTO S_SYNC
	VALUES (5999,
	1,
	'SQ_EEP_SpecializedPackageExternalEntityFormalize',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any eep from instances of SQ_EEP where USER::selectOne(id:selected.Part_ID);
select one ee related by eep->S_EE[R933];
existingId = GD::NULL_UNIQUE_ID();
if(not_empty ee)
  existingId = ee.EE_ID;
end if;
select one participant related by eep->SQ_P[R930];

select one sequence related by participant->SQ_S[R929];
select one communication related by participant->COMM_COMM[R1126];
domName = "";
if(not_empty sequence)
  domName = sequence.getPath(domainNameOnly:true);
elif(not_empty communication)
  domName = communication.getPath(domainNameOnly:true);
end if;
select any domain from instances of S_DOM where (selected.Name == domName);
if ( not_empty domain )
  select any Package related by domain->S_EEPK[R300] where USER::selectOne(id:selected.EEPack_ID);
  if(not_empty Package)
    select any Entity related by Package->S_EEIP[R33]->S_EE[R33]
                    where USER::selectOne(id:selected.EE_ID) and selected.EE_ID != existingId;
    if ( not_empty Entity )
      eep.formalize(eeId:Entity.EE_ID);
    end if;
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6000);
INSERT INTO S_SYNC
	VALUES (6000,
	1,
	'SQ_FPP_Formalize',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any fpp from instances of SQ_FPP where USER::selectOne(id:selected.Part_ID);
select one fpk related by fpp->S_FPK[R932];
existingId = GD::NULL_UNIQUE_ID();
if(not_empty fpk)
  existingId = fpk.FunPack_ID;
end if;
select one participant related by fpp->SQ_P[R930];

select one packageableElem related by participant->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;
select one sequence related by participant->SQ_S[R929];
select one communication related by participant->COMM_COMM[R1126];
domName = "";
if(not_empty sequence)
  domName = sequence.getPath(domainNameOnly:true);
elif(not_empty communication)
  domName = communication.getPath(domainNameOnly:true);
end if;
select any domain from instances of S_DOM where (selected.Name == domName);
if ( not_empty domain )
  select any Package related by domain->PL_FPID[R301]->S_FPK[R301]
              where USER::selectOne(id:selected.FunPack_ID) and selected.FunPack_ID != existingId;
  if ( not_empty Package )
    fpp.formalize(fpId:Package.FunPack_ID);
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6001);
INSERT INTO S_SYNC
	VALUES (6001,
	1,
	'SQ_CIP_NewAttribute',
	'ContextMenuFunction: TRUE',
	'select any cip from instances of SQ_CIP where USER::selectOne(id:selected.Part_ID);
if(not_empty cip)
  cip.newInstanceAttributeValue();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6002);
INSERT INTO S_SYNC
	VALUES (6002,
	1,
	'SQ_CP_SpecializedPackageClassFormalize',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any cp from instances of SQ_CP where USER::selectOne(id:selected.Part_ID);
select one mclass related by cp->O_OBJ[R939];
existingId = GD::NULL_UNIQUE_ID();
if(not_empty mclass)
  existingId = mclass.Obj_ID;
end if;
select one participant related by cp->SQ_P[R930];
select one sequence related by participant->SQ_S[R929];
select one communication related by participant->COMM_COMM[R1126];
domName = "";
if(not_empty sequence)
  domName = sequence.getPath(domainNameOnly:true);
elif(not_empty communication)
  domName = communication.getPath(domainNameOnly:true);
end if;
select any domain from instances of S_DOM where (selected.Name == domName);
select any Subsystem related by domain->S_SS[R1] where USER::selectOne(id:selected.SS_ID);
if ( not_empty Subsystem )
  select any Class related by Subsystem->O_OBJ[R2]
               where USER::selectOne(id:selected.Obj_ID) and selected.Obj_ID != existingId;
  if ( not_empty Class )
    cp.formalize(classId:Class.Obj_ID);
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6003);
INSERT INTO S_SYNC
	VALUES (6003,
	1,
	'MSG_SM_BridgeOperationFormalize',
	'ContextMenuFunction: TRUE',
	'select any syncMessage from instances of MSG_SM where USER::selectOne(id:selected.Msg_ID);
select one bridgeOp related by syncMessage->MSG_B[R1020]->S_BRG[R1012];
existingId = GD::NULL_UNIQUE_ID();
if(not_empty bridgeOp)
  existingId = bridgeOp.Brg_ID;
end if;
select one message related by syncMessage->MSG_M[R1018];
select one participant related by message->SQ_P[R1007];
select one eep related by participant->SQ_EEP[R930];
if(empty eep)
  // consider lifeline
  select one eep related by participant->SQ_LS[R930]->SQ_P[R940]->SQ_EEP[R930];
end if;
select one ee related by eep->S_EE[R933];
if(not_empty ee)
  select any Message related by ee->S_BRG[R19]
             where USER::selectOne(id:selected.Brg_ID) and selected.Brg_ID != existingId;
  if(not_empty Message)
    syncMessage.formalizeWithBridgeOperation(bridgeId:Message.Brg_ID);
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6004);
INSERT INTO S_SYNC
	VALUES (6004,
	1,
	'MSG_SM_FunctionFormalize',
	'ContextMenuFunction: TRUE',
	'select any syncMessage from instances of MSG_SM where USER::selectOne(id:selected.Msg_ID);
select one message related by syncMessage->MSG_M[R1018];
select one participant related by message->SQ_P[R1007];
select one function related by syncMessage->MSG_F[R1020]->S_SYNC[R1010];
existingId = GD::NULL_UNIQUE_ID();
if(not_empty function)
  existingId = function.Sync_ID;
end if;
select one fpp related by participant->SQ_FPP[R930];
if(empty fpp)
  select one fpp related by participant->SQ_LS[R930]->SQ_P[R940]->SQ_FPP[R930];
end if;
if(not_empty fpp)
  select one fpk related by fpp->S_FPK[R932];
  if(not_empty fpk)
    select any Message related by fpk->S_FIP[R31]->S_SYNC[R31]
            where USER::selectOne(id:selected.Sync_ID) and selected.Sync_ID != existingId;
    if(not_empty Message)
      syncMessage.formalizeWithFunction(functionId:Message.Sync_ID);
    end if;
  end if;
end if;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6005);
INSERT INTO S_SYNC
	VALUES (6005,
	1,
	'SQ_CP_NewAttribute',
	'ContextMenuFunction: TRUE',
	'select any cp from instances of SQ_CP where USER::selectOne(id:selected.Part_ID);
if(not_empty cp)
  cp.newAttribute();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6006);
INSERT INTO S_SYNC
	VALUES (6006,
	1,
	'SQ_CIP_InstanceUnformalize',
	'ContextMenuFunction: TRUE',
	'select any cip from instances of SQ_CIP where USER::selectOne(id:selected.Part_ID);
if(not_empty cip)
  cip.unformalize();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6007);
INSERT INTO S_SYNC
	VALUES (6007,
	1,
	'SQ_CP_ClassUnformalize',
	'ContextMenuFunction: TRUE',
	'select any cp from instances of SQ_CP where USER::selectOne(id:selected.Part_ID);
if(not_empty cp)
  cp.unformalize();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6008);
INSERT INTO S_SYNC
	VALUES (6008,
	1,
	'SQ_EEP_ExternalEntityUnformalize',
	'ContextMenuFunction: TRUE',
	'select any eep from instances of SQ_EEP where USER::selectOne(id:selected.Part_ID);
if(not_empty eep)
  eep.unformalize();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6009);
INSERT INTO S_SYNC
	VALUES (6009,
	1,
	'SQ_FPP_FunctionPackageUnformalize',
	'ContextMenuFunction: TRUE',
	'select any fpp from instances of SQ_FPP where USER::selectOne(id:selected.Part_ID);
if(not_empty fpp)
  fpp.unformalize();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6010);
INSERT INTO S_SYNC
	VALUES (6010,
	1,
	'MSG_SM_ClassOperationFormalize',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any syncMessage from instances of MSG_SM where USER::selectOne(id:selected.Msg_ID);
select one operation related by syncMessage->MSG_O[R1020]->O_TFR[R1011];
existingId = GD::NULL_UNIQUE_ID();
if(not_empty operation)
  existingId = operation.Tfr_ID;
end if;
select one message related by syncMessage->MSG_M[R1018];
select one participant related by message->SQ_P[R1007];
select one cp related by participant->SQ_CP[R930];
if(empty cp)
  // consider communication line
  select one cp related by participant->SQ_LS[R930]->SQ_P[R940]->SQ_CP[R930];
end if;
select one cip related by participant->SQ_CIP[R930];
select one mclass related by cp->O_OBJ[R939];
if(empty mclass) and (not_empty cip)
  // only allow if not on a communication
  select one communication related by cip->SQ_P[R930]->COMM_PIC[R1126]->COMM_COMM[R1126];
  if(empty communication or not message.participatesInCommunication)
    select one mclass related by cip->O_OBJ[R934];
  end if;
end if;
if(not_empty mclass)
  select any Message related by mclass->O_TFR[R115]
                                   where USER::selectOne(id:selected.Tfr_ID) and
        ((selected.Instance_Based == Scope::Class) and (selected.Tfr_ID != existingId));
  if(not_empty Message)
    syncMessage.formalizeWithClassOperation(operationId:Message.Tfr_ID);
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6011);
INSERT INTO S_SYNC
	VALUES (6011,
	1,
	'MSG_AM_InstanceEventFormalize',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any asyncMessage from instances of MSG_AM where USER::selectOne(id:selected.Msg_ID);
select one message related by asyncMessage->MSG_M[R1018];
select one participant related by message->SQ_P[R1007];
select one ls related by participant->SQ_LS[R930];
select one cip related by ls->SQ_P[R940]->SQ_CIP[R930];
select any cipclass from instances of O_OBJ where (selected.Obj_ID == GD::NULL_UNIQUE_ID());
if(not_empty cip)
  select one cipclass related by cip->O_OBJ[R934];
else
  select one cip related by message->SQ_P[R1007]->SQ_CIP[R930];
  if(not_empty cip)
    select one communication related by cip->SQ_P[R930]->COMM_PIC[R1126]->COMM_COMM[R1126];
    if(not_empty communication)
      select one cipclass related by cip->O_OBJ[R934];
    end if;
  end if;
end if;
if(not_empty cipclass)
  select one evt related by asyncMessage->MSG_E[R1019]->SM_EVT[R1009];
  existingId = GD::NULL_UNIQUE_ID();
  if(not_empty evt)
    existingId = evt.SMevt_ID;
  end if;
  select one stateMachine related by cipclass->SM_ISM[R518]->SM_SM[R517];
  select many machines related by cipclass->PE_PE[R8001]->EP_PKG[R8000]
                                     ->S_SYS[R1405]->EP_PKG[R1405]->PE_PE[R8000]
                                      ->O_OBJ[R8001]->SM_ISM[R518]->SM_SM[R517];
  if(empty machines)
    select many machines related by cipclass->S_SS[R2]->S_DOM[R1]->S_SS[R1]
                             	  	     ->O_OBJ[R2]->SM_ISM[R518]->SM_SM[R517];
  end if;
  select any Message related by machines->SM_EVT[R502] where
        USER::selectOne(id:selected.SMevt_ID) and ((stateMachine.canAssignEvent(
                  eventId:selected.SMevt_ID, eventStateMachineId:selected.SM_ID,
            isCreationTransition:false)) and (selected.SMevt_ID != existingId));
  if(not_empty Message)
    asyncMessage.formalizeWithEvent(eventId:Message.SMevt_ID);
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6012);
INSERT INTO S_SYNC
	VALUES (6012,
	1,
	'SQ_LS_MarkInstanceDestroyed',
	'ContextMenuFunction: TRUE',
	'select any ls from instances of SQ_LS where USER::selectOne(id:selected.Part_ID);
if(not_empty ls)
  ls.Destroyed = true;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6013);
INSERT INTO S_SYNC
	VALUES (6013,
	1,
	'SQ_LS_MarkInstanceNotDestroyed',
	'ContextMenuFunction: TRUE',
	'select any ls from instances of SQ_LS where USER::selectOne(id:selected.Part_ID);
if(not_empty ls)
  ls.Destroyed = false;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6014);
INSERT INTO S_SYNC
	VALUES (6014,
	1,
	'SQ_CPA_Delete',
	'ContextMenuFunction: TRUE',
	'select many attrs from instances of SQ_CPA where USER::selectOne(id:selected.Ia_ID);
for each attr in attrs
  attr.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6015);
INSERT INTO S_SYNC
	VALUES (6015,
	1,
	'SQ_AV_Delete',
	'ContextMenuFunction: TRUE',
	'select many avs from instances of SQ_AV where USER::selectOne(id:selected.Av_ID);
for each av in avs
  av.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6016);
INSERT INTO S_SYNC
	VALUES (6016,
	1,
	'SQ_CPA_Rename',
	'ContextMenuFunction: TRUE',
	'select any attr from instances of SQ_CPA where USER::selectOne(id:selected.Ia_ID);
if(not_empty attr)
  attr.Name = param.new_name;
end if;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (6017,
	6016,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6018);
INSERT INTO S_SYNC
	VALUES (6018,
	1,
	'SQ_AV_Rename',
	'ContextMenuFunction: TRUE',
	'select any av from instances of SQ_AV where USER::selectOne(id:selected.Av_ID);
if(not_empty av)
  av.InformalName = param.new_name;
end if;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (6019,
	6018,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6020);
INSERT INTO S_SYNC
	VALUES (6020,
	1,
	'SQ_AP_Rename',
	'ContextMenuFunction: TRUE',
	'select any ap from instances of SQ_AP where USER::selectOne(id:selected.Part_ID);
if(not_empty ap)
  ap.Name = param.new_name;
end if;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (6021,
	6020,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6022);
INSERT INTO S_SYNC
	VALUES (6022,
	1,
	'SQ_AP_Delete',
	'ContextMenuFunction: TRUE',
	'select many aps from instances of SQ_AP where USER::selectOne(id:selected.Part_ID);
for each ap in aps
  ap.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6023);
INSERT INTO S_SYNC
	VALUES (6023,
	1,
	'MSG_R_NewArgument',
	'ContextMenuFunction: TRUE',
	'select any message from instances of MSG_R where USER::selectOne(id:selected.Msg_ID);
if(not_empty message)
  message.newArgument();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6024);
INSERT INTO S_SYNC
	VALUES (6024,
	1,
	'MSG_SM_NewArgument',
	'ContextMenuFunction: TRUE',
	'select any message from instances of MSG_SM where USER::selectOne(id:selected.Msg_ID);
if(not_empty message)
  message.newArgument();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6025);
INSERT INTO S_SYNC
	VALUES (6025,
	1,
	'MSG_AM_NewArgument',
	'ContextMenuFunction: TRUE',
	'select any message from instances of MSG_AM where USER::selectOne(id:selected.Msg_ID);
if(not_empty message)
  message.newArgument();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6026);
INSERT INTO S_SYNC
	VALUES (6026,
	1,
	'MSG_SM_MessageUnformalize',
	'ContextMenuFunction: TRUE',
	'select any message from instances of MSG_SM where USER::selectOne(id:selected.Msg_ID);
if(not_empty message)
  message.unformalize();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6027);
INSERT INTO S_SYNC
	VALUES (6027,
	1,
	'MSG_AM_MessageUnformalize',
	'ContextMenuFunction: TRUE',
	'select any message from instances of MSG_AM where USER::selectOne(id:selected.Msg_ID);
if(not_empty message)
  message.unformalize();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6028);
INSERT INTO S_SYNC
	VALUES (6028,
	1,
	'MSG_SM_Delete',
	'ContextMenuFunction: TRUE',
	'select many messages from instances of MSG_SM where USER::selectOne(id:selected.Msg_ID);
for each message in messages
  message.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6029);
INSERT INTO S_SYNC
	VALUES (6029,
	1,
	'MSG_SM_Rename',
	'ContextMenuFunction: TRUE',
	'select any message from instances of MSG_SM where USER::selectOne(id:selected.Msg_ID);
if(not_empty message)
  message.InformalName = param.new_name;
end if;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (6030,
	6029,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6031);
INSERT INTO S_SYNC
	VALUES (6031,
	1,
	'MSG_AM_Delete',
	'ContextMenuFunction: TRUE',
	'select many messages from instances of MSG_AM where USER::selectOne(id:selected.Msg_ID);
for each message in messages
  message.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6032);
INSERT INTO S_SYNC
	VALUES (6032,
	1,
	'MSG_AM_Rename',
	'ContextMenuFunction: TRUE',
	'select any message from instances of MSG_AM where USER::selectOne(id:selected.Msg_ID);
if(not_empty message)
  message.InformalName = param.new_name;
end if;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (6033,
	6032,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6034);
INSERT INTO S_SYNC
	VALUES (6034,
	1,
	'MSG_R_Delete',
	'ContextMenuFunction: TRUE',
	'select many messages from instances of MSG_R where USER::selectOne(id:selected.Msg_ID);
for each message in messages
  message.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6035);
INSERT INTO S_SYNC
	VALUES (6035,
	1,
	'MSG_R_Rename',
	'ContextMenuFunction: TRUE',
	'select any message from instances of MSG_R where USER::selectOne(id:selected.Msg_ID);
if(not_empty message)
  message.Name = param.new_name;
end if;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (6036,
	6035,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6037);
INSERT INTO S_SYNC
	VALUES (6037,
	1,
	'MSG_A_Rename',
	'ContextMenuFunction: TRUE',
	'select any argument from instances of MSG_A where USER::selectOne(id:selected.Arg_ID);
if(not_empty argument)
  argument.InformalName = param.new_name;
end if;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (6038,
	6037,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6039);
INSERT INTO S_SYNC
	VALUES (6039,
	1,
	'MSG_A_Delete',
	'ContextMenuFunction: TRUE',
	'select many arguments from instances of MSG_A where USER::selectOne(id:selected.Arg_ID);
for each argument in arguments
  argument.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6040);
INSERT INTO S_SYNC
	VALUES (6040,
	1,
	'MSG_AM_InstanceClassEventFormalize',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any asyncMessage from instances of MSG_AM where USER::selectOne(id:selected.Msg_ID);
select one message related by asyncMessage->MSG_M[R1018];
select one participant related by message->SQ_P[R1007];
select one cip related by participant->SQ_CIP[R930];
select one mclass related by cip->O_OBJ[R934];
select one communication related by cip->SQ_P[R930]->COMM_PIC[R1126]->COMM_COMM[R1126];
if(empty communication)
  if(not_empty mclass)
    select one stateMachine related by mclass->SM_ASM[R519]->SM_SM[R517];
    select one asm related by mclass->SM_ASM[R519];
    select one ism related by mclass->SM_ISM[R518];
    // the action filter will guarantee that at least one state machine
    // exists, but not both
    asmId = GD::NULL_UNIQUE_ID();
    ismId = GD::NULL_UNIQUE_ID();
    if(not_empty asm)
      asmId = asm.SM_ID;
    end if;
    if(not_empty ism)
      ismId = ism.SM_ID;
    end if;
    select one evt related by asyncMessage->MSG_E[R1019]->SM_EVT[R1009];
    existingId = GD::NULL_UNIQUE_ID();
    if(not_empty evt)
      existingId = evt.SMevt_ID;
    end if;
  	select many machines from instances of SM_SM where (selected.SM_ID == asmId) or (selected.SM_ID == ismId);
    select any Message related by machines->SM_EVT[R502] where USER::selectOne(id:selected.SMevt_ID) and
  		  ((mclass.eventIsClassBased(eventId:selected.SMevt_ID,
  			 	  instanceStateMachineId:ismId,classStateMachineId:asmId)) and
  			 	  (selected.SMevt_ID != existingId));
    if(not_empty Message)
      asyncMessage.formalizeWithEvent(eventId:Message.SMevt_ID);
    end if;
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6041);
INSERT INTO S_SYNC
	VALUES (6041,
	1,
	'COMM_COMM_Delete',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many comms from instances of COMM_COMM where USER::selectOne(id:selected.Package_ID);
for each comm in comms
  comm.dispose();
end for;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6042);
INSERT INTO S_SYNC
	VALUES (6042,
	1,
	'COMM_COMM_Rename',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any comm from instances of COMM_COMM where USER::selectOne(id:selected.Package_ID);
if(not_empty comm)
  comm.Name = param.new_name;
end if;
',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (6043,
	6042,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6044);
INSERT INTO S_SYNC
	VALUES (6044,
	1,
	'COMM_LNK_Delete',
	'ContextMenuFunction: TRUE',
	'select many links from instances of COMM_LNK where USER::selectOne(id:selected.Link_ID);
for each link in links
  link.dispose();
end for;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6045);
INSERT INTO S_SYNC
	VALUES (6045,
	1,
	'COMM_LNK_LinkFormalize',
	'ContextMenuFunction: TRUE',
	'select any link from instances of COMM_LNK where USER::selectOne(id:selected.Link_ID);
if(not_empty link)
  select one startObj related by link->SQ_P[R1133]->SQ_CIP[R930]->O_OBJ[R934];
  select any Association related by startObj->R_OIR[R201]->R_REL[R201] where USER::selectOne(id:selected.Rel_ID)
			and link.participatesWithFormalParticipants(assocId:selected.Rel_ID);
	link.formalize(assocId:Association.Rel_ID);
end if;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6046);
INSERT INTO S_SYNC
	VALUES (6046,
	1,
	'COMM_LNK_Unformalize',
	'ContextMenuFunction: TRUE',
	'select any link from instances of COMM_LNK where USER::selectOne(id:selected.Link_ID);
if(not_empty link)
  link.unformalize();
end if;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6047);
INSERT INTO S_SYNC
	VALUES (6047,
	1,
	'MSG_SM_CommunicationClassOperationFormalize',
	'ContextMenuFunction: TRUE',
	'select any syncMessage from instances of MSG_SM where USER::selectOne(id:selected.Msg_ID);
if(not_empty syncMessage)
  select any cp from instances of SQ_CP where USER::selectOne(id:selected.Part_ID);
  if(not_empty cp)
    select one operation related by syncMessage->MSG_O[R1020]->O_TFR[R1011];
    existingId = GD::NULL_UNIQUE_ID();
    if(not_empty operation)
      existingId = operation.Tfr_ID;
    end if;
    // relate the message to the destination participant
    select one message related by syncMessage->MSG_M[R1018];
    select one participant related by cp->SQ_P[R930];
    relate message to participant across R1007;
    select one mclass related by cp->O_OBJ[R939];
    if(not_empty mclass)
      select any Message related by mclass->O_TFR[R115]
                                   where USER::selectOne(id:selected.Tfr_ID) and
        ((selected.Instance_Based == Scope::Class) and (selected.Tfr_ID != existingId));
      syncMessage.formalizeWithClassOperation(operationId:Message.Tfr_ID);
      // clear the selection so that following moves will not
      // move the destination shape as well
      Sel::clearSelection();
    end if;
  end if;
end if;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6048);
INSERT INTO S_SYNC
	VALUES (6048,
	1,
	'MSG_SM_CommunicationInstanceOperationFormalize',
	'ContextMenuFunction: TRUE',
	'select any syncMessage from instances of MSG_SM where USER::selectOne(id:selected.Msg_ID);
if(not_empty syncMessage)
  select any cip from instances of SQ_CIP where USER::selectOne(id:selected.Part_ID);
  if(not_empty cip)
    select one operation related by syncMessage->MSG_O[R1020]->O_TFR[R1011];
    existingId = GD::NULL_UNIQUE_ID();
    if(not_empty operation)
      existingId = operation.Tfr_ID;
    end if;
    // relate the message to the destination participant
    select one message related by syncMessage->MSG_M[R1018];
    select one participant related by cip->SQ_P[R930];
    relate message to participant across R1007;
    select one mclass related by cip->O_OBJ[R934];
    if(not_empty mclass)
      select any Message related by mclass->O_TFR[R115]
                                   where USER::selectOne(id:selected.Tfr_ID) and
     ((selected.Instance_Based == Scope::Instance) and (selected.Tfr_ID != existingId));
      syncMessage.formalizeWithClassOperation(operationId:Message.Tfr_ID);
      // clear the selection so that following moves will not
      // move the destination shape as well
      Sel::clearSelection();
    end if;
  end if;
end if;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6049);
INSERT INTO S_SYNC
	VALUES (6049,
	1,
	'MSG_SM_CommunicationBridgeOperationFormalize',
	'ContextMenuFunction: TRUE',
	'select any syncMessage from instances of MSG_SM where USER::selectOne(id:selected.Msg_ID);
if(not_empty syncMessage)
  select any eep from instances of SQ_EEP where USER::selectOne(id:selected.Part_ID);
  if(not_empty eep)
    select one bridgeOp related by syncMessage->MSG_B[R1020]->S_BRG[R1012];
    existingId = GD::NULL_UNIQUE_ID();
    if(not_empty bridgeOp)
      existingId = bridgeOp.Brg_ID;
    end if;
    // relate the message to the destination participant
    select one message related by syncMessage->MSG_M[R1018];
    select one participant related by eep->SQ_P[R930];
    relate message to participant across R1007;
    select one ee related by eep->S_EE[R933];
    if(not_empty ee)
      select any Message related by ee->S_BRG[R19]
             where USER::selectOne(id:selected.Brg_ID) and selected.Brg_ID != existingId;
      syncMessage.formalizeWithBridgeOperation(bridgeId:Message.Brg_ID);
      // clear the selection so that following moves will not
      // move the destination shape as well
      Sel::clearSelection();
    end if;
  end if;
end if;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6050);
INSERT INTO S_SYNC
	VALUES (6050,
	1,
	'MSG_SM_CommunicationFunctionFormalize',
	'ContextMenuFunction: TRUE',
	'select any syncMessage from instances of MSG_SM where USER::selectOne(id:selected.Msg_ID);
if(not_empty syncMessage)
  select one function related by syncMessage->MSG_F[R1020]->S_SYNC[R1010];
  select any fpp from instances of SQ_FPP where USER::selectOne(id:selected.Part_ID);
  if(not_empty fpp)
    existingId = GD::NULL_UNIQUE_ID();
    if(not_empty function)
      existingId = function.Sync_ID;
    end if;
    // relate the message to the destination participant
    select one message related by syncMessage->MSG_M[R1018];
    select one participant related by fpp->SQ_P[R930];
    relate message to participant across R1007;
    select one fpk related by fpp->S_FPK[R932];
    if(not_empty fpk)
      select any Message related by fpk->S_FIP[R31]->S_SYNC[R31]
            where USER::selectOne(id:selected.Sync_ID) and selected.Sync_ID != existingId;
      syncMessage.formalizeWithFunction(functionId:Message.Sync_ID);
      // clear the selection so that following moves will not
      // move the destination shape as well
      Sel::clearSelection();
    end if;
  end if;
end if;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6051);
INSERT INTO S_SYNC
	VALUES (6051,
	1,
	'MSG_AM_CommunicationClassEventFormalize',
	'ContextMenuFunction: TRUE',
	'select any asyncMessage from instances of MSG_AM where USER::selectOne(id:selected.Msg_ID);
if(not_empty asyncMessage)
  select any cp from instances of SQ_CP where USER::selectOne(id:selected.Part_ID);
  if(not_empty cp)
    // relate the message to the destination participant
    select one message related by asyncMessage->MSG_M[R1018];
    select one participant related by cp->SQ_P[R930];
    relate message to participant across R1007;
    select one mclass related by cp->O_OBJ[R939];
    if(not_empty mclass)
      select one stateMachine related by mclass->SM_ASM[R519]->SM_SM[R517];
      select one asm related by mclass->SM_ASM[R519];
      select one ism related by mclass->SM_ISM[R518];
      // the action filter will guarantee that at least one state machine
      // exists, but not both
      asmId = GD::NULL_UNIQUE_ID();
      ismId = GD::NULL_UNIQUE_ID();
      if(not_empty asm)
        asmId = asm.SM_ID;
      end if;
      if(not_empty ism)
        ismId = ism.SM_ID;
      end if;
      select one evt related by asyncMessage->MSG_E[R1019]->SM_EVT[R1009];
      existingId = GD::NULL_UNIQUE_ID();
      if(not_empty evt)
        existingId = evt.SMevt_ID;
      end if;
	  select many machines from instances of SM_SM where (selected.SM_ID == asmId) or (selected.SM_ID == ismId);
      select any Message related by machines->SM_EVT[R502] where USER::selectOne(id:selected.SMevt_ID) and
  		   ((mclass.eventIsClassBased(eventId:selected.SMevt_ID,
  				  instanceStateMachineId:ismId,classStateMachineId:asmId)) and
  				  (selected.SMevt_ID != existingId));
      if(not_empty Message)
        asyncMessage.formalizeWithEvent(eventId:Message.SMevt_ID);
        // clear the selection so that following moves will not
        // move the destination shape as well
        Sel::clearSelection();
      end if;
    end if;
  end if;
end if;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6052);
INSERT INTO S_SYNC
	VALUES (6052,
	1,
	'MSG_AM_CommunicationInstanceEventFormalize',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any asyncMessage from instances of MSG_AM where USER::selectOne(id:selected.Msg_ID);
if(not_empty asyncMessage)
  select any cip from instances of SQ_CIP where USER::selectOne(id:selected.Part_ID);
  if(not_empty cip)
    // relate the message to the destination participant
    select one message related by asyncMessage->MSG_M[R1018];
    select one participant related by cip->SQ_P[R930];
    relate message to participant across R1007;
    select one mclass related by cip->O_OBJ[R934];
    if(not_empty mclass)
      select one evt related by asyncMessage->MSG_E[R1019]->SM_EVT[R1009];
      existingId = GD::NULL_UNIQUE_ID();
      if(not_empty evt)
        existingId = evt.SMevt_ID;
      end if;
      select one stateMachine related by mclass->SM_ISM[R518]->SM_SM[R517];
      select many machines related by mclass->PE_PE[R8001]->EP_PKG[R8000]
                                     ->S_SYS[R1405]->EP_PKG[R1405]->PE_PE[R8000]
                                      ->O_OBJ[R8001]->SM_ISM[R518]->SM_SM[R517];
      if(empty machines)
        select many machines related by mclass->S_SS[R2]->S_DOM[R1]->S_SS[R1]
                             	  	     ->O_OBJ[R2]->SM_ISM[R518]->SM_SM[R517];
      end if;
      select any Message related by machines->SM_EVT[R502] where
        USER::selectOne(id:selected.SMevt_ID) and ((stateMachine.canAssignEvent(
                  eventId:selected.SMevt_ID, eventStateMachineId:selected.SM_ID,
            isCreationTransition:false)) and (selected.SMevt_ID != existingId));
      if(not_empty Message)
        asyncMessage.formalizeWithEvent(eventId:Message.SMevt_ID);
        // clear the selection so that following moves will not
        // move the destination shape as well
        Sel::clearSelection();
      end if;
    end if;
  end if;
end if;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6053);
INSERT INTO S_SYNC
	VALUES (6053,
	1,
	'COMM_LNK_ToggleStartVisibility',
	'ContextMenuFunction: TRUE',
	'select many links from instances of COMM_LNK where USER::selectOne(id:selected.Link_ID);
for each link in links
  link.toggleVisibility(end:End::Start);
end for;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6054);
INSERT INTO S_SYNC
	VALUES (6054,
	1,
	'COMM_LNK_ToggleEndVisibility',
	'ContextMenuFunction: TRUE',
	'select many links from instances of COMM_LNK where USER::selectOne(id:selected.Link_ID);
for each link in links
  link.toggleVisibility(end:End::End);
end for;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6055);
INSERT INTO S_SYNC
	VALUES (6055,
	1,
	'MSG_SM_NoTargetFormalize',
	'ContextMenuFunction: TRUE',
	'select any syncMessage from instances of MSG_SM where USER::selectOne(id:selected.Msg_ID);
if(not_empty syncMessage)
  USER::information(msg:"To formalize this message you must select the target as well as the message.  To do this select the message, hold the control key then select the target.  At this point you will be able to select the Formalize... menu item if there is anything to formalize against in the target.", title:"No Target Selected");
end if;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6056);
INSERT INTO S_SYNC
	VALUES (6056,
	1,
	'MSG_AM_NoTargetFormalize',
	'ContextMenuFunction: TRUE',
	'select any asyncMessage from instances of MSG_AM where USER::selectOne(id:selected.Msg_ID);
if(not_empty asyncMessage)
  USER::information(msg:"To formalize this message you must select the target as well as the message.  To do this select the message, hold the control key then select the target.  At this point you will be able to select the Formalize... menu item if there is anything to formalize against in the target.", title:"No Target Selected");
end if;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6057);
INSERT INTO S_SYNC
	VALUES (6057,
	1,
	'A_A_NewActivityDiagram',
	'ContextMenuFunction: TRUE
',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any act from instances of A_A where USER::selectOne(id:selected.Package_ID);
if(not empty act)
act.newActivity();
end if;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (6058,
	6057,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6059);
INSERT INTO S_SYNC
	VALUES (6059,
	1,
	'UC_UCC_Delete',
	'ContextMenuFunction: TRUE
',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many uccs from instances of UC_UCC where USER::selectOne(id:selected.Package_ID);
for each ucc in uccs
  ucc.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6060);
INSERT INTO S_SYNC
	VALUES (6060,
	1,
	'IA_UCP_Rename',
	'ContextMenuFunction: TRUE
',
	'select any uc from instances of IA_UCP where USER::selectOne(id:selected.Part_ID);
if(not_empty uc)
  uc.Name = param.new_name;
end if;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (6061,
	6060,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6062);
INSERT INTO S_SYNC
	VALUES (6062,
	1,
	'IA_UCP_Delete',
	'ContextMenuFunction: TRUE
',
	'select many ucs from instances of IA_UCP where USER::selectOne(id:selected.Part_ID);
for each uc in ucs
  uc.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6063);
INSERT INTO S_SYNC
	VALUES (6063,
	1,
	'UC_BA_Delete',
	'ContextMenuFunction: TRUE
',
	'select many bas from instances of UC_BA where USER::selectOne(id:selected.Assoc_ID);
for each ba in bas
  ba.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6064);
INSERT INTO S_SYNC
	VALUES (6064,
	1,
	'UC_G_Delete',
	'ContextMenuFunction: TRUE
',
	'select many gens from instances of UC_G where USER::selectOne(id:selected.Assoc_ID);
for each gen in gens
  gen.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6065);
INSERT INTO S_SYNC
	VALUES (6065,
	1,
	'UC_I_Delete',
	'ContextMenuFunction: TRUE
',
	'select many incs from instances of UC_I where USER::selectOne(id:selected.Assoc_ID);
for each inc in incs
  inc.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6066);
INSERT INTO S_SYNC
	VALUES (6066,
	1,
	'UC_E_Delete',
	'ContextMenuFunction: TRUE
',
	'select many exts from instances of UC_E where USER::selectOne(id:selected.Assoc_ID);
for each ext in exts
  ext.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6067);
INSERT INTO S_SYNC
	VALUES (6067,
	1,
	'O_ATTR_AddToIdentifier',
	'ContextMenuFunction: TRUE
',
	'select any attr from instances of O_ATTR
    where USER::selectOne(id:selected.Attr_ID);
// UI: exclude O_ID instances we are already related to
select any Identifier related by attr->O_OBJ[R102]->O_ID[R104]
    where USER::selectOneWithInt(id:selected.Oid_ID) and not attr.isPartOfId(id: selected.Oid_ID);
if ( not_empty Identifier )
  attr.addToIdentifier(oid: Identifier.Oid_ID );
end if;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6068);
INSERT INTO S_SYNC
	VALUES (6068,
	1,
	'O_ATTR_RemoveFromIdentifier',
	'ContextMenuFunction: TRUE
',
	'// UI: only call if this attribute is part of an identifier
select any attr from instances of O_ATTR
    where USER::selectOne(id:selected.Attr_ID);
select any Identifier related by attr->O_ID[R105]
    where USER::selectOneWithInt(id:selected.Oid_ID);
if ( not_empty Identifier )
  result = attr.removeFromIdentifier( oid: Identifier.Oid_ID );
  if ( result != "" )
    USER::warning( msg: result );
    return false;
  end if;
end if;
',
	316,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6069);
INSERT INTO S_SYNC
	VALUES (6069,
	1,
	'O_IOBJ_SpecializedPackageAssignClass',
	'ContextMenuFunction: TRUE
',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any iobj from instances of O_IOBJ
    where USER::selectOne(id:selected.IObj_ID);

// exclude the subsystem containing the iobj
select any Subsystem related by iobj->S_SS[R3]->S_DOM[R1]->S_SS[R1]
    where USER::selectOne(id:selected.SS_ID) and selected.SS_ID != iobj.SS_ID;
if ( not_empty Subsystem )
  select any Class related by Subsystem->O_OBJ[R2]
      where USER::selectOne(id:selected.Obj_ID);
  if ( not_empty Class )
    relate iobj to Class across R101;
  end if;
end if;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6070);
INSERT INTO S_SYNC
	VALUES (6070,
	1,
	'O_ATTR_SetAsDerivedAttribute',
	'ContextMenuFunction: TRUE
',
	'     // UI: only applies to O_NBATTR instances
     select any attr from instances of O_ATTR
         where USER::selectOne(id:selected.Attr_ID);
     attr.migrateBaseToDerived();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6071);
INSERT INTO S_SYNC
	VALUES (6071,
	1,
	'O_ATTR_SetAsBaseAttribute',
	'ContextMenuFunction: TRUE
',
	'     // UI: only applies to O_DBATTR instances
     select any attr from instances of O_ATTR
         where USER::selectOne(id:selected.Attr_ID);
     attr.migrateDerivedToBase();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6072);
INSERT INTO S_SYNC
	VALUES (6072,
	1,
	'R_REL_Unformalize',
	'ContextMenuFunction: TRUE
',
	'// UI: relationship is formalized
select any rel from instances of R_REL
   where USER::selectOne(id:selected.Rel_ID);
rel.unformalize();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6073);
INSERT INTO S_SYNC
	VALUES (6073,
	1,
	'SM_TXN_SpecializedPackageAssignEvent',
	'ContextMenuFunction: TRUE
',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// UI: event exists to assign
select any txn from instances of SM_TXN
   where USER::selectOne(id:selected.Trans_ID);
select one dest_state related by txn->SM_STATE[R506];
select one legal_evt_defining_state related by txn->
                                                 SM_NETXN[R507]->SM_STATE[R508];
if ( empty legal_evt_defining_state )
  select one legal_evt_defining_state related by txn->
                                  SM_NSTXN[R507]->SM_SEME[R504]->SM_STATE[R503];
end if;
// select all events in the domain that meet our criteria for assignment
// ("select ... from instances of" not being possible here since generating
// code from it in this context will produce errors);
// note that we have to take into account in both the upwards and downwards
// traversals whether we are dealing with a class or instance state machine
select one stateMachine related by txn->SM_SM[R505];
select one classStateMachine related by stateMachine->SM_ASM[R517];
isClassStateMachine = not_empty classStateMachine;
select one modelClass related by stateMachine->SM_ISM[R517]->O_OBJ[R518];
if (isClassStateMachine)
	select one modelClass related by stateMachine->SM_ASM[R517]->O_OBJ[R519];
end if;
select many machines related by modelClass->S_SS[R2]->S_DOM[R1]->S_SS[R1]
	->O_OBJ[R2]->SM_ISM[R518]->SM_SM[R517];
if (isClassStateMachine)
	select many machines related by modelClass->S_SS[R2]->S_DOM[R1]->S_SS[R1]
		->O_OBJ[R2]->SM_ASM[R519]->SM_SM[R517];
end if;
select any event related by machines->SM_EVT[R502]
	where USER::selectOne(id:selected.SMevt_ID)
    	and stateMachine.canAssignEvent(
    		eventId:selected.SMevt_ID, eventStateMachineId:selected.SM_ID,
    		isCreationTransition:false)
	    and legal_evt_defining_state.notAlreadyAssigned(
                             eventId:selected.SMevt_ID,
                             eventStateMachineId: selected.SM_ID, crtxn: false);
txn.addEvent(eventId:event.SMevt_ID, eventStateMachineId:event.SM_ID);',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6074);
INSERT INTO S_SYNC
	VALUES (6074,
	1,
	'SM_TXN_RemoveEvent',
	'ContextMenuFunction: TRUE
',
	'// UI: event is assigned to transition
select any txn from instances of SM_TXN
   where USER::selectOne(id:selected.Trans_ID);
txn.removeEvent();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6075);
INSERT INTO S_SYNC
	VALUES (6075,
	1,
	'R_REL_BinaryFormalize',
	'ContextMenuFunction: TRUE
Label1: "Class"
',
	'// UI: relationship is not formalized
select any rel from instances of R_REL
   where USER::selectOne(id:selected.Rel_ID);
select one simp related by rel->R_SIMP[R206];
select any non_formalizer related by simp->R_PART[R207]->R_RTO[R204]
   ->R_OIR[R203]->O_OBJ[R201]
    where USER::selectOne(id:selected.Obj_ID) and simp.canParticipate(id: selected.Obj_ID);
if ( not_empty non_formalizer )
  select any Identifier related by non_formalizer->O_ID[R104]
    where USER::selectOne(id:selected.Obj_ID) and
       O_ID::hasAttributes(obj_id: selected.Obj_ID, oid_id: selected.Oid_ID );
  if ( not_empty Identifier )
    simp.formalize( part_oir_id: non_formalizer.Obj_ID, id_id: Identifier.Oid_ID );
  end if;
end if;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6076);
INSERT INTO S_SYNC
	VALUES (6076,
	1,
	'R_REL_LinkedFormalize',
	'ContextMenuFunction: TRUE
Label1: ModelClass_c.getOneO_OBJOnR104(One_idInstances[0]).getName()
Label2: ModelClass_c.getOneO_OBJOnR104(Oth_idInstances[0]).getName()
',
	'// UI: relationship is not formalized
select any rel from instances of R_REL
   where USER::selectOne(id:selected.Rel_ID);
select one a_rel related by rel->R_ASSOC[R206];
select one one_obj related by a_rel->R_AONE[R209]->R_RTO[R204]
   ->R_OIR[R203]->O_OBJ[R201];
select one oth_obj related by a_rel->R_AOTH[R210]->R_RTO[R204]
   ->R_OIR[R203]->O_OBJ[R201];
select any one_id related by one_obj->O_ID[R104]
    where USER::selectOne(id:selected.Obj_ID) and
       O_ID::hasAttributes(obj_id: selected.Obj_ID, oid_id: selected.Oid_ID );
select any oth_id related by oth_obj->O_ID[R104]
    where USER::selectOne(id:selected.Obj_ID) and
       O_ID::hasAttributes(obj_id: selected.Obj_ID, oid_id: selected.Oid_ID );

if ( not_empty one_id and not_empty oth_id )
  a_rel.formalize( one_id: one_id.Oid_ID, oth_id: oth_id.Oid_ID );
end if;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6077);
INSERT INTO S_SYNC
	VALUES (6077,
	1,
	'R_REL_InheritanceFormalize',
	'ContextMenuFunction: TRUE
',
	'// UI: relationship is not formalized
select any rel from instances of R_REL
   where USER::selectOne(id:selected.Rel_ID);
select one ss_rel related by rel->R_SUBSUP[R206];
select one super_obj related by ss_rel->R_SUPER[R212]->R_RTO[R204]
   ->R_OIR[R203]->O_OBJ[R201];
select any Identifier related by super_obj->O_ID[R104]
    where USER::selectOne(id:selected.Obj_ID) and
       O_ID::hasAttributes(obj_id: selected.Obj_ID, oid_id: selected.Oid_ID );
if ( not_empty Identifier )
  ss_rel.formalize( id: Identifier.Oid_ID );
end if;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6078);
INSERT INTO S_SYNC
	VALUES (6078,
	1,
	'SM_EVT_SpecializedPackageIgnoreInState',
	'ContextMenuFunction: TRUE
',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// UI: cant happen entry exists for this event
	select any event from instances of SM_EVT
         where USER::selectOne(id:selected.SMevt_ID);

// select all states in the domain that may currently be selected to ignore
// the event ("select ... from instances of" not being possible here since
// generating code from it in this context will produce errors);
// note that we have to take into account in both the upwards and downwards
// traversals whether we are dealing with a class or instance state machine
select one stateMachine related by event->SM_SM[R502];
select one classStateMachine related by stateMachine->SM_ASM[R517];
isClassStateMachine = not_empty classStateMachine;
select one modelClass related by stateMachine->SM_ISM[R517]->O_OBJ[R518];
if (isClassStateMachine)
	select one modelClass related by stateMachine->SM_ASM[R517]->O_OBJ[R519];
end if;
select many machines related by modelClass->S_SS[R2]->S_DOM[R1]->S_SS[R1]
	->O_OBJ[R2]->SM_ISM[R518]->SM_SM[R517];
if (isClassStateMachine)
	select many machines related by modelClass->S_SS[R2]->S_DOM[R1]->S_SS[R1]
		->O_OBJ[R2]->SM_ASM[R519]->SM_SM[R517];
end if;
select any state related by machines->SM_STATE[R501]
	where USER::selectOne(id:selected.SMstt_ID)
    	and event.canStateIgnoreOrSayCantHappen(
    		stateId:selected.SMstt_ID, stateStateMachineId:selected.SM_ID,
    		considerCantHappen:false);

if (not_empty state)
  event.ignoreOnState(stateId:state.SMstt_ID, stateStateMachineId:state.SM_ID);
end if;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6079);
INSERT INTO S_SYNC
	VALUES (6079,
	1,
	'SM_EVT_SpecializedPackageCantHappenInState',
	'ContextMenuFunction: TRUE
',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// UI: event ignored entry exists for this event
select any event from instances of SM_EVT
         where USER::selectOne(id:selected.SMevt_ID);

// select all states in the domain that may currently be selected to say
// the event cannot happen on them ("select ... from instances of" not being
// possible here since  generating code from it in this context will produce
// errors); note that we have to take into account in both the upwards and
// downwards traversals whether we are dealing with a class or instance
// state machine
select one stateMachine related by event->SM_SM[R502];
select one classStateMachine related by stateMachine->SM_ASM[R517];
isClassStateMachine = not_empty classStateMachine;
select one modelClass related by stateMachine->SM_ISM[R517]->O_OBJ[R518];
if (isClassStateMachine)
	select one modelClass related by stateMachine->SM_ASM[R517]->O_OBJ[R519];
end if;
select many machines related by modelClass->S_SS[R2]->S_DOM[R1]->S_SS[R1]
	->O_OBJ[R2]->SM_ISM[R518]->SM_SM[R517];
if (isClassStateMachine)
	select many machines related by modelClass->S_SS[R2]->S_DOM[R1]->S_SS[R1]
		->O_OBJ[R2]->SM_ASM[R519]->SM_SM[R517];
end if;
select any state related by machines->SM_STATE[R501]
	where USER::selectOne(id:selected.SMstt_ID)
    	and event.canStateIgnoreOrSayCantHappen(
    		stateId:selected.SMstt_ID, stateStateMachineId:selected.SM_ID,
    		considerCantHappen:true);
if (not_empty event)
  event.sayCantHappenOnState(stateId:state.SMstt_ID, stateStateMachineId:state.SM_ID);
end if;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6080);
INSERT INTO S_SYNC
	VALUES (6080,
	1,
	'SM_STATE_SpecializedPackageIgnoreEvent',
	'ContextMenuFunction: TRUE
',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// UI: cant happen entry exists for this state
select any state from instances of SM_STATE
         where USER::selectOne(id:selected.SMstt_ID);

// select all events in the domain that may currently be selected to be
// ignored on the given state ("select ... from instances of" not being
// possible here since  generating code from it in this context will produce
// errors); note that we have to take into account in both the upwards and
// downwards traversals whether we are dealing with a class or instance
// state machine
select one stateMachine related by state->SM_SM[R501];
select one classStateMachine related by stateMachine->SM_ASM[R517];
isClassStateMachine = not_empty classStateMachine;
select one modelClass related by stateMachine->SM_ISM[R517]->O_OBJ[R518];
if (isClassStateMachine)
	select one modelClass related by stateMachine->SM_ASM[R517]->O_OBJ[R519];
end if;
select many machines related by modelClass->S_SS[R2]->S_DOM[R1]->S_SS[R1]
	->O_OBJ[R2]->SM_ISM[R518]->SM_SM[R517];
if (isClassStateMachine)
	select many machines related by modelClass->S_SS[R2]->S_DOM[R1]->S_SS[R1]
		->O_OBJ[R2]->SM_ASM[R519]->SM_SM[R517];
end if;
select any event related by machines->SM_EVT[R502]
	where USER::selectOne(id:selected.SMevt_ID)
    	and state.canIgnoreOrSayEventCantHappen(
    		eventId:selected.SMevt_ID, eventStateMachineId: selected.SM_ID,
    		considerCantHappen:false);
if (not_empty event)
  event.ignoreOnState(stateId:state.SMstt_ID, stateStateMachineId:state.SM_ID);
end if;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6081);
INSERT INTO S_SYNC
	VALUES (6081,
	1,
	'SM_STATE_SpecializedPackageCantHappenEvent',
	'ContextMenuFunction: TRUE
',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// UI: event ignored entry exists for this state
select any state from instances of SM_STATE
         where USER::selectOne(id:selected.SMstt_ID);

// select all events in the domain that may currently be selected to cannot
// happen on the given state ("select ... from instances of" not being
// possible here since  generating code from it in this context will produce
// errors); note that we have to take into account in both the upwards and
// downwards traversals whether we are dealing with a class or instance
// state machine
select one stateMachine related by state->SM_SM[R501];
select one classStateMachine related by stateMachine->SM_ASM[R517];
isClassStateMachine = not_empty classStateMachine;
select one modelClass related by stateMachine->SM_ISM[R517]->O_OBJ[R518];
if (isClassStateMachine)
	select one modelClass related by stateMachine->SM_ASM[R517]->O_OBJ[R519];
end if;
select many machines related by modelClass->S_SS[R2]->S_DOM[R1]->S_SS[R1]
	->O_OBJ[R2]->SM_ISM[R518]->SM_SM[R517];
if (isClassStateMachine)
	select many machines related by modelClass->S_SS[R2]->S_DOM[R1]->S_SS[R1]
		->O_OBJ[R2]->SM_ASM[R519]->SM_SM[R517];
end if;
select any event related by machines->SM_EVT[R502]
	where USER::selectOne(id:selected.SMevt_ID)
    	and state.canIgnoreOrSayEventCantHappen(
    		eventId:selected.SMevt_ID, eventStateMachineId: selected.SM_ID,
    		considerCantHappen:true);
if (not_empty event)
  event.sayCantHappenOnState(stateId:state.SMstt_ID, stateStateMachineId:state.SM_ID);
end if;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6082);
INSERT INTO S_SYNC
	VALUES (6082,
	1,
	'O_ATTR_MoveUp',
	'ContextMenuFunction: TRUE
',
	'// UI: exclude attribute at top of list
select any attr from instances of O_ATTR
    where USER::selectOne(id:selected.Attr_ID);
attr.moveUp();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6083);
INSERT INTO S_SYNC
	VALUES (6083,
	1,
	'O_ATTR_MoveDown',
	'ContextMenuFunction: TRUE
',
	'// UI: exclude attribute at bottom of list
select any attr from instances of O_ATTR
    where USER::selectOne(id:selected.Attr_ID);
attr.moveDown();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6084);
INSERT INTO S_SYNC
	VALUES (6084,
	1,
	'R_SUB_InheritanceFormalize',
	'ContextMenuFunction: TRUE
',
	'// UI: relationship is not formalized
select any r_sub from instances of R_SUB
   where USER::selectOne(id:selected.Rel_ID);
select one ss_rel related by r_sub->R_SUBSUP[R213];
select one super_obj related by ss_rel->R_SUPER[R212]->R_RTO[R204]
   ->R_OIR[R203]->O_OBJ[R201];
select any Identifier related by super_obj->O_ID[R104]
    where USER::selectOne(id:selected.Obj_ID) and
       O_ID::hasAttributes(obj_id: selected.Obj_ID, oid_id: selected.Oid_ID );
if ( not_empty Identifier )
  ss_rel.formalize( id: Identifier.Oid_ID );
end if;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6085);
INSERT INTO S_SYNC
	VALUES (6085,
	1,
	'R_ASSR_LinkedFormalize',
	'ContextMenuFunction: TRUE
Label1: ModelClass_c.getOneO_OBJOnR104(One_idInstances[0]).getName()
Label2: ModelClass_c.getOneO_OBJOnR104(Oth_idInstances[0]).getName()
',
	'// UI: relationship is not formalized
select any assr from instances of R_ASSR
   where USER::selectOne(id:selected.Rel_ID);
select one a_rel related by assr->R_ASSOC[R211];
select one one_obj related by a_rel->R_AONE[R209]->R_RTO[R204]
   ->R_OIR[R203]->O_OBJ[R201];
select one oth_obj related by a_rel->R_AOTH[R210]->R_RTO[R204]
   ->R_OIR[R203]->O_OBJ[R201];
select any one_id related by one_obj->O_ID[R104]
    where USER::selectOne(id:selected.Obj_ID) and
       O_ID::hasAttributes(obj_id: selected.Obj_ID, oid_id: selected.Oid_ID );
select any oth_id related by oth_obj->O_ID[R104]
    where USER::selectOne(id:selected.Obj_ID) and
       O_ID::hasAttributes(obj_id: selected.Obj_ID, oid_id: selected.Oid_ID );

if ( not_empty one_id and not_empty oth_id )
  a_rel.formalize( one_id: one_id.Oid_ID, oth_id: oth_id.Oid_ID );
end if;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6086);
INSERT INTO S_SYNC
	VALUES (6086,
	1,
	'R_ASSR_Unformalize',
	'ContextMenuFunction: TRUE
',
	'// UI: relationship is formalized
select any assr from instances of R_ASSR
   where USER::selectOne(id:selected.Rel_ID);
select one rel related by assr->R_ASSOC[R211]->R_REL[R206];
rel.unformalize();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6087);
INSERT INTO S_SYNC
	VALUES (6087,
	1,
	'R_SUB_Unformalize',
	'ContextMenuFunction: TRUE
',
	'// UI: relationship is formalized
select any r_sub from instances of R_SUB
   where USER::selectOne(id:selected.Rel_ID);
select one rel related by r_sub->R_SUBSUP[R213]->R_REL[R206];
rel.unformalize();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6088);
INSERT INTO S_SYNC
	VALUES (6088,
	1,
	'O_ATTR_CombineWith',
	'ContextMenuFunction: TRUE
',
	'// UI: there is at least one other attr to combine with
select any o_attr from instances of O_ATTR
   where USER::selectOne(id:selected.Attr_ID);
select one rattr related by o_attr->O_RATTR[R106];
select one base_attr related by rattr->O_BATTR[R113];
select any Combine_with related by o_attr->O_OBJ[R102]->O_ATTR[R102]->O_RATTR[R106]
    where USER::selectOne(id:selected.Attr_ID) and
       selected.BAttr_ID == base_attr.Attr_ID and
       selected.BObj_ID == base_attr.Obj_ID and
       not rattr.alreadyCombinedWith( id: selected.Attr_ID );
rattr.combine_refs( other_id: Combine_with.Attr_ID );
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6089);
INSERT INTO S_SYNC
	VALUES (6089,
	1,
	'O_ATTR_Split',
	'ContextMenuFunction: TRUE
',
	'// UI: there is at least one other attr to split from
select any o_attr from instances of O_ATTR
   where USER::selectOne(id:selected.Attr_ID);
select one rattr related by o_attr->O_RATTR[R106];
select any Split_from related by rattr->O_REF[R108]
    where USER::selectOne(id:selected.Attr_ID);
rattr.split_refs( other_id: Split_from.ARef_ID );
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6090);
INSERT INTO S_SYNC
	VALUES (6090,
	1,
	'A_A_Delete',
	'ContextMenuFunction: TRUE
',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many acts from instances of A_A where USER::selectOne(id:selected.Package_ID);
for each act in acts
  act.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6091);
INSERT INTO S_SYNC
	VALUES (6091,
	1,
	'A_A_Rename',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any act from instances of A_A where USER::selectOne(id:selected.Package_ID);
act.Name = param.new_name;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (6092,
	6091,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6093);
INSERT INTO S_SYNC
	VALUES (6093,
	1,
	'A_FJ_Delete',
	'ContextMenuFunction: TRUE',
	'select many fjs from instances of A_FJ where USER::selectOne(id:selected.Id);
for each fj in fjs
  fj.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6094);
INSERT INTO S_SYNC
	VALUES (6094,
	1,
	'A_FJ_Rename',
	'ContextMenuFunction: TRUE',
	'select any fj from instances of A_FJ where USER::selectOne(id:selected.Id);
fj.GuardCondition = param.new_name;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (6095,
	6094,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6096);
INSERT INTO S_SYNC
	VALUES (6096,
	1,
	'A_INI_Delete',
	'ContextMenuFunction: TRUE',
	'select many inis from instances of A_INI where USER::selectOne(id:selected.Id);
for each ini in inis
  ini.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6097);
INSERT INTO S_SYNC
	VALUES (6097,
	1,
	'A_E_Delete',
	'ContextMenuFunction: TRUE',
	'select many aes from instances of A_E where USER::selectOne(id:selected.Id);
for each ae in aes
  ae.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6098);
INSERT INTO S_SYNC
	VALUES (6098,
	1,
	'A_E_Rename',
	'ContextMenuFunction: TRUE',
	'select any ae from instances of A_E where USER::selectOne(id:selected.Id);
ae.Guard = param.new_name;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (6099,
	6098,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6100);
INSERT INTO S_SYNC
	VALUES (6100,
	1,
	'A_AF_Delete',
	'ContextMenuFunction: TRUE',
	'select many afs from instances of A_AF where USER::selectOne(id:selected.Id);
for each af in afs
  af.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6101);
INSERT INTO S_SYNC
	VALUES (6101,
	1,
	'A_FF_Delete',
	'ContextMenuFunction: TRUE',
	'select many ffs from instances of A_FF where USER::selectOne(id:selected.Id);
for each ff in ffs
  ff.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6102);
INSERT INTO S_SYNC
	VALUES (6102,
	1,
	'A_GA_Delete',
	'ContextMenuFunction: TRUE',
	'select many gas from instances of A_GA where USER::selectOne(id:selected.Id);
for each ga in gas
  ga.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6103);
INSERT INTO S_SYNC
	VALUES (6103,
	1,
	'A_GA_Rename',
	'ContextMenuFunction: TRUE',
	'select any ga from instances of A_GA where USER::selectOne(id:selected.Id);
ga.Name = param.new_name;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (6104,
	6103,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6105);
INSERT INTO S_SYNC
	VALUES (6105,
	1,
	'A_DM_Rename',
	'ContextMenuFunction: TRUE',
	'select any dm from instances of A_DM where USER::selectOne(id:selected.Id);
dm.Name = param.new_name;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (6106,
	6105,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6107);
INSERT INTO S_SYNC
	VALUES (6107,
	1,
	'A_DM_Delete',
	'ContextMenuFunction: TRUE',
	'select many dms from instances of A_DM where USER::selectOne(id:selected.Id);
for each dm in dms
  dm.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6108);
INSERT INTO S_SYNC
	VALUES (6108,
	1,
	'A_OBJ_Delete',
	'ContextMenuFunction: TRUE',
	'select many objs from instances of A_OBJ where USER::selectOne(id:selected.Id);
for each obj in objs
  obj.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6109);
INSERT INTO S_SYNC
	VALUES (6109,
	1,
	'A_OBJ_Rename',
	'ContextMenuFunction: TRUE',
	'select any obj from instances of A_OBJ where USER::selectOne(id:selected.Id);
obj.Name = param.new_name;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (6110,
	6109,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6111);
INSERT INTO S_SYNC
	VALUES (6111,
	1,
	'A_AEA_Delete',
	'ContextMenuFunction: TRUE',
	'select many aeas from instances of A_AEA where USER::selectOne(id:selected.Id);
for each aea in aeas
  aea.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6112);
INSERT INTO S_SYNC
	VALUES (6112,
	1,
	'A_AEA_Rename',
	'ContextMenuFunction: TRUE',
	'select any aea from instances of A_AEA where USER::selectOne(id:selected.Id);
aea.Name = param.new_name;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (6113,
	6112,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6114);
INSERT INTO S_SYNC
	VALUES (6114,
	1,
	'A_SS_Delete',
	'ContextMenuFunction: TRUE',
	'select many sss from instances of A_SS where USER::selectOne(id:selected.Id);
for each ss in sss
  ss.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6115);
INSERT INTO S_SYNC
	VALUES (6115,
	1,
	'A_SS_Rename',
	'ContextMenuFunction: TRUE',
	'select any ss from instances of A_SS where USER::selectOne(id:selected.Id);
ss.Name = param.new_name;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (6116,
	6115,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6117);
INSERT INTO S_SYNC
	VALUES (6117,
	1,
	'A_AP_Delete',
	'ContextMenuFunction: TRUE',
	'select many aps from instances of A_AP where USER::selectOne(id:selected.Id);
for each ap in aps
  ap.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6118);
INSERT INTO S_SYNC
	VALUES (6118,
	1,
	'A_AP_Rename',
	'ContextMenuFunction: TRUE',
	'select any ap from instances of A_AP where USER::selectOne(id:selected.Id);
ap.Name = param.new_name;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (6119,
	6118,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6120);
INSERT INTO S_SYNC
	VALUES (6120,
	1,
	'A_ATE_Delete',
	'ContextMenuFunction: TRUE',
	'select many ates from instances of A_ATE where USER::selectOne(id:selected.Id);
for each ate in ates
  ate.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6121);
INSERT INTO S_SYNC
	VALUES (6121,
	1,
	'A_ATE_Rename',
	'ContextMenuFunction: TRUE',
	'select any ate from instances of A_ATE where USER::selectOne(id:selected.Id);
ate.Name = param.new_name;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (6122,
	6121,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6123);
INSERT INTO S_SYNC
	VALUES (6123,
	1,
	'C_I_NewSignal',
	'ContextMenuFunction: TRUE',
	'select any interface from instances of C_I where USER::selectOne(id:selected.Id);
if(not_empty interface)
   assign discardUuid = interface.newExecutableProperty(asynchronous:true);
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6124);
INSERT INTO S_SYNC
	VALUES (6124,
	1,
	'C_I_NewOperation',
	'ContextMenuFunction: TRUE',
	'select any interface from instances of C_I where USER::selectOne(id:selected.Id);
if(not_empty interface)
  assign discardUuid = interface.newExecutableProperty(asynchronous:false);
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6125);
INSERT INTO S_SYNC
	VALUES (6125,
	1,
	'IP_IP_Delete',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many diagrams from instances of IP_IP where USER::selectOne(id:selected.Package_ID);
for each diagram in diagrams
  diagram.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6126);
INSERT INTO S_SYNC
	VALUES (6126,
	1,
	'IP_IP_Rename',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any diagram from instances of IP_IP where USER::selectOne(id:selected.Package_ID);
if(not_empty diagram)
  diagram.Name = param.new_name;
end if;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (6127,
	6126,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6128);
INSERT INTO S_SYNC
	VALUES (6128,
	1,
	'C_C_Delete',
	'ContextMenuFunction: TRUE',
	'select many comps from instances of C_C where USER::selectOne(id:selected.Id);
for each comp in comps
  comp.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6129);
INSERT INTO S_SYNC
	VALUES (6129,
	1,
	'C_C_Rename',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any comp from instances of C_C where USER::selectOne(id:selected.Id);
if(not_empty comp)
  select one domain related by comp->CN_DC[R4204]->S_DOM[R4204];
  if(not_empty domain)
    domain.Name = param.new_name;
    comp.Name = param.new_name;
    
  else
    comp.Name = param.new_name;
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (6130,
	6129,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6131);
INSERT INTO S_SYNC
	VALUES (6131,
	1,
	'C_I_Delete',
	'ContextMenuFunction: TRUE',
	'select many interfaces from instances of C_I where USER::selectOne(id:selected.Id);
for each i in interfaces
  i.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6132);
INSERT INTO S_SYNC
	VALUES (6132,
	1,
	'C_I_Rename',
	'ContextMenuFunction: TRUE',
	'select any interface from instances of C_I where USER::selectOne(id:selected.Id);
if(not_empty interface)
  interface.Name = param.new_name;
end if;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (6133,
	6132,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6134);
INSERT INTO S_SYNC
	VALUES (6134,
	1,
	'C_P_Delete',
	'ContextMenuFunction: TRUE',
	'select many provisions from instances of C_P where USER::selectOne(id:selected.Provision_Id);
for each provision in provisions
  provision.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6135);
INSERT INTO S_SYNC
	VALUES (6135,
	1,
	'C_P_Rename',
	'ContextMenuFunction: TRUE',
	'select any provision from instances of C_P where USER::selectOne(id:selected.Provision_Id);
if(not_empty provision)
  provision.InformalName = param.new_name;
end if;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (6136,
	6135,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6137);
INSERT INTO S_SYNC
	VALUES (6137,
	1,
	'C_R_Delete',
	'ContextMenuFunction: TRUE',
	'select many reqs from instances of C_R where USER::selectOne(id:selected.Requirement_Id);
for each req in reqs
  req.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6138);
INSERT INTO S_SYNC
	VALUES (6138,
	1,
	'C_R_Rename',
	'ContextMenuFunction: TRUE',
	'select any req from instances of C_R where USER::selectOne(id:selected.Requirement_Id);
if(not_empty req)
  req.InformalName = param.new_name;
end if;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (6139,
	6138,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6140);
INSERT INTO S_SYNC
	VALUES (6140,
	1,
	'C_AS_Delete',
	'ContextMenuFunction: TRUE',
	'select many signals from instances of C_AS where USER::selectOne(id:selected.Id);
for each signal in signals
  signal.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6141);
INSERT INTO S_SYNC
	VALUES (6141,
	1,
	'C_AS_Rename',
	'ContextMenuFunction: TRUE',
	'select any signal from instances of C_AS where USER::selectOne(id:selected.Id);
if(not_empty signal)
  signal.Name = param.new_name;
end if;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (6142,
	6141,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6143);
INSERT INTO S_SYNC
	VALUES (6143,
	1,
	'C_AS_NewParameter',
	'ContextMenuFunction: TRUE',
	'select any signal from instances of C_AS where USER::selectOne(id:selected.Id);
if(not_empty signal)
  signal.newParameter();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6144);
INSERT INTO S_SYNC
	VALUES (6144,
	1,
	'C_PP_Delete',
	'ContextMenuFunction: TRUE',
	'select many parms from instances of C_PP where
                                             USER::selectOne(id:selected.PP_Id);
for each parm in parms
  parm.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6145);
INSERT INTO S_SYNC
	VALUES (6145,
	1,
	'C_PP_Rename',
	'ContextMenuFunction: TRUE',
	'select any parm from instances of C_PP where USER::selectOne(id:selected.PP_Id);
if(not_empty parm)
  parm.Name = param.new_name;
end if;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (6146,
	6145,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6147);
INSERT INTO S_SYNC
	VALUES (6147,
	1,
	'C_C_ComponentFormalize',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
//       Note that the C_C action filter prevents this routine from being called
//       when the component is under a generic package, so no OAL change is 
//       required here.  When specialized packages are removed this function can
//       be removed.
select any component from instances of C_C where USER::selectOne(id:selected.Id);

if(not_empty component)
  select one componentPackage related by component->CP_CP[R4604];
  if(empty componentPackage)
    select one componentParent related by component->CN_CIC[R4203]->C_C[R4202];
    while(empty componentPackage)
      select one componentPackage related by componentParent->CP_CP[R4604];
      select one componentParent related by componentParent->CN_CIC[R4203]->C_C[R4202];
    end while;
  end if;
  if (not empty componentPackage)
    select one system related by componentPackage->S_SYS[R4606];
    select any Domain related by system->S_DOM[R28] where USER::selectOne(id:selected.Dom_ID);
    component.formalize(domId:Domain.Dom_ID);
  end if;
end if;   
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6148);
INSERT INTO S_SYNC
	VALUES (6148,
	1,
	'C_C_Unformalize',
	'ContextMenuFunction: TRUE',
	'select any component from instances of C_C where USER::selectOne(id:selected.Id);
if(not_empty component)
  component.unformalize();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6149);
INSERT INTO S_SYNC
	VALUES (6149,
	1,
	'C_P_SpecializedPackageProvidedInterfaceFormalize',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any provision from instances of C_P where USER::selectOne(id:selected.Provision_Id);
if(not_empty provision)
  select one component related by provision->C_IR[R4009]->C_PO[R4016]->C_C[R4010];
  if (not_empty component)
    select one componentPackage related by component->CP_CP[R4604];
    // if the package is empty, search up the component tree
    // until we find one
    if(empty componentPackage)
      select one parentComponent related by component->CN_CIC[R4203]->C_C[R4202];
      if(not_empty parentComponent)
        while(empty componentPackage)
          select one componentPackage related by parentComponent->CP_CP[R4604];
          select one parentComponent related by parentComponent->CN_CIC[R4203]->C_C[R4202];
        end while;
      end if;
    end if;
    if (not empty componentPackage)
      select one system related by componentPackage->S_SYS[R4606];
      select one existingI related by provision->C_IR[R4009]->C_I[R4012];
      id = GD::NULL_UNIQUE_ID();
      if(not_empty existingI)
        id = existingI.Id;
      end if;
      select any Diagram related by system->IP_IP[R4304] where USER::selectOne(id:selected.Package_ID) and provision.canUseInterfacesInPackage(Id:selected.Package_ID);
      if(not_empty Diagram)
        select any Interface related by Diagram->C_I[R4303] where USER::selectOne(id:selected.Id) and (selected.Id != id);
        provision.formalize(Id:Interface.Id, formalizeReq:true);
      end if;
    end if;
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6150);
INSERT INTO S_SYNC
	VALUES (6150,
	1,
	'C_P_ProvidedInterfaceUnformalize',
	'ContextMenuFunction: TRUE',
	'select any provision from instances of C_P where USER::selectOne(id:selected.Provision_Id);
if(not_empty provision)
  provision.unformalize(unformalizeReq:true);
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6151);
INSERT INTO S_SYNC
	VALUES (6151,
	1,
	'C_R_SpecializedPackageRequiredInterfaceFormalize',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any requirement from instances of C_R where USER::selectOne(id:selected.Requirement_Id);
if(not_empty requirement)
  select one component related by requirement->C_IR[R4009]->C_PO[R4016]->C_C[R4010];
  if (not_empty component)
    select one componentPackage related by component->CP_CP[R4604];
    // if the package is empty, search up the component tree
    // until we find one
    if(empty componentPackage)
      select one parentComponent related by component->CN_CIC[R4203]->C_C[R4202];
      if(not_empty parentComponent)
        while(empty componentPackage)
          select one componentPackage related by parentComponent->CP_CP[R4604];
          select one parentComponent related by parentComponent->CN_CIC[R4203]->C_C[R4202];
        end while;
      end if;
    end if;
    if (not empty componentPackage)
      select one system related by componentPackage->S_SYS[R4606];
      select one existingI related by requirement->C_IR[R4009]->C_I[R4012];
      id = GD::NULL_UNIQUE_ID();
      if (not_empty existingI)
        id = existingI.Id;
      end if;
      select any Diagram related by system->IP_IP[R4304] where USER::selectOne(id:selected.Package_ID) and requirement.canUseInterfacesInPackage(Id:selected.Package_ID);
      if(not_empty Diagram)
        select any Interface related by Diagram->C_I[R4303] where USER::selectOne(id:selected.Id) and (selected.Id != id);
        requirement.formalize(Id:Interface.Id, formalizePro:true);
      end if;
    end if;
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6152);
INSERT INTO S_SYNC
	VALUES (6152,
	1,
	'C_R_RequiredInterfaceUnformalize',
	'ContextMenuFunction: TRUE',
	'select any requirement from instances of C_R where USER::selectOne(id:selected.Requirement_Id);
if(not_empty requirement)
  requirement.unformalize(unformalizePro:true);
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6153);
INSERT INTO S_SYNC
	VALUES (6153,
	1,
	'CL_IC_SpecializedPackageAssignComponent',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// ::CN_IC_AssignComponent()
select any icomp from instances of CL_IC where USER::selectOne(id:selected.Id);
select one compPackage related by icomp->CP_CP[R4605];
if(empty compPackage)
  select one container related by icomp->C_C[R4205];
  if(not_empty container)
    while(empty compPackage)
      select one compPackage related by container->CP_CP[R4604];
      select one container related by container->CN_CIC[R4203]->C_C[R4202];
    end while;
  end if;
end if;
select one component related by icomp->C_C[R4201];
existingId = GD::NULL_UNIQUE_ID();
if not_empty component
  existingId = component.Id;
end if;
if not_empty compPackage
  select one system related by compPackage->S_SYS[R4606];
  select any Package related by system->CP_CP[R4606] where
              USER::selectOne(id:selected.Package_ID) and icomp.canAssignToCompInPackage(Id:selected.Package_ID);
  if not_empty Package
    select any Component related by Package->C_C[R4604] where
                USER::selectOne(id:selected.Id) and selected.Id != existingId and icomp.canAssignToComp(Id:selected.Id, checkExistingType:true);
    if not_empty Component
      icomp.assignToComp(Id:Component.Id);
    end if;
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6154);
INSERT INTO S_SYNC
	VALUES (6154,
	1,
	'CL_IC_Unassign',
	'ContextMenuFunction: TRUE',
	'select any icomp from instances of CL_IC where USER::selectOne(id:selected.Id);
if(not_empty icomp)
  icomp.unAssign();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6155);
INSERT INTO S_SYNC
	VALUES (6155,
	1,
	'CL_IC_Delete',
	'ContextMenuFunction: TRUE',
	'select many imports from instances of CL_IC where USER::selectOne(id:selected.Id);
for each import in imports
  import.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6156);
INSERT INTO S_SYNC
	VALUES (6156,
	1,
	'C_IO_Delete',
	'ContextMenuFunction: TRUE',
	'select many ops from instances of C_IO where USER::selectOne(id:selected.Id);
for each op in ops
  op.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6157);
INSERT INTO S_SYNC
	VALUES (6157,
	1,
	'C_IO_Rename',
	'ContextMenuFunction: TRUE',
	'select any op from instances of C_IO where USER::selectOne(id:selected.Id);
if(not_empty op)
  op.Name = param.new_name;
end if;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (6158,
	6157,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6159);
INSERT INTO S_SYNC
	VALUES (6159,
	1,
	'C_IO_NewParameter',
	'ContextMenuFunction: TRUE',
	'select any op from instances of C_IO where USER::selectOne(id:selected.Id);
if(not_empty op)
  op.newParameter();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6160);
INSERT INTO S_SYNC
	VALUES (6160,
	1,
	'S_SDT_Delete',
	'ContextMenuFunction: TRUE',
	'select many sdts from instances of S_SDT where USER::selectOne(id:selected.DT_ID);
for each sdt in sdts
  select one dt related by sdt->S_DT[R17];
  dt.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6161);
INSERT INTO S_SYNC
	VALUES (6161,
	1,
	'S_SDT_Rename',
	'ContextMenuFunction: TRUE',
	'select any sdt from instances of S_SDT where USER::selectOne(id:selected.DT_ID);
sdt.rename(new_name:param.new_name);',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (6162,
	6161,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6163);
INSERT INTO S_SYNC
	VALUES (6163,
	1,
	'S_MBR_Delete',
	'ContextMenuFunction: TRUE',
	'select many members from instances of S_MBR where USER::selectOne(id:selected.Member_ID);
for each member in members
  member.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6164);
INSERT INTO S_SYNC
	VALUES (6164,
	1,
	'S_MBR_Rename',
	'ContextMenuFunction: TRUE',
	'select any member from instances of S_MBR where
                                         USER::selectOne(id:selected.Member_ID);
member.rename(new_name:param.new_name);',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (6165,
	6164,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6166);
INSERT INTO S_SYNC
	VALUES (6166,
	1,
	'S_SDT_NewMember',
	'ContextMenuFunction: TRUE',
	'select any sdt from instances of S_SDT where USER::selectOne(id:selected.DT_ID);
sdt.newMember();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6167);
INSERT INTO S_SYNC
	VALUES (6167,
	1,
	'S_MBR_MoveUp',
	'ContextMenuFunction: TRUE',
	'// UI: exclude member at top of list
select any member from instances of S_MBR
                                   where USER::selectOne(id:selected.Member_ID);
member.moveUp();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6168);
INSERT INTO S_SYNC
	VALUES (6168,
	1,
	'S_MBR_MoveDown',
	'ContextMenuFunction: TRUE',
	'// UI: exclude member at bottom of list
select any member from instances of S_MBR
                                   where USER::selectOne(id:selected.Member_ID);
member.moveDown();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6169);
INSERT INTO S_SYNC
	VALUES (6169,
	1,
	'SM_CRTXN_Delete',
	'ContextMenuFunction: TRUE
',
	'select many ctrans from instances of SM_CRTXN where USER::selectMany(id:selected.Trans_ID);
for each ctran in ctrans
  select one transition related by ctran->SM_TXN[R507];
  // may be empty if the destination state is
  // deleted first
  if(not_empty transition)
    transition.dispose();
  end if;
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6170);
INSERT INTO S_SYNC
	VALUES (6170,
	1,
	'SM_CRTXN_SpecializedPackageAssignEvent',
	'ContextMenuFunction: TRUE
',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// UI: event exists to assign
select any ctxn from instances of SM_CRTXN
   where USER::selectOne(id:selected.Trans_ID);
select one txn related by ctxn->SM_TXN[R507];
select one dest_state related by txn->SM_STATE[R506];
// select all events in the domain that meet our criteria for assignment
// ("select ... from instances of" not being possible here since generating
// code from it in this context will produce errors);
// note that we have to take into account in both the upwards and downwards
// traversals whether we are dealing with a class or instance state machine
select one stateMachine related by txn->SM_SM[R505];
select one modelClass related by stateMachine->SM_ISM[R517]->O_OBJ[R518];
select many machines related by modelClass->S_SS[R2]->S_DOM[R1]->S_SS[R1]
	->O_OBJ[R2]->SM_ISM[R518]->SM_SM[R517];
select any event related by machines->SM_EVT[R502]
	where USER::selectOne(id:selected.SMevt_ID)
    	and stateMachine.canAssignEvent(eventId:selected.SMevt_ID,
                 eventStateMachineId:selected.SM_ID, isCreationTransition:true)
	    and dest_state.notAlreadyAssigned(eventId:selected.SMevt_ID,
                              eventStateMachineId: selected.SM_ID, crtxn: true);
txn.addEvent(eventId:event.SMevt_ID, eventStateMachineId:event.SM_ID);',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6171);
INSERT INTO S_SYNC
	VALUES (6171,
	1,
	'SM_CRTXN_RemoveEvent',
	'ContextMenuFunction: TRUE
',
	'// UI: event is assigned to transition
select any crtxn from instances of SM_CRTXN
   where USER::selectOne(id:selected.Trans_ID);
select one txn related by crtxn->SM_TXN[R507];
txn.removeEvent();',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6172);
INSERT INTO S_SYNC
	VALUES (6172,
	1,
	'SM_NLEVT_Delete',
	'ContextMenuFunction: TRUE
',
	'select many evts from instances of SM_NLEVT where USER::selectOne(id:selected.SMevt_ID);
for each nlevt in evts
  select one evt related by nlevt->SM_SEVT[R526]->SM_EVT[R525];
  evt.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6173);
INSERT INTO S_SYNC
	VALUES (6173,
	1,
	'CP_CP_Rename',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any package from instances of CP_CP where USER::selectOne(id:selected.Package_ID);
if(not_empty package)
  package.Name = param.new_name;
end if;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (6174,
	6173,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6175);
INSERT INTO S_SYNC
	VALUES (6175,
	1,
	'CP_CP_Delete',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many packages from instances of CP_CP where USER::selectOne(id:selected.Package_ID);
for each package in packages
  package.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6176);
INSERT INTO S_SYNC
	VALUES (6176,
	1,
	'C_DG_Unformalize',
	'ContextMenuFunction: TRUE',
	'select any delegation from instances of C_DG where USER::selectOne(id:selected.Id);
if(not_empty delegation)
  select any ir related by delegation->C_RID[R4013]->C_IR[R4013];
  if(not_empty ir)
    select one provision related by ir->C_P[R4009];
    if(not_empty provision)
      provision.unformalize(unformalizeReq:true);
    end if;
    select one requirement related by ir->C_R[R4009];
    if(not_empty requirement)
      requirement.unformalize(unformalizePro:true);
    end if;
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6177);
INSERT INTO S_SYNC
	VALUES (6177,
	1,
	'C_DG_SpecializedPackageFormalize',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any delegation from instances of C_DG where USER::selectOne(id:selected.Id);
if(not_empty delegation)
  select any ir related by delegation->C_RID[R4013]->C_IR[R4013];
  select one component related by ir->C_PO[R4016]->C_C[R4010];
  if (not_empty component)
    select one componentPackage related by component->CP_CP[R4604];
    // if the package is empty, search up the component tree
    // until we find one
    if(empty componentPackage)
      select one parentComponent related by component->CN_CIC[R4203]->C_C[R4202];
      if(not_empty parentComponent)
        while(empty componentPackage)
          select one componentPackage related by parentComponent->CP_CP[R4604];
          select one parentComponent related by parentComponent->CN_CIC[R4203]->C_C[R4202];
        end while;
      end if;
    end if;
    if (not empty componentPackage)
      select one system related by componentPackage->S_SYS[R4606];
      select one existingI related by ir->C_I[R4012];
      id = GD::NULL_UNIQUE_ID();
      if(not_empty existingI)
        id = existingI.Id;
      end if;
      select any Diagram related by system->IP_IP[R4304] where USER::selectOne(id:selected.Package_ID) and ir.canUseInterfacesInPackage(Id:selected.Package_ID);
      if(not_empty Diagram)
        select any Interface related by Diagram->C_I[R4303] where USER::selectOne(id:selected.Id) and (selected.Id != id);
        select one provision related by ir->C_P[R4009];
        if(not_empty provision)
          provision.formalize(Id:Interface.Id, formalizeReq:true);
        end if;
        select one requirement related by ir->C_R[R4009];
        if(not_empty requirement)
          requirement.formalize(Id:Interface.Id, formalizePro:true);
        end if;
      end if;
    end if;
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6178);
INSERT INTO S_SYNC
	VALUES (6178,
	1,
	'C_DG_Delete',
	'ContextMenuFunction: TRUE',
	'select many delegations from instances of C_DG where USER::selectOne(id:selected.Id);
for each delegation in delegations
  delegation.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6179);
INSERT INTO S_SYNC
	VALUES (6179,
	1,
	'SM_TXN_SpecializedPackageAssignSignal',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// UI: signal exists to assign
select any txn from instances of SM_TXN where
                                          USER::selectOne(id:selected.Trans_ID);
Trans_ID = txn.Trans_ID;
select one stateMachine related by txn->SM_SM[R505];
select one classStateMachine related by stateMachine->SM_ASM[R517];
select any interface related by classStateMachine->O_OBJ[R519]->
                    S_SS[R2]->S_DOM[R1]->CN_DC[R4204]->C_C[R4204]->
                                         C_PO[R4010]->C_IR[R4016] where
                                       USER::selectOne(id:selected.Id) and
                                                stateMachine.hasValidSignals(
                              interface_id:selected.Id, transition_id:Trans_ID);
if not_empty interface
  select any signal related by interface->
                     C_I[R4012]->C_EP[R4003]->C_AS[R4004] where
                              USER::selectOne(id:selected.Id) and
                                        stateMachine.canAssignSignal(
                                signal_id:selected.Id, transition_id:Trans_ID,
                                                     interface_id:interface.Id);
  txn.addSignal(interface_id:interface.Id, signal_id:signal.Id);
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6180);
INSERT INTO S_SYNC
	VALUES (6180,
	1,
	'SM_TXN_RemoveSignal',
	'ContextMenuFunction: TRUE',
	'// UI: signal is assigned to transition
select any txn from instances of SM_TXN where
                                          USER::selectOne(id:selected.Trans_ID);
txn.removeSignal();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6181);
INSERT INTO S_SYNC
	VALUES (6181,
	1,
	'C_PO_Rename',
	'ContextMenuFunction: TRUE',
	'select any port from instances of C_PO where USER::selectOne(id:selected.Id);
if(not_empty port)
  port.Name = param.new_name;
end if;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (6182,
	6181,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6183);
INSERT INTO S_SYNC
	VALUES (6183,
	1,
	'C_PO_Delete',
	'ContextMenuFunction: TRUE',
	'select many ports from instances of C_PO where USER::selectOne(id:selected.Id);
for each port in ports
  port.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6184);
INSERT INTO S_SYNC
	VALUES (6184,
	1,
	'SM_EVT_NewParameter',
	'ContextMenuFunction: TRUE',
	'// ::SM_EVT_NewEventParameter()
select any evt from instances of SM_EVT where
                                          USER::selectOne(id:selected.SMevt_ID);
evt.newParameter();',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6185);
INSERT INTO S_SYNC
	VALUES (6185,
	1,
	'SQ_COP_Delete',
	'ContextMenuFunction: TRUE',
	'select many comps from instances of SQ_COP where USER::selectOne(id:selected.Part_ID);
for each comp in comps
  comp.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6186);
INSERT INTO S_SYNC
	VALUES (6186,
	1,
	'SQ_COP_Rename',
	'ContextMenuFunction: TRUE',
	'select any compPart from instances of SQ_COP where USER::selectOne(id:selected.Part_ID);
if(not_empty compPart)
  compPart.InformalComponentName = param.new_name;
end if;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (6187,
	6186,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6188);
INSERT INTO S_SYNC
	VALUES (6188,
	1,
	'EP_PKG_Rename',
	'ContextMenuFunction: TRUE',
	'select any package from instances of EP_PKG 
                                  where USER::selectOne(id:selected.Package_ID);
if(not_empty package)
  package.Name = param.new_name;
end if;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (6189,
	6188,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6190);
INSERT INTO S_SYNC
	VALUES (6190,
	1,
	'EP_PKG_Delete',
	'ContextMenuFunction: TRUE',
	'select many packages from instances of EP_PKG where USER::selectOne(id:selected.Package_ID);
for each package in packages
  package.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6191);
INSERT INTO S_SYNC
	VALUES (6191,
	1,
	'S_SPARM_MoveUp',
	'ContextMenuFunction: TRUE',
	'// UI: exclude item at top of list
select any item from instances of S_SPARM
                                   where USER::selectOne(id:selected.SParm_ID);
item.moveUp();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6192);
INSERT INTO S_SYNC
	VALUES (6192,
	1,
	'S_SPARM_MoveDown',
	'ContextMenuFunction: TRUE',
	'// UI: exclude item at bottom of list
select any item from instances of S_SPARM
                                   where USER::selectOne(id:selected.SParm_ID);
item.moveDown();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6193);
INSERT INTO S_SYNC
	VALUES (6193,
	1,
	'S_BPARM_MoveUp',
	'ContextMenuFunction: TRUE',
	'// UI: exclude item at top of list
select any item from instances of S_BPARM
                                   where USER::selectOne(id:selected.BParm_ID);
item.moveUp();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6194);
INSERT INTO S_SYNC
	VALUES (6194,
	1,
	'S_BPARM_MoveDown',
	'ContextMenuFunction: TRUE',
	'// UI: exclude item at bottom of list
select any item from instances of S_BPARM
                                   where USER::selectOne(id:selected.BParm_ID);
item.moveDown();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6195);
INSERT INTO S_SYNC
	VALUES (6195,
	1,
	'S_ENUM_MoveUp',
	'ContextMenuFunction: TRUE',
	'// UI: exclude item at top of list
select any item from instances of S_ENUM
                                   where USER::selectOne(id:selected.Enum_ID);
item.moveUp();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6196);
INSERT INTO S_SYNC
	VALUES (6196,
	1,
	'S_ENUM_MoveDown',
	'ContextMenuFunction: TRUE',
	'// UI: exclude item at bottom of list
select any item from instances of S_ENUM
                                   where USER::selectOne(id:selected.Enum_ID);
item.moveDown();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6197);
INSERT INTO S_SYNC
	VALUES (6197,
	1,
	'SM_EVTDI_MoveUp',
	'ContextMenuFunction: TRUE',
	'// UI: exclude item at top of list
select any item from instances of SM_EVTDI
                                   where USER::selectOne(id:selected.SMedi_ID);
item.moveUp();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6198);
INSERT INTO S_SYNC
	VALUES (6198,
	1,
	'SM_EVTDI_MoveDown',
	'ContextMenuFunction: TRUE',
	'// UI: exclude item at bottom of list
select any item from instances of SM_EVTDI
                                   where USER::selectOne(id:selected.SMedi_ID);
item.moveDown();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6199);
INSERT INTO S_SYNC
	VALUES (6199,
	1,
	'C_AS_MoveUp',
	'ContextMenuFunction: TRUE',
	'// UI: exclude item at top of list
select any item from instances of C_AS
                                   where USER::selectOne(id:selected.Id);
item.moveUp();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6200);
INSERT INTO S_SYNC
	VALUES (6200,
	1,
	'C_AS_MoveDown',
	'ContextMenuFunction: TRUE',
	'// UI: exclude item at bottom of list
select any item from instances of C_AS
                                   where USER::selectOne(id:selected.Id);
item.moveDown();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6201);
INSERT INTO S_SYNC
	VALUES (6201,
	1,
	'C_IO_MoveUp',
	'ContextMenuFunction: TRUE',
	'// UI: exclude item at top of list
select any item from instances of C_IO
                                   where USER::selectOne(id:selected.Id);
item.moveUp();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6202);
INSERT INTO S_SYNC
	VALUES (6202,
	1,
	'C_IO_MoveDown',
	'ContextMenuFunction: TRUE',
	'// UI: exclude item at bottom of list
select any item from instances of C_IO
                                   where USER::selectOne(id:selected.Id);
item.moveDown();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6203);
INSERT INTO S_SYNC
	VALUES (6203,
	1,
	'C_PP_MoveUp',
	'ContextMenuFunction: TRUE',
	'// UI: exclude item at top of list
select any item from instances of C_PP
                                   where USER::selectOne(id:selected.PP_Id);
item.moveUp();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6204);
INSERT INTO S_SYNC
	VALUES (6204,
	1,
	'C_PP_MoveDown',
	'ContextMenuFunction: TRUE',
	'// UI: exclude item at bottom of list
select any item from instances of C_PP
                                   where USER::selectOne(id:selected.PP_Id);
item.moveDown();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6205);
INSERT INTO S_SYNC
	VALUES (6205,
	1,
	'O_TFR_MoveDown',
	'ContextMenuFunction: TRUE',
	'// UI: exclude item at bottom of list
select any item from instances of O_TFR
                                   where USER::selectOne(id:selected.Tfr_ID);
item.moveDown();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6206);
INSERT INTO S_SYNC
	VALUES (6206,
	1,
	'O_TPARM_MoveUp',
	'ContextMenuFunction: TRUE',
	'// UI: exclude item at top of list
select any item from instances of O_TPARM
                                   where USER::selectOne(id:selected.TParm_ID);
item.moveUp();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6207);
INSERT INTO S_SYNC
	VALUES (6207,
	1,
	'O_TPARM_MoveDown',
	'ContextMenuFunction: TRUE',
	'// UI: exclude item at bottom of list
select any item from instances of O_TPARM
                                   where USER::selectOne(id:selected.TParm_ID);
item.moveDown();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6208);
INSERT INTO S_SYNC
	VALUES (6208,
	1,
	'O_TFR_MoveUp',
	'ContextMenuFunction: TRUE',
	'// UI: exclude item at top of list
select any item from instances of O_TFR
                                   where USER::selectOne(id:selected.Tfr_ID);
item.moveUp();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6209);
INSERT INTO S_SYNC
	VALUES (6209,
	1,
	'O_OBJ_PublishReferences',
	'ContextMenuFunction: TRUE',
	'select any clazz from instances of O_OBJ where USER::selectOne(id:selected.Obj_ID);
                             clazz.newInstanceReferenceDataType();',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6210);
INSERT INTO S_SYNC
	VALUES (6210,
	1,
	'C_IO_SetReturnType',
	'ContextMenuFunction: TRUE',
	'select any element from instances of C_IO where USER::selectOne(id:selected.Id);
select one existingElement related by element->S_DT[R4008] where USER::selectExisting(id:selected.DT_ID);
if(not_empty element)
  select any selectedDT from instances of S_DT where USER::selectOne(id:selected.DT_ID) and (element.canUseDataType(id:selected.DT_ID));
  if(not_empty selectedDT)
    select one originalDT related by element->S_DT[R4008];
    if(selectedDT != originalDT)
      unrelate element from originalDT across R4008;
      relate element to selectedDT across R4008;
    end if;
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6211);
INSERT INTO S_SYNC
	VALUES (6211,
	1,
	'C_PP_SetType',
	'ContextMenuFunction: TRUE',
	'select any element from instances of C_PP where USER::selectOne(id:selected.PP_Id);
select one existingElement related by element->S_DT[R4007] where USER::selectExisting(id:selected.DT_ID);
if(not_empty element)
  select any selectedDT from instances of S_DT where USER::selectOne(id:selected.DT_ID) and (element.canUseDataType(id:selected.DT_ID));
  if(not_empty selectedDT)
    select one originalDT related by element->S_DT[R4007];
    if(selectedDT != originalDT)
      unrelate element from originalDT across R4007;
      relate element to selectedDT across R4007;
    end if;
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6212);
INSERT INTO S_SYNC
	VALUES (6212,
	1,
	'S_BPARM_SetType',
	'ContextMenuFunction: TRUE',
	'select any element from instances of S_BPARM where USER::selectOne(id:selected.BParm_ID);
select one existingElement related by element->S_DT[R22] where USER::selectExisting(id:selected.DT_ID);
if(not_empty element)
  select any selectedDT from instances of S_DT where USER::selectOne(id:selected.DT_ID) and (element.canUseDataType(id:selected.DT_ID));
  if(not_empty selectedDT)
    select one originalDT related by element->S_DT[R22];
    if(selectedDT != originalDT)
      unrelate element from originalDT across R22;
      relate element to selectedDT across R22;
    end if;
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6213);
INSERT INTO S_SYNC
	VALUES (6213,
	1,
	'S_BRG_SetReturnType',
	'ContextMenuFunction: TRUE',
	'select any element from instances of S_BRG where USER::selectOne(id:selected.Brg_ID);
select one existingElement related by element->S_DT[R20] where USER::selectExisting(id:selected.DT_ID);
if(not_empty element)
  select any selectedDT from instances of S_DT where USER::selectOne(id:selected.DT_ID) and (element.canUseDataType(id:selected.DT_ID));
  if(not_empty selectedDT)
    select one originalDT related by element->S_DT[R20];
    if(selectedDT != originalDT)
      unrelate element from originalDT across R20;
      relate element to selectedDT across R20;
    end if;
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6214);
INSERT INTO S_SYNC
	VALUES (6214,
	1,
	'S_SYNC_SetReturnType',
	'ContextMenuFunction: TRUE',
	'select any element from instances of S_SYNC where USER::selectOne(id:selected.Sync_ID);
select one existingElement related by element->S_DT[R25] where USER::selectExisting(id:selected.DT_ID);
if(not_empty element)
  select any selectedDT from instances of S_DT where USER::selectOne(id:selected.DT_ID) and (element.canUseDataType(id:selected.DT_ID));
  if(not_empty selectedDT)
    select one originalDT related by element->S_DT[R25];
    if(selectedDT != originalDT)
      unrelate element from originalDT across R25;
      relate element to selectedDT across R25;
    end if;
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6215);
INSERT INTO S_SYNC
	VALUES (6215,
	1,
	'S_SPARM_SetType',
	'ContextMenuFunction: TRUE',
	'select any element from instances of S_SPARM where USER::selectOne(id:selected.SParm_ID);
select one existingElement related by element->S_DT[R26] where USER::selectExisting(id:selected.DT_ID);
if(not_empty element)
  select any selectedDT from instances of S_DT where USER::selectOne(id:selected.DT_ID) and (element.canUseDataType(id:selected.DT_ID));
  if(not_empty selectedDT)
    select one originalDT related by element->S_DT[R26];
    if(selectedDT != originalDT)
      unrelate element from originalDT across R26;
      relate element to selectedDT across R26;
    end if;
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6216);
INSERT INTO S_SYNC
	VALUES (6216,
	1,
	'S_MBR_SetType',
	'ContextMenuFunction: TRUE',
	'select any element from instances of S_MBR where USER::selectOne(id:selected.Member_ID);
select one existingElement related by element->S_DT[R45] where USER::selectExisting(id:selected.DT_ID);
if(not_empty element)
  select any selectedDT from instances of S_DT where USER::selectOne(id:selected.DT_ID) and (element.canUseDataType(id:selected.DT_ID));
  if(not_empty selectedDT)
    select one originalDT related by element->S_DT[R45];
    if(selectedDT != originalDT)
      unrelate element from originalDT across R45;
      relate element to selectedDT across R45;
    end if;
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6217);
INSERT INTO S_SYNC
	VALUES (6217,
	1,
	'SM_EVTDI_SetType',
	'ContextMenuFunction: TRUE',
	'select any element from instances of SM_EVTDI where USER::selectOne(id:selected.SMedi_ID);
select one existingElement related by element->S_DT[R524] where USER::selectExisting(id:selected.DT_ID);
if(not_empty element)
  select any selectedDT from instances of S_DT where USER::selectOne(id:selected.DT_ID) and (element.canUseDataType(id:selected.DT_ID));
  if(not_empty selectedDT)
    select one originalDT related by element->S_DT[R524];
    if(selectedDT != originalDT)
      unrelate element from originalDT across R524;
      relate element to selectedDT across R524;
    end if;
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6218);
INSERT INTO S_SYNC
	VALUES (6218,
	1,
	'O_TPARM_SetType',
	'ContextMenuFunction: TRUE',
	'select any element from instances of O_TPARM where USER::selectOne(id:selected.TParm_ID);
select one existingElement related by element->S_DT[R118] where USER::selectExisting(id:selected.DT_ID);
if(not_empty element)
  select any selectedDT from instances of S_DT where USER::selectOne(id:selected.DT_ID) and (element.canUseDataType(id:selected.DT_ID));
  if(not_empty selectedDT)
    select one originalDT related by element->S_DT[R118];
    if(selectedDT != originalDT)
      unrelate element from originalDT across R118;
      relate element to selectedDT across R118;
    end if;
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6219);
INSERT INTO S_SYNC
	VALUES (6219,
	1,
	'O_TFR_SetReturnType',
	'ContextMenuFunction: TRUE',
	'select any element from instances of O_TFR where USER::selectOne(id:selected.Tfr_ID);
select one existingElement related by element->S_DT[R116] where USER::selectExisting(id:selected.DT_ID);
if(not_empty element)
  select any selectedDT from instances of S_DT where USER::selectOne(id:selected.DT_ID) and (element.canUseDataType(id:selected.DT_ID));
  if(not_empty selectedDT)
    select one originalDT related by element->S_DT[R116];
    if(selectedDT != originalDT)
      unrelate element from originalDT across R116;
      relate element to selectedDT across R116;
    end if;
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6220);
INSERT INTO S_SYNC
	VALUES (6220,
	1,
	'O_ATTR_SetType',
	'ContextMenuFunction: TRUE',
	'select any element from instances of O_ATTR where USER::selectOne(id:selected.Attr_ID);
select one existingElement related by element->S_DT[R114] where USER::selectExisting(id:selected.DT_ID);
if(not_empty element)
  select any selectedDT from instances of S_DT where USER::selectOne(id:selected.DT_ID) and (element.canUseDataType(id:selected.DT_ID));
  if(not_empty selectedDT)
    select one originalDT related by element->S_DT[R114];
    if(selectedDT != originalDT)
      unrelate element from originalDT across R114;
      relate element to selectedDT across R114;
    end if;
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6221);
INSERT INTO S_SYNC
	VALUES (6221,
	1,
	'S_UDT_SetType',
	'ContextMenuFunction: TRUE',
	'select any element from instances of S_UDT where USER::selectOne(id:selected.DT_ID);
select one existingElement related by element->S_DT[R18] where USER::selectExisting(id:selected.DT_ID);
if(not_empty element)
  select any selectedDT from instances of S_DT where USER::selectOne(id:selected.DT_ID) and (element.canUseDataType(id:selected.DT_ID));
  if(not_empty selectedDT)
    select one originalCoreDT related by element->S_DT[R18];
    if(selectedDT != originalCoreDT)
      unrelate element from originalCoreDT across R18;
      relate element to selectedDT across R18;
    end if;
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6222);
INSERT INTO S_SYNC
	VALUES (6222,
	1,
	'CNST_CSP_NewConstant',
	'ContextMenuFunction: TRUE',
	'select any csp from instances of CNST_CSP where USER::selectOne(id:selected.Constant_Spec_ID);
csp.newLiteralSymbolicConstant();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6223);
INSERT INTO S_SYNC
	VALUES (6223,
	1,
	'CNST_CSP_Delete',
	'ContextMenuFunction: TRUE',
	'select many csps from instances of CNST_CSP where USER::selectOne(id:selected.Constant_Spec_ID);
for each csp in csps
  csp.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6224);
INSERT INTO S_SYNC
	VALUES (6224,
	1,
	'CNST_CSP_Rename',
	'ContextMenuFunction: TRUE',
	'select any csp from instances of CNST_CSP where USER::selectOne(id:selected.Constant_Spec_ID);
csp.InformalGroupName = param.new_name;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (6225,
	6224,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6226);
INSERT INTO S_SYNC
	VALUES (6226,
	1,
	'CNST_LSC_Delete',
	'ContextMenuFunction: TRUE',
	'// To remove a literal symbolic constant, we find the symbolic constant supertype
// and delete it, which cleans up the whole supertype-subtype chain.
select many lscs from instances of CNST_LSC where USER::selectOne(id:selected.Const_ID);
for each lsc in lscs
  select one syc related by lsc->CNST_LFSC[R1503]->CNST_SYC[R1502];
  syc.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6227);
INSERT INTO S_SYNC
	VALUES (6227,
	1,
	'CNST_LSC_Rename',
	'ContextMenuFunction: TRUE',
	'select any lsc from instances of CNST_LSC where USER::selectOne(id:selected.Const_ID);
select one syc related by lsc->CNST_LFSC[R1503]->CNST_SYC[R1502];
syc.Name = param.new_name;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (6228,
	6227,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6229);
INSERT INTO S_SYNC
	VALUES (6229,
	1,
	'CNST_LSC_SetType',
	'ContextMenuFunction: TRUE',
	'select any element from instances of CNST_LSC where USER::selectOne(id:selected.Const_ID);
select one existingElement related by element->CNST_LFSC[R1503]->CNST_SYC[R1502]
                    ->S_DT[R1500] where USER::selectExisting(id:selected.DT_ID);
if(not_empty element)
  select any selectedDT from instances of S_DT where USER::selectOne(id:selected.DT_ID) and (element.canUseDataType(id:selected.DT_ID));
  if(not_empty selectedDT)
    select one syc related by element->CNST_LFSC[R1503]->CNST_SYC[R1502];
    select one originalDT related by syc->S_DT[R1500];
    unrelate syc from originalDT across R1500;

    relate syc to selectedDT across R1500;

    // Set the value to the default for this type
    element.updateValueToDefault(typeName:selectedDT.Name);
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6230);
INSERT INTO S_SYNC
	VALUES (6230,
	1,
	'C_P_Disconnect',
	'ContextMenuFunction: TRUE',
	'select many provisions from instances of C_P where
                                      USER::selectOne(id:selected.Provision_Id);
for each provision in provisions
  provision.dissatisfy();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6231);
INSERT INTO S_SYNC
	VALUES (6231,
	1,
	'C_R_Disconnect',
	'ContextMenuFunction: TRUE',
	'select many reqs from instances of C_R where
                                    USER::selectOne(id:selected.Requirement_Id);
for each req in reqs
  req.dissatisfy();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6232);
INSERT INTO S_SYNC
	VALUES (6232,
	1,
	'CL_IP_Disconnect',
	'ContextMenuFunction: TRUE',
	'select many providers from instances of CL_IP where
                                                USER::selectOne(id:selected.Id);
for each provider in providers
  provider.dissatisfy();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6233);
INSERT INTO S_SYNC
	VALUES (6233,
	1,
	'CL_IR_Disconnect',
	'ContextMenuFunction: TRUE',
	'select many reqs from instances of CL_IR where USER::selectOne(id:selected.Id);
for each req in reqs
  req.dissatisfy();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6234);
INSERT INTO S_SYNC
	VALUES (6234,
	1,
	'EP_PKG_NewFunction',
	'ContextMenuFunction: TRUE
',
	'select any pkg from instances of EP_PKG where USER::selectOne(id:selected.Package_ID);
pkg.newFunction();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6235);
INSERT INTO S_SYNC
	VALUES (6235,
	1,
	'CP_CP_NewComponent',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any package from instances of CP_CP where USER::selectOne(id:selected.Package_ID);
if(not empty package)
package.newComponent();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6236);
INSERT INTO S_SYNC
	VALUES (6236,
	1,
	'S_SYS_NewComponentPackage',
	'ContextMenuFunction: TRUE',
	'select any sys from instances of S_SYS where USER::selectOne(id:selected.Sys_ID);
if(not empty sys)
sys.newComponentPackage();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6237);
INSERT INTO S_SYNC
	VALUES (6237,
	1,
	'S_SYS_NewPackage',
	'ContextMenuFunction: TRUE',
	'select any sys from instances of S_SYS where USER::selectOne(id:selected.Sys_ID);
if(not empty sys)
sys.newPackage();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6238);
INSERT INTO S_SYNC
	VALUES (6238,
	1,
	'S_SYS_NewSystemLevelDatatypePackage',
	'ContextMenuFunction: TRUE',
	'select any sys from instances of S_SYS where USER::selectOne(id:selected.Sys_ID);
if(not empty sys)
sys.newSystemDTPkg();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6239);
INSERT INTO S_SYNC
	VALUES (6239,
	1,
	'S_SYS_NewInterfacePackage',
	'ContextMenuFunction: TRUE',
	'select any sys from instances of S_SYS where USER::selectOne(id:selected.Sys_ID);
if(not empty sys)
sys.newInterfacePackage();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6240);
INSERT INTO S_SYNC
	VALUES (6240,
	1,
	'S_SYS_NewSequenceDiagram',
	'ContextMenuFunction: TRUE',
	'select any sys from instances of S_SYS where USER::selectOne(id:selected.Sys_ID);
if(not empty sys)
sys.newSequence();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6241);
INSERT INTO S_SYNC
	VALUES (6241,
	1,
	'S_SYS_NewCommunicationDiagram',
	'ContextMenuFunction: TRUE',
	'select any sys from instances of S_SYS where USER::selectOne(id:selected.Sys_ID);
if(not empty sys)
sys.newCommunication();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6242);
INSERT INTO S_SYNC
	VALUES (6242,
	1,
	'S_SYS_NewUsecaseDiagram',
	'ContextMenuFunction: TRUE',
	'select any sys from instances of S_SYS where USER::selectOne(id:selected.Sys_ID);
if(not empty sys)
sys.newUseCasePackage();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6243);
INSERT INTO S_SYNC
	VALUES (6243,
	1,
	'S_SYS_NewActivityDiagram',
	'ContextMenuFunction: TRUE',
	'select any sys from instances of S_SYS where USER::selectOne(id:selected.Sys_ID);
if(not empty sys)
sys.newActivity();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6244);
INSERT INTO S_SYNC
	VALUES (6244,
	1,
	'CP_CP_NewInterfacePackage',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any package from instances of CP_CP where USER::selectOne(id:selected.Package_ID);
if(not empty package)
package.newInterfacePackage();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6245);
INSERT INTO S_SYNC
	VALUES (6245,
	1,
	'CP_CP_NewComponentPackage',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any package from instances of CP_CP where USER::selectOne(id:selected.Package_ID);
if(not empty package)
package.newComponentPackage();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6246);
INSERT INTO S_SYNC
	VALUES (6246,
	1,
	'CP_CP_NewSequenceDiagram',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any package from instances of CP_CP where USER::selectOne(id:selected.Package_ID);
if(not empty package)
package.newSequence();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6247);
INSERT INTO S_SYNC
	VALUES (6247,
	1,
	'CP_CP_NewCommunicationDiagram',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any package from instances of CP_CP where USER::selectOne(id:selected.Package_ID);
if(not empty package)
package.newCommunication();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6248);
INSERT INTO S_SYNC
	VALUES (6248,
	1,
	'CP_CP_NewUsecaseDiagram',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any package from instances of CP_CP where USER::selectOne(id:selected.Package_ID);
if(not empty package)
package.newUseCasePackage();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6249);
INSERT INTO S_SYNC
	VALUES (6249,
	1,
	'CP_CP_NewActivityDiagram',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any package from instances of CP_CP where USER::selectOne(id:selected.Package_ID);
if(not empty package)
package.newActivity();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6250);
INSERT INTO S_SYNC
	VALUES (6250,
	1,
	'CP_CP_NewComponentReference',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any package from instances of CP_CP where USER::selectOne(id:selected.Package_ID);
if(not empty package)
package.newImportedComponent();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6251);
INSERT INTO S_SYNC
	VALUES (6251,
	1,
	'EP_PKG_NewPackage',
	'ContextMenuFunction: TRUE',
	'select any package from instances of EP_PKG where USER::selectOne(id:selected.Package_ID);
if(not_empty package)
  package.newPackage();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6252);
INSERT INTO S_SYNC
	VALUES (6252,
	1,
	'S_DPK_NewUserDatatype',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any dPkg from instances of S_DPK where USER::selectOne(id:selected.Package_ID);
if(not empty dPkg)
dPkg.newDatatype();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6253);
INSERT INTO S_SYNC
	VALUES (6253,
	1,
	'S_DPK_NewStructuredDatatype',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any dPkg from instances of S_DPK where USER::selectOne(id:selected.Package_ID);
if(not empty dPkg)
dPkg.newStructuredDatatype();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6254);
INSERT INTO S_SYNC
	VALUES (6254,
	1,
	'S_DPK_NewEnumerationDatatype',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any dPkg from instances of S_DPK where USER::selectOne(id:selected.Package_ID);
if(not empty dPkg)
dPkg.newEnumeration();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6255);
INSERT INTO S_SYNC
	VALUES (6255,
	1,
	'S_DPK_NewConstantSpecification',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any dPkg from instances of S_DPK where USER::selectOne(id:selected.Package_ID);
if(not empty dPkg)
dPkg.newConstantSpecification();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6256);
INSERT INTO S_SYNC
	VALUES (6256,
	1,
	'S_DPK_NewDatatypePackage',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any dPkg from instances of S_DPK where USER::selectOne(id:selected.Package_ID);
if(not empty dPkg)
dPkg.newDatatypePackage();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6257);
INSERT INTO S_SYNC
	VALUES (6257,
	1,
	'IP_IP_NewInterface',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any diagram from instances of IP_IP where USER::selectOne(id:selected.Package_ID);
if(not_empty diagram)
  diagram.newInterface();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6258);
INSERT INTO S_SYNC
	VALUES (6258,
	1,
	'IP_IP_NewInterfacePackage',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any diagram from instances of IP_IP where USER::selectOne(id:selected.Package_ID);
if(not_empty diagram)
  diagram.newInterfacePackage();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6259);
INSERT INTO S_SYNC
	VALUES (6259,
	1,
	'SQ_S_NewSequenceDiagram',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any sequence from instances of SQ_S where USER::selectOne(id:selected.Package_ID);
if(not_empty sequence)
  sequence.newSequence();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6260);
INSERT INTO S_SYNC
	VALUES (6260,
	1,
	'SQ_S_NewComponentParticipant',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any sequence from instances of SQ_S where USER::selectOne(id:selected.Package_ID);
if(not_empty sequence)
  sequence.newComponentParticipant();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6261);
INSERT INTO S_SYNC
	VALUES (6261,
	1,
	'SQ_S_NewInstance',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any sequence from instances of SQ_S where USER::selectOne(id:selected.Package_ID);
if(not_empty sequence)
  sequence.newClassInstance();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6262);
INSERT INTO S_SYNC
	VALUES (6262,
	1,
	'SQ_S_NewActorParticipant',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any sequence from instances of SQ_S where USER::selectOne(id:selected.Package_ID);
if(not_empty sequence)
  sequence.newActor();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6263);
INSERT INTO S_SYNC
	VALUES (6263,
	1,
	'SQ_S_NewExternalEntity',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any sequence from instances of SQ_S where USER::selectOne(id:selected.Package_ID);
if(not_empty sequence)
  sequence.newExternalEntityParticipant();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6264);
INSERT INTO S_SYNC
	VALUES (6264,
	1,
	'SQ_S_NewClassParticipant',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any sequence from instances of SQ_S where USER::selectOne(id:selected.Package_ID);
if(not_empty sequence)
  sequence.newClassParticipant();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6265);
INSERT INTO S_SYNC
	VALUES (6265,
	1,
	'SQ_S_NewFunctionPackageParticipant',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any sequence from instances of SQ_S where USER::selectOne(id:selected.Package_ID);
if(not_empty sequence)
  sequence.newFunctionPackageParticipant();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6266);
INSERT INTO S_SYNC
	VALUES (6266,
	1,
	'COMM_COMM_NewCommunicationDiagram',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any comm from instances of COMM_COMM where USER::selectOne(id:selected.Package_ID);
if(not_empty comm)
  comm.newCommunication();
end if;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6267);
INSERT INTO S_SYNC
	VALUES (6267,
	1,
	'COMM_COMM_NewComponentParticipant',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any comm from instances of COMM_COMM where USER::selectOne(id:selected.Package_ID);
if(not_empty comm)
  comm.newComponentParticipant();
  
end if;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6268);
INSERT INTO S_SYNC
	VALUES (6268,
	1,
	'COMM_COMM_NewInstance',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any comm from instances of COMM_COMM where USER::selectOne(id:selected.Package_ID);
if(not_empty comm)
  comm.newClassInstance();
end if;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6269);
INSERT INTO S_SYNC
	VALUES (6269,
	1,
	'COMM_COMM_NewActorParticipant',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any comm from instances of COMM_COMM where USER::selectOne(id:selected.Package_ID);
if(not_empty comm)
  comm.newActor();
end if;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6270);
INSERT INTO S_SYNC
	VALUES (6270,
	1,
	'COMM_COMM_NewExternalEntity',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any comm from instances of COMM_COMM where USER::selectOne(id:selected.Package_ID);
if(not_empty comm)
  comm.newExternalEntityParticipant();
end if;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6271);
INSERT INTO S_SYNC
	VALUES (6271,
	1,
	'COMM_COMM_NewClassParticipant',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any comm from instances of COMM_COMM where USER::selectOne(id:selected.Package_ID);
if(not_empty comm)
  comm.newClassParticipant();
end if;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6272);
INSERT INTO S_SYNC
	VALUES (6272,
	1,
	'COMM_COMM_NewFunctionPackageParticipant',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any comm from instances of COMM_COMM where USER::selectOne(id:selected.Package_ID);
if(not_empty comm)
  comm.newFunctionPackageParticipant();
end if;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6273);
INSERT INTO S_SYNC
	VALUES (6273,
	1,
	'UC_UCC_NewUseCaseDiagram',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any ucc from instances of UC_UCC where USER::selectOne(id:selected.Package_ID);
if(not_empty ucc)
  ucc.newUseCasePackage();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6274);
INSERT INTO S_SYNC
	VALUES (6274,
	1,
	'UC_UCC_NewUsecase',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any ucc from instances of UC_UCC where USER::selectOne(id:selected.Package_ID);
if(not_empty ucc)
  ucc.newUseCase();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6275);
INSERT INTO S_SYNC
	VALUES (6275,
	1,
	'UC_UCC_NewActor',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any ucc from instances of UC_UCC where USER::selectOne(id:selected.Package_ID);
if(not_empty ucc)
  ucc.newActor();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6276);
INSERT INTO S_SYNC
	VALUES (6276,
	1,
	'A_A_NewAction',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any act from instances of A_A where USER::selectOne(id:selected.Package_ID);
if(not empty act)
act.newGenericAction();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6277);
INSERT INTO S_SYNC
	VALUES (6277,
	1,
	'A_A_NewObjectNode',
	'ContextMenuFunction: TRUE
',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any act from instances of A_A where USER::selectOne(id:selected.Package_ID);
if(not empty act)
act.newObjectNode();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6278);
INSERT INTO S_SYNC
	VALUES (6278,
	1,
	'A_A_NewAcceptEventAction',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any act from instances of A_A where USER::selectOne(id:selected.Package_ID);
if(not empty act)
act.newAcceptEventAction();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6279);
INSERT INTO S_SYNC
	VALUES (6279,
	1,
	'A_A_NewSendSignalAction',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any act from instances of A_A where USER::selectOne(id:selected.Package_ID);
if(not empty act)
act.newSendSignalAction();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6280);
INSERT INTO S_SYNC
	VALUES (6280,
	1,
	'A_A_NewAcceptTimeEventAction',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any act from instances of A_A where USER::selectOne(id:selected.Package_ID);
if(not empty act)
act.newAcceptTimeEventAction();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6281);
INSERT INTO S_SYNC
	VALUES (6281,
	1,
	'S_DOM_NewSubsystem',
	'ContextMenuFunction: TRUE
',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any dom from instances of S_DOM where USER::selectOne(id:selected.Dom_ID);
if(not empty dom)
dom.newSubsystem();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6282);
INSERT INTO S_SYNC
	VALUES (6282,
	1,
	'S_DOM_NewExternalEntityPackage',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any dom from instances of S_DOM where USER::selectOne(id:selected.Dom_ID);
if(not empty dom)
dom.newExternalEntityPackage();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6283);
INSERT INTO S_SYNC
	VALUES (6283,
	1,
	'S_DOM_NewFunctionPackage',
	'ContextMenuFunction: TRUE
',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any dom from instances of S_DOM where USER::selectOne(id:selected.Dom_ID);
if(not empty dom)
dom.newFunctionPackage();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6284);
INSERT INTO S_SYNC
	VALUES (6284,
	1,
	'S_DOM_NewDatatypePackage',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any dom from instances of S_DOM where USER::selectOne(id:selected.Dom_ID);
if(not empty dom)
dom.newDatatypePackage();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6285);
INSERT INTO S_SYNC
	VALUES (6285,
	1,
	'S_DOM_NewSequenceDiagram',
	'ContextMenuFunction: TRUE
',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any dom from instances of S_DOM where USER::selectOne(id:selected.Dom_ID);
if(not empty dom)
dom.newSequence();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6286);
INSERT INTO S_SYNC
	VALUES (6286,
	1,
	'S_DOM_NewCommunicationDiagram',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any dom from instances of S_DOM where USER::selectOne(id:selected.Dom_ID);
if(not empty dom)
dom.newCommunication();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6287);
INSERT INTO S_SYNC
	VALUES (6287,
	1,
	'S_DOM_NewUsecaseDiagram',
	'ContextMenuFunction: TRUE
',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any dom from instances of S_DOM where USER::selectOne(id:selected.Dom_ID);
if(not empty dom)
dom.newUseCasePackage();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6288);
INSERT INTO S_SYNC
	VALUES (6288,
	1,
	'S_DOM_NewActivityDiagram',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any dom from instances of S_DOM where USER::selectOne(id:selected.Dom_ID);
if(not empty dom)
dom.newActivity();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6289);
INSERT INTO S_SYNC
	VALUES (6289,
	1,
	'S_SS_NewClass',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any ss from instances of S_SS where USER::selectOne(id:selected.SS_ID);
if(not empty ss)
ss.newClass();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6290);
INSERT INTO S_SYNC
	VALUES (6290,
	1,
	'S_SS_NewImportedClass',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any ss from instances of S_SS where USER::selectOne(id:selected.SS_ID);
if(not empty ss)
ss.newIClass();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6291);
INSERT INTO S_SYNC
	VALUES (6291,
	1,
	'S_SS_NewSubsystem',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any ss from instances of S_SS where USER::selectOne(id:selected.SS_ID);
if(not empty ss)
ss.newSubsystem();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6292);
INSERT INTO S_SYNC
	VALUES (6292,
	1,
	'S_SS_NewSequenceDiagram',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any ss from instances of S_SS where USER::selectOne(id:selected.SS_ID);
if(not empty ss)
ss.newSequence();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6293);
INSERT INTO S_SYNC
	VALUES (6293,
	1,
	'S_SS_NewCommunicationDiagram',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any ss from instances of S_SS where USER::selectOne(id:selected.SS_ID);
if(not empty ss)
ss.newCommunication();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6294);
INSERT INTO S_SYNC
	VALUES (6294,
	1,
	'S_SS_NewUsecaseDiagram',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any ss from instances of S_SS where USER::selectOne(id:selected.SS_ID);
if(not empty ss)
ss.newUseCasePackage();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6295);
INSERT INTO S_SYNC
	VALUES (6295,
	1,
	'S_SS_NewActivityDiagram',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any ss from instances of S_SS where USER::selectOne(id:selected.SS_ID);
if(not empty ss)
ss.newActivity();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6296);
INSERT INTO S_SYNC
	VALUES (6296,
	1,
	'S_EEPK_NewExternalEntity',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any ePkg from instances of S_EEPK where USER::selectOne(id:selected.EEPack_ID);
if(not empty ePkg)
ePkg.newExternalEntity();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6297);
INSERT INTO S_SYNC
	VALUES (6297,
	1,
	'S_EEPK_NewExternalEntityPackage',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any ePkg from instances of S_EEPK where USER::selectOne(id:selected.EEPack_ID);
if(not empty ePkg)
ePkg.newExternalEntityPackage();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6298);
INSERT INTO S_SYNC
	VALUES (6298,
	1,
	'S_FPK_NewFunctionPackage',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any fPkg from instances of S_FPK where USER::selectOne(id:selected.FunPack_ID);
if(not empty fPkg)
fPkg.newFunctionPackage();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6299);
INSERT INTO S_SYNC
	VALUES (6299,
	1,
	'C_C_NewInterfacePackage',
	'ContextMenuFunction: TRUE',
	'select any component from instances of C_C where USER::selectOne(id:selected.Package_ID);
if(not_empty component)
  component.newInterfacePackage();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6300);
INSERT INTO S_SYNC
	VALUES (6300,
	1,
	'C_C_NewSequenceDiagram',
	'ContextMenuFunction: TRUE',
	'select any component from instances of C_C where USER::selectOne(id:selected.Package_ID);
if(not empty component)
component.newSequence();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6301);
INSERT INTO S_SYNC
	VALUES (6301,
	1,
	'C_C_NewCommunicationDiagram',
	'ContextMenuFunction: TRUE',
	'select any component from instances of C_C where USER::selectOne(id:selected.Package_ID);
if(not empty component)
component.newCommunication();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6302);
INSERT INTO S_SYNC
	VALUES (6302,
	1,
	'C_C_NewUsecaseDiagram',
	'ContextMenuFunction: TRUE',
	'select any component from instances of C_C where USER::selectOne(id:selected.Package_ID);
if(not empty component)
component.newUseCasePackage();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6303);
INSERT INTO S_SYNC
	VALUES (6303,
	1,
	'C_C_NewActivityDiagram',
	'ContextMenuFunction: TRUE',
	'select any component from instances of C_C where USER::selectOne(id:selected.Package_ID);
if(not empty component)
component.newActivity();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6304);
INSERT INTO S_SYNC
	VALUES (6304,
	1,
	'C_C_NewComponent',
	'ContextMenuFunction: TRUE',
	'select any component from instances of C_C where USER::selectOne(id:selected.Package_ID);
if(not empty component)
  assign discardUuid = component.newComponent();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6305);
INSERT INTO S_SYNC
	VALUES (6305,
	1,
	'C_C_NewComponentReference',
	'ContextMenuFunction: TRUE',
	'select any component from instances of C_C where USER::selectOne(id:selected.Package_ID);
if(not empty component)
component.newImportedComponent();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6306);
INSERT INTO S_SYNC
	VALUES (6306,
	1,
	'SM_ISM_NewState',
	'ContextMenuFunction: TRUE
',
	'select any ism from instances of SM_ISM where USER::selectOne(id:selected.SM_ID);
if(not empty ism)
 ism.newState();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6307);
INSERT INTO S_SYNC
	VALUES (6307,
	1,
	'SM_ASM_NewState',
	'ContextMenuFunction: TRUE
',
	'select any asm from instances of SM_ASM where USER::selectOne(id:selected.SM_ID);
if(not empty asm)
 asm.newState();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6308);
INSERT INTO S_SYNC
	VALUES (6308,
	1,
	'UC_UCC_Rename',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any ucc from instances of UC_UCC where USER::selectOne(id:selected.Package_ID);
if(not_empty ucc)
  ucc.Name = param.new_name;
end if;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (6309,
	6308,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6310);
INSERT INTO S_SYNC
	VALUES (6310,
	1,
	'EP_PKG_MakePublic',
	'ContextMenuFunction: TRUE',
	'select any pkg from instances of EP_PKG where
                                        USER::selectOne(id:selected.Package_ID);
select one pe related by pkg->PE_PE[R8001];
pe.Visibility = Visibility::Public;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6311);
INSERT INTO S_SYNC
	VALUES (6311,
	1,
	'EP_PKG_MakePrivate',
	'ContextMenuFunction: TRUE',
	'select any pkg from instances of EP_PKG where
                                        USER::selectOne(id:selected.Package_ID);
select one pe related by pkg->PE_PE[R8001];
pe.Visibility = Visibility::Private;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6312);
INSERT INTO S_SYNC
	VALUES (6312,
	1,
	'S_UDT_MakePrivate',
	'ContextMenuFunction: TRUE',
	'select any udt from instances of S_UDT where USER::selectOne(id:selected.DT_ID);
select one pe related by udt->S_DT[R17]->PE_PE[R8001];
pe.Visibility = Visibility::Private;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6313);
INSERT INTO S_SYNC
	VALUES (6313,
	1,
	'S_UDT_MakePublic',
	'ContextMenuFunction: TRUE',
	'select any udt from instances of S_UDT where USER::selectOne(id:selected.DT_ID);
select one pe related by udt->S_DT[R17]->PE_PE[R8001];
pe.Visibility = Visibility::Public;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6314);
INSERT INTO S_SYNC
	VALUES (6314,
	1,
	'O_IOBJ_GenericPackageAssignClass',
	'ContextMenuFunction: TRUE',
	'// ::O_IOBJ_GenericPackageAssignClass()
select any element from instances of O_IOBJ where
                                           USER::selectOne(id:selected.IObj_ID);
select one existingElement related by element->O_OBJ[R101] where
                                       USER::selectExisting(id:selected.Obj_ID);
if not_empty element
  select any selectedObj from instances of O_OBJ where
                                            USER::selectOne(id:selected.Obj_ID);
  if not_empty selectedObj
    unrelate element from existingElement across R101;
    relate element to selectedObj across R101;
end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6315);
INSERT INTO S_SYNC
	VALUES (6315,
	1,
	'SQ_CIP_GenericPackageFormalize',
	'ContextMenuFunction: TRUE',
	'select any element from instances of SQ_CIP
                                     where USER::selectOne(id:selected.Part_ID);
select one existingElement related by element->O_OBJ[R934]
                                 where USER::selectExisting(id:selected.Obj_ID);
if(not_empty element)
  select any selectedElement from instances of O_OBJ
                                       where USER::selectOne(id:selected.Obj_ID)
                                     and selected.SS_ID == GD::NULL_UNIQUE_ID();
  if(not_empty selectedElement)
    element.formalize(classId:selectedElement.Obj_ID);
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6316);
INSERT INTO S_SYNC
	VALUES (6316,
	1,
	'SQ_EEP_GenericPackageFormalize',
	'ContextMenuFunction: TRUE',
	'select any element from instances of SQ_EEP
                                     where USER::selectOne(id:selected.Part_ID);
select one existingElement related by element->S_EE[R933]
                                  where USER::selectExisting(id:selected.EE_ID);
if(not_empty element)
  select any selectedElement from instances of S_EE
                                        where USER::selectOne(id:selected.EE_ID)
                                     and selected.Dom_ID == GD::NULL_UNIQUE_ID();
  if(not_empty selectedElement)
    element.formalize(eeId:selectedElement.EE_ID);
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6317);
INSERT INTO S_SYNC
	VALUES (6317,
	1,
	'SQ_CP_GenericPackageFormalize',
	'ContextMenuFunction: TRUE',
	'select any element from instances of SQ_CP
                                     where USER::selectOne(id:selected.Part_ID);
select one existingElement related by element->O_OBJ[R939]
                                 where USER::selectExisting(id:selected.Obj_ID);
if(not_empty element)
  select any selectedElement from instances of O_OBJ
                                       where USER::selectOne(id:selected.Obj_ID)
                                     and selected.SS_ID == GD::NULL_UNIQUE_ID();
  if(not_empty selectedElement)
    element.formalize(classId:selectedElement.Obj_ID);
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6318);
INSERT INTO S_SYNC
	VALUES (6318,
	1,
	'SM_TXN_GenericPackageAssignEvent',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// UI: event exists to assign
select any txn from instances of SM_TXN
   where USER::selectOne(id:selected.Trans_ID);
select one dest_state related by txn->SM_STATE[R506];
select one legal_evt_defining_state related by txn->
                                                 SM_NETXN[R507]->SM_STATE[R508];
if ( empty legal_evt_defining_state )
  select one legal_evt_defining_state related by txn->
                                  SM_NSTXN[R507]->SM_SEME[R504]->SM_STATE[R503];
end if;
// select all events in the domain that meet our criteria for assignment
// ("select ... from instances of" not being possible here since generating
// code from it in this context will produce errors);
// note that we have to take into account in both the upwards and downwards
// traversals whether we are dealing with a class or instance state machine
select one stateMachine related by txn->SM_SM[R505];
select one classStateMachine related by stateMachine->SM_ASM[R517];
isClassStateMachine = not_empty classStateMachine;
select one modelClass related by stateMachine->SM_ISM[R517]->O_OBJ[R518];
if (isClassStateMachine)
	select one modelClass related by stateMachine->SM_ASM[R517]->O_OBJ[R519];
end if;
select one packageableElem related by modelClass->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
if (empty package)
  select one package related by packageableElem->C_C[R8003]->PE_PE[R8001]->EP_PKG[R8001];
end if;  

select many machines related by package->PE_PE[R8000]->O_OBJ[R8001]->
                                                    SM_ISM[R518]->SM_SM[R517];
if (isClassStateMachine)
  select many machines related by package->PE_PE[R8000]->O_OBJ[R8001]->
                                                    SM_ASM[R519]->SM_SM[R517];
end if;
select any event related by machines->SM_EVT[R502]
	where USER::selectOne(id:selected.SMevt_ID)
    	and stateMachine.canAssignEvent(
    		eventId:selected.SMevt_ID, eventStateMachineId:selected.SM_ID,
    		isCreationTransition:false)
	    and legal_evt_defining_state.notAlreadyAssigned(
                             eventId:selected.SMevt_ID,
                             eventStateMachineId: selected.SM_ID, crtxn: false);
txn.addEvent(eventId:event.SMevt_ID, eventStateMachineId:event.SM_ID);',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6319);
INSERT INTO S_SYNC
	VALUES (6319,
	1,
	'SM_EVT_GenericPackageIgnoreInState',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// UI: cant happen entry exists for this event
	select any event from instances of SM_EVT
         where USER::selectOne(id:selected.SMevt_ID);

// select all states in the domain that may currently be selected to ignore
// the event ("select ... from instances of" not being possible here since
// generating code from it in this context will produce errors);
// note that we have to take into account in both the upwards and downwards
// traversals whether we are dealing with a class or instance state machine
select one stateMachine related by event->SM_SM[R502];
select one classStateMachine related by stateMachine->SM_ASM[R517];
isClassStateMachine = not_empty classStateMachine;
select one modelClass related by stateMachine->SM_ISM[R517]->O_OBJ[R518];
if (isClassStateMachine)
	select one modelClass related by stateMachine->SM_ASM[R517]->O_OBJ[R519];
end if;
select many machines related by modelClass->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405]->
	  	  EP_PKG[R1405]->PE_PE[R8000]->O_OBJ[R8001]->SM_ISM[R518]->SM_SM[R517];
if (isClassStateMachine)
	select many machines related by modelClass->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405]->
	  	  EP_PKG[R1405]->PE_PE[R8000]->O_OBJ[R8001]->SM_ASM[R519]->SM_SM[R517];
end if;
select any state related by machines->SM_STATE[R501]
	where USER::selectOne(id:selected.SMstt_ID)
    	and event.canStateIgnoreOrSayCantHappen(
    		stateId:selected.SMstt_ID, stateStateMachineId:selected.SM_ID,
    		considerCantHappen:false);

if (not_empty state)
  event.ignoreOnState(stateId:state.SMstt_ID, stateStateMachineId:state.SM_ID);
end if;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6320);
INSERT INTO S_SYNC
	VALUES (6320,
	1,
	'SM_EVT_GenericPackageCantHappenInState',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// UI: event ignored entry exists for this event
select any event from instances of SM_EVT
         where USER::selectOne(id:selected.SMevt_ID);

// select all states in the domain that may currently be selected to say
// the event cannot happen on them ("select ... from instances of" not being
// possible here since  generating code from it in this context will produce
// errors); note that we have to take into account in both the upwards and
// downwards traversals whether we are dealing with a class or instance
// state machine
select one stateMachine related by event->SM_SM[R502];
select one classStateMachine related by stateMachine->SM_ASM[R517];
isClassStateMachine = not_empty classStateMachine;
select one modelClass related by stateMachine->SM_ISM[R517]->O_OBJ[R518];
if (isClassStateMachine)
	select one modelClass related by stateMachine->SM_ASM[R517]->O_OBJ[R519];
end if;
select many machines related by modelClass->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405]->
	  	  EP_PKG[R1405]->PE_PE[R8000]->O_OBJ[R8001]->SM_ISM[R518]->SM_SM[R517];
if (isClassStateMachine)
	select many machines related by modelClass->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405]->
	  	  EP_PKG[R1405]->PE_PE[R8000]->O_OBJ[R8001]->SM_ASM[R519]->SM_SM[R517];
end if;
select any state related by machines->SM_STATE[R501]
	where USER::selectOne(id:selected.SMstt_ID)
    	and event.canStateIgnoreOrSayCantHappen(
    		stateId:selected.SMstt_ID, stateStateMachineId:selected.SM_ID,
    		considerCantHappen:true);
if (not_empty event)
  event.sayCantHappenOnState(stateId:state.SMstt_ID, stateStateMachineId:state.SM_ID);
end if;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6321);
INSERT INTO S_SYNC
	VALUES (6321,
	1,
	'SM_STATE_GenericPackageIgnoreEvent',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// UI: cant happen entry exists for this state
select any state from instances of SM_STATE
         where USER::selectOne(id:selected.SMstt_ID);

// select all events in the domain that may currently be selected to be
// ignored on the given state ("select ... from instances of" not being
// possible here since  generating code from it in this context will produce
// errors); note that we have to take into account in both the upwards and
// downwards traversals whether we are dealing with a class or instance
// state machine
select one stateMachine related by state->SM_SM[R501];
select one classStateMachine related by stateMachine->SM_ASM[R517];
isClassStateMachine = not_empty classStateMachine;
select one modelClass related by stateMachine->SM_ISM[R517]->O_OBJ[R518];
if (isClassStateMachine)
	select one modelClass related by stateMachine->SM_ASM[R517]->O_OBJ[R519];
end if;
select many machines related by modelClass->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405]->
	  	  EP_PKG[R1405]->PE_PE[R8000]->O_OBJ[R8001]->SM_ISM[R518]->SM_SM[R517];
if (isClassStateMachine)
	select many machines related by modelClass->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405]->
	  	  EP_PKG[R1405]->PE_PE[R8000]->O_OBJ[R8001]->SM_ASM[R519]->SM_SM[R517];
end if;
select any event related by machines->SM_EVT[R502]
	where USER::selectOne(id:selected.SMevt_ID)
    	and state.canIgnoreOrSayEventCantHappen(
    		eventId:selected.SMevt_ID, eventStateMachineId: selected.SM_ID,
    		considerCantHappen:false);
if (not_empty event)
  event.ignoreOnState(stateId:state.SMstt_ID, stateStateMachineId:state.SM_ID);
end if;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6322);
INSERT INTO S_SYNC
	VALUES (6322,
	1,
	'C_P_GenericPackageFormalize',
	'ContextMenuFunction: TRUE',
	'select any element from instances of C_P
                                where USER::selectOne(id:selected.Provision_Id);
select one existingElement related by element->C_IR[R4009]->C_I[R4012] 
                                     where USER::selectExisting(id:selected.Id);
if(not_empty element)
  select any selectedObj from instances of C_I
                                          where USER::selectOne(id:selected.Id);
  if(not_empty selectedObj)
    element.formalize(Id:selectedObj.Id, formalizeReq:true);
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6323);
INSERT INTO S_SYNC
	VALUES (6323,
	1,
	'SM_STATE_GenericPackageCantHappenEvent',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// UI: event ignored entry exists for this state
select any state from instances of SM_STATE
         where USER::selectOne(id:selected.SMstt_ID);

// select all events in the domain that may currently be selected to cannot
// happen on the given state ("select ... from instances of" not being
// possible here since  generating code from it in this context will produce
// errors); note that we have to take into account in both the upwards and
// downwards traversals whether we are dealing with a class or instance
// state machine
select one stateMachine related by state->SM_SM[R501];
select one classStateMachine related by stateMachine->SM_ASM[R517];
isClassStateMachine = not_empty classStateMachine;
select one modelClass related by stateMachine->SM_ISM[R517]->O_OBJ[R518];
if (isClassStateMachine)
	select one modelClass related by stateMachine->SM_ASM[R517]->O_OBJ[R519];
end if;
select many machines related by modelClass->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405]->
	  	  EP_PKG[R1405]->PE_PE[R8000]->O_OBJ[R8001]->SM_ISM[R518]->SM_SM[R517];
if (isClassStateMachine)
	select many machines related by modelClass->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405]->
	  	  EP_PKG[R1405]->PE_PE[R8000]->O_OBJ[R8001]->SM_ASM[R519]->SM_SM[R517];
end if;
select any event related by machines->SM_EVT[R502]
	where USER::selectOne(id:selected.SMevt_ID)
    	and state.canIgnoreOrSayEventCantHappen(
    		eventId:selected.SMevt_ID, eventStateMachineId: selected.SM_ID,
    		considerCantHappen:true);
if (not_empty event)
  event.sayCantHappenOnState(stateId:state.SMstt_ID, stateStateMachineId:state.SM_ID);
end if;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6324);
INSERT INTO S_SYNC
	VALUES (6324,
	1,
	'C_R_GenericPackageFormalize',
	'ContextMenuFunction: TRUE',
	'select any element from instances of C_R
                              where USER::selectOne(id:selected.Requirement_Id);
select one existingElement related by element->C_IR[R4009]->C_I[R4012]
                                     where USER::selectExisting(id:selected.Id);
if(not_empty element)
  select any selectedObj from instances of C_I
                                          where USER::selectOne(id:selected.Id);
  if(not_empty selectedObj)
    element.formalize(Id:selectedObj.Id, formalizePro:true);
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6325);
INSERT INTO S_SYNC
	VALUES (6325,
	1,
	'CL_IC_GenericPackageAssignComponent',
	'ContextMenuFunction: TRUE',
	'// ::CL_IC_GenericPackageAssignComponent()
select any element from instances of CL_IC where USER::selectOne(id:selected.Id);
select one existingElement related by element->C_C[R4201] where USER::selectExisting(id:selected.Id);
if not_empty element
  select any selectedComp from instances of C_C where USER::selectOne(id:selected.Id);
  if not_empty selectedComp
    // note we must reselect here for the case where multiple
    // component references are selected
    select one currentComp related by element->C_C[R4201];
    if(currentComp != selectedComp)
      element.assignToComp(Id:selectedComp.Id);
    end if;
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6326);
INSERT INTO S_SYNC
	VALUES (6326,
	1,
	'SM_CRTXN_GenericPackageAssignEvent',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// UI: event exists to assign
select any ctxn from instances of SM_CRTXN
   where USER::selectOne(id:selected.Trans_ID);
select one txn related by ctxn->SM_TXN[R507];
select one dest_state related by txn->SM_STATE[R506];
// select all events in the domain that meet our criteria for assignment
// ("select ... from instances of" not being possible here since generating
// code from it in this context will produce errors);
// note that we have to take into account in both the upwards and downwards
// traversals whether we are dealing with a class or instance state machine
select one stateMachine related by txn->SM_SM[R505];
select one modelClass related by stateMachine->SM_ISM[R517]->O_OBJ[R518];
select many machines related by modelClass->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405]->
	  	  EP_PKG[R1405]->PE_PE[R8000]->O_OBJ[R8001]->SM_ISM[R518]->SM_SM[R517];
select any event related by machines->SM_EVT[R502]
	where USER::selectOne(id:selected.SMevt_ID)
    	and stateMachine.canAssignEvent(eventId:selected.SMevt_ID,
                 eventStateMachineId:selected.SM_ID, isCreationTransition:true)
	    and dest_state.notAlreadyAssigned(eventId:selected.SMevt_ID,
                              eventStateMachineId: selected.SM_ID, crtxn: true);
txn.addEvent(eventId:event.SMevt_ID, eventStateMachineId:event.SM_ID);',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6327);
INSERT INTO S_SYNC
	VALUES (6327,
	1,
	'C_DG_GenericPackageFormalize',
	'ContextMenuFunction: TRUE',
	'select any element from instances of C_DG where USER::selectOne(id:selected.Id);
select any ir related by element->C_RID[R4013]->C_IR[R4013];
select any existingElement related by element->C_RID[R4013]->C_IR[R4013]
                        ->C_I[R4012] where USER::selectExisting(id:selected.Id);
if(not_empty element)
  select any selectedObj from instances of C_I
                                          where USER::selectOne(id:selected.Id);
  if(not_empty selectedObj)
    select one provision related by ir->C_P[R4009];
    if(not_empty provision)
      provision.formalize(Id:selectedObj.Id, formalizeReq:true);
    end if;
    select one requirement related by ir->C_R[R4009];
    if(not_empty requirement)
      requirement.formalize(Id:selectedObj.Id, formalizePro:true);
    end if;
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6328);
INSERT INTO S_SYNC
	VALUES (6328,
	1,
	'SM_TXN_GenericPackageAssignSignal',
	'ContextMenuFunction: TRUE',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// UI: signal exists to assign
select any txn from instances of SM_TXN where
                                          USER::selectOne(id:selected.Trans_ID);
Trans_ID = txn.Trans_ID;
select one stateMachine related by txn->SM_SM[R505];
select one classStateMachine related by stateMachine->SM_ASM[R517];
select one containingPackage related by classStateMachine->O_OBJ[R519]->
                                                    PE_PE[R8001]->EP_PKG[R8000];
containingComponentId = containingPackage.getContainingComponentId();
select any containingComponent from instances of C_C where
                                           selected.Id == containingComponentId;
select any interface related by containingComponent->
                                         C_PO[R4010]->C_IR[R4016] where
                                       USER::selectOne(id:selected.Id) and
                                                stateMachine.hasValidSignals(
                              interface_id:selected.Id, transition_id:Trans_ID);
if not_empty interface
  select any signal related by interface->
                     C_I[R4012]->C_EP[R4003]->C_AS[R4004] where
                              USER::selectOne(id:selected.Id) and
                                        stateMachine.canAssignSignal(
                                signal_id:selected.Id, transition_id:Trans_ID,
                                                     interface_id:interface.Id);
  txn.addSignal(interface_id:interface.Id, signal_id:signal.Id);
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6329);
INSERT INTO S_SYNC
	VALUES (6329,
	1,
	'C_C_NewSubsystem',
	'ContextMenuFunction: TRUE',
	'select any component from instances of C_C where USER::selectOne(id:selected.Package_ID);
select one dom related by component->CN_DC[R4204]->S_DOM[R4204];
if(not empty dom)
dom.newSubsystem();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6330);
INSERT INTO S_SYNC
	VALUES (6330,
	1,
	'C_C_NewExternalEntityPackage',
	'ContextMenuFunction: TRUE',
	'select any component from instances of C_C where USER::selectOne(id:selected.Package_ID);
select one dom related by component->CN_DC[R4204]->S_DOM[R4204];
if(not empty dom)
dom.newExternalEntityPackage();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6331);
INSERT INTO S_SYNC
	VALUES (6331,
	1,
	'C_C_NewFunctionPackage',
	'ContextMenuFunction: TRUE',
	'select any component from instances of C_C where USER::selectOne(id:selected.Package_ID);
select one dom related by component->CN_DC[R4204]->S_DOM[R4204];
if(not empty dom)
dom.newFunctionPackage();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6332);
INSERT INTO S_SYNC
	VALUES (6332,
	1,
	'C_C_NewDatatypePackage',
	'ContextMenuFunction: TRUE',
	'select any component from instances of C_C where USER::selectOne(id:selected.Package_ID);
select one dom related by component->CN_DC[R4204]->S_DOM[R4204];
if(not empty dom)
dom.newDatatypePackage();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6333);
INSERT INTO S_SYNC
	VALUES (6333,
	1,
	'S_EDT_MakePrivate',
	'ContextMenuFunction: TRUE',
	'select any edt from instances of S_EDT where USER::selectOne(id:selected.DT_ID);
select one pe related by edt->S_DT[R17]->PE_PE[R8001];
pe.Visibility = Visibility::Private;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6334);
INSERT INTO S_SYNC
	VALUES (6334,
	1,
	'S_SDT_MakePrivate',
	'ContextMenuFunction: TRUE
',
	'select any sdt from instances of S_SDT where USER::selectOne(id:selected.DT_ID);
select one pe related by sdt->S_DT[R17]->PE_PE[R8001];
pe.Visibility = Visibility::Private;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6335);
INSERT INTO S_SYNC
	VALUES (6335,
	1,
	'S_EDT_MakePublic',
	'ContextMenuFunction: TRUE',
	'select any edt from instances of S_EDT where USER::selectOne(id:selected.DT_ID);
select one pe related by edt->S_DT[R17]->PE_PE[R8001];
pe.Visibility = Visibility::Public;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6336);
INSERT INTO S_SYNC
	VALUES (6336,
	1,
	'S_SDT_MakePublic',
	'ContextMenuFunction: TRUE
',
	'select any sdt from instances of S_SDT where USER::selectOne(id:selected.DT_ID);
select one pe related by sdt->S_DT[R17]->PE_PE[R8001];
pe.Visibility = Visibility::Public;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6337);
INSERT INTO S_SYNC
	VALUES (6337,
	1,
	'CNST_CSP_MakePublic',
	'ContextMenuFunction: TRUE',
	'select any const from instances of CNST_CSP where USER::selectOne(id:selected.Constant_Spec_ID);
select one pe related by const->PE_PE[R8001];
pe.Visibility = Visibility::Public;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6338);
INSERT INTO S_SYNC
	VALUES (6338,
	1,
	'CNST_CSP_MakePrivate',
	'ContextMenuFunction: TRUE',
	'select any const from instances of CNST_CSP where USER::selectOne(id:selected.Constant_Spec_ID);
select one pe related by const->PE_PE[R8001];
pe.Visibility = Visibility::Private;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6339);
INSERT INTO S_SYNC
	VALUES (6339,
	1,
	'C_C_NewPackage',
	'ContextMenuFunction: TRUE',
	'select any component from instances of C_C where USER::selectOne(id:selected.Package_ID);
if(not empty component)
component.newPackage();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6340);
INSERT INTO S_SYNC
	VALUES (6340,
	1,
	'SQ_PP_Delete',
	'ContextMenuFunction: TRUE',
	'select many participants from instances of SQ_PP where USER::selectOne(id:selected.Part_ID);
for each participant in participants
  participant.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6341);
INSERT INTO S_SYNC
	VALUES (6341,
	1,
	'SQ_PP_Formalize',
	'ContextMenuFunction: TRUE',
	'select any element from instances of SQ_PP
                                     where USER::selectOne(id:selected.Part_ID);
select one existingElement related by element->EP_PKG[R956]
                             where USER::selectExisting(id:selected.Package_ID);
if(not_empty element)
  select any selectedElement from instances of EP_PKG
                                  where USER::selectOne(id:selected.Package_ID);
  if(not_empty selectedElement)
    element.formalize(fpId:selectedElement.Package_ID);
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6342);
INSERT INTO S_SYNC
	VALUES (6342,
	1,
	'SQ_PP_PackageParticipantUnformalize',
	'ContextMenuFunction: TRUE',
	'select any pp from instances of SQ_PP where USER::selectOne(id:selected.Part_ID);
if(not_empty pp)
  pp.unformalize();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6343);
INSERT INTO S_SYNC
	VALUES (6343,
	1,
	'SQ_PP_Rename',
	'ContextMenuFunction: TRUE',
	'select any participant from instances of SQ_PP where USER::selectOne(id:selected.Part_ID);
if(not_empty participant)
  participant.InformalName = param.new_name;
end if;',
	19,
	1,
	'');
INSERT INTO S_SPARM
	VALUES (6344,
	6343,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6345);
INSERT INTO S_SYNC
	VALUES (6345,
	1,
	'SQ_COP_SpecializedPackageFormalize',
	'ContextMenuFunction: TRUE',
	'// ::SQ_COP_SpecializedPackageComponentFormalize()
select any cop from instances of SQ_COP where
                                           USER::selectOne(id:selected.Part_ID);
select one participant related by cop->SQ_P[R930];
select one system related by participant->SQ_S[R929]->CP_CP[R951]->S_SYS[R4606];
if empty system
  if not_empty participant
    id = participant.getSystemId();
    select any system from instances of S_SYS where selected.Sys_ID == id;
  end if;
end if;
if not_empty system
  select any Component related by system->CP_CP[R4606]->C_C[R4604] where
                                                USER::selectOne(id:selected.Id)
                                and cop.canFormalizeToComponent(id:selected.Id);
  if not_empty Component
    cop.formalize(compId:Component.Id);
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6346);
INSERT INTO S_SYNC
	VALUES (6346,
	1,
	'SQ_COP_Unformalize',
	'ContextMenuFunction: TRUE',
	'// ::SQ_COP_ComponentParticipantUnformalize()
select any cop from instances of SQ_COP where
                                           USER::selectOne(id:selected.Part_ID);
if(not_empty cop)
  cop.unformalize();
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6347);
INSERT INTO S_SYNC
	VALUES (6347,
	1,
	'MSG_SM_InterfaceOperationFormalize',
	'ContextMenuFunction: TRUE',
	'// ::MSG_SM_SpecializedPackageInterfaceOperationFormalize()
select any syncMessage from instances of MSG_SM where USER::selectOne(id:selected.Msg_ID);
select one message related by syncMessage->MSG_M[R1018];
select one participant related by message->SQ_P[R1007];
select one cop related by participant->SQ_COP[R930];
if(empty cop)
  // consider the lifeline
  select one cop related by participant->SQ_LS[R930]->SQ_P[R940]->SQ_COP[R930];
end if;
select any component from instances of C_C where (selected.Id == GD::NULL_UNIQUE_ID());
if(not_empty cop)
  select one component related by cop->C_C[R955];  
end if;
if(not_empty component)
  select any Operation related by component->C_PO[R4010]->C_IR[R4016]->C_I[R4012]->
                 C_EP[R4003]->C_IO[R4004] where USER::selectOne(id:selected.Id)
            and syncMessage.canFormalizeUsingInterfaceOperation(id:selected.Id);
  if(not_empty Operation)
    syncMessage.formalizeWithInterfaceOperation(iOpId:Operation.Id);
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6348);
INSERT INTO S_SYNC
	VALUES (6348,
	1,
	'MSG_AM_SignalFormalize',
	'ContextMenuFunction: TRUE',
	'// ::MSG_AM_SpecializedPackageSignalFormalize()
select any asyncMessage from instances of MSG_AM where USER::selectOne(id:selected.Msg_ID);
select one message related by asyncMessage->MSG_M[R1018];
select one participant related by message->SQ_P[R1007];
select one cop related by participant->SQ_COP[R930];
select any component from instances of C_C where (selected.Id == GD::NULL_UNIQUE_ID());
if(empty cop)
  // consider lifeline, if in a communication the above selection
  // should not return null
  select one cop related by participant->SQ_LS[R930]->SQ_P[R940]->SQ_COP[R930];
end if;
if(not_empty cop)
  select one component related by cop->C_C[R955];
end if;
if(not_empty component)
  select any Signal related by component->C_PO[R4010]->C_IR[R4016]->C_I[R4012]->
                 C_EP[R4003]->C_AS[R4004] where USER::selectOne(id:selected.Id)
              and asyncMessage.canFormalizeUsingInterfaceSignal(id:selected.Id);
  if(not_empty Signal)
    asyncMessage.formalizeWithSignal(signalId:Signal.Id);
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6349);
INSERT INTO S_SYNC
	VALUES (6349,
	1,
	'MSG_AM_CommunicationSignalFormalize',
	'ContextMenuFunction: TRUE',
	'// ::MSG_AM_SpecializedPackageCommunicationSignalFormalize()
select any asyncMessage from instances of MSG_AM where USER::selectOne(id:selected.Msg_ID);
if(not_empty asyncMessage)
  select any cop from instances of SQ_COP where USER::selectOne(id:selected.Part_ID);
  if(not_empty cop)
    // relate the message to the destination participant
    select one message related by asyncMessage->MSG_M[R1018];
    select one participant related by cop->SQ_P[R930];
    relate message to participant across R1007;
    select one comp related by cop->C_C[R955];
    if(not_empty comp)
      select many interfaces related by comp->C_PO[R4010]->C_IR[R4016]->C_I[R4012];
      select any Signal related by interfaces->C_EP[R4003]->C_AS[R4004] where
                                             USER::selectOne(id:selected.Id) and
                  asyncMessage.canFormalizeUsingInterfaceSignal(id:selected.Id);
      if(not_empty Signal)
        asyncMessage.formalizeWithSignal(signalId:Signal.Id);
        // clear the selection so that following moves will not
        // move the destination shape as well
        Sel::clearSelection();
      end if;
    end if;
  end if;
end if;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6350);
INSERT INTO S_SYNC
	VALUES (6350,
	1,
	'MSG_SM_CommunicationInterfaceOperationFormalize',
	'ContextMenuFunction: TRUE',
	'// ::MSG_SM_SpecializedPackageCommunicationInterfaceOperationFormalize()
select any syncMessage from instances of MSG_SM where USER::selectOne(id:selected.Msg_ID);
if(not_empty syncMessage)
  select any cop from instances of SQ_COP where USER::selectOne(id:selected.Part_ID);
  if(not_empty cop)
    // relate the message to the destination participant
    select one message related by syncMessage->MSG_M[R1018];
    select one participant related by cop->SQ_P[R930];
    relate message to participant across R1007;
    select one comp related by cop->C_C[R955];
    if(not_empty comp)
      select many interfaces related by comp->C_PO[R4010]->C_IR[R4016]->C_I[R4012];
      select any Operation related by interfaces->C_EP[R4003]->C_IO[R4004] where
                                             USER::selectOne(id:selected.Id) and
                syncMessage.canFormalizeUsingInterfaceOperation(id:selected.Id);
      if(not_empty Operation)
        syncMessage.formalizeWithInterfaceOperation(iOpId:Operation.Id);
        // clear the selection so that following moves will not
        // move the destination shape as well
        Sel::clearSelection();
      end if;
    end if;
  end if;
end if;
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6351);
INSERT INTO S_SYNC
	VALUES (6351,
	1,
	'EP_PKG_MakeProtected',
	'ContextMenuFunction: TRUE',
	'select any pkg from instances of EP_PKG where
                                        USER::selectOne(id:selected.Package_ID);
select one pe related by pkg->PE_PE[R8001];
pe.Visibility = Visibility::Protected;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6352);
INSERT INTO S_SYNC
	VALUES (6352,
	1,
	'S_EDT_MakeProtected',
	'ContextMenuFunction: TRUE',
	'select any edt from instances of S_EDT where USER::selectOne(id:selected.DT_ID);
select one pe related by edt->S_DT[R17]->PE_PE[R8001];
pe.Visibility = Visibility::Protected;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6353);
INSERT INTO S_SYNC
	VALUES (6353,
	1,
	'S_SDT_MakeProtected',
	'ContextMenuFunction: TRUE',
	'select any sdt from instances of S_SDT where USER::selectOne(id:selected.DT_ID);
select one pe related by sdt->S_DT[R17]->PE_PE[R8001];
pe.Visibility = Visibility::Protected;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6354);
INSERT INTO S_SYNC
	VALUES (6354,
	1,
	'S_UDT_MakeProtected',
	'ContextMenuFunction: TRUE',
	'select any udt from instances of S_UDT where USER::selectOne(id:selected.DT_ID);
select one pe related by udt->S_DT[R17]->PE_PE[R8001];
pe.Visibility = Visibility::Protected;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6355);
INSERT INTO S_SYNC
	VALUES (6355,
	1,
	'O_OBJ_MakePrivate',
	'ContextMenuFunction: TRUE',
	'select any obj from instances of O_OBJ where USER::selectOne(id:selected.Obj_ID);
select one pe related by obj->PE_PE[R8001];
pe.Visibility = Visibility::Private;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6356);
INSERT INTO S_SYNC
	VALUES (6356,
	1,
	'O_OBJ_MakeProtected',
	'ContextMenuFunction: TRUE',
	'select any obj from instances of O_OBJ where USER::selectOne(id:selected.Obj_ID);
select one pe related by obj->PE_PE[R8001];
pe.Visibility = Visibility::Protected;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6357);
INSERT INTO S_SYNC
	VALUES (6357,
	1,
	'O_OBJ_MakePublic',
	'ContextMenuFunction: TRUE',
	'select any obj from instances of O_OBJ where USER::selectOne(id:selected.Obj_ID);
select one pe related by obj->PE_PE[R8001];
pe.Visibility = Visibility::Public;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6358);
INSERT INTO S_SYNC
	VALUES (6358,
	1,
	'CNST_CSP_MakeProtected',
	'ContextMenuFunction: TRUE',
	'select any const from instances of CNST_CSP where USER::selectOne(id:selected.Constant_Spec_ID);
select one pe related by const->PE_PE[R8001];
pe.Visibility = Visibility::Protected;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6359);
INSERT INTO S_SYNC
	VALUES (6359,
	1,
	'C_C_MakePublic',
	'ContextMenuFunction: TRUE',
	'select any comp from instances of C_C where USER::selectOne(id:selected.Id);
select one pe related by comp->PE_PE[R8001];
pe.Visibility = Visibility::Public;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6360);
INSERT INTO S_SYNC
	VALUES (6360,
	1,
	'C_C_MakeProtected',
	'ContextMenuFunction: TRUE',
	'select any comp from instances of C_C where USER::selectOne(id:selected.Id);
select one pe related by comp->PE_PE[R8001];
pe.Visibility = Visibility::Protected;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6361);
INSERT INTO S_SYNC
	VALUES (6361,
	1,
	'C_C_MakePrivate',
	'ContextMenuFunction: TRUE',
	'select any comp from instances of C_C where USER::selectOne(id:selected.Id);
select one pe related by comp->PE_PE[R8001];
pe.Visibility = Visibility::Private;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6362);
INSERT INTO S_SYNC
	VALUES (6362,
	1,
	'SQ_COP_GenericPackageFormalize',
	'ContextMenuFunction: TRUE',
	'select any element from instances of SQ_COP
                                     where USER::selectOne(id:selected.Part_ID);
select one existingElement related by element->C_C[R955]
                                     where USER::selectExisting(id:selected.Id);
if(not_empty element)
  select any selectedElement from instances of C_C
                                          where USER::selectOne(id:selected.Id);
  if(not_empty selectedElement)
    element.formalize(compId:selectedElement.Id);
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6363);
INSERT INTO S_SYNC
	VALUES (6363,
	1,
	'MSG_SM_CommunicationPackageFunctionFormalize',
	'ContextMenuFunction: TRUE',
	'select any syncMessage from instances of MSG_SM where USER::selectOne(id:selected.Msg_ID);
if(not_empty syncMessage)
  select one function related by syncMessage->MSG_F[R1020]->S_SYNC[R1010];
  // must be a package participant
  select any pp from instances of SQ_PP where USER::selectOne(id:selected.Part_ID);
  existingId = GD::NULL_UNIQUE_ID();
  if(not_empty function)
    existingId = function.Sync_ID;
  end if; 
  // relate the message to the destination participant
  select one message related by syncMessage->MSG_M[R1018];
  select one participant related by pp->SQ_P[R930];
  relate message to participant across R1007;
  select one pkg related by pp->EP_PKG[R956];
  if(not_empty pkg)
    select any Message related by pkg->PE_PE[R8000]->S_SYNC[R8001]
                                      where USER::selectOne(id:selected.Sync_ID)
                                             and selected.Sync_ID != existingId;
    syncMessage.formalizeWithFunction(functionId:Message.Sync_ID);
    // clear the selection so that following moves will not
    // move the destination shape as well
    Sel::clearSelection();
  end if;    
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6364);
INSERT INTO S_SYNC
	VALUES (6364,
	1,
	'MSG_SM_PackageFunctionFormalize',
	'ContextMenuFunction: TRUE',
	'select any syncMessage from instances of MSG_SM where USER::selectOne(id:selected.Msg_ID);
select one message related by syncMessage->MSG_M[R1018];
select one participant related by message->SQ_P[R1007];
select one function related by syncMessage->MSG_F[R1020]->S_SYNC[R1010];
existingId = GD::NULL_UNIQUE_ID();
if(not_empty function)
  existingId = function.Sync_ID;
end if;
// must be a package
select one pp related by participant->SQ_PP[R930];
if(empty pp)
  select one pp related by participant->SQ_LS[R930]->SQ_P[R940]->SQ_PP[R930];
end if;
if(not_empty pp)
  select one pkg related by pp->EP_PKG[R956];
  if(not_empty pkg)
    select any Message related by pkg->PE_PE[R8000]->S_SYNC[R8001]
                                      where USER::selectOne(id:selected.Sync_ID)
                                             and selected.Sync_ID != existingId;
    if(not_empty Message)
      syncMessage.formalizeWithFunction(functionId:Message.Sync_ID);
    end if;      
  end if;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6365);
INSERT INTO S_SYNC
	VALUES (6365,
	1,
	'EP_PKG_ClassesClass',
	'ContextMenuFunction: TRUE',
	'select any pkg from instances of EP_PKG where USER::selectOne(id:selected.Package_ID);
pkg.newClass();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6366);
INSERT INTO S_SYNC
	VALUES (6366,
	1,
	'EP_PKG_ClassesImportedClass',
	'ContextMenuFunction: TRUE',
	'select any pkg from instances of EP_PKG where USER::selectOne(id:selected.Package_ID);
pkg.newIClass();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6367);
INSERT INTO S_SYNC
	VALUES (6367,
	1,
	'EP_PKG_ComponentsComponent',
	'ContextMenuFunction: TRUE',
	'select any pkg from instances of EP_PKG where USER::selectOne(id:selected.Package_ID);
pkg.newComponent();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6368);
INSERT INTO S_SYNC
	VALUES (6368,
	1,
	'EP_PKG_ComponentsComponentReference',
	'ContextMenuFunction: TRUE',
	'select any pkg from instances of EP_PKG where USER::selectOne(id:selected.Package_ID);
pkg.newImportedComponent();',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6369);
INSERT INTO S_SYNC
	VALUES (6369,
	1,
	'EP_PKG_ComponentsInterface',
	'ContextMenuFunction: TRUE',
	'select any pkg from instances of EP_PKG where USER::selectOne(id:selected.Package_ID);
pkg.newInterface();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6370);
INSERT INTO S_SYNC
	VALUES (6370,
	1,
	'EP_PKG_ActivityAcceptEventAction',
	'ContextMenuFunction: TRUE',
	'select any pkg from instances of EP_PKG where USER::selectOne(id:selected.Package_ID);
pkg.newAcceptEventAction();
',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6371);
INSERT INTO S_SYNC
	VALUES (6371,
	1,
	'EP_PKG_ActivityAcceptTimeEventAction',
	'ContextMenuFunction: TRUE',
	'select any pkg from instances of EP_PKG where USER::selectOne(id:selected.Package_ID);
pkg.newAcceptTimeEventAction();',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6372);
INSERT INTO S_SYNC
	VALUES (6372,
	1,
	'EP_PKG_ActivityAction',
	'ContextMenuFunction: TRUE',
	'select any pkg from instances of EP_PKG where USER::selectOne(id:selected.Package_ID);
pkg.newGenericAction();',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6373);
INSERT INTO S_SYNC
	VALUES (6373,
	1,
	'EP_PKG_ActivityObjectNode',
	'ContextMenuFunction: TRUE',
	'select any pkg from instances of EP_PKG where USER::selectOne(id:selected.Package_ID);
pkg.newObjectNode();',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6374);
INSERT INTO S_SYNC
	VALUES (6374,
	1,
	'EP_PKG_ActivitySendSignalAction',
	'ContextMenuFunction: TRUE',
	'select any pkg from instances of EP_PKG where USER::selectOne(id:selected.Package_ID);
pkg.newSendSignalAction();',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6375);
INSERT INTO S_SYNC
	VALUES (6375,
	1,
	'EP_PKG_ExternalExternalEntity',
	'ContextMenuFunction: TRUE',
	'select any pkg from instances of EP_PKG where USER::selectOne(id:selected.Package_ID);
pkg.newExternalEntity();',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6376);
INSERT INTO S_SYNC
	VALUES (6376,
	1,
	'EP_PKG_InteractionActor',
	'ContextMenuFunction: TRUE',
	'select any pkg from instances of EP_PKG where USER::selectOne(id:selected.Package_ID);
pkg.newActor();',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6377);
INSERT INTO S_SYNC
	VALUES (6377,
	1,
	'EP_PKG_InteractionClass',
	'ContextMenuFunction: TRUE',
	'select any pkg from instances of EP_PKG where USER::selectOne(id:selected.Package_ID);
pkg.newClassParticipant();',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6378);
INSERT INTO S_SYNC
	VALUES (6378,
	1,
	'EP_PKG_InteractionComponent',
	'ContextMenuFunction: TRUE',
	'select any pkg from instances of EP_PKG where USER::selectOne(id:selected.Package_ID);
pkg.newComponentParticipant();',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6379);
INSERT INTO S_SYNC
	VALUES (6379,
	1,
	'EP_PKG_InteractionExternalEntity',
	'ContextMenuFunction: TRUE',
	'select any pkg from instances of EP_PKG where USER::selectOne(id:selected.Package_ID);
pkg.newExternalEntityParticipant();',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6380);
INSERT INTO S_SYNC
	VALUES (6380,
	1,
	'EP_PKG_InteractionPackageParticipant',
	'ContextMenuFunction: TRUE',
	'select any pkg from instances of EP_PKG where USER::selectOne(id:selected.Package_ID);
pkg.newPackageParticipant();',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6381);
INSERT INTO S_SYNC
	VALUES (6381,
	1,
	'EP_PKG_InteractionInstance',
	'ContextMenuFunction: TRUE',
	'select any pkg from instances of EP_PKG where USER::selectOne(id:selected.Package_ID);
pkg.newClassInstance();',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6382);
INSERT INTO S_SYNC
	VALUES (6382,
	1,
	'EP_PKG_TypesConstantSpecification',
	'ContextMenuFunction: TRUE',
	'select any pkg from instances of EP_PKG where USER::selectOne(id:selected.Package_ID);
pkg.newConstantSpecification();',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6383);
INSERT INTO S_SYNC
	VALUES (6383,
	1,
	'EP_PKG_TypesEnumerationDatatype',
	'ContextMenuFunction: TRUE',
	'select any pkg from instances of EP_PKG where USER::selectOne(id:selected.Package_ID);
pkg.newEnumeration();',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6384);
INSERT INTO S_SYNC
	VALUES (6384,
	1,
	'EP_PKG_TypesStructuredDatatype',
	'ContextMenuFunction: TRUE',
	'select any pkg from instances of EP_PKG where USER::selectOne(id:selected.Package_ID);
pkg.newStructuredDatatype();',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6385);
INSERT INTO S_SYNC
	VALUES (6385,
	1,
	'EP_PKG_TypesUserDatatype',
	'ContextMenuFunction: TRUE',
	'select any pkg from instances of EP_PKG where USER::selectOne(id:selected.Package_ID);
pkg.newDatatype();',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6386);
INSERT INTO S_SYNC
	VALUES (6386,
	1,
	'EP_PKG_UsecaseUsecase',
	'ContextMenuFunction: TRUE',
	'select any pkg from instances of EP_PKG where USER::selectOne(id:selected.Package_ID);
pkg.newUseCase();',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6387);
INSERT INTO S_SYNC
	VALUES (6387,
	1,
	'SPR_PS_Delete',
	'ContextMenuFunction: TRUE
',
	'select many providedSignals from instances of SPR_PS
                                          where USER::selectOne(id:selected.Id);
for each signal in providedSignals
  signal.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6388);
INSERT INTO S_SYNC
	VALUES (6388,
	1,
	'SPR_PO_Delete',
	'ContextMenuFunction: TRUE
',
	'select many providedOperations from instances of SPR_PO
                                          where USER::selectOne(id:selected.Id);
for each operation in providedOperations
  operation.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6389);
INSERT INTO S_SYNC
	VALUES (6389,
	1,
	'SPR_RS_Delete',
	'ContextMenuFunction: TRUE
',
	'select many requiredSignals from instances of SPR_RS
                                          where USER::selectOne(id:selected.Id);
for each signal in requiredSignals
  signal.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6390);
INSERT INTO S_SYNC
	VALUES (6390,
	1,
	'SPR_RO_Delete',
	'ContextMenuFunction: TRUE
',
	'select many requiredOperations from instances of SPR_RO
                                          where USER::selectOne(id:selected.Id);
for each operation in requiredOperations
  operation.dispose();
end for;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6391);
INSERT INTO S_SYNC
	VALUES (6391,
	1,
	'C_AS_SetFromProvider',
	'ContextMenuFunction: TRUE',
	'select any is from instances of C_AS where USER::selectOne(id:selected.Id);
if(not_empty is)
  is.Direction = IFDirectionType::ServerClient;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6392);
INSERT INTO S_SYNC
	VALUES (6392,
	1,
	'C_IO_SetFromProvider',
	'ContextMenuFunction: TRUE',
	'select any io from instances of C_IO where USER::selectOne(id:selected.Id);
if(not_empty io)
  io.Direction = IFDirectionType::ServerClient;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6393);
INSERT INTO S_SYNC
	VALUES (6393,
	1,
	'C_AS_SetToProvider',
	'ContextMenuFunction: TRUE',
	'select any is from instances of C_AS where USER::selectOne(id:selected.Id);
if(not_empty is)
  is.Direction = IFDirectionType::ClientServer;
end if;',
	19,
	1,
	'');
INSERT INTO S_FIP
	VALUES (5891,
	6394);
INSERT INTO S_SYNC
	VALUES (6394,
	1,
	'C_IO_SetToProvider',
	'ContextMenuFunction: TRUE',
	'select any io from instances of C_IO where USER::selectOne(id:selected.Id);
if(not_empty io)
  io.Direction = IFDirectionType::ClientServer;
end if;',
	19,
	1,
	'');
-- BP 7.1.6 content: ExternalEntityPackage syschar: 3 persistence-version: 7.1.6

INSERT INTO S_EEPK
	VALUES (6395,
	'External Entities',
	1,
	0);
INSERT INTO PL_EEPID
	VALUES (1,
	6395);
INSERT INTO S_EEIP
	VALUES (6395,
	6396);
INSERT INTO S_EE
	VALUES (6396,
	'User',
	'This EE represents the user of the tool. It''s bridge calls all
capture required interactions with that user.
 
Import:com.mentor.nucleus.bp.core.common.*
',
	'USER',
	1,
	'',
	'User');
INSERT INTO S_BRG
	VALUES (6397,
	6396,
	'selectOne',
	'This bridge is typically called by an action from the where clause
of a select statement. It is used when the user must choose one item
from a number of alternatives provided by the main body of the select
statement.',
	0,
	316,
	'return true;',
	1,
	'');
INSERT INTO S_BPARM
	VALUES (6398,
	6397,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6399,
	6396,
	'selectMany',
	'This bridge is typically called by an action from the where clause
of a select statement. It is used when the user must choose several
items from a number of alternatives provided by the main body of the
select statement.',
	0,
	316,
	'return true;',
	1,
	'');
INSERT INTO S_BPARM
	VALUES (6400,
	6399,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6401,
	6396,
	'warning',
	'Translate:native
',
	0,
	19,
	'// native
org.eclipse.swt.widgets.Shell sh = 
   CorePlugin.getDefault().getWorkbench().getActiveWorkbenchWindow().getShell();
org.eclipse.jface.dialogs.MessageDialog.openError(sh, "Warning", p_Msg);
',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6402,
	6401,
	'msg',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6403,
	6396,
	'logError',
	'Translate:native
',
	0,
	19,
	'// native
String pathToUse = p_Path;
if (pathToUse == null || pathToUse.equals("")) {
	pathToUse = "<Path is not available>";
  } 
CorePlugin.err.println(p_Msg + " at " + pathToUse);
',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6404,
	6403,
	'msg',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6405,
	6403,
	'path',
	322,
	0,
	'',
	6404,
	'');
INSERT INTO S_BRG
	VALUES (6406,
	6396,
	'information',
	'Translate:native',
	0,
	19,
	'// native
org.eclipse.swt.widgets.Shell sh = 
   CorePlugin.getDefault().getWorkbench().getActiveWorkbenchWindow().getShell();
org.eclipse.jface.dialogs.MessageDialog.openInformation(sh, p_Title, p_Msg);',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6407,
	6406,
	'msg',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6408,
	6406,
	'title',
	322,
	0,
	'',
	6407,
	'');
INSERT INTO S_BRG
	VALUES (6409,
	6396,
	'selectOneWithInt',
	'',
	0,
	316,
	'return true;',
	1,
	'');
INSERT INTO S_BPARM
	VALUES (6410,
	6409,
	'id',
	298,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6411,
	6396,
	'logInfo',
	'Translate: native',
	0,
	19,
	'// native
if (CorePlugin.loggingEnabled) {
  CorePlugin.out.println(p_Msg);
}
',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6412,
	6411,
	'msg',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6413,
	6396,
	'selectExisting',
	'This bridge is typically called by an action from the where clause
of a select statement. It is used when an existing association must be known.',
	0,
	316,
	'return true;',
	1,
	'');
INSERT INTO S_BPARM
	VALUES (6414,
	6413,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_EEIP
	VALUES (6395,
	6415);
INSERT INTO S_EE
	VALUES (6415,
	'Graphics Domain',
	'This EE is a holding place for some miscellaneous bridge functions
needed for interacting with the Graphics domain. Some of these
bridges are duplicated by the OS EE and should be integrated at
some point in the near future.

Import:java.util.UUID;import java.util.Calendar',
	'GD',
	1,
	'',
	'Graphics Domain');
INSERT INTO S_BRG
	VALUES (6416,
	6415,
	'newline',
	'Translate:native',
	0,
	322,
	'return "\n";',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6417,
	6415,
	'int_to_string',
	'Translate:native',
	0,
	322,
	'return Integer.toString(p_Value);',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6418,
	6417,
	'value',
	298,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6419,
	6415,
	'max_number',
	'Translate:native',
	0,
	298,
	'return Integer.MAX_VALUE;',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6420,
	6415,
	'NULL_UNIQUE_ID',
	'Translate:native',
	0,
	296,
	'return com.mentor.nucleus.bp.core.common.IdAssigner.NULL_UUID;',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6421,
	6415,
	'strlen',
	'Translate:native',
	0,
	298,
	'return p_S.length();',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6422,
	6421,
	's',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6423,
	6415,
	'numberOfLines',
	'Translate:native',
	0,
	298,
	'        int count = 0;
        for(int i = 0; i < p_String.length(); i++) {
        	if(p_String.toCharArray()[i] == ''\n'') {
        		count = count + 1;
        	}
        }
        return count;',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6424,
	6423,
	'string',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6425,
	6415,
	'string_to_int',
	'Translate:native',
	0,
	298,
	'String value = p_Value;
try {
  int val = 0;
  // Coerce reals to integers
  int decimal = p_Value.indexOf(''.'');
  int exponent = p_Value.toUpperCase().indexOf(''E'');
  if (decimal != -1 || exponent != -1) {
    val = (int) Float.parseFloat(p_Value);
  // Convert alternate base to base 10 if necessary
  } else if (p_Value.startsWith("0b")) {
    val = Integer.parseInt(p_Value.substring(2), 2);
  } else if (p_Value.startsWith("0x")) {
    val = Integer.parseInt(p_Value.substring(2), 16);
  } else {
    val = Integer.parseInt(value);
  }
  return val;
} catch (NumberFormatException e) {
	//A number format exception was caught here, just return -1;
	CorePlugin.logError(
			"GD::string_to_int exception: NumberFormatException", e);
	return -1;
} catch (Exception e) {
	//An exception was caught here, just return -1;
	CorePlugin.logError("GD::string_to_int exception: Exception", e);
	return -1;
}',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6426,
	6425,
	'value',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6427,
	6415,
	'string_to_real',
	'Translate:native',
	0,
	374,
	'String value = p_Value;
// Promote integers
int decimal = p_Value.indexOf(''.'');
if (decimal == -1) {
	value = value + ".0";
}
try {
	return Float.parseFloat(value);
} catch (NumberFormatException e) {
	//A number format exception was caught here, just return -1.1;
	CorePlugin.logError(
			"GD::string_to_real exception: NumberFormatException", e);
	return -1;
} catch (Exception e) {
	//An exception was caught here, just return -1.1;
	CorePlugin.logError("GD::string_to_real exception: Exception", e);
	return -1;
}
',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6428,
	6427,
	'value',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6429,
	6415,
	'real_to_string',
	'Translate:native',
	0,
	322,
	'return Float.toString(p_Value);',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6430,
	6429,
	'value',
	374,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6431,
	6415,
	'unique_id_to_string',
	'Translate:native',
	0,
	322,
	'return p_Value.toString();',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6432,
	6431,
	'value',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6433,
	6415,
	'boolean_to_string',
	'Translate:native',
	0,
	322,
	'return Boolean.toString(p_Value);',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6434,
	6433,
	'value',
	316,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6435,
	6415,
	'string_to_boolean',
	'Translate:native',
	0,
	316,
	'try
{  
  return (Boolean.valueOf(p_Value)).booleanValue();
}
catch(Exception e)
{
  //An exception was caught here, just return false;
  CorePlugin.logError("GD::string_to_boolean exception: Exception", e);
  return false;
}',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6436,
	6435,
	'value',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6437,
	6415,
	'string_to_unique_id',
	'Translate:native',
	0,
	296,
	'try
{
  if (p_Value.contains("::Unknown")) {
    return Null_unique_id();
  }
  else {
    return UUID.fromString(p_Value);
  }
}
catch(Exception e)
{
  //An exception was caught here, just return NULL_UUID;
  CorePlugin.logError("GD::string_to_unique_id exception: Exception", e);
  return Null_unique_id();
}

',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6438,
	6437,
	'value',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6439,
	6415,
	'toLower',
	'Translate:native',
	0,
	322,
	'return p_Value.toLowerCase();',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6440,
	6439,
	'value',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6441,
	6415,
	'string_to_instance',
	'Translate:native',
	0,
	317,
	'return (Object)p_Value; 
',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6442,
	6441,
	'value',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6443,
	6415,
	'boolean_to_instance',
	'Translate:native',
	0,
	317,
	'return (Object)Boolean.toString(p_Value);',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6444,
	6443,
	'value',
	316,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6445,
	6415,
	'instance_to_string',
	'Translate:native',
	0,
	322,
	'if (p_Value == null) {
  return "";
}
try
{
  if (p_Value instanceof lib.BPInteger) 
  {
    Integer intValue = new Integer(((lib.BPInteger) p_Value).getValue());
    return intValue.toString();
  }
  if (p_Value instanceof lib.BPUniqueId) {
    return ((lib.BPUniqueId) p_Value).getValue().toString();
  }
  if (p_Value instanceof lib.BPFloat)
  {
    Float floatValue = new Float(((lib.BPFloat) p_Value).getValue());
    return floatValue.toString();
  }
  if (p_Value instanceof lib.BPBoolean)
  {
    Boolean boolValue = new Boolean(((lib.BPBoolean) p_Value).getValue());
    return boolValue.toString();
  }
  if (p_Value instanceof lib.BPString)
  {
    String stringValue = new String(((lib.BPString) p_Value).getValue());
    return stringValue;
  }
  
  return p_Value.toString();
}

catch (ClassCastException e)
{
  CorePlugin.logError("GD::instance_to_string exception: Exception", e);
  return p_Value.toString();
}
catch (Exception e)
{
  CorePlugin.logError("GD::instance_to_string exception: Exception", e);
  return p_Value.toString();
}
',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6446,
	6445,
	'value',
	317,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6447,
	6415,
	'int_to_instance',
	'Translate:native',
	0,
	317,
	'return (Object)Integer.toString(p_Value);',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6448,
	6447,
	'value',
	298,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6449,
	6415,
	'real_to_instance',
	'Translate:native',
	0,
	317,
	'return (Object)Float.toString(p_Value);
',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6450,
	6449,
	'value',
	374,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6451,
	6415,
	'unique_id_to_instance',
	'Translate:native',
	0,
	317,
	'return (Object) p_Value.toString();',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6452,
	6451,
	'value',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6453,
	6415,
	'instance_to_boolean',
	'Translate:native',
	0,
	316,
	'try
{
  if (p_Value instanceof lib.BPString)
  {
    return String_to_boolean(((lib.BPString)p_Value).getValue());				
  }
  if (p_Value instanceof lib.BPBoolean)
  {
    return ((lib.BPBoolean) p_Value).getValue();
  }
  
  //object has to be converted to string because it was originally stored as string 
  return String_to_boolean(p_Value.toString());   
}
catch(Exception e)
{
  //An exception was caught here, just return false;
  CorePlugin.logError("GD::instance_to_boolean exception: Exception", e);
  return false;
}',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6454,
	6453,
	'value',
	317,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6455,
	6415,
	'instance_to_real',
	'Translate:native',
	0,
	374,
	'try
{
  if (p_Value instanceof lib.BPString)
  {
    return String_to_real(((lib.BPString) p_Value).getValue());
  }
  if (p_Value instanceof lib.BPFloat)
  {
    return ((lib.BPFloat)p_Value).getValue(); 
  }
  
  //object has to be converted to string because it was originally stored as string 
  return String_to_real(p_Value.toString());  
}
catch(NumberFormatException e)
{  
  //A number format exception was caught here, just return -1.1;
  CorePlugin.logError("GD::instance_to_real exception: NumberFormatException", e);
  return -1;
}
catch(Exception e)
{
  //An exception was caught here, just return -1.1;
  CorePlugin.logError("GD::instance_to_real exception: Exception", e);
  return -1;
}
',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6456,
	6455,
	'value',
	317,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6457,
	6415,
	'instance_to_int',
	'Translate:native',
	0,
	298,
	'try
{
  if (p_Value instanceof lib.BPString)
  {
    return String_to_int(((lib.BPString) p_Value).getValue());
  }
  if (p_Value instanceof lib.BPInteger)
  {
    return ((lib.BPInteger)p_Value).getValue();
  }
  if (p_Value instanceof String) {
    if (((String)p_Value).equals("not participating")) {
      return 0;
    }
  }
  //object has to be converted to string because it was originally stored as string 
  return String_to_int(p_Value.toString());  
}
catch(NumberFormatException e)
{  
  //A number format exception was caught here, just return -1;
  CorePlugin.logError("GD::instance_to_int exception: NumberFormatException", e);
  return -1;
}
catch(Exception e)
{
  //An exception was caught here, just return -1;
  CorePlugin.logError("GD::instance_to_int exception: Exception", e);
  return -1;
}
  
',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6458,
	6457,
	'value',
	317,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6459,
	6415,
	'instance_to_unique_id',
	'Translate:native',
	0,
	296,
	'try
{
  if (p_Value == null) {
    return Null_unique_id();
  }
  if (p_Value instanceof lib.BPString)
  {
    return String_to_unique_id(((lib.BPString) p_Value).getValue());
  }
  
  //object has to be converted to string because it was originally stored as string 
  return String_to_unique_id(p_Value.toString());
}
catch(NumberFormatException e)
{
  //A number format exception was caught here, just return 0;
  CorePlugin.logError("GD::instance_to_unique_id exception: NumberFormatException", e);
  return Null_unique_id();
}
catch(Exception e)
{
  //An exception was caught here, just return 0;
  CorePlugin.logError("GD::instance_to_unique_id exception: Exception", e);
  return Null_unique_id();
}

',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6460,
	6459,
	'value',
	317,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6461,
	6415,
	'instance_to_pending_event_id',
	'Translate:native',
	0,
	296,
	'return ((PendingEvent_c)p_Value).getEvent_id();',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6462,
	6461,
	'value',
	317,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6463,
	6415,
	'convertToBPDataType',
	'Translate:native

This bridge should only be for converting data types of parameters being passed
by reference into realized code.',
	0,
	317,
	'try
{
  if (p_Type.equals("boolean")) { //$NON-NLS-1$
    return new lib.BPBoolean(new Boolean((String) p_Value).booleanValue());
  } else if (p_Type.equals("integer")) { //$NON-NLS-1$
    return new lib.BPInteger(new Integer((String) p_Value).intValue());
  } else if (p_Type.equals("real")) { //$NON-NLS-1$
    return new lib.BPFloat(new Float((String) p_Value).floatValue());
  } else if (p_Type.equals("string")) { //$NON-NLS-1$
    return new lib.BPString((String) p_Value);
  } else if (p_Type.equals("unique_id")) { //$NON-NLS-1$
	return new lib.BPUniqueId(
			IdAssigner.createRuntimeUUIDFromString((String) p_Value, null));
  } else {
    CorePlugin.logError("GD::convertToBPType error: conversion not supported for" + p_Type, null);
    return null;
  }
}
catch (ClassCastException e)
{
  CorePlugin.logError("GD::convertToBPType exception occurred when converting type " + p_Type, e);
  return null;				
}
catch (Exception e)
{
  CorePlugin.logError("GD::convertToBPType exception occurred when converting type " + p_Type, e);
  return null;
}',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6464,
	6463,
	'type',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6465,
	6463,
	'value',
	317,
	0,
	'',
	6464,
	'');
INSERT INTO S_BRG
	VALUES (6466,
	6415,
	'convertFromBPDataType',
	'Translate:native

This bridge should only be for converting data types of parameters being passed
by reference into realized code.

Import:com.mentor.nucleus.bp.core.common.IdAssigner',
	0,
	317,
	'try
{			
  if (p_Type.equals("boolean")) { //$NON-NLS-1$
    return new Boolean(((lib.BPBoolean) p_Value).getValue());
  } else if (p_Type.equals("integer")) { //$NON-NLS-1$
    return new Integer(((lib.BPInteger) p_Value).getValue());
  } else if (p_Type.equals("real")) { //$NON-NLS-1$
    return new Float(((lib.BPFloat) p_Value).getValue());
  } else if (p_Type.equals("string")) { //$NON-NLS-1$
    return new String(((lib.BPString) p_Value).getValue());
  } else if (p_Type.equals("unique_id")) { //$NON-NLS-1$
    return ((lib.BPUniqueId) p_Value).getValue().toString();
  } else {
    CorePlugin.logError("GD::convertfromBPType error: conversion not supported for" + p_Type, null);
    return null;
  }
}
catch (ClassCastException e)
{
  CorePlugin.logError("GD::convertFromBPType exception occurred when converting type " + p_Type, e);
  return null;					
}
catch (Exception e)
{
  CorePlugin.logError("GD::convertFromBPType exception occurred when converting type " + p_Type, e);
  return null;
}	',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6467,
	6466,
	'type',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6468,
	6466,
	'value',
	317,
	0,
	'',
	6467,
	'');
INSERT INTO S_BRG
	VALUES (6469,
	6415,
	'NULL_INSTANCE',
	'Translate:native',
	0,
	317,
	'		return null;
',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6470,
	6415,
	'timestamp_to_string',
	'Translate:native',
	0,
	322,
	'		// Timestamps are already strings
		if ( p_Value != null){
			return p_Value.toString();
		}
		return "empty";',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6471,
	6470,
	'value',
	317,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6472,
	6415,
	'date_to_string',
	'Translate:native',
	0,
	322,
	'		if (p_Value instanceof Calendar) {
			String result = ((Calendar) p_Value).getTime().toLocaleString();
			return result;
		}
		return "empty";
',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6473,
	6472,
	'value',
	317,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6474,
	6415,
	'timer_to_string',
	'Translate:native',
	0,
	322,
	'		if (p_Value instanceof Timer_c) {
			String result = ((Timer_c) p_Value).getLabel();
			return result;
		}
		return "empty";
',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6475,
	6474,
	'value',
	317,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6476,
	6415,
	'event_to_string',
	'Translate:native',
	0,
	322,
	'		if (p_Value instanceof PendingEvent_c) {
			String result = ((PendingEvent_c) p_Value).getLabel();
			return result;
		}
		return "empty";
',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6477,
	6476,
	'value',
	317,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6478,
	6415,
	'strip_tics',
	'Translate:native',
	0,
	322,
	'String rel_phrase = p_Value;
if (rel_phrase.length() > 0 && rel_phrase.charAt(0) == ''\'''' && rel_phrase.charAt(rel_phrase.length() - 1) == ''\'''') {
  rel_phrase = rel_phrase.substring(1, rel_phrase.length() - 1);
}
return rel_phrase;',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6479,
	6478,
	'value',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6480,
	6415,
	'compare_dates',
	'Translate:native',
	0,
	298,
	'		if ((p_D1 instanceof Calendar) && (p_D2 instanceof Calendar)) {
		    long d1 = ((Calendar) p_D1).getTimeInMillis();
		    long d2 = ((Calendar) p_D2).getTimeInMillis();
		    if (d1 == d2)
		    	return 0;
		    if (d1 < d2)
		    	return 1;
		    if (d1 > d2)
		    	return 2;
		}
		return -1;',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6481,
	6480,
	'd1',
	317,
	0,
	'',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6482,
	6480,
	'd2',
	317,
	0,
	'',
	6481,
	'');
INSERT INTO S_BRG
	VALUES (6483,
	6415,
	'compare_times',
	'Translate:native',
	0,
	298,
	'	    long t1 = Long.parseLong((String) p_T1);
	    long t2 = Long.parseLong((String) p_T2);
	    if (t1 == t2)
	    	return 0;
	    if (t1 < t2)
	    	return 1;
	    if (t1 > t2)
	    	return 2;
	    return -1;
',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6484,
	6483,
	't1',
	317,
	0,
	'',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6485,
	6483,
	't2',
	317,
	0,
	'',
	6484,
	'');
INSERT INTO S_BRG
	VALUES (6486,
	6415,
	'component_instance_to_string',
	'Translate:native',
	0,
	322,
	'		if (p_Value instanceof ComponentInstance_c) {
			ComponentInstance_c ci = (ComponentInstance_c) p_Value;
			String label = ci.getLabel();
			int num = ci.Getenginenumber();
			String result = label + "[" + num + "]";
			return result;
		}
		return "Component not found";
',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6487,
	6486,
	'value',
	317,
	0,
	'',
	0,
	'');
INSERT INTO S_EEIP
	VALUES (6395,
	6488);
INSERT INTO S_EE
	VALUES (6488,
	'Utilities',
	'This EE contains utility bridges that provide functionality which cannot be
modeled.
                                      
Import:java.util.*; import com.mentor.nucleus.bp.core.ui.actions.ElementChange
',
	'Util',
	1,
	'',
	'Utilities');
INSERT INTO S_BRG
	VALUES (6489,
	6488,
	'removeDuplicateStrings',
	'This bridge will take a string and remove any lines that are duplicated.

Import:java.util.ArrayList
Translate:native',
	0,
	322,
	'		String[] stringArray = p_Completestring.split(p_Separator);
		ArrayList uniqueArray = new ArrayList();
		String result = "";
		for(int i = 0; i < stringArray.length; i++) {
			if(!uniqueArray.contains(stringArray[i])) {
				uniqueArray.add(stringArray[i]);
			}
		}
		for(int i = 0; i < uniqueArray.size(); i++) {
			result = result + uniqueArray.get(i) + p_Separator;
		}
		return result;',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6490,
	6489,
	'completeString',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6491,
	6489,
	'separator',
	322,
	0,
	'',
	6490,
	'');
INSERT INTO S_BRG
	VALUES (6492,
	6488,
	'selectionContainsValidParticipant',
	'This bridge is used to check the current selection to see if a valid Interaction
Participant is contained within it.  This is required with free-floating message
formalization.

Import:com.mentor.nucleus.bp.core.*; import com.mentor.nucleus.bp.core.common.*; import com.mentor.nucleus.bp.core.inspector.ModelInspector; import com.mentor.nucleus.bp.core.ui.*; import java.util.Iterator
Translate:native',
	0,
	316,
	'		Object foundElement = null;
		Iterator iterator = Selection.getInstance().getStructuredSelection()
			.iterator();
		while (iterator.hasNext()) {
			Object currentSelection = iterator.next();
			if ((currentSelection instanceof ClassParticipant_c)
				|| (currentSelection instanceof ClassInstanceParticipant_c)
				|| (currentSelection instanceof ExternalEntityParticipant_c)
				|| (currentSelection instanceof FunctionPackageParticipant_c)
				|| (currentSelection instanceof ComponentParticipant_c)
				|| (currentSelection instanceof PackageParticipant_c)) {
				foundElement = currentSelection;
				break;
			}
		}
		if (foundElement != null) {
			ModelInspector inspector = new ModelInspector();
			Object parent = inspector.getParent(foundElement);
			if (parent == p_From) {
				return true;
			}
		}
		return false;',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6493,
	6492,
	'from',
	317,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6494,
	6488,
	'getCommunicationInstance',
	'This bridge is used to data type a communication so that during action filtering
for messages the elements contained in the selection can be checked to see if
they are contained within the communication.

Translate:native',
	0,
	317,
	'		final UUID finalId = p_Id;
		Iterator<?> iterator = Selection.getInstance().getStructuredSelection().iterator();
		SynchronousMessage_c synchronousMessage = null;
		AsynchronousMessage_c asynchronousMessage = null;
		while (iterator.hasNext()) {
			Object selection = iterator.next();
			if (selection instanceof SynchronousMessage_c) {
				synchronousMessage = (SynchronousMessage_c) selection;
			} else if (selection instanceof AsynchronousMessage_c) {
				asynchronousMessage = (AsynchronousMessage_c) selection;
			}
		}
		ModelRoot modelRoot = null;
		if (synchronousMessage != null)
			modelRoot = synchronousMessage.getModelRoot();
		if (asynchronousMessage != null)
			modelRoot = asynchronousMessage.getModelRoot();
		Communication_c communication = Communication_c.CommunicationInstance(
				modelRoot, new ClassQueryInterface_c() {

					public boolean evaluate(Object candidate) {
						Communication_c selected = (Communication_c) candidate;
						return selected.getPackage_id().equals(finalId);
					}

				});
		if(communication == null) {
			// should be in a package
			Package_c pkg = (Package_c) modelRoot.getInstanceList(
					Package_c.class).get(finalId);
			return pkg;
		}
		return communication;',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6495,
	6494,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6496,
	6488,
	'isAllowedReturnType',
	'This bridge is used to check all model-roots for dts and determine if the
dt is an allowed return type.
                           
Translate:native',
	0,
	316,
	'SystemModel_c system = (SystemModel_c) p_System;
DataType_c dt = DataType_c.getOneS_DTOnR4401(SystemDatatypeInPackage_c.getManySLD_SDINPsOnR4402(system), new ClassQueryInterface_c() {
		public boolean evaluate(Object candidate) {
		return ((DataType_c) candidate).getName().equals(p_Typename);
    }
});
if (system != null && system.getUseglobals()) {
	dt = DataType_c.getOneS_DTOnR8001(PackageableElement_c
					.getManyPE_PEsOnR9100(GlobalElementInSystem_c
							.getManyG_EISsOnR9100(system)),
		new ClassQueryInterface_c() {
			public boolean evaluate(Object candidate) {
				return ((DataType_c) candidate).getName().equals(
									p_Typename);
			}
	});
}
if ((dt != null)) {
	if ((dt.Iscommonallowedtype())) {
    	return true;
	}
	else if ((p_Typename.equals("void"))) {
		return true;
	}
}
return false;',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6497,
	6496,
	'typeName',
	322,
	0,
	'',
	6498,
	'');
INSERT INTO S_BPARM
	VALUES (6498,
	6496,
	'system',
	317,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6499,
	6488,
	'isAllowedParameterType',
	'This bridge is used to check all model-roots for dts and determine if the
dt is an allowed parameter type.
                           
Translate:native',
	0,
	316,
	'SystemModel_c system = (SystemModel_c) p_System;
DataType_c dt = DataType_c.getOneS_DTOnR4401(SystemDatatypeInPackage_c.getManySLD_SDINPsOnR4402(system), new ClassQueryInterface_c() {
	public boolean evaluate(Object candidate) {
		return ((DataType_c) candidate).getName().equals(p_Typename);
	}
});
if (system != null && system.getUseglobals()) {
	dt = DataType_c.getOneS_DTOnR8001(PackageableElement_c
					.getManyPE_PEsOnR9100(GlobalElementInSystem_c
							.getManyG_EISsOnR9100(system)),
		new ClassQueryInterface_c() {
			public boolean evaluate(Object candidate) {
				return ((DataType_c) candidate).getName().equals(
									p_Typename);
			}
	});
}
if ((dt != null)) {
	return dt.Iscommonallowedtype();
}
return false;',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6500,
	6499,
	'typeName',
	322,
	0,
	'',
	6501,
	'');
INSERT INTO S_BPARM
	VALUES (6501,
	6499,
	'system',
	317,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6502,
	6488,
	'addPastedElementToProblemList',
	'This bridge will add element names that are being pasted to a list that is kept
in the paste action.  The paste action will check this list and display a
dialog to the user indicating some problem.

Import:com.mentor.nucleus.bp.core.ui.PasteAction
Translate:native',
	0,
	19,
	'PasteAction.addElementToProblemsList(p_Message, p_Elementname);',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6503,
	6502,
	'elementName',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6504,
	6502,
	'message',
	322,
	0,
	'',
	6503,
	'');
INSERT INTO S_BRG
	VALUES (6505,
	6488,
	'isProxy',
	'This bridge will determine if an element is a proxy or not.

Translate:native',
	0,
	316,
	'return ((NonRootModelElement)p_Element).isProxy();',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6506,
	6505,
	'element',
	317,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6507,
	6488,
	'getSimpleClassName',
	'This bridge will return the java simple class name.

Translate:native',
	0,
	322,
	'		return p_Element.getClass().getSimpleName().replaceAll("_c", "");',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6508,
	6507,
	'element',
	317,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6509,
	6488,
	'hasSameModelRoot',
	'This bridge is used to compare 2 model roots.
                           
Translate:native',
	0,
	316,
	'boolean hasSameRoot = false;
if (p_Nrme1 != null && p_Nrme2 != null) {
	if ((p_Nrme1 instanceof NonRootModelElement)
			&& (p_Nrme2 instanceof NonRootModelElement)) {
		ModelRoot root1 = ((NonRootModelElement) p_Nrme1).getModelRoot();
		ModelRoot root2 = ((NonRootModelElement) p_Nrme2).getModelRoot();
		if (root1.getId() != null && root1.getId().equals(root2.getId())) {
			hasSameRoot = true;
		}
	}
}
return hasSameRoot;
',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6510,
	6509,
	'nrme1',
	317,
	0,
	'',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6511,
	6509,
	'nrme2',
	317,
	0,
	'',
	6510,
	'');
INSERT INTO S_BRG
	VALUES (6512,
	6488,
	'addIntToLong',
	'Translate:native',
	0,
	2978,
	'return p_Longvar + p_Intvar;',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6513,
	6512,
	'longVar',
	2978,
	0,
	'',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6514,
	6512,
	'intVar',
	298,
	0,
	'',
	6513,
	'');
INSERT INTO S_BRG
	VALUES (6515,
	6488,
	'diffLongsToInt',
	'Translate:native',
	0,
	298,
	'return (int) (p_V1 - p_V2);',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6516,
	6515,
	'v1',
	2978,
	0,
	'',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6517,
	6515,
	'v2',
	2978,
	0,
	'',
	6516,
	'');
INSERT INTO S_BRG
	VALUES (6518,
	6488,
	'collectModelElementsNames',
	'This bridge will add element names that are affected by the datatype/Interfacce
being deleted to a list that is kept in the TransactionManager . 
The TransactionManager will check this list and display a confirmation
dialog to the user indicating the names of the elements affected.                        
Translate:native
',
	0,
	19,
	'TransactionManager.collectModelElementsNames(p_Elementtype,p_Elementname);',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6519,
	6518,
	'elementName',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6520,
	6518,
	'elementType',
	322,
	0,
	'',
	6519,
	'');
INSERT INTO S_BRG
	VALUES (6521,
	6488,
	'getElementCountInSystem',
	'Translate:native',
	0,
	298,
	'		Class<?> classType = null;
		if (p_Elementtype == Elementtypeconstants_c.EE) {
			classType = ExternalEntity_c.class;
		} else if (p_Elementtype == Elementtypeconstants_c.COMPONENT) {
			classType = Component_c.class;
		} else if (p_Elementtype == Elementtypeconstants_c.CLASS) {
			classType = ModelClass_c.class;
		} else if (p_Elementtype == Elementtypeconstants_c.PACKAGE) {
		    classType = Package_c.class;
		}
		int count = 0;
		Ooaofooa[] instances = OoaofooaBase.getInstancesUnderSystem(((NonRootModelElement) p_Askingelement).getModelRoot());
		for (int i = 0; i < instances.length; i++) {
			// if there is no package in this model root, skip it
			// this method currently is only used for generic package
			// cases
			if (instances[i].getInstanceList(Package_c.class).size() != 0) {
				count = count + instances[i].getInstanceList(classType).size();
			}
		}
		// look for other systems if IPRs are enabled
		SystemModel_c sys = (SystemModel_c) ((NonRootModelElement) p_Askingelement).getRoot();
		if (Pref_c.Getsystemboolean(
				"com.mentor.nucleus.bp.ui.project.references",
				sys.getName())) {
			SystemModel_c[] systems = SystemModel_c.SystemModelInstances(Ooaofooa.getDefaultInstance());
			for(SystemModel_c system : systems) {
				if(sys != system && system.getUseglobals()) {
					instances = OoaofooaBase.getInstancesUnderSystem(system.getName());
					for (int i = 0; i < instances.length; i++) {
						// if there is no package in this model root, skip it
						// this method currently is only used for generic
						// package
						// cases
						if (instances[i].getInstanceList(Package_c.class).size() != 0) {
							count = count + instances[i].getInstanceList(classType).size();
						}
					}
				}
			}
		}
		return count;
',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6522,
	6521,
	'elementType',
	2878,
	0,
	'',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6523,
	6521,
	'askingElement',
	317,
	0,
	'',
	6522,
	'');
INSERT INTO S_BRG
	VALUES (6524,
	6488,
	'logError',
	'Translate:native',
	0,
	19,
	'//native
CorePlugin.logError(p_Message , null);',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6525,
	6524,
	'message',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6526,
	6488,
	'getModelRootId',
	'Translate:native',
	0,
	322,
	'return "";',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6527,
	6526,
	'element',
	317,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6528,
	6488,
	'getFullyQualifiedClassName',
	'Translate:native',
	0,
	322,
	'	return p_Element.getClass().getName();',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6529,
	6528,
	'element',
	317,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6530,
	6488,
	'addElementToList',
	'This bridge will add an element to a native Java java.util.List

Import:com.mentor.nucleus.bp.core.common.NonRootModelElement
Translate:native',
	0,
	19,
	'		if(!(p_Elementlist instanceof List<?>)) {
			CorePlugin.logError("Incorrect usage of Util::addElementToList() bridge.", null);
			return;
		}
		@SuppressWarnings("unchecked")
		List<Object> thisList = (List<Object>) p_Elementlist;
		thisList.add(p_Element);',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6531,
	6530,
	'element',
	317,
	0,
	'',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6532,
	6530,
	'elementList',
	317,
	0,
	'',
	6531,
	'');
INSERT INTO S_BRG
	VALUES (6533,
	6488,
	'createElementChange',
	'Translate:native',
	0,
	19,
	'		if(!(p_Changelist instanceof List<?>)) {
			CorePlugin.logError("Incorrect usage of Util::createElementChange() bridge.", null);
			return;
		}
		@SuppressWarnings("unchecked")
		List<Object> thisList = (List<Object>) p_Changelist;
		thisList.add(new ElementChange(p_Elementchanged, p_Isremoval, p_Changelabel));',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6534,
	6533,
	'isRemoval',
	316,
	0,
	'',
	6535,
	'');
INSERT INTO S_BPARM
	VALUES (6535,
	6533,
	'elementChanged',
	317,
	0,
	'',
	6536,
	'');
INSERT INTO S_BPARM
	VALUES (6537,
	6533,
	'changeLabel',
	322,
	0,
	'',
	6534,
	'');
INSERT INTO S_BPARM
	VALUES (6536,
	6533,
	'changeList',
	317,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6538,
	6488,
	'isNull',
	'// This bridge returns true if the passed element is null
Translate:native',
	0,
	316,
	'         return p_Element == null;
',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6539,
	6538,
	'element',
	317,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6540,
	6488,
	'getLastSegmentForPath',
	'Translate:native',
	0,
	322,
	'		String resultPath = p_Path.replace("\\", "/");
		if (resultPath.contains("/")) {
			String[] split = resultPath.split("/");
			return split[split.length - 1];
		}
		return resultPath;',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6541,
	6540,
	'path',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6542,
	6488,
	'getTic',
	'Translate: native',
	0,
	322,
	'return "''";',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6543,
	6488,
	'getUniqueStateMachineId',
	'Translate:native',
	0,
	296,
	'		IdAssigner assigner = new IdAssigner();
		int hashCode = p_Classid.hashCode() + p_Type.hashCode();
		assigner.setSeed(hashCode);
		UUID stateId = assigner.createUUID();
		return stateId;',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6544,
	6543,
	'classId',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6545,
	6543,
	'type',
	322,
	0,
	'',
	6544,
	'');
INSERT INTO S_BRG
	VALUES (6546,
	6488,
	'createInstanceStateMachine',
	'Translate:native',
	0,
	19,
	'		if (p_Class instanceof ModelClass_c) {
			ModelClass_c modelClass = (ModelClass_c) p_Class;
			StateMachine_c sm = new StateMachine_c(modelClass.getModelRoot(),
					modelClass.getIsm_id(), "", 0);
			Ooaofooa.getDefaultInstance().fireModelElementCreated(
					new BaseModelDelta(Modeleventnotification_c.DELTA_NEW, sm));
			InstanceStateMachine_c ism = new InstanceStateMachine_c(
					modelClass.getModelRoot());
			Ooaofooa.getDefaultInstance()
					.fireModelElementCreated(
							new BaseModelDelta(
									Modeleventnotification_c.DELTA_NEW, ism));
			modelClass.relateAcrossR518To(ism);
			sm.relateAcrossR517To(ism);
		}',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6547,
	6546,
	'class',
	317,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6548,
	6488,
	'createClassStateMachine',
	'Translate:native',
	0,
	19,
	'		if (p_Class instanceof ModelClass_c) {
			ModelClass_c modelClass = (ModelClass_c) p_Class;
			StateMachine_c sm = new StateMachine_c(modelClass.getModelRoot(),
					modelClass.getCsm_id(), "", 0);
			Ooaofooa.getDefaultInstance().fireModelElementCreated(
					new BaseModelDelta(Modeleventnotification_c.DELTA_NEW, sm));
			ClassStateMachine_c csm = new ClassStateMachine_c(
					modelClass.getModelRoot());
			Ooaofooa.getDefaultInstance()
					.fireModelElementCreated(
							new BaseModelDelta(
									Modeleventnotification_c.DELTA_NEW, csm));
			modelClass.relateAcrossR519To(csm);
			sm.relateAcrossR517To(csm);
		}
',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6549,
	6548,
	'class',
	317,
	0,
	'',
	0,
	'');
INSERT INTO S_EEIP
	VALUES (6395,
	6550);
INSERT INTO S_EE
	VALUES (6550,
	'Selection',
	'This EE contains bridge operations that provide access to the tool''s selection
provider which cannot be modeled.',
	'Sel',
	1,
	'',
	'Selection');
INSERT INTO S_BRG
	VALUES (6551,
	6550,
	'getCurrentSelectionCount',
	'This bridge returns the tools current selection count.

Import:com.mentor.nucleus.bp.core.ui.Selection
Translate:native',
	0,
	298,
	'	return Selection.getInstance().getStructuredSelection().size();',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6552,
	6550,
	'clearSelection',
	'This bridge clears the current selection.

Import:com.mentor.nucleus.bp.core.ui.Selection
Translate:native',
	0,
	19,
	'	Selection.getInstance().clear();',
	0,
	'');
INSERT INTO S_EEIP
	VALUES (6395,
	6553);
INSERT INTO S_EE
	VALUES (6553,
	'Parse Error Reporting',
	'This external entity contains bridges that notify the user of parse errors that have occurred.
It is implemented by a hand-written class.

This External Entity should be exported with graphics and with Only Referenced
user data types.

Translate: false',
	'ERR',
	1,
	'',
	'Parse Error Reporting');
INSERT INTO S_BRG
	VALUES (6554,
	6553,
	'reportParseError',
	'This bridge abstracts the reporting of parse errors to the user.
The error occured at line, in column col, and the error message is msg.',
	0,
	19,
	'',
	1,
	'');
INSERT INTO S_BPARM
	VALUES (6555,
	6554,
	'msg',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6556,
	6554,
	'token',
	4438,
	0,
	'',
	6555,
	'');
INSERT INTO S_BRG
	VALUES (6557,
	6553,
	'tokenHasValues',
	'Translate:native',
	0,
	316,
	'',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6558,
	6557,
	'token',
	4438,
	0,
	'',
	0,
	'');
INSERT INTO S_EEIP
	VALUES (6395,
	6559);
INSERT INTO S_EE
	VALUES (6559,
	'Operating System',
	'This external entity provides utility operations that are typically supplied
by the operating system.  It is implemented by a hand-written class.

This External Entity should be exported with graphics and with Only Referenced
user data types.',
	'OS',
	1,
	'',
	'Operating System');
INSERT INTO S_BRG
	VALUES (6560,
	6559,
	'convert_relationship_string',
	'This bridge converts the input string "Rxx" to the integer
value of xx.  If the string is improperly formatted, the function
returns -1.
Translate: native',
	0,
	298,
	'if ( p_Rel.charAt(0) != ''R'' )
  return -1;
else
{
  try {
    return Integer.parseInt(p_Rel.substring(1));
  }
  catch (NumberFormatException  e) {
    return -1;
  }
}',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6561,
	6560,
	'rel',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6562,
	6559,
	'remove_ticks',
	'This function removes a single tick from the beginning
and end of the string passed in.  It does nothing if 
the first character of the string is not a single tick.

Translate: native',
	0,
	322,
	'if ( p_Ticked_string.charAt(0) == ''\'''' )
{
  return p_Ticked_string.substring(1, p_Ticked_string.length()-1);
}
else
  return p_Ticked_string;',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6563,
	6562,
	'ticked_string',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6564,
	6559,
	'remove_star',
	'
Translate: native',
	0,
	322,
	'if ( p_S.charAt(p_S.length()-1) == ''*'' )
{
  return p_S.substring(0, p_S.length()-1);
}
else
  return p_S;',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6565,
	6564,
	's',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6566,
	6559,
	'getEnvVariable',
	'
Translate: native',
	0,
	316,
	'	String env = System.getenv(p_Name);
	return Boolean.valueOf(env);
',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6567,
	6566,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6568,
	6559,
	'remove_spaces',
	'
Translate: native',
	0,
	322,
	'return p_S.replaceAll("\\s", "");',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6569,
	6568,
	's',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_EEIP
	VALUES (6395,
	6570);
INSERT INTO S_EE
	VALUES (6570,
	'Virtual Machine',
	'This entity represents the virtual machine under which the tool is executing
We use this to load users realized code.
-----------------------------------------------------------------------------------
Translate:false',
	'VM',
	1,
	'',
	'Virtual Machine');
INSERT INTO S_BRG
	VALUES (6571,
	6570,
	'loadClass',
	'',
	0,
	316,
	'return true;',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6572,
	6571,
	'name',
	322,
	0,
	'',
	6573,
	'');
INSERT INTO S_BPARM
	VALUES (6573,
	6571,
	'system_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6574,
	6570,
	'addArgumentValue',
	'',
	0,
	19,
	'',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6575,
	6574,
	'value',
	317,
	0,
	'',
	6576,
	'');
INSERT INTO S_BPARM
	VALUES (6576,
	6574,
	'type',
	322,
	0,
	'',
	6577,
	'');
INSERT INTO S_BPARM
	VALUES (6577,
	6574,
	'byRef',
	316,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6578,
	6570,
	'resetValues',
	'',
	0,
	19,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6579,
	6570,
	'execute',
	'',
	0,
	316,
	'return true;',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6580,
	6579,
	'name',
	322,
	0,
	'',
	6581,
	'');
INSERT INTO S_BPARM
	VALUES (6581,
	6579,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6582,
	6570,
	'setUserClassPath',
	'',
	0,
	19,
	'',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6583,
	6582,
	'System_ID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6584,
	6570,
	'getResult',
	'',
	0,
	317,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6585,
	6570,
	'addUserClassPath',
	'',
	0,
	19,
	'',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6586,
	6585,
	'System_ID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6587,
	6585,
	'path',
	322,
	0,
	'',
	6586,
	'');
INSERT INTO S_EEIP
	VALUES (6395,
	6588);
INSERT INTO S_EE
	VALUES (6588,
	'Preferences',
	'This EE represents the interface to the Eclipse preferences. It''s bridge calls
provide a means for action language to access the preferences.

Import: com.mentor.nucleus.bp.core.common.*; import org.eclipse.jface.dialogs.*; import com.mentor.nucleus.bp.core.ui.preferences.*; import org.osgi.service.prefs.Preferences; import org.eclipse.core.resources.*; import org.eclipse.jface.preference.*; import org.eclipse.core.runtime.preferences.IScopeContext; import org.eclipse.jface.dialogs.MessageDialogWithToggle
',
	'PREF',
	1,
	'',
	'Preferences');
INSERT INTO S_BRG
	VALUES (6589,
	6588,
	'getBoolean',
	'This bridge is used to get a boolean eclipse preference.

Translate:native',
	0,
	316,
	'		IPreferenceStore store = CorePlugin.getDefault().getPreferenceStore();
		if (p_Name.equals("bridgepoint_prefs_allow_int_to_real_promotion")
             || p_Name.equals("bridgepoint_prefs_allow_real_to_int_coercion")) {
          String option = store.getString(p_Name);
          if (option.equals(MessageDialogWithToggle.ALWAYS)) {
            return true;
          } else {
            return false;
          }
        } else {
          return store.getBoolean(p_Name);
        }
',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6590,
	6589,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6591,
	6588,
	'getInteger',
	'This bridge is used to get an integer eclipse preference.

Translate:native',
	0,
	298,
	'        IPreferenceStore store = CorePlugin.getDefault().getPreferenceStore();
        return store.getInt(p_Name);
',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6592,
	6591,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6593,
	6588,
	'getReal',
	'This bridge is used to get a real/double eclipse preference.

Translate:native',
	0,
	374,
	'        IPreferenceStore store = CorePlugin.getDefault().getPreferenceStore();
        return store.getFloat(p_Name);
',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6594,
	6593,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6595,
	6588,
	'getString',
	'This bridge is used to get a string eclipse preference.

Translate:native',
	0,
	322,
	'        IPreferenceStore store = CorePlugin.getDefault().getPreferenceStore();
        return store.getString(p_Name);
',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6596,
	6595,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6597,
	6588,
	'getSystemBoolean',
	'This bridge is used to get a boolean eclipse project level preference.

Translate:native',
	0,
	316,
	'		IProject selectedProject = ResourcesPlugin.getWorkspace().getRoot()
				.getProject(p_Systemname);
		if (selectedProject != null) {
			IScopeContext projectScope = new ProjectScope(selectedProject);
			Preferences projectNode = projectScope
					.getNode(BridgePointProjectPreferences.BP_PROJECT_PREFERENCES_ID);
			// handle defaults for parse preferences
			if (p_Name
					.equals(BridgePointProjectActionLanguagePreferences.ENABLE_ERROR_FOR_EMPTY_SYNCHRONOUS_MESSAGE)
					|| p_Name
							.equals(BridgePointProjectActionLanguagePreferences.ENABLE_ERROR_FOR_EMPTY_SYNCHRONOUS_MESSAGE_REALIZED)) {
				// we need to consider the workspace preference if a project preference
				// has not been set
				boolean workspacePreference = CorePlugin.getDefault()
						.getPreferenceStore().getBoolean(p_Name);
				// use the workspace preference as the default
				return projectNode.getBoolean(p_Name, workspacePreference);
			}
			// handle defaults for emit RTO data
			if (p_Name
					.equals(BridgePointProjectReferencesPreferences.BP_PROJECT_EMITRTODATA_ID)) {
				return projectNode.getBoolean(p_Name, true);
			}
			return projectNode.getBoolean(p_Name, false);
		}
		return false;
',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6598,
	6597,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6599,
	6597,
	'systemName',
	322,
	0,
	'',
	6598,
	'');
INSERT INTO S_EEIP
	VALUES (6395,
	6600);
INSERT INTO S_EE
	VALUES (6600,
	'Search',
	'Translate:false',
	'Search',
	1,
	'',
	'Search');
INSERT INTO S_BRG
	VALUES (6601,
	6600,
	'locateContentResults',
	'Translate: native',
	0,
	296,
	'',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6602,
	6601,
	'pattern',
	322,
	0,
	'',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6603,
	6601,
	'contents',
	322,
	0,
	'',
	6602,
	'');
INSERT INTO S_BPARM
	VALUES (6604,
	6601,
	'isCaseSensitive',
	316,
	0,
	'',
	6603,
	'');
INSERT INTO S_BRG
	VALUES (6605,
	6600,
	'gatherParticipants',
	'',
	0,
	19,
	'',
	3,
	'');
INSERT INTO S_BPARM
	VALUES (6606,
	6605,
	'queryId',
	296,
	0,
	'',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6607,
	6605,
	'monitor',
	317,
	0,
	'',
	6606,
	'');
INSERT INTO S_BRG
	VALUES (6608,
	6600,
	'clearQueryData',
	'',
	0,
	19,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6609,
	6600,
	'monitorCanceled',
	'',
	0,
	316,
	'',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6610,
	6609,
	'monitor',
	317,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6611,
	6600,
	'matchCreated',
	'',
	0,
	19,
	'',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6612,
	6611,
	'match',
	317,
	0,
	'',
	0,
	'');
INSERT INTO S_BRG
	VALUES (6613,
	6600,
	'configureScope',
	'',
	0,
	19,
	'',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6614,
	6613,
	'scope',
	2512,
	0,
	'',
	0,
	'');
INSERT INTO S_BPARM
	VALUES (6615,
	6613,
	'monitor',
	317,
	0,
	'',
	6614,
	'');
-- BP 7.1 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (6616,
	'Event',
	'This subsystem focuses on the creation and generation
of events. Events to instances, class, creators and
external entities are covered, as well as the creation of
event instances of those types. Finally the generation
of pre-existing event instances are also covered.
Notify_Changes:false
Persistent:false
// This is used by schema_gen to ignore this subsystem (for publication)
TRANSLATE_FOR_EXTERNAL_USE:FALSE
',
	'E',
	700,
	1,
	6617);
INSERT INTO S_SID
	VALUES (1,
	6616);
INSERT INTO O_IOBJ
	VALUES (6618,
	68,
	5,
	6616,
	'Actual Parameter',
	'V_PAR');
INSERT INTO O_IOBJ
	VALUES (6619,
	129,
	5,
	6616,
	'Variable',
	'V_VAR');
INSERT INTO O_IOBJ
	VALUES (6620,
	129,
	5,
	6616,
	'Variable',
	'V_VAR');
INSERT INTO O_IOBJ
	VALUES (6621,
	6622,
	5,
	6616,
	'External Entity Event',
	'S_EEEVT');
INSERT INTO O_IOBJ
	VALUES (6623,
	1488,
	5,
	6616,
	'State Machine Event',
	'SM_EVT');
INSERT INTO O_IOBJ
	VALUES (6624,
	70,
	0,
	6616,
	'Value',
	'V_VAL');
INSERT INTO R_SIMP
	VALUES (6625);
INSERT INTO R_REL
	VALUES (6625,
	712,
	'',
	6616);
INSERT INTO R_FORM
	VALUES (6626,
	6625,
	6627,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (6626,
	6625,
	6627);
INSERT INTO R_OIR
	VALUES (6626,
	6625,
	6627,
	0);
INSERT INTO R_PART
	VALUES (129,
	6625,
	6628,
	0,
	0,
	'has recipient');
INSERT INTO O_RTIDA
	VALUES (131,
	129,
	0,
	6625,
	6628);
INSERT INTO R_RTO
	VALUES (129,
	6625,
	6628,
	0);
INSERT INTO R_OIR
	VALUES (129,
	6625,
	6628,
	6620);
INSERT INTO R_SIMP
	VALUES (6629);
INSERT INTO R_REL
	VALUES (6629,
	711,
	'',
	6616);
INSERT INTO R_FORM
	VALUES (6630,
	6629,
	6631,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (6630,
	6629,
	6631);
INSERT INTO R_OIR
	VALUES (6630,
	6629,
	6631,
	0);
INSERT INTO R_PART
	VALUES (129,
	6629,
	6632,
	0,
	0,
	'has recipient');
INSERT INTO O_RTIDA
	VALUES (131,
	129,
	0,
	6629,
	6632);
INSERT INTO R_RTO
	VALUES (129,
	6629,
	6632,
	0);
INSERT INTO R_OIR
	VALUES (129,
	6629,
	6632,
	6619);
INSERT INTO R_SIMP
	VALUES (6633);
INSERT INTO R_REL
	VALUES (6633,
	708,
	'',
	6616);
INSERT INTO R_FORM
	VALUES (6634,
	6633,
	6635,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (6634,
	6633,
	6635);
INSERT INTO R_OIR
	VALUES (6634,
	6633,
	6635,
	0);
INSERT INTO R_PART
	VALUES (6622,
	6633,
	6636,
	0,
	0,
	'creates');
INSERT INTO O_RTIDA
	VALUES (6637,
	6622,
	0,
	6633,
	6636);
INSERT INTO O_RTIDA
	VALUES (6638,
	6622,
	0,
	6633,
	6636);
INSERT INTO R_RTO
	VALUES (6622,
	6633,
	6636,
	0);
INSERT INTO R_OIR
	VALUES (6622,
	6633,
	6636,
	6621);
INSERT INTO R_SIMP
	VALUES (6639);
INSERT INTO R_REL
	VALUES (6639,
	709,
	'',
	6616);
INSERT INTO R_FORM
	VALUES (6640,
	6639,
	6641,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (6640,
	6639,
	6641);
INSERT INTO R_OIR
	VALUES (6640,
	6639,
	6641,
	0);
INSERT INTO R_PART
	VALUES (6622,
	6639,
	6642,
	0,
	0,
	'generates');
INSERT INTO O_RTIDA
	VALUES (6637,
	6622,
	0,
	6639,
	6642);
INSERT INTO O_RTIDA
	VALUES (6638,
	6622,
	0,
	6639,
	6642);
INSERT INTO R_RTO
	VALUES (6622,
	6639,
	6642,
	0);
INSERT INTO R_OIR
	VALUES (6622,
	6639,
	6642,
	6621);
INSERT INTO R_SUBSUP
	VALUES (6643);
INSERT INTO R_REL
	VALUES (6643,
	701,
	'',
	6616);
INSERT INTO R_SUPER
	VALUES (667,
	6643,
	6644);
INSERT INTO O_RTIDA
	VALUES (668,
	667,
	0,
	6643,
	6644);
INSERT INTO R_RTO
	VALUES (667,
	6643,
	6644,
	0);
INSERT INTO R_OIR
	VALUES (667,
	6643,
	6644,
	0);
INSERT INTO R_SUB
	VALUES (6645,
	6643,
	6646);
INSERT INTO R_RGO
	VALUES (6645,
	6643,
	6646);
INSERT INTO R_OIR
	VALUES (6645,
	6643,
	6646,
	0);
INSERT INTO R_SUB
	VALUES (6647,
	6643,
	6648);
INSERT INTO R_RGO
	VALUES (6647,
	6643,
	6648);
INSERT INTO R_OIR
	VALUES (6647,
	6643,
	6648,
	0);
INSERT INTO R_SIMP
	VALUES (6649);
INSERT INTO R_REL
	VALUES (6649,
	710,
	'',
	6616);
INSERT INTO R_FORM
	VALUES (6645,
	6649,
	6650,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (6645,
	6649,
	6650);
INSERT INTO R_OIR
	VALUES (6645,
	6649,
	6650,
	0);
INSERT INTO R_PART
	VALUES (129,
	6649,
	6651,
	0,
	0,
	'result');
INSERT INTO O_RTIDA
	VALUES (131,
	129,
	0,
	6649,
	6651);
INSERT INTO R_RTO
	VALUES (129,
	6649,
	6651,
	0);
INSERT INTO R_OIR
	VALUES (129,
	6649,
	6651,
	6619);
INSERT INTO R_SUBSUP
	VALUES (6652);
INSERT INTO R_REL
	VALUES (6652,
	702,
	'',
	6616);
INSERT INTO R_SUPER
	VALUES (6645,
	6652,
	6653);
INSERT INTO O_RTIDA
	VALUES (6654,
	6645,
	0,
	6652,
	6653);
INSERT INTO R_RTO
	VALUES (6645,
	6652,
	6653,
	0);
INSERT INTO R_OIR
	VALUES (6645,
	6652,
	6653,
	0);
INSERT INTO R_SUB
	VALUES (6634,
	6652,
	6655);
INSERT INTO R_RGO
	VALUES (6634,
	6652,
	6655);
INSERT INTO R_OIR
	VALUES (6634,
	6652,
	6655,
	0);
INSERT INTO R_SUB
	VALUES (6656,
	6652,
	6657);
INSERT INTO R_RGO
	VALUES (6656,
	6652,
	6657);
INSERT INTO R_OIR
	VALUES (6656,
	6652,
	6657,
	0);
INSERT INTO R_SUBSUP
	VALUES (6658);
INSERT INTO R_REL
	VALUES (6658,
	703,
	'',
	6616);
INSERT INTO R_SUPER
	VALUES (6647,
	6658,
	6659);
INSERT INTO O_RTIDA
	VALUES (6660,
	6647,
	0,
	6658,
	6659);
INSERT INTO R_RTO
	VALUES (6647,
	6658,
	6659,
	0);
INSERT INTO R_OIR
	VALUES (6647,
	6658,
	6659,
	0);
INSERT INTO R_SUB
	VALUES (6640,
	6658,
	6661);
INSERT INTO R_RGO
	VALUES (6640,
	6658,
	6661);
INSERT INTO R_OIR
	VALUES (6640,
	6658,
	6661,
	0);
INSERT INTO R_SUB
	VALUES (6662,
	6658,
	6663);
INSERT INTO R_RGO
	VALUES (6662,
	6658,
	6663);
INSERT INTO R_OIR
	VALUES (6662,
	6658,
	6663,
	0);
INSERT INTO R_SIMP
	VALUES (6664);
INSERT INTO R_REL
	VALUES (6664,
	706,
	'',
	6616);
INSERT INTO R_FORM
	VALUES (6656,
	6664,
	6665,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (6656,
	6664,
	6665);
INSERT INTO R_OIR
	VALUES (6656,
	6664,
	6665,
	0);
INSERT INTO R_PART
	VALUES (1488,
	6664,
	6666,
	0,
	0,
	'creates');
INSERT INTO O_RTIDA
	VALUES (1604,
	1488,
	0,
	6664,
	6666);
INSERT INTO R_RTO
	VALUES (1488,
	6664,
	6666,
	0);
INSERT INTO R_OIR
	VALUES (1488,
	6664,
	6666,
	6623);
INSERT INTO R_SUBSUP
	VALUES (6667);
INSERT INTO R_REL
	VALUES (6667,
	704,
	'',
	6616);
INSERT INTO R_SUPER
	VALUES (6656,
	6667,
	6668);
INSERT INTO O_RTIDA
	VALUES (6669,
	6656,
	0,
	6667,
	6668);
INSERT INTO R_RTO
	VALUES (6656,
	6667,
	6668,
	0);
INSERT INTO R_OIR
	VALUES (6656,
	6667,
	6668,
	0);
INSERT INTO R_SUB
	VALUES (6630,
	6667,
	6670);
INSERT INTO R_RGO
	VALUES (6630,
	6667,
	6670);
INSERT INTO R_OIR
	VALUES (6630,
	6667,
	6670,
	0);
INSERT INTO R_SUB
	VALUES (6671,
	6667,
	6672);
INSERT INTO R_RGO
	VALUES (6671,
	6667,
	6672);
INSERT INTO R_OIR
	VALUES (6671,
	6667,
	6672,
	0);
INSERT INTO R_SUB
	VALUES (6673,
	6667,
	6674);
INSERT INTO R_RGO
	VALUES (6673,
	6667,
	6674);
INSERT INTO R_OIR
	VALUES (6673,
	6667,
	6674,
	0);
INSERT INTO R_SUBSUP
	VALUES (6675);
INSERT INTO R_REL
	VALUES (6675,
	705,
	'',
	6616);
INSERT INTO R_SUPER
	VALUES (6662,
	6675,
	6676);
INSERT INTO O_RTIDA
	VALUES (6677,
	6662,
	0,
	6675,
	6676);
INSERT INTO R_RTO
	VALUES (6662,
	6675,
	6676,
	0);
INSERT INTO R_OIR
	VALUES (6662,
	6675,
	6676,
	0);
INSERT INTO R_SUB
	VALUES (6626,
	6675,
	6678);
INSERT INTO R_RGO
	VALUES (6626,
	6675,
	6678);
INSERT INTO R_OIR
	VALUES (6626,
	6675,
	6678,
	0);
INSERT INTO R_SUB
	VALUES (6679,
	6675,
	6680);
INSERT INTO R_RGO
	VALUES (6679,
	6675,
	6680);
INSERT INTO R_OIR
	VALUES (6679,
	6675,
	6680,
	0);
INSERT INTO R_SUB
	VALUES (6681,
	6675,
	6682);
INSERT INTO R_RGO
	VALUES (6681,
	6675,
	6682);
INSERT INTO R_OIR
	VALUES (6681,
	6675,
	6682,
	0);
INSERT INTO R_SIMP
	VALUES (6683);
INSERT INTO R_REL
	VALUES (6683,
	707,
	'',
	6616);
INSERT INTO R_FORM
	VALUES (6662,
	6683,
	6684,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (6662,
	6683,
	6684);
INSERT INTO R_OIR
	VALUES (6662,
	6683,
	6684,
	0);
INSERT INTO R_PART
	VALUES (1488,
	6683,
	6685,
	0,
	0,
	'generates');
INSERT INTO O_RTIDA
	VALUES (1604,
	1488,
	0,
	6683,
	6685);
INSERT INTO R_RTO
	VALUES (1488,
	6683,
	6685,
	0);
INSERT INTO R_OIR
	VALUES (1488,
	6683,
	6685,
	6623);
INSERT INTO R_SIMP
	VALUES (669);
INSERT INTO R_REL
	VALUES (669,
	700,
	'',
	6616);
INSERT INTO R_PART
	VALUES (667,
	669,
	671,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (668,
	667,
	0,
	669,
	671);
INSERT INTO R_RTO
	VALUES (667,
	669,
	671,
	0);
INSERT INTO R_OIR
	VALUES (667,
	669,
	671,
	0);
INSERT INTO R_FORM
	VALUES (68,
	669,
	670,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (68,
	669,
	670);
INSERT INTO R_OIR
	VALUES (68,
	669,
	670,
	6618);
INSERT INTO R_SIMP
	VALUES (6686);
INSERT INTO R_REL
	VALUES (6686,
	714,
	'',
	6616);
INSERT INTO R_FORM
	VALUES (6687,
	6686,
	6688,
	0,
	1,
	'holds event to be generated by');
INSERT INTO R_RGO
	VALUES (6687,
	6686,
	6688);
INSERT INTO R_OIR
	VALUES (6687,
	6686,
	6688,
	0);
INSERT INTO R_PART
	VALUES (70,
	6686,
	6689,
	0,
	1,
	'generates event held by');
INSERT INTO O_RTIDA
	VALUES (72,
	70,
	0,
	6686,
	6689);
INSERT INTO R_RTO
	VALUES (70,
	6686,
	6689,
	0);
INSERT INTO R_OIR
	VALUES (70,
	6686,
	6689,
	6624);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (6640,
	'Generate to External Entity',
	707,
	'E_GEE',
	'This class represents the generation of an event to an external entity.',
	6616);
INSERT INTO O_TFR
	VALUES (6690,
	6640,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'select one evt related by self->S_EEEVT[R709];
if ( not empty evt )
  unrelate self from evt across R709;
end if;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (6640,
	6647,
	0,
	6660,
	6658,
	6661,
	6659,
	6691,
	6692,
	0,
	0,
	'',
	'Generate Event Statement',
	'Statement_ID',
	'R703');
INSERT INTO O_RATTR
	VALUES (6691,
	6640,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (6691,
	6640,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (6640,
	6622,
	0,
	6637,
	6639,
	6641,
	6642,
	6693,
	6694,
	0,
	0,
	'',
	'External Entity Event',
	'EEevt_ID',
	'R709');
INSERT INTO O_RATTR
	VALUES (6693,
	6640,
	6637,
	6622,
	1,
	'EEevt_ID');
INSERT INTO O_ATTR
	VALUES (6693,
	6640,
	6695,
	'EEevt_ID',
	'

',
	'',
	'EEevt_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (6640,
	6622,
	0,
	6638,
	6639,
	6641,
	6642,
	6695,
	6696,
	0,
	0,
	'',
	'External Entity Event',
	'EE_ID',
	'R709');
INSERT INTO O_RATTR
	VALUES (6695,
	6640,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (6695,
	6640,
	6691,
	'EE_ID',
	'',
	'',
	'EE_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	6640);
INSERT INTO O_OIDA
	VALUES (6691,
	6640,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	6640);
INSERT INTO O_ID
	VALUES (2,
	6640);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (6681,
	'Generate to Creator',
	705,
	'E_GEC',
	'This class represents the generation of a creation event to a target class. This has the effect of creating an instance and then delivering the event to the instance.',
	6616);
INSERT INTO O_TFR
	VALUES (6697,
	6681,
	'dispose',
	'This operation does nothing.',
	19,
	1,
	'// do nothing
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (6698,
	6681,
	'execute',
	'',
	19,
	1,
	'// Event: Generate to Creator.execute()

// Create a pending event for this event
select one evt related by self->E_GSME[R705]->SM_EVT[R707];
create object instance evtInst of I_EVI;
relate evt to evtInst across R2906;

// Mark the pending event as a creation transition
evtInst.isCreation = true;

// Now hook up event data
select one evt_spec_stmt related by self->E_GSME[R705]->
                                                       E_GES[R703]->E_ESS[R701];
valueComputationComplete =
                      evt_spec_stmt.hookUpEventData(evtInst_ID:evtInst.Event_ID,
                                          stack_frame_id: param.stack_frame_id);
if (valueComputationComplete)
  // Find the originating instance for this event and relate this event to it
  evt_spec_stmt.relateToOriginatingInst(evtInst_ID:evtInst.Event_ID,
                                          stack_frame_id: param.stack_frame_id);

  // Set this event as pending for the target instance
  evtInst.fire();
end if;',
	1,
	'',
	6697);
INSERT INTO O_TPARM
	VALUES (6699,
	6698,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (6681,
	6662,
	0,
	6677,
	6675,
	6682,
	6676,
	6700,
	6701,
	0,
	0,
	'',
	'Generate SM Event Statement',
	'Statement_ID',
	'R705');
INSERT INTO O_RATTR
	VALUES (6700,
	6681,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (6700,
	6681,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	6681);
INSERT INTO O_OIDA
	VALUES (6700,
	6681,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	6681);
INSERT INTO O_ID
	VALUES (2,
	6681);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (6679,
	'Generate to Class',
	704,
	'E_GAR',
	'This class represents the generation of an event to a target class.',
	6616);
INSERT INTO O_TFR
	VALUES (6702,
	6679,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.
',
	19,
	1,
	'// do nothing
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (6703,
	6679,
	'execute',
	'',
	19,
	1,
	' // Event: Generate to Class.execute()
                                   
// Create a pending event for this event
select one evt related by self->E_GSME[R705]->SM_EVT[R707];
create object instance evtInst of I_EVI;
relate evt to evtInst across R2906;

// Hook up event data
select one evt_spec_stmt related by self->E_GSME[R705]->E_GES[R703]->E_ESS[R701];
valueComputationComplete =
                      evt_spec_stmt.hookUpEventData(evtInst_ID:evtInst.Event_ID,
                                          stack_frame_id: param.stack_frame_id);
if (valueComputationComplete)
  // Find the originating instance for this event and relate this event to it
  evt_spec_stmt.relateToOriginatingInst(evtInst_ID:evtInst.Event_ID,
                                          stack_frame_id: param.stack_frame_id);

  // Set this event as pending for the target instance
  evtInst.fire();
end if;',
	1,
	'',
	6702);
INSERT INTO O_TPARM
	VALUES (6704,
	6703,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (6679,
	6662,
	0,
	6677,
	6675,
	6680,
	6676,
	6705,
	6706,
	0,
	0,
	'',
	'Generate SM Event Statement',
	'Statement_ID',
	'R705');
INSERT INTO O_RATTR
	VALUES (6705,
	6679,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (6705,
	6679,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	6679);
INSERT INTO O_OIDA
	VALUES (6705,
	6679,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	6679);
INSERT INTO O_ID
	VALUES (2,
	6679);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (6662,
	'Generate SM Event Statement',
	713,
	'E_GSME',
	'This class captures the common data (the event being generated) for a
statement that generates an event to a statechart.',
	6616);
INSERT INTO O_TFR
	VALUES (6707,
	6662,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'select one gen related by self->E_GEN[R705];
if ( not_empty gen )
  unrelate self from gen across R705;
  gen.dispose();
end if;

select one gar related by self->E_GAR[R705];
if ( not_empty gar )
  unrelate self from gar across R705;
  gar.dispose();
end if;

select one gec related by self->E_GEC[R705];
if ( not_empty gec )
  unrelate self from gec across R705;
  gec.dispose();
end if;

select one evt related by self->SM_EVT[R707];
if ( not_empty evt )
  unrelate self from evt across R707;
end if;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (6708,
	6662,
	'execute',
	'',
	19,
	1,
	' // Generate SM Event Statement.execute()
                                   
select one gen related by self->E_GEN[R705];
select one gar related by self->E_GAR[R705];
select one gec related by self->E_GEC[R705];

if (not_empty gen)
  gen.execute(stack_frame_id: param.stack_frame_id);
elif (not_empty gar)
  gar.execute(stack_frame_id: param.stack_frame_id);
elif (not_empty gec)
  gec.execute(stack_frame_id: param.stack_frame_id);
end if;
',
	1,
	'',
	6707);
INSERT INTO O_TPARM
	VALUES (6709,
	6708,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (6662,
	6647,
	0,
	6660,
	6658,
	6663,
	6659,
	6677,
	6710,
	0,
	0,
	'',
	'Generate Event Statement',
	'Statement_ID',
	'R703');
INSERT INTO O_RATTR
	VALUES (6677,
	6662,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (6677,
	6662,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (6662,
	1488,
	0,
	1604,
	6683,
	6684,
	6685,
	6711,
	6712,
	0,
	0,
	'',
	'State Machine Event',
	'SMevt_ID',
	'R707');
INSERT INTO O_RATTR
	VALUES (6711,
	6662,
	1604,
	1488,
	1,
	'SMevt_ID');
INSERT INTO O_ATTR
	VALUES (6711,
	6662,
	6677,
	'SMevt_ID',
	'

',
	'',
	'SMevt_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	6662);
INSERT INTO O_OIDA
	VALUES (6677,
	6662,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	6662);
INSERT INTO O_ID
	VALUES (2,
	6662);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (6687,
	'Generate Preexisting Event',
	702,
	'E_GPR',
	'Generates a preexisting event. The event instance captures the event, its data and its target.',
	6616);
INSERT INTO O_TFR
	VALUES (6713,
	6687,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'// Generate preexisting Event.Dispose()
select one val related by self->V_VAL[R714];
if ( not empty val )
  val.dispose();
end if;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (6714,
	6687,
	'execute',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	6713);
INSERT INTO O_TPARM
	VALUES (6715,
	6714,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (6687,
	686,
	0,
	685,
	2386,
	6716,
	2388,
	6717,
	6718,
	0,
	0,
	'',
	'Statement',
	'Statement_ID',
	'R603');
INSERT INTO O_RATTR
	VALUES (6717,
	6687,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (6717,
	6687,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (6687,
	70,
	0,
	72,
	6686,
	6688,
	6689,
	6719,
	6720,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R714.''generates event held by''');
INSERT INTO O_RATTR
	VALUES (6719,
	6687,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (6719,
	6687,
	6717,
	'Value_ID',
	'',
	'',
	'Value_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	6687);
INSERT INTO O_OIDA
	VALUES (6717,
	6687,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	6687);
INSERT INTO O_ID
	VALUES (2,
	6687);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (6647,
	'Generate Event Statement',
	711,
	'E_GES',
	'This class captures the common data for all statements that generate an event.',
	6616);
INSERT INTO O_TFR
	VALUES (6721,
	6647,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'select one gsme related by self->E_GSME[R703];
if ( not_empty gsme )
  unrelate self from gsme across R703;
  gsme.dispose();
end if;

select one gee related by self->E_GEE[R703];
if ( not_empty gee )
  unrelate self from gee across R703;
  gee.dispose();
end if;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (6722,
	6647,
	'execute',
	'',
	19,
	1,
	'// Generate Event Statement.execute()

select one genSMEv related by self->E_GSME[R703];
select one genGEEv related by self->E_GEE[R703];
if (not_empty genSMEv)
  genSMEv.execute(stack_frame_id: param.stack_frame_id);
elif (not_empty genGEEv)
  select one body related by self->E_ESS[R701]->ACT_SMT[R603]->ACT_BLK[R602]->ACT_ACT[R601];
  pathMsg = "<No Path Available - Empty instance>";
    if (not_empty body)
      pathMsg = body.getPath();
    end if;
	USER::logError(msg:"Generate Event Statement.execute: Executing events to External Entities is not supported at this time.",path:pathMsg);
end if;',
	1,
	'',
	6721);
INSERT INTO O_TPARM
	VALUES (6723,
	6722,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (6647,
	667,
	0,
	668,
	6643,
	6648,
	6644,
	6660,
	6724,
	0,
	0,
	'',
	'Event Specification Statement',
	'Statement_ID',
	'R701');
INSERT INTO O_RATTR
	VALUES (6660,
	6647,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (6660,
	6647,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	6647);
INSERT INTO O_OIDA
	VALUES (6660,
	6647,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	6647);
INSERT INTO O_ID
	VALUES (2,
	6647);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (6626,
	'Generate',
	701,
	'E_GEN',
	'This class represents the generation of an event to a target instance.',
	6616);
INSERT INTO O_TFR
	VALUES (6725,
	6626,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'select one var related by self->V_VAR[R712];
if ( not empty var )
  unrelate self from var across R712;
end if;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (6726,
	6626,
	'execute',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-',
	1,
	'',
	6725);
INSERT INTO O_TPARM
	VALUES (6727,
	6726,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (6626,
	6662,
	0,
	6677,
	6675,
	6678,
	6676,
	6728,
	6729,
	0,
	0,
	'',
	'Generate SM Event Statement',
	'Statement_ID',
	'R705');
INSERT INTO O_RATTR
	VALUES (6728,
	6626,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (6728,
	6626,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (6626,
	129,
	0,
	131,
	6625,
	6627,
	6628,
	6730,
	6731,
	0,
	0,
	'',
	'Variable',
	'Var_ID',
	'R712.''has recipient''');
INSERT INTO O_RATTR
	VALUES (6730,
	6626,
	131,
	129,
	1,
	'Var_ID');
INSERT INTO O_ATTR
	VALUES (6730,
	6626,
	6728,
	'Var_ID',
	'

',
	'',
	'Var_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	6626);
INSERT INTO O_OIDA
	VALUES (6728,
	6626,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	6626);
INSERT INTO O_ID
	VALUES (2,
	6626);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (667,
	'Event Specification Statement',
	709,
	'E_ESS',
	'This class captures the common data of a statement that specifies an
event for either generation or creation.',
	6616);
INSERT INTO O_TFR
	VALUES (6732,
	667,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'select one ces related by self->E_CES[R701];
if ( not empty ces )
  unrelate self from ces across R701;
  ces.dispose();
end if;

select one ges related by self->E_GES[R701];
if ( not empty ges )
  unrelate self from ges across R701;
  ges.dispose();
end if;

select many parm_set related by self->V_PAR[R700];
for each parm in parm_set 
  unrelate self from parm across R700;
  parm.dispose();
end for;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (6733,
	667,
	'execute',
	'',
	19,
	1,
	'//Event Specifiation Statement.execute()

select one genStmt related by self->E_GES[R701];
select one createStmt related by self->E_CES[R701];
if (not_empty genStmt)
  genStmt.execute(stack_frame_id: param.stack_frame_id);
elif (not_empty createStmt)
  createStmt.execute(stack_frame_id: param.stack_frame_id);
end if;',
	1,
	'',
	6732);
INSERT INTO O_TPARM
	VALUES (6734,
	6733,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6735,
	667,
	'relateToOriginatingInst',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	6736);
INSERT INTO O_TPARM
	VALUES (6737,
	6735,
	'evtInst_ID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (6738,
	6735,
	'stack_frame_id',
	296,
	0,
	'',
	6737,
	'');
INSERT INTO O_TFR
	VALUES (6736,
	667,
	'hookUpEventData',
	'',
	316,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return false;',
	1,
	'',
	6733);
INSERT INTO O_TPARM
	VALUES (6739,
	6736,
	'evtInst_ID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (6740,
	6736,
	'stack_frame_id',
	296,
	0,
	'',
	6739,
	'');
INSERT INTO O_REF
	VALUES (667,
	686,
	0,
	685,
	2386,
	6741,
	2388,
	668,
	6742,
	0,
	0,
	'',
	'Statement',
	'Statement_ID',
	'R603');
INSERT INTO O_RATTR
	VALUES (668,
	667,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (668,
	667,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (6743,
	667);
INSERT INTO O_BATTR
	VALUES (6743,
	667);
INSERT INTO O_ATTR
	VALUES (6743,
	667,
	668,
	'ParmListOK',
	'This attribute is true if there were no errors in parsing the event''s parameter list.
--------------------------------------------------------------------------------
Bridge:ALS',
	'',
	'ParmListOK',
	0,
	316,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (6744,
	667);
INSERT INTO O_BATTR
	VALUES (6744,
	667);
INSERT INTO O_ATTR
	VALUES (6744,
	667,
	6743,
	'PEIndicated',
	'This attribute is true if there was a ''*'' in the event label, indicating that this is a polymorphic event.
--------------------------------------------------------------------------------
Bridge:ALS',
	'',
	'PEIndicated',
	0,
	316,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (6745,
	667);
INSERT INTO O_BATTR
	VALUES (6745,
	667);
INSERT INTO O_ATTR
	VALUES (6745,
	667,
	6744,
	'eventDerivedLabelLineNumber',
	'',
	'',
	'eventDerivedLabelLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (6746,
	667);
INSERT INTO O_BATTR
	VALUES (6746,
	667);
INSERT INTO O_ATTR
	VALUES (6746,
	667,
	6745,
	'eventDerivedLabelColumn',
	'',
	'',
	'eventDerivedLabelColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (6747,
	667);
INSERT INTO O_BATTR
	VALUES (6747,
	667);
INSERT INTO O_ATTR
	VALUES (6747,
	667,
	6746,
	'eventMeaningLineNumber',
	'',
	'',
	'eventMeaningLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (6748,
	667);
INSERT INTO O_BATTR
	VALUES (6748,
	667);
INSERT INTO O_ATTR
	VALUES (6748,
	667,
	6747,
	'eventMeaningColumn',
	'',
	'',
	'eventMeaningColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (6749,
	667);
INSERT INTO O_BATTR
	VALUES (6749,
	667);
INSERT INTO O_ATTR
	VALUES (6749,
	667,
	6748,
	'eventTargetKeyLettersLineNumber',
	'',
	'',
	'eventTargetKeyLettersLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (6750,
	667);
INSERT INTO O_BATTR
	VALUES (6750,
	667);
INSERT INTO O_ATTR
	VALUES (6750,
	667,
	6749,
	'eventTargetKeyLettersColumn',
	'',
	'',
	'eventTargetKeyLettersColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (6751,
	667);
INSERT INTO O_BATTR
	VALUES (6751,
	667);
INSERT INTO O_ATTR
	VALUES (6751,
	667,
	6750,
	'firstEventDataItemNameLineNumber',
	'',
	'',
	'firstEventDataItemNameLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (6752,
	667);
INSERT INTO O_BATTR
	VALUES (6752,
	667);
INSERT INTO O_ATTR
	VALUES (6752,
	667,
	6751,
	'firstEventDataItemNameColumn',
	'',
	'',
	'firstEventDataItemNameColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (6753,
	667);
INSERT INTO O_BATTR
	VALUES (6753,
	667);
INSERT INTO O_ATTR
	VALUES (6753,
	667,
	6752,
	'currentLaterEventDataItemNameLineNumber',
	'',
	'',
	'currentLaterEventDataItemNameLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (6754,
	667);
INSERT INTO O_BATTR
	VALUES (6754,
	667);
INSERT INTO O_ATTR
	VALUES (6754,
	667,
	6753,
	'currentLaterEventDataItemNameColumn',
	'',
	'',
	'currentLaterEventDataItemNameColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	667);
INSERT INTO O_OIDA
	VALUES (668,
	667,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	667);
INSERT INTO O_ID
	VALUES (2,
	667);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (6656,
	'Create SM Event Statement',
	712,
	'E_CSME',
	'This class captures the common data (the event being created) for a
statement that creates an instance of an event to a statechart.',
	6616);
INSERT INTO O_TFR
	VALUES (6755,
	6656,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.
',
	19,
	1,
	'select one cei related by self->E_CEI[R704];
if ( not_empty cei )
  unrelate self from cei across R704;
  cei.dispose();
end if;

select one cea related by self->E_CEA[R704];
if ( not_empty cea )
  unrelate self from cea across R704;
  cea.dispose();
end if;

select one cec related by self->E_CEC[R704];
if ( not_empty cec )
  unrelate self from cec across R704;
  cec.dispose();
end if;

select one evt related by self->SM_EVT[R706];
if ( not_empty evt )
  unrelate self from evt across R706;
end if;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (6756,
	6656,
	'execute',
	'',
	19,
	1,
	'//Create SM Event Statement.execute()

select one createInstEvt related by self->E_CEI[R704];
select one createClassEvt related by self->E_CEA[R704];
select one createCreatorEvt related by self->E_CEC[R704];

if (not_empty createInstEvt)
  createInstEvt.execute(stack_frame_id:param.stack_frame_id);
elif (not_empty createClassEvt)
  createClassEvt.execute(stack_frame_id:param.stack_frame_id);
elif (not_empty createCreatorEvt)
  createCreatorEvt.execute(stack_frame_id:param.stack_frame_id);
end if;',
	1,
	'',
	6755);
INSERT INTO O_TPARM
	VALUES (6757,
	6756,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (6656,
	6645,
	0,
	6654,
	6652,
	6657,
	6653,
	6669,
	6758,
	0,
	0,
	'',
	'Create Event Statement',
	'Statement_ID',
	'R702');
INSERT INTO O_RATTR
	VALUES (6669,
	6656,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (6669,
	6656,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (6656,
	1488,
	0,
	1604,
	6664,
	6665,
	6666,
	6759,
	6760,
	0,
	0,
	'',
	'State Machine Event',
	'SMevt_ID',
	'R706');
INSERT INTO O_RATTR
	VALUES (6759,
	6656,
	1604,
	1488,
	1,
	'SMevt_ID');
INSERT INTO O_ATTR
	VALUES (6759,
	6656,
	6669,
	'SMevt_ID',
	'

',
	'',
	'SMevt_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	6656);
INSERT INTO O_OIDA
	VALUES (6669,
	6656,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	6656);
INSERT INTO O_ID
	VALUES (2,
	6656);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (6630,
	'Create Event to Instance',
	700,
	'E_CEI',
	'This class represents the precreation of an event to an instance for later delivery. Uses the same concepts as Generate but does not actually generate the event. It instead yields an event instance that can be generated later using Generate Preexisting Event.',
	6616);
INSERT INTO O_TFR
	VALUES (6761,
	6630,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'select one var related by self->V_VAR[R711];
if ( not empty var )
  unrelate self from var across R711;
end if;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (6762,
	6630,
	'execute',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	6761);
INSERT INTO O_TPARM
	VALUES (6763,
	6762,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (6630,
	6656,
	0,
	6669,
	6667,
	6670,
	6668,
	6764,
	6765,
	0,
	0,
	'',
	'Create SM Event Statement',
	'Statement_ID',
	'R704');
INSERT INTO O_RATTR
	VALUES (6764,
	6630,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (6764,
	6630,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (6630,
	129,
	0,
	131,
	6629,
	6631,
	6632,
	6766,
	6767,
	0,
	0,
	'',
	'Variable',
	'Var_ID',
	'R711.''has recipient''');
INSERT INTO O_RATTR
	VALUES (6766,
	6630,
	131,
	129,
	1,
	'Var_ID');
INSERT INTO O_ATTR
	VALUES (6766,
	6630,
	6764,
	'Var_ID',
	'

',
	'',
	'Var_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	6630);
INSERT INTO O_OIDA
	VALUES (6764,
	6630,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	6630);
INSERT INTO O_ID
	VALUES (2,
	6630);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (6634,
	'Create Event to External Entity',
	706,
	'E_CEE',
	'This class specifies the precreation of an event to an external entity for later delivery. Uses the same concepts as Generate to External Entity but does not actually generate the event. It instead yields an event instance that can be generated later using Generate Preexisting Event.',
	6616);
INSERT INTO O_TFR
	VALUES (6768,
	6634,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'select one evt related by self->S_EEEVT[R708];
if ( not empty evt )
  unrelate self from evt across R708;
end if;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (6634,
	6645,
	0,
	6654,
	6652,
	6655,
	6653,
	6769,
	6770,
	0,
	0,
	'',
	'Create Event Statement',
	'Statement_ID',
	'R702');
INSERT INTO O_RATTR
	VALUES (6769,
	6634,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (6769,
	6634,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (6634,
	6622,
	0,
	6637,
	6633,
	6635,
	6636,
	6771,
	6772,
	0,
	0,
	'',
	'External Entity Event',
	'EEevt_ID',
	'R708');
INSERT INTO O_RATTR
	VALUES (6771,
	6634,
	6637,
	6622,
	1,
	'EEevt_ID');
INSERT INTO O_ATTR
	VALUES (6771,
	6634,
	6773,
	'EEevt_ID',
	'

',
	'',
	'EEevt_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (6634,
	6622,
	0,
	6638,
	6633,
	6635,
	6636,
	6773,
	6774,
	0,
	0,
	'',
	'External Entity Event',
	'EE_ID',
	'R708');
INSERT INTO O_RATTR
	VALUES (6773,
	6634,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (6773,
	6634,
	6769,
	'EE_ID',
	'

',
	'',
	'EE_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	6634);
INSERT INTO O_OIDA
	VALUES (6769,
	6634,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	6634);
INSERT INTO O_ID
	VALUES (2,
	6634);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (6673,
	'Create Event to Creator',
	708,
	'E_CEC',
	'This class specifies the precreation of a creation event to a class for later delivery. Uses the same concepts as Generate to Creator but does not actually generate the event. It instead yields an event instance that can be generated later using Generate Preexisting Event.',
	6616);
INSERT INTO O_TFR
	VALUES (6775,
	6673,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'// do nothing
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (6776,
	6673,
	'execute',
	'',
	19,
	1,
	'// Event: Create Event to Creator.execute()

// Create a pending event for this event
select one evt related by self->E_CSME[R704]->SM_EVT[R706];
create object instance evtInst of I_EVI;
relate evt to evtInst across R2906;

// The instance for this creation transition will be created when the event
// is generated.  So mark this pending event as a creation transition.
evtInst.isCreation = true;

// Hook up event data
select one evt_spec_stmt related by self->E_CSME[R704]->
                                                       E_CES[R702]->E_ESS[R701];
valueComputationComplete =
                      evt_spec_stmt.hookUpEventData(evtInst_ID:evtInst.Event_ID,
                                          stack_frame_id: param.stack_frame_id);
if (valueComputationComplete)
  // Hook up the event instance to the result instance handle
  select one createEvtStmt related by self->E_CSME[R704]->E_CES[R702];
  createEvtStmt.hookUpEvtInstToHandle(evtInst_ID:evtInst.Event_ID,
                                          stack_frame_id: param.stack_frame_id);

  // Find the originating instance for this event and relate this event to it
  evt_spec_stmt.relateToOriginatingInst(evtInst_ID:evtInst.Event_ID,
                                          stack_frame_id: param.stack_frame_id);
end if;',
	1,
	'',
	6775);
INSERT INTO O_TPARM
	VALUES (6777,
	6776,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (6673,
	6656,
	0,
	6669,
	6667,
	6674,
	6668,
	6778,
	6779,
	0,
	0,
	'',
	'Create SM Event Statement',
	'Statement_ID',
	'R704');
INSERT INTO O_RATTR
	VALUES (6778,
	6673,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (6778,
	6673,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	6673);
INSERT INTO O_OIDA
	VALUES (6778,
	6673,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	6673);
INSERT INTO O_ID
	VALUES (2,
	6673);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (6671,
	'Create Event to Class',
	703,
	'E_CEA',
	'This class represents the precreation of an event to a class for later delivery. Uses the same concepts as Generate to Class but does not actually generate the event. It instead yields an event instance that can be generated later using Generate Preexisting Event.',
	6616);
INSERT INTO O_TFR
	VALUES (6780,
	6671,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'// do nothing
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (6781,
	6671,
	'execute',
	'',
	19,
	1,
	'//Event: Create Event to Class.execute()

// Create a pending event for this event
select one evt related by self->E_CSME[R704]->SM_EVT[R706];
create object instance evtInst of I_EVI;
relate evt to evtInst across R2906;

// Hook up event data
select one evt_spec_stmt related by self->E_CSME[R704]->E_CES[R702]->E_ESS[R701];
valueComputationComplete =
                      evt_spec_stmt.hookUpEventData(evtInst_ID:evtInst.Event_ID,
                                           stack_frame_id:param.stack_frame_id);
if (valueComputationComplete)
  // Hook up the event instance to the result instance handle
  select one createEvtStmt related by self->E_CSME[R704]->E_CES[R702];
  createEvtStmt.hookUpEvtInstToHandle(evtInst_ID:evtInst.Event_ID,
                                          stack_frame_id: param.stack_frame_id);

  // Find the originating instance for this event and relate this event to it
  evt_spec_stmt.relateToOriginatingInst(evtInst_ID:evtInst.Event_ID,
                                          stack_frame_id: param.stack_frame_id);
end if;',
	1,
	'',
	6780);
INSERT INTO O_TPARM
	VALUES (6782,
	6781,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (6671,
	6656,
	0,
	6669,
	6667,
	6672,
	6668,
	6783,
	6784,
	0,
	0,
	'',
	'Create SM Event Statement',
	'Statement_ID',
	'R704');
INSERT INTO O_RATTR
	VALUES (6783,
	6671,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (6783,
	6671,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	6671);
INSERT INTO O_OIDA
	VALUES (6783,
	6671,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	6671);
INSERT INTO O_ID
	VALUES (2,
	6671);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (6645,
	'Create Event Statement',
	710,
	'E_CES',
	'This class captures the data for a statement that creates an instance
of an event.',
	6616);
INSERT INTO O_TFR
	VALUES (6785,
	6645,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'select one csme related by self->E_CSME[R702];
if ( not_empty csme )
  unrelate self from csme across R702;
  csme.dispose();
end if;

select one cee related by self->E_CEE[R702];
if ( not_empty cee )
  unrelate self from cee across R702;
  cee.dispose();
end if;

select one var related by self->V_VAR[R710];
if ( not_empty var )
  unrelate self from var across R710;
end if;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (6786,
	6645,
	'execute',
	'',
	19,
	1,
	'//Create Event Statement.execute()

select one createSMEvt related by self->E_CSME[R702];
select one createEEEvt related by self->E_CEE[R702];

if (not_empty createSMEvt)
  createSMEvt.execute(stack_frame_id:param.stack_frame_id);
elif (not_empty createEEEvt)
  select one body related by self->V_VAR[R710]->ACT_BLK[R823]->ACT_ACT[R601];
  pathMsg = "<No Path Available - Empty instance>";
    if (not_empty body)
      pathMsg = body.getPath();
    end if;
	USER::logError(msg:"Create Event Statement.execute: Executing events to External Entities is not supported at this time.",path:pathMsg);
end if;',
	1,
	'',
	6785);
INSERT INTO O_TPARM
	VALUES (6787,
	6786,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6788,
	6645,
	'hookUpEvtInstToHandle',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	6786);
INSERT INTO O_TPARM
	VALUES (6789,
	6788,
	'evtInst_ID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (6790,
	6788,
	'stack_frame_id',
	296,
	0,
	'',
	6789,
	'');
INSERT INTO O_REF
	VALUES (6645,
	667,
	0,
	668,
	6643,
	6646,
	6644,
	6654,
	6791,
	0,
	0,
	'',
	'Event Specification Statement',
	'Statement_ID',
	'R701');
INSERT INTO O_RATTR
	VALUES (6654,
	6645,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (6654,
	6645,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (6792,
	6645);
INSERT INTO O_BATTR
	VALUES (6792,
	6645);
INSERT INTO O_ATTR
	VALUES (6792,
	6645,
	6654,
	'is_implicit',
	'This attribute is true if the statement needs to implicitly declare the variable
that the result of this statement will be assigned to.


',
	'',
	'is_implicit',
	0,
	316,
	'',
	'');
INSERT INTO O_REF
	VALUES (6645,
	129,
	0,
	131,
	6649,
	6650,
	6651,
	6793,
	6794,
	0,
	0,
	'',
	'Variable',
	'Var_ID',
	'R710.''result''');
INSERT INTO O_RATTR
	VALUES (6793,
	6645,
	131,
	129,
	1,
	'Var_ID');
INSERT INTO O_ATTR
	VALUES (6793,
	6645,
	6792,
	'Var_ID',
	'

',
	'',
	'Var_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	6645);
INSERT INTO O_OIDA
	VALUES (6654,
	6645,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	6645);
INSERT INTO O_ID
	VALUES (2,
	6645);
-- BP 7.1 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (6795,
	'Element Packaging',
	'',
	'EP',
	1400,
	1,
	0);
INSERT INTO S_SID
	VALUES (1,
	6795);
INSERT INTO O_IOBJ
	VALUES (6796,
	705,
	0,
	6795,
	'System Model',
	'S_SYS');
INSERT INTO O_IOBJ
	VALUES (6797,
	6798,
	0,
	6795,
	'Activity',
	'A_A');
INSERT INTO O_IOBJ
	VALUES (6799,
	6800,
	0,
	6795,
	'Communication',
	'COMM_COMM');
INSERT INTO O_IOBJ
	VALUES (6801,
	707,
	0,
	6795,
	'Component Package',
	'CP_CP');
INSERT INTO O_IOBJ
	VALUES (6802,
	936,
	0,
	6795,
	'Data Type Package',
	'S_DPK');
INSERT INTO O_IOBJ
	VALUES (6803,
	3435,
	0,
	6795,
	'Interface Package',
	'IP_IP');
INSERT INTO O_IOBJ
	VALUES (6804,
	2144,
	0,
	6795,
	'Sequence',
	'SQ_S');
INSERT INTO O_IOBJ
	VALUES (6805,
	713,
	0,
	6795,
	'Use Case Diagram',
	'UC_UCC');
INSERT INTO R_SUBSUP
	VALUES (854);
INSERT INTO R_REL
	VALUES (854,
	1402,
	'Optional:true
',
	6795);
INSERT INTO R_SUPER
	VALUES (773,
	854,
	856);
INSERT INTO O_RTIDA
	VALUES (772,
	773,
	0,
	854,
	856);
INSERT INTO R_RTO
	VALUES (773,
	854,
	856,
	0);
INSERT INTO R_OIR
	VALUES (773,
	854,
	856,
	0);
INSERT INTO R_SUB
	VALUES (6798,
	854,
	6806);
INSERT INTO R_RGO
	VALUES (6798,
	854,
	6806);
INSERT INTO R_OIR
	VALUES (6798,
	854,
	6806,
	6797);
INSERT INTO R_SUB
	VALUES (6800,
	854,
	6807);
INSERT INTO R_RGO
	VALUES (6800,
	854,
	6807);
INSERT INTO R_OIR
	VALUES (6800,
	854,
	6807,
	6799);
INSERT INTO R_SUB
	VALUES (707,
	854,
	6808);
INSERT INTO R_RGO
	VALUES (707,
	854,
	6808);
INSERT INTO R_OIR
	VALUES (707,
	854,
	6808,
	6801);
INSERT INTO R_SUB
	VALUES (936,
	854,
	6809);
INSERT INTO R_RGO
	VALUES (936,
	854,
	6809);
INSERT INTO R_OIR
	VALUES (936,
	854,
	6809,
	6802);
INSERT INTO R_SUB
	VALUES (3435,
	854,
	3509);
INSERT INTO R_RGO
	VALUES (3435,
	854,
	3509);
INSERT INTO R_OIR
	VALUES (3435,
	854,
	3509,
	6803);
INSERT INTO R_SUB
	VALUES (713,
	854,
	855);
INSERT INTO R_RGO
	VALUES (713,
	854,
	855);
INSERT INTO R_OIR
	VALUES (713,
	854,
	855,
	6805);
INSERT INTO R_SUB
	VALUES (2144,
	854,
	2306);
INSERT INTO R_RGO
	VALUES (2144,
	854,
	2306);
INSERT INTO R_OIR
	VALUES (2144,
	854,
	2306,
	6804);
INSERT INTO R_SIMP
	VALUES (6810);
INSERT INTO R_REL
	VALUES (6810,
	1401,
	'',
	6795);
INSERT INTO R_PART
	VALUES (705,
	6810,
	6811,
	0,
	1,
	'directly contained under');
INSERT INTO O_RTIDA
	VALUES (754,
	705,
	0,
	6810,
	6811);
INSERT INTO R_RTO
	VALUES (705,
	6810,
	6811,
	0);
INSERT INTO R_OIR
	VALUES (705,
	6810,
	6811,
	6796);
INSERT INTO R_FORM
	VALUES (2798,
	6810,
	6812,
	1,
	1,
	'contains');
INSERT INTO R_RGO
	VALUES (2798,
	6810,
	6812);
INSERT INTO R_OIR
	VALUES (2798,
	6810,
	6812,
	0);
INSERT INTO R_SIMP
	VALUES (6813);
INSERT INTO R_REL
	VALUES (6813,
	1400,
	'',
	6795);
INSERT INTO R_FORM
	VALUES (773,
	6813,
	6814,
	1,
	1,
	'contains');
INSERT INTO R_RGO
	VALUES (773,
	6813,
	6814);
INSERT INTO R_OIR
	VALUES (773,
	6813,
	6814,
	0);
INSERT INTO R_PART
	VALUES (2798,
	6813,
	6815,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (2825,
	2798,
	0,
	6813,
	6815);
INSERT INTO R_RTO
	VALUES (2798,
	6813,
	6815,
	0);
INSERT INTO R_OIR
	VALUES (2798,
	6813,
	6815,
	0);
INSERT INTO R_SIMP
	VALUES (6816);
INSERT INTO R_REL
	VALUES (6816,
	1403,
	'',
	6795);
INSERT INTO R_PART
	VALUES (2798,
	6816,
	6817,
	0,
	0,
	'contained within');
INSERT INTO O_RTIDA
	VALUES (2825,
	2798,
	0,
	6816,
	6817);
INSERT INTO R_RTO
	VALUES (2798,
	6816,
	6817,
	0);
INSERT INTO R_OIR
	VALUES (2798,
	6816,
	6817,
	0);
INSERT INTO R_FORM
	VALUES (6818,
	6816,
	6819,
	1,
	1,
	'contains');
INSERT INTO R_RGO
	VALUES (6818,
	6816,
	6819);
INSERT INTO R_OIR
	VALUES (6818,
	6816,
	6819,
	0);
INSERT INTO R_SIMP
	VALUES (6820);
INSERT INTO R_REL
	VALUES (6820,
	1404,
	'',
	6795);
INSERT INTO R_FORM
	VALUES (6818,
	6820,
	6821,
	0,
	1,
	'linked to parent through');
INSERT INTO R_RGO
	VALUES (6818,
	6820,
	6821);
INSERT INTO R_OIR
	VALUES (6818,
	6820,
	6821,
	0);
INSERT INTO R_PART
	VALUES (2798,
	6820,
	6822,
	0,
	0,
	'links to parent of');
INSERT INTO O_RTIDA
	VALUES (2825,
	2798,
	0,
	6820,
	6822);
INSERT INTO R_RTO
	VALUES (2798,
	6820,
	6822,
	0);
INSERT INTO R_OIR
	VALUES (2798,
	6820,
	6822,
	0);
INSERT INTO R_SIMP
	VALUES (6823);
INSERT INTO R_REL
	VALUES (6823,
	1405,
	'CrossComponent:true',
	6795);
INSERT INTO R_PART
	VALUES (705,
	6823,
	6824,
	0,
	0,
	'');
INSERT INTO O_RTIDA
	VALUES (754,
	705,
	0,
	6823,
	6824);
INSERT INTO R_RTO
	VALUES (705,
	6823,
	6824,
	0);
INSERT INTO R_OIR
	VALUES (705,
	6823,
	6824,
	6796);
INSERT INTO R_FORM
	VALUES (2798,
	6823,
	6825,
	1,
	1,
	'contains');
INSERT INTO R_RGO
	VALUES (2798,
	6823,
	6825);
INSERT INTO R_OIR
	VALUES (2798,
	6823,
	6825,
	0);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (773,
	'Specification Package',
	1401,
	'EP_SPKG',
	'',
	6795);
INSERT INTO O_TFR
	VALUES (6826,
	773,
	'dispose',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one activity related by self->A_A[R1402];
select one communication related by self->COMM_COMM[R1402];
select one componentPkg related by self->CP_CP[R1402];
select one dtPkg related by self->S_DPK[R1402];
select one interfacePkg related by self->IP_IP[R1402];
select one sequence related by self->SQ_S[R1402];
select one useCase related by self->UC_UCC[R1402];
if(not_empty activity)
  unrelate self from activity across R1402;
  activity.dispose();
elif(not_empty communication)
  unrelate self from communication across R1402;
  communication.dispose();
elif(not_empty componentPkg)
  unrelate self from componentPkg across R1402;
  componentPkg.dispose();
elif(not_empty dtPkg)
  // When datatypes in DT pkgs are disposed, they may need to use R1402.
  // Therefore, we have to call dispose() before unrelating across R1402.
  dtPkg.dispose();
  unrelate self from dtPkg across R1402;
elif(not_empty interfacePkg)
  unrelate self from interfacePkg across R1402;
  interfacePkg.dispose();
elif(not_empty sequence)
  unrelate self from sequence across R1402;
  sequence.dispose();
elif(not_empty useCase)
  unrelate self from useCase across R1402;
  useCase.dispose();
end if;
select one containerPackage related by self->EP_PKG[R1400];
if(not_empty containerPackage)
  unrelate self from containerPackage across R1400;
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_NBATTR
	VALUES (772,
	773);
INSERT INTO O_BATTR
	VALUES (772,
	773);
INSERT INTO O_ATTR
	VALUES (772,
	773,
	0,
	'Package_ID',
	'',
	'',
	'Package_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_REF
	VALUES (773,
	2798,
	0,
	2825,
	6813,
	6814,
	6815,
	6827,
	6828,
	0,
	0,
	'',
	'Package',
	'Package_ID',
	'R1400');
INSERT INTO O_RATTR
	VALUES (6827,
	773,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (6827,
	773,
	772,
	'Container_Package_ID',
	'',
	'Container_',
	'Package_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	773);
INSERT INTO O_OIDA
	VALUES (772,
	773,
	0,
	'Package_ID');
INSERT INTO O_ID
	VALUES (1,
	773);
INSERT INTO O_ID
	VALUES (2,
	773);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (6818,
	'Package In Package',
	1402,
	'EP_PIP',
	'',
	6795);
INSERT INTO O_REF
	VALUES (6818,
	2798,
	0,
	2825,
	6816,
	6819,
	6817,
	6829,
	6830,
	0,
	0,
	'',
	'Package',
	'Package_ID',
	'R1403');
INSERT INTO O_RATTR
	VALUES (6829,
	6818,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (6829,
	6818,
	0,
	'Parent_Package_ID',
	'',
	'Parent_',
	'Package_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (6818,
	2798,
	0,
	2825,
	6820,
	6821,
	6822,
	6831,
	6832,
	0,
	0,
	'',
	'Package',
	'Package_ID',
	'R1404');
INSERT INTO O_RATTR
	VALUES (6831,
	6818,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (6831,
	6818,
	6829,
	'Child_Package_ID',
	'',
	'Child_',
	'Package_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	6818);
INSERT INTO O_OIDA
	VALUES (6829,
	6818,
	0,
	'Parent_Package_ID');
INSERT INTO O_OIDA
	VALUES (6831,
	6818,
	0,
	'Child_Package_ID');
INSERT INTO O_ID
	VALUES (1,
	6818);
INSERT INTO O_ID
	VALUES (2,
	6818);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2798,
	'Package',
	1400,
	'EP_PKG',
	'',
	6795);
INSERT INTO O_TFR
	VALUES (6833,
	2798,
	'dispose',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one system related by self->S_SYS[R1401];
if(not_empty system)
  unrelate self from system across R1401;
end if;
select many specPkgs related by self->EP_SPKG[R1400];
for each specPkg in specPkgs
  // A Specification Package can contain a datatype package.  When datatypes
  // are disposed, they may need to use R1400.  Therefore, we have to call
  // dispose() before unrelating across R1400.
  specPkg.dispose();
  unrelate self from specPkg across R1400;
end for;
select many pps related by self->SQ_PP[R956];
for each pp in pps
  pp.unformalize();
end for;
select many pips related by self->EP_PIP[R1403];
for each pip in pips
  select one childPackage related by pip->EP_PKG[R1404];
  unrelate self from pip across R1403;
  childPackage.dispose();
end for;
select one pip related by self->EP_PIP[R1404];
if(not_empty pip)
  unrelate self from pip across R1404;
  select one parent related by pip->EP_PKG[R1403];
  if(not_empty parent)
    unrelate pip from parent across R1403;
  end if;
  delete object instance pip;
end if;
self.clearScope();
// dispose Packagable Elements
select many pes related by self ->PE_PE[R8000];
for each pe in pes
  // let the PE_PE.dispose() tear down
  // this association so that S_DT.dispose()
  // can properly find a system for type
  // migration
  pe.dispose();
end for;
// note that the following must be after the
// call to dispose the PE_PE instances, otherwise
// data type migration will not work
select one system related by self->S_SYS[R1405];
if(not_empty system)
  unrelate self from system across R1405;
end if;
// dispose Packagable Element
select one pkgElement related by self ->PE_PE[R8001];
if not_empty  pkgElement 
  unrelate self from pkgElement across R8001;
  pkgElement.dispose();
end if;

select many elemVis related by self->PE_VIS[R8002];
for each elemV in elemVis
  select one pe related by elemV->PE_PE[R8002];
  unrelate self from pe across R8002 using elemV;
  delete object instance elemV;
end for;
select many elemRSs related by self->PE_SRS[R8005];
for each elemRS in elemRSs
  elemRS.dispose();
end for;
select one compInst related by self->I_EXE[R2970];
if not_empty compInst
  unrelate self from compInst across R2970;
  compInst.dispose();
end if;


delete object instance self;
',
	1,
	'',
	6834);
INSERT INTO O_TFR
	VALUES (6835,
	2798,
	'getPath',
	'',
	322,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// return a path from this element to the root (system)
path = self.Name;
if(param.path != "")
  path = path + "::" + param.path;
end if;
select one system related by self->S_SYS[R1401];
if(not_empty system)
  return system.Name + "::" + path;
else
  select one parentPkg related by self->EP_PIP[R1404]->EP_PKG[R1403];
  if(not_empty parentPkg)
    return parentPkg.getPath(path:path);
  else
    select one parentPkg related by self->PE_PE[R8001]->EP_PKG[R8000];
    if(not_empty parentPkg)
      return parentPkg.getPath(path:path);
    else
      // check for a component as parent
      select one component related by self->PE_PE[R8001]->C_C[R8003];
      if(not_empty component)
        return component.getPath(path:path, includeSelf:true);
      end if;
    end if;
  end if;
end if;
return "";',
	1,
	'',
	6833);
INSERT INTO O_TPARM
	VALUES (6836,
	6835,
	'path',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6837,
	2798,
	'initialize',
	'',
	19,
	1,
	'name = ::getUniqueInitialName( 
    instance: self.convertToInstance(), 
    candidateName: "Unnamed Package" );
success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:true);    
if ( success!="") 
 self.Name=success;
else 
 self.dispose();
end if;    ',
	1,
	'',
	6838);
INSERT INTO O_TFR
	VALUES (6839,
	2798,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'return this;',
	0,
	'',
	6840);
INSERT INTO O_TFR
	VALUES (6841,
	2798,
	'get_style',
	'',
	784,
	1,
	'return Style::Folder;',
	1,
	'',
	6842);
INSERT INTO O_TFR
	VALUES (6842,
	2798,
	'get_entries',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	6843);
INSERT INTO O_TPARM
	VALUES (6844,
	6842,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6843,
	2798,
	'get_compartments',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	6845);
INSERT INTO O_TFR
	VALUES (6845,
	2798,
	'get_compartment_text',
	'',
	322,
	1,
	'result = "";
if (param.at == Justification::Center_in_X)
  result = "package";
elif (param.at == Justification::Center)
  result = self.Name;
  select one pe related by self->PE_PE[R8001];
  if not_empty pe
    result = pe.getVisibilityAdornment() + result;
  end if;
end if;
return result;',
	1,
	'',
	6846);
INSERT INTO O_TPARM
	VALUES (6847,
	6845,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (6848,
	6845,
	'ent_num',
	298,
	0,
	'',
	6849,
	'');
INSERT INTO O_TPARM
	VALUES (6849,
	6845,
	'comp_num',
	298,
	0,
	'',
	6847,
	'');
INSERT INTO O_TFR
	VALUES (6838,
	2798,
	'get_text_style',
	'',
	784,
	1,
	'return Style::None;',
	1,
	'',
	6841);
INSERT INTO O_TPARM
	VALUES (6850,
	6838,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (6851,
	6838,
	'ent_num',
	298,
	0,
	'',
	6852,
	'');
INSERT INTO O_TPARM
	VALUES (6852,
	6838,
	'comp_num',
	298,
	0,
	'',
	6850,
	'');
INSERT INTO O_TFR
	VALUES (6853,
	2798,
	'actionFilter',
	'',
	316,
	1,
	'result = false;
if(param.name == "can")
  if(param.value == "launchVerifier")
    // check that all components rooted under this package
    // can be verified
    return self.ownsExecutableElementsOrChildOwnsExecutableElements();
  end if;
  if param.value == "make public"
    select one pe related by self->PE_PE[R8001];
    if not_empty pe 
      return pe.Visibility != Visibility::Public;
    end if;
  elif param.value == "make protected"
    select one pe related by self->PE_PE[R8001];
    if not_empty pe 
      return pe.Visibility != Visibility::Protected;
    end if;
  elif param.value == "make private"
    select one pe related by self->PE_PE[R8001];
    if not_empty pe 
      return pe.Visibility != Visibility::Private;
    end if;
  end if;
elif (param.name == "has")
  if (param.value == "realized components")
    return self.hasRealizedComponents();
  end if;
end if;
return result;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (6854,
	6853,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (6855,
	6853,
	'value',
	322,
	0,
	'',
	6854,
	'');
INSERT INTO O_TFR
	VALUES (6846,
	2798,
	'getSystemId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one system related by self->S_SYS[R1401];
if(not_empty system)
  return system.Sys_ID;
else
  select one system related by self->S_SYS[R1405];
  if not_empty system
    return system.Sys_ID;
  end if;
end if;
select one parent related by self->EP_PIP[R1404]->EP_PKG[R1403];
while(not_empty parent)
  select one system related by parent->S_SYS[R1401];
  select one parent related by parent->EP_PIP[R1404]->EP_PKG[R1403];
end while;
if(not_empty system)
  return system.Sys_ID;
end if;
return GD::NULL_UNIQUE_ID();',
	1,
	'',
	6835);
INSERT INTO O_TFR
	VALUES (6856,
	2798,
	'newPackage',
	'',
	19,
	1,
	'// Package::newPackage()
create object instance package of EP_PKG;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate package to pe across R8001;
select one system related by self->S_SYS[R1405];
relate package to system across R1405;
relate self to pe across R8000;
package.initialize();
pe.type = ElementTypeConstants::PACKAGE;
pe.initialize();
',
	1,
	'',
	6857);
INSERT INTO O_TFR
	VALUES (6858,
	2798,
	'associateWithSystem',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one system related by self->S_SYS[R1405];
if(not_empty system and system.Sys_ID != param.sysID)
  // different system
  unrelate self from system across R1405;
  select one rootSys related by self->S_SYS[R1401];
  if (not_empty rootSys)
    unrelate self from system across R1401;
  end if;  
end if;
// first associate all component packages and their
// children with the system pasted into
select many componentPackages related by self->EP_SPKG[R1400]->CP_CP[R1402];
for each componentPackage in componentPackages
  componentPackage.associatePackageWithSystem(sysID:param.sysID);
end for;
// now do the same for every interface package
select many interfacePackages related by self->EP_SPKG[R1400]->IP_IP[R1402];
for each interfacePackage in interfacePackages
  interfacePackage.associatePackageWithSystem(sysID:param.sysID);
end for;
// the same for nested packages
select many pips related by self->EP_PIP[R1403]->EP_PKG[R1404];
for each pip in pips
  pip.associateWithSystem(sysID:param.sysID);
end for;
//
select any system from instances of S_SYS where (selected.Sys_ID == param.sysID);
if(not_empty system)
  select many packages related by self->PE_PE[R8000]->EP_PKG[R8001];
  for each package in packages
    relate package to system across R1405;
    package.associateWithSystem(sysID:param.sysID);
  end for;
  select many components related by self->PE_PE[R8000]->C_C[R8001];
  for each component in components
    component.associatePackagesWithSystem(id:param.sysID);
  end for;
end if;//

// and the same for data type packages
select many dtPackages related by self->EP_SPKG[R1400]->S_DPK[R1402];
for each dtPackage in dtPackages
  // must associate all dts with the system
  dtPackage.associateDTSWithSystem(sys_id:param.sysID);
  // must associate all constant specs with the system
  dtPackage.associateCSPsWithSystem(sys_id:param.sysID);
  // before removing any core dts from this package
  // we must resolve any user dts to new core types
  dtPackage.handleUserDataTypeResolution();
end for;',
	1,
	'',
	6853);
INSERT INTO O_TPARM
	VALUES (6859,
	6858,
	'sysID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6860,
	2798,
	'pastePackage',
	'',
	19,
	1,
	'select any pkg from instances of EP_PKG where (selected.Package_ID == param.id);
if(not_empty pkg)
  select one directSystem related by pkg->S_SYS[R1401];
  if(not_empty directSystem)
    unrelate pkg from directSystem across R1401;
  end if;
  select one system related by pkg->S_SYS[R1405];
  if(not_empty system)
    unrelate pkg from system across R1405;
  end if;
  select one pe related by pkg->PE_PE[R8001];
  relate pe to self across R8000;
  // guarantee a unique name for the pasted dt package
  pkg.Name = ::getUniqueInitialNameInParent(instance:pkg.convertToInstance(),
  						name:pkg.Name, parent:self.convertToInstance());
  select one thisSystem related by self->S_SYS[R1405];
  relate pkg to thisSystem across R1405;
  // associate all children with this
  // system
  pkg.associateWithSystem(sysID:thisSystem.Sys_ID);
  // for any non local event below this package
  // remove incomplete ones (those that are not
  // resolvable)
  pkg.removeIncompleteSignalEvents();
end if;',
	1,
	'',
	6856);
INSERT INTO O_TPARM
	VALUES (6861,
	6860,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6834,
	2798,
	'deassociateFromParent',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// deassociate the pasted pkg with original parent
select one prevSystem related by self->S_SYS[R1401];
if(not_empty prevSystem)
  unrelate self from prevSystem across R1401;
end if;
select one pe related by self->PE_PE[R8001];
if not empty pe 
  select one pkg related by pe->EP_PKG[R8000];
  if not_empty pkg
    unrelate pkg from pe across R8000;
  end if;
  unrelate pe from self across R8001;
  delete object instance pe;
end if;',
	1,
	'',
	6839);
INSERT INTO O_TFR
	VALUES (6840,
	2798,
	'associateWithPackage',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// unhook from current parent
self.deassociateFromParent();
// hook up with package
select any package from instances of EP_PKG
                                     where (selected.Package_ID == param.pkgID);
create object instance pe of PE_PE;
relate pe to package across R8000;
relate pe to self across R8001;
pe.type = ElementTypeConstants::PACKAGE;
pe.initialize();',
	1,
	'',
	6858);
INSERT INTO O_TPARM
	VALUES (6862,
	6840,
	'pkgID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6863,
	2798,
	'newDatatype',
	'',
	19,
	1,
	'// Package::newDatatype()

// Create the new data type
create object instance dt of S_DT;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate dt to pe across R8001;
relate pe to self across R8000;

create object instance udt of S_UDT;
relate dt to udt across R17;

// Default to core integer type
select one system related by self->S_SYS[R1405];
dt_id = GD::NULL_UNIQUE_ID();
if not_empty system
  dt_id = system.getCoreTypeId(name:"integer");
end if;
select any int_pe from instances of PE_PE where selected.Element_ID == dt_id;
select one int_dt related by int_pe->S_DT[R8001]; 
relate udt to int_dt across R18;

dt.initialize(newname:"Unnamed Data Type");
pe.type = ElementTypeConstants::DATATYPE;
pe.initialize();',
	1,
	'',
	6860);
INSERT INTO O_TFR
	VALUES (6864,
	2798,
	'newActor',
	'',
	19,
	1,
	'// Package::newActor()
create object instance actor of SQ_AP;
create object instance participant of SQ_P;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate participant to pe across R8001;
relate actor to participant across R930;
relate self to pe across R8000;
pe.type = ElementTypeConstants::INTERACTION_PARTICIPANT;
pe.initialize();
actor.initialize();',
	1,
	'',
	6865);
INSERT INTO O_TFR
	VALUES (6866,
	2798,
	'newUseCase',
	'',
	19,
	1,
	'// Package::newUseCase()
create object instance useCase of IA_UCP;
create object instance participant of SQ_P;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate participant to pe across R8001;
pe.type = ElementTypeConstants::INTERACTION_PARTICIPANT;
pe.initialize();
relate useCase to participant across R930;
relate self to pe across R8000;
useCase.initialize();',
	1,
	'',
	6867);
INSERT INTO O_TFR
	VALUES (6868,
	2798,
	'newAssociation',
	'',
	316,
	1,
	'// Package::newAssociation()

// This operation handles associatin creation for both the Use Case Association
// and the Class Association.  
//

select any sourceActor related by self->PE_PE[R8000]->
                  SQ_P[R8001]->SQ_AP[R930] where selected.Part_ID == param.from;
select any destinationUC related by self->PE_PE[R8000]->
                   SQ_P[R8001]->IA_UCP[R930] where selected.Part_ID == param.to;
if not_empty sourceActor and not_empty destinationUC
  // This is a Use Case Association
  
  create object instance association of UC_UCA;
  // create Packageable Element supertype and hook up to this package.
  create object instance pe of PE_PE;
  relate association to pe across R8001;
  relate self to pe across R8000;
  pe.type = ElementTypeConstants::USE_CASE_ASSOCIATION;
  pe.initialize();
  create object instance ba of UC_BA;
  select one sourcePart related by sourceActor->SQ_P[R930];
  select one destPart related by destinationUC->SQ_P[R930];
  relate association to sourcePart across R1206;
  relate association to destPart across R1207;
  relate association to ba across R1210;
  return true;
else
  // It was not a Use Case association, so see if it is a class assocition.
  
  select any fromClass related by self->PE_PE[R8000]->O_OBJ[R8001] where (selected.Obj_ID == param.from);
  select any fromIClass related by self->PE_PE[R8000]->O_IOBJ[R8001] where (selected.IObj_ID == param.from);
  if (param.fromIsImported)
    if (not_empty fromIClass)
      select one fromClass related by fromIClass->O_OBJ[R101];
    end if;
  end if;
  select any toClass related by self->PE_PE[R8000]->O_OBJ[R8001] where (selected.Obj_ID == param.to);
  select any toIClass related by self->PE_PE[R8000]->O_IOBJ[R8001] where (selected.IObj_ID == param.to);
  if (param.toIsImported)
    if (not_empty toIClass)
      select one toClass related by toIClass->O_OBJ[R101];
    end if;
  end if;
  //
  if (not_empty fromClass and not_empty toClass)
    create object instance assoc of R_REL;
    // create Packageable Element supertype and hook up to this package.
    create object instance pe of PE_PE;
    relate assoc to pe across R8001;
    relate pe to self across R8000;
    pe.type = ElementTypeConstants::ASSOCIATION;
    pe.initialize();
    assoc.initialize();
    create object instance simp of R_SIMP;
    relate simp to assoc across R206;
    //
    create object instance fromOIR of R_OIR;
    relate fromClass to assoc across R201 using fromOIR;
    create object instance fromRTO of R_RTO;
    relate fromOIR to fromRTO across R203;
    create object instance fromPART of R_PART;
    relate fromPART to fromRTO across R204;
    relate fromPART to simp across R207;
    if (param.fromIsImported)
      if (not_empty fromIClass)
        relate fromOIR to fromIClass across R202;
      end if;
    end if;
    //
    create object instance toOIR of R_OIR;
    relate toClass to assoc across R201 using toOIR;
    create object instance toRTO of R_RTO;
    relate toOIR to toRTO across R203;
    create object instance toPART of R_PART;
    relate toPART to toRTO across R204;
    relate toPART to simp across R207;
    if (param.toIsImported)
      if (not_empty toIClass)
        relate toOIR to toIClass across R202;
      end if;
    end if;
    return true;
  end if;
end if;
return false;',
	1,
	'',
	6869);
INSERT INTO O_TPARM
	VALUES (6870,
	6868,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (6871,
	6868,
	'fromIsImported',
	316,
	0,
	'',
	6870,
	'');
INSERT INTO O_TPARM
	VALUES (6872,
	6868,
	'to',
	296,
	0,
	'',
	6871,
	'');
INSERT INTO O_TPARM
	VALUES (6873,
	6868,
	'toIsImported',
	316,
	0,
	'',
	6872,
	'');
INSERT INTO O_TFR
	VALUES (6874,
	2798,
	'newSendSignalAction',
	'',
	19,
	1,
	'// Package::newSendSignalAction()
create object instance node of A_N;
create object instance act of A_ACT;
create object instance ss of A_SS;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate node to pe across R8001;
pe.type = ElementTypeConstants::ACTIVITY_NODE;
pe.initialize();

relate node to act across R1105;
relate act to ss across R1107;
relate self to pe across R8000;
ss.initialize();',
	1,
	'',
	6875);
INSERT INTO O_TFR
	VALUES (6876,
	2798,
	'newGenericAction',
	'',
	19,
	1,
	'// Package::newGenericAction()
create object instance node of A_N;
create object instance act of A_ACT;
create object instance ga of A_GA;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate node to pe across R8001;
pe.type = ElementTypeConstants::ACTIVITY_NODE;
pe.initialize();

relate node to act across R1105;
relate act to ga across R1107;
relate self to pe across R8000;
ga.initialize();',
	1,
	'',
	6877);
INSERT INTO O_TFR
	VALUES (6878,
	2798,
	'newClass',
	'',
	19,
	1,
	'// Package::newClass()
create object instance cl of O_OBJ;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate cl to pe across R8001;
pe.type = ElementTypeConstants::CLASS;
pe.initialize();

relate self to pe across R8000;
cl.initialize();',
	1,
	'',
	6879);
INSERT INTO O_TFR
	VALUES (6880,
	2798,
	'newAcceptEventAction',
	'',
	19,
	1,
	'// Package::newAcceptEventAction()
create object instance node of A_N;
create object instance act of A_ACT;
create object instance ae of A_AE;
create object instance aea of A_AEA;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate node to pe across R8001;
pe.type = ElementTypeConstants::ACTIVITY_NODE;
pe.initialize();

relate node to act across R1105;
relate act to ae across R1107;
relate ae to aea across R1112;
relate self to pe across R8000;
aea.initialize();',
	1,
	'',
	6881);
INSERT INTO O_TFR
	VALUES (6882,
	2798,
	'newAcceptTimeEventAction',
	'',
	19,
	1,
	'// Package::newAcceptTimeEventAction()
create object instance node of A_N;
create object instance act of A_ACT;
create object instance ae of A_AE;
create object instance ate of A_ATE;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate node to pe across R8001;
pe.type = ElementTypeConstants::ACTIVITY_NODE;
pe.initialize();

relate node to act across R1105;
relate act to ae across R1107;
relate ae to ate across R1112;
relate self to pe across R8000;
ate.initialize();',
	1,
	'',
	6883);
INSERT INTO O_TFR
	VALUES (6884,
	2798,
	'newComponent',
	'',
	19,
	1,
	'create object instance component of C_C;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate component to pe across R8001;
relate pe to self across R8000;
pe.type = ElementTypeConstants::COMPONENT;
pe.initialize();
component.initialize();',
	1,
	'',
	6885);
INSERT INTO O_TFR
	VALUES (6886,
	2798,
	'newImportedComponent',
	'',
	19,
	1,
	'create object instance importedComp of CL_IC;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate importedComp to pe across R8001;
relate pe to self across R8000;
pe.type = ElementTypeConstants::COMPONENT_REFERENCE;
pe.initialize();
',
	1,
	'',
	6887);
INSERT INTO O_TFR
	VALUES (6888,
	2798,
	'newProvision',
	'',
	316,
	1,
	'select any component from instances of C_C where (selected.Id == param.from);
select any requirement from instances of C_R where (selected.Requirement_Id == param.to);
select any importedRef from instances of CL_IIR where (selected.Id == param.to);
if(not_empty requirement) and (not_empty component)
  return component.initializeProvision(requirement_id:requirement.Requirement_Id, provision_id:GD::NULL_UNIQUE_ID(), proceed:true);
end if;
if(not_empty importedRef) and (not_empty component)
  return component.initializeProvision(requirement_id:importedRef.Id, provision_id:GD::NULL_UNIQUE_ID(), proceed:true);
end if;
if(empty requirement and not_empty component)
  return component.initializeProvision(requirement_id:GD::NULL_UNIQUE_ID(), provision_id:GD::NULL_UNIQUE_ID(), proceed:true);
end if;
return false;',
	1,
	'',
	6886);
INSERT INTO O_TPARM
	VALUES (6889,
	6888,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (6890,
	6888,
	'fromIsImported',
	316,
	0,
	'',
	6889,
	'');
INSERT INTO O_TPARM
	VALUES (6891,
	6888,
	'to',
	296,
	0,
	'',
	6890,
	'');
INSERT INTO O_TPARM
	VALUES (6892,
	6888,
	'toIsImported',
	316,
	0,
	'',
	6891,
	'');
INSERT INTO O_TFR
	VALUES (6893,
	2798,
	'newRequirement',
	'',
	316,
	1,
	'select any component from instances of C_C where (selected.Id == param.from);
select any provision from instances of C_P where (selected.Provision_Id == param.to);
select any importedRef from instances of CL_IIR where (selected.Id == param.to);
if(not_empty provision and not_empty component)
  return component.initializeRequirement(provision_id:provision.Provision_Id, requirement_id:GD::NULL_UNIQUE_ID(), proceed:true);
end if;
if(not_empty importedRef) and (not_empty component)
  return component.initializeRequirement(provision_id:importedRef.Id, requirement_id:GD::NULL_UNIQUE_ID(), proceed:true);
end if;
if(not_empty component)
  return component.initializeRequirement(provision_id:GD::NULL_UNIQUE_ID(), requirement_id:GD::NULL_UNIQUE_ID(), proceed:true);
end if;
return false;',
	1,
	'',
	6894);
INSERT INTO O_TPARM
	VALUES (6895,
	6893,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (6896,
	6893,
	'fromIsImported',
	316,
	0,
	'',
	6895,
	'');
INSERT INTO O_TPARM
	VALUES (6897,
	6893,
	'to',
	296,
	0,
	'',
	6896,
	'');
INSERT INTO O_TPARM
	VALUES (6898,
	6893,
	'toIsImported',
	316,
	0,
	'',
	6897,
	'');
INSERT INTO O_TFR
	VALUES (6899,
	2798,
	'newInterface',
	'',
	19,
	1,
	'create object instance interface of C_I;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate interface to pe across R8001;
relate pe to self across R8000;
pe.type = ElementTypeConstants::INTERFACE;
pe.initialize();
interface.initialize();
',
	1,
	'',
	6900);
INSERT INTO O_TFR
	VALUES (6857,
	2798,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Package_ID;',
	1,
	'',
	6837);
INSERT INTO O_TFR
	VALUES (6901,
	2798,
	'newConstantSpecification',
	'',
	19,
	1,
	'// Data Type Package::newConstantSpecification()
create object instance csp of CNST_CSP;
create object instance cip of CNST_CIP;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate csp to pe across R8001;
relate pe to self across R8000;
pe.type = ElementTypeConstants::CONSTANT;
pe.initialize();
csp.initialize();
',
	1,
	'',
	6902);
INSERT INTO O_TFR
	VALUES (6903,
	2798,
	'newEnumeration',
	'',
	19,
	1,
	'// Data Type Package::newEnumeration()
create object instance dt of S_DT;
create object instance dip of S_DIP;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate dt to pe across R8001;
create object instance edt of S_EDT;
relate dt to edt across R17;
relate pe to self across R8000;
pe.type = ElementTypeConstants::DATATYPE;
pe.initialize();

dt.initialize(newname:"Unnamed Enumeration");
',
	1,
	'',
	6904);
INSERT INTO O_TFR
	VALUES (6905,
	2798,
	'newStructuredDatatype',
	'',
	19,
	1,
	'// Data Type Package::newStructuredDatatype()
create object instance dt of S_DT;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate dt to pe across R8001;
create object instance sdt of S_SDT;
relate dt to sdt across R17;
create object instance dip of S_DIP;
relate pe to self across R8000;
pe.type = ElementTypeConstants::DATATYPE;
pe.initialize();
dt.initialize(newname:"Unnamed Structured Data Type");
',
	1,
	'',
	6906);
INSERT INTO O_TFR
	VALUES (6907,
	2798,
	'newGeneralization',
	'',
	316,
	1,
	'select any source related by self->PE_PE[R8000]->SQ_P[R8001] where (selected.Part_ID == param.from);
select any destination related by self->PE_PE[R8000]->SQ_P[R8001] where (selected.Part_ID == param.to);
createAssoc = false;
if((not_empty source) and (not_empty destination) and (source != destination))
  select one sourceUC related by source->IA_UCP[R930];
  select one destUC related by destination->IA_UCP[R930];
  if(not_empty sourceUC and not_empty destUC)
    createAssoc = true;
  else
    select one sourceActor related by source->SQ_AP[R930];
    select one destActor related by destination->SQ_AP[R930];
    if(not_empty sourceActor and not_empty destActor)
      createAssoc = true;
    end if;
  end if;
end if;
if(createAssoc)
  create object instance association of UC_UCA;
  // create Packageable Element supertype and hook up to this package.
  create object instance pe of PE_PE;
  relate association to pe across R8001;
  relate self to pe across R8000;
  pe.type = ElementTypeConstants::INTERACTION_PARTICIPANT;
  pe.initialize();
  create object instance gen of UC_G;
  if (not_empty source)
    relate association to source across R1206;
  end if;
  if (not_empty destination)
    relate association to destination across R1207;
  end if;
  relate association to gen across R1210;
  return true;
end if;
return false;',
	1,
	'',
	6908);
INSERT INTO O_TPARM
	VALUES (6909,
	6907,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (6910,
	6907,
	'fromIsImported',
	316,
	0,
	'',
	6909,
	'');
INSERT INTO O_TPARM
	VALUES (6911,
	6907,
	'to',
	296,
	0,
	'',
	6910,
	'');
INSERT INTO O_TPARM
	VALUES (6912,
	6907,
	'toIsImported',
	316,
	0,
	'',
	6911,
	'');
INSERT INTO O_TFR
	VALUES (6913,
	2798,
	'newInclude',
	'',
	316,
	1,
	'select any sourceUC related by self->PE_PE[R8000]->SQ_P[R8001]->IA_UCP[R930] where (selected.Part_ID == param.from);
select any destinationUC related by self->PE_PE[R8000]->SQ_P[R8001]->IA_UCP[R930] where (selected.Part_ID == param.to);
if(not_empty sourceUC and not_empty destinationUC) and (sourceUC != destinationUC)
  create object instance association of UC_UCA;
  // create Packageable Element supertype and hook up to this package.
  create object instance pe of PE_PE;
  relate association to pe across R8001;
  relate self to pe across R8000;
  pe.type = ElementTypeConstants::USE_CASE_ASSOCIATION;
  pe.initialize();
  create object instance inc of UC_I;
  select one source related by sourceUC->SQ_P[R930];
  select one destination related by destinationUC->SQ_P[R930];
  relate association to source across R1206;
  relate association to destination across R1207;
  relate association to inc across R1210;
  return true;
end if;
return false;',
	1,
	'',
	6914);
INSERT INTO O_TPARM
	VALUES (6915,
	6913,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (6916,
	6913,
	'fromIsImported',
	316,
	0,
	'',
	6915,
	'');
INSERT INTO O_TPARM
	VALUES (6917,
	6913,
	'to',
	296,
	0,
	'',
	6916,
	'');
INSERT INTO O_TPARM
	VALUES (6918,
	6913,
	'toIsImported',
	316,
	0,
	'',
	6917,
	'');
INSERT INTO O_TFR
	VALUES (6919,
	2798,
	'newExtend',
	'',
	316,
	1,
	'select any sourceUC related by self->PE_PE[R8000]->SQ_P[R8001]->IA_UCP[R930] where (selected.Part_ID == param.from);
select any destinationUC related by self->PE_PE[R8000]->SQ_P[R8001]->IA_UCP[R930] where (selected.Part_ID == param.to);
if(not_empty sourceUC and not_empty destinationUC) and (sourceUC != destinationUC)
  create object instance association of UC_UCA;
  // create Packageable Element supertype and hook up to this package.
  create object instance pe of PE_PE;
  relate association to pe across R8001;
  pe.type = ElementTypeConstants::INTERACTION_PARTICIPANT;
  pe.initialize();
  relate self to pe across R8000;
  create object instance ext of UC_E;
  select one source related by sourceUC->SQ_P[R930];
  select one destination related by destinationUC->SQ_P[R930];
  relate association to source across R1206;
  relate association to destination across R1207;
  relate association to ext across R1210;
  return true;
end if;
return false;',
	1,
	'',
	6920);
INSERT INTO O_TPARM
	VALUES (6921,
	6919,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (6922,
	6919,
	'fromIsImported',
	316,
	0,
	'',
	6921,
	'');
INSERT INTO O_TPARM
	VALUES (6923,
	6919,
	'to',
	296,
	0,
	'',
	6922,
	'');
INSERT INTO O_TPARM
	VALUES (6924,
	6919,
	'toIsImported',
	316,
	0,
	'',
	6923,
	'');
INSERT INTO O_TFR
	VALUES (6925,
	2798,
	'newActivityPartition',
	'',
	316,
	1,
	'create object instance ap of A_AP;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate ap to pe across R8001;
relate pe to self across R8000;
pe.type = ElementTypeConstants::ACTIVITY_PARTITION;
pe.initialize();
return true;',
	1,
	'',
	6926);
INSERT INTO O_TPARM
	VALUES (6927,
	6925,
	'to',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (6928,
	6925,
	'toTypeIsImported',
	316,
	0,
	'',
	6927,
	'');
INSERT INTO O_TPARM
	VALUES (6929,
	6925,
	'from',
	296,
	0,
	'',
	6928,
	'');
INSERT INTO O_TPARM
	VALUES (6930,
	6925,
	'fromTypeIsImported',
	316,
	0,
	'',
	6929,
	'');
INSERT INTO O_TFR
	VALUES (6931,
	2798,
	'newObjectNode',
	'',
	19,
	1,
	'create object instance node of A_N;
create object instance obj of A_OBJ;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate node to pe across R8001;
relate pe to self across R8000;
pe.type = ElementTypeConstants::ACTIVITY_NODE;
pe.initialize();

relate node to obj across R1105;
obj.initialize();',
	1,
	'',
	6932);
INSERT INTO O_TFR
	VALUES (6933,
	2798,
	'newActivityEdge',
	'',
	316,
	1,
	'if ( param.from == param.to )
  return false;
end if;
select any fromNode related by self->PE_PE[R8000]->A_N[R8001] where (selected.Id == param.from);
select any toNode related by self->PE_PE[R8000]->A_N[R8001] where (selected.Id == param.to);
if (not_empty fromNode and not_empty toNode)
  if ( fromNode.outgoingEdgeAllowed() and toNode.incomingEdgeAllowed() )
    create object instance edge of A_E;
    // create Packageable Element supertype and hook up to this package.
    create object instance pe of PE_PE;
    relate edge to pe across R8001;
    relate pe to self across R8000;
    pe.type = ElementTypeConstants::ACTIVITY_EDGE;
    pe.initialize();
    relate edge to fromNode across R1104;
    relate edge to toNode across R1103;
    return true;
  end if;
end if;
return false;',
	1,
	'',
	6934);
INSERT INTO O_TPARM
	VALUES (6935,
	6933,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (6936,
	6933,
	'fromTypeIsImported',
	316,
	0,
	'',
	6935,
	'');
INSERT INTO O_TPARM
	VALUES (6937,
	6933,
	'to',
	296,
	0,
	'',
	6936,
	'');
INSERT INTO O_TPARM
	VALUES (6938,
	6933,
	'toTypeIsImported',
	316,
	0,
	'',
	6937,
	'');
INSERT INTO O_TFR
	VALUES (6939,
	2798,
	'newForkJoin',
	'',
	316,
	1,
	'if(param.from == GD::NULL_UNIQUE_ID()) and (param.to == GD::NULL_UNIQUE_ID())
  create object instance node of A_N;
  create object instance ctl of A_CTL;
  create object instance fj of A_FJ;
  
  // create Packageable Element supertype and hook up to this package.
  create object instance pe of PE_PE;
  relate node to pe across R8001;
  relate pe to self across R8000;
  pe.type = ElementTypeConstants::ACTIVITY_NODE;
  pe.initialize();

  relate node to ctl across R1105;
  relate ctl to fj across R1106;
  
  return true;
end if;
return false;
',
	1,
	'',
	6940);
INSERT INTO O_TPARM
	VALUES (6941,
	6939,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (6942,
	6939,
	'fromTypeIsImported',
	316,
	0,
	'',
	6941,
	'');
INSERT INTO O_TPARM
	VALUES (6943,
	6939,
	'to',
	296,
	0,
	'',
	6942,
	'');
INSERT INTO O_TPARM
	VALUES (6944,
	6939,
	'toTypeIsImported',
	316,
	0,
	'',
	6943,
	'');
INSERT INTO O_TFR
	VALUES (6945,
	2798,
	'newDecisionMergeNode',
	'',
	19,
	1,
	'create object instance node of A_N;
create object instance ctl of A_CTL;
create object instance d of A_DM;

// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate node to pe across R8001;
relate pe to self across R8000;
pe.type = ElementTypeConstants::ACTIVITY_NODE;
pe.initialize();
  
relate node to ctl across R1105;
relate ctl to d across R1106;

d.initialize();
',
	1,
	'',
	6946);
INSERT INTO O_TFR
	VALUES (6947,
	2798,
	'newInitialNode',
	'',
	19,
	1,
	'create object instance node of A_N;
create object instance ctl of A_CTL;
create object instance ini of A_INI;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate node to pe across R8001;
relate pe to self across R8000;
pe.type = ElementTypeConstants::ACTIVITY_NODE;
pe.initialize();

relate node to ctl across R1105;
relate ctl to ini across R1106;
',
	1,
	'',
	6948);
INSERT INTO O_TFR
	VALUES (6949,
	2798,
	'newActivityFinalNode',
	'',
	19,
	1,
	'create object instance node of A_N;
create object instance ctl of A_CTL;
create object instance af of A_AF;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate node to pe across R8001;
relate pe to self across R8000;
pe.type = ElementTypeConstants::ACTIVITY_NODE;
pe.initialize();

relate node to ctl across R1105;
relate ctl to af across R1106;
',
	1,
	'',
	6950);
INSERT INTO O_TFR
	VALUES (6951,
	2798,
	'newFlowFinalNode',
	'',
	19,
	1,
	'create object instance node of A_N;
create object instance ctl of A_CTL;
create object instance ff of A_FF;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate node to pe across R8001;
relate pe to self across R8000;
pe.type = ElementTypeConstants::ACTIVITY_NODE;
pe.initialize();

relate node to ctl across R1105;
relate ctl to ff across R1106;',
	1,
	'',
	6952);
INSERT INTO O_TFR
	VALUES (6953,
	2798,
	'newClassInstance',
	'',
	19,
	1,
	'create object instance participant of SQ_P;
create object instance inst of SQ_CIP;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate participant to pe across R8001;
relate pe to self across R8000;
pe.type = ElementTypeConstants::INTERACTION_PARTICIPANT;
pe.initialize();

relate participant to inst across R930;
inst.initialize();',
	1,
	'',
	6954);
INSERT INTO O_TFR
	VALUES (6955,
	2798,
	'newExternalEntityParticipant',
	'',
	19,
	1,
	'create object instance participant of SQ_P;
create object instance eep of SQ_EEP;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate participant to pe across R8001;
relate pe to self across R8000;
pe.type = ElementTypeConstants::INTERACTION_PARTICIPANT;
pe.initialize();
relate participant to eep across R930;
eep.initialize();',
	1,
	'',
	6956);
INSERT INTO O_TFR
	VALUES (6957,
	2798,
	'newLifeSpan',
	'',
	316,
	1,
	'select any part from instances of SQ_P where (selected.Part_ID == param.from);
select any partTo from instances of SQ_P where (selected.Part_ID == param.to);
// if the element that this lifespan is drawn to is
// the instance, we must switch it so that it is the
// element from which the lifespan is drawn from 
// so that the logic below works
if(empty part) and (not_empty partTo)
  inst = partTo;
end if;
if(not_empty part)
  // don''t allow more that one lifeline per
  // element
  select one otherLifeSpan related by part->SQ_LS[R940];
  if(not_empty otherLifeSpan)
    return false;
  end if;
  // otherwise create the lifespan on this instance
  create object instance lifeSpanPart of SQ_P;
  create object instance lifespan of SQ_LS;
  // create Packageable Element supertype and hook up to this package.
  create object instance pe of PE_PE;
  relate lifeSpanPart to pe across R8001;
  relate pe to self across R8000;
  pe.type = ElementTypeConstants::INTERACTION_PARTICIPANT;
  pe.initialize();
  relate lifespan to part across R940;
  relate lifespan to lifeSpanPart across R930;
  return true;
end if;
return false;',
	1,
	'',
	6958);
INSERT INTO O_TPARM
	VALUES (6959,
	6957,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (6960,
	6957,
	'fromIsImported',
	316,
	0,
	'',
	6959,
	'');
INSERT INTO O_TPARM
	VALUES (6961,
	6957,
	'to',
	296,
	0,
	'',
	6960,
	'');
INSERT INTO O_TPARM
	VALUES (6962,
	6957,
	'toIsImported',
	316,
	0,
	'',
	6961,
	'');
INSERT INTO O_TFR
	VALUES (6963,
	2798,
	'newClassParticipant',
	'',
	19,
	1,
	'create object instance participant of SQ_P;
create object instance cp of SQ_CP;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate participant to pe across R8001;
relate pe to self across R8000;
pe.type = ElementTypeConstants::INTERACTION_PARTICIPANT;
pe.initialize();
relate participant to cp across R930;
cp.initialize();',
	1,
	'',
	6964);
INSERT INTO O_TFR
	VALUES (6965,
	2798,
	'newTimingMark',
	'',
	316,
	1,
	'select any lifespan from instances of SQ_LS where (selected.Part_ID == param.from);
if(not_empty lifespan)
  create object instance mark of SQ_TM;
  relate mark to lifespan across R931;
  return true;
end if;
return false;',
	1,
	'',
	6966);
INSERT INTO O_TPARM
	VALUES (6967,
	6965,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (6968,
	6965,
	'fromIsImported',
	316,
	0,
	'',
	6967,
	'');
INSERT INTO O_TPARM
	VALUES (6969,
	6965,
	'to',
	296,
	0,
	'',
	6968,
	'');
INSERT INTO O_TPARM
	VALUES (6970,
	6965,
	'toIsImported',
	316,
	0,
	'',
	6969,
	'');
INSERT INTO O_TFR
	VALUES (6971,
	2798,
	'newTimeSpan',
	'',
	316,
	1,
	'select any mark from instances of SQ_TM where (selected.Mark_ID == param.from);
if(not_empty mark)
  select any otherMark from instances of SQ_TM where (selected.Mark_ID == param.to);
  if(not_empty otherMark)
    create object instance span of SQ_TS;
    relate span to mark across R941;
    relate span to otherMark across R942;
    return true;
  end if;
end if;
return false;',
	1,
	'',
	6972);
INSERT INTO O_TPARM
	VALUES (6973,
	6971,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (6974,
	6971,
	'fromIsImported',
	316,
	0,
	'',
	6973,
	'');
INSERT INTO O_TPARM
	VALUES (6975,
	6971,
	'to',
	296,
	0,
	'',
	6974,
	'');
INSERT INTO O_TPARM
	VALUES (6976,
	6971,
	'toIsImported',
	316,
	0,
	'',
	6975,
	'');
INSERT INTO O_TFR
	VALUES (6977,
	2798,
	'newSyncMessage',
	'',
	316,
	1,
	'// This operation handles associatin creation for both the Sequence and
// the Communication Synchronous Message.
//
select any fromParticipant from instances of SQ_P where (selected.Part_ID == param.from);
select any toParticipant from instances of SQ_P where (selected.Part_ID == param.to);
if not_empty toParticipant
  // This is a Sequence Synchronous Message.
  
  // it only matters that there is a toParticipant
  if(not_empty toParticipant)
    create object instance message of MSG_M;
    // create Packageable Element supertype and hook up to this package.
    create object instance pe of PE_PE;
    relate message to pe across R8001;
    relate pe to self across R8000;
    pe.type = ElementTypeConstants::MESSAGE;
    pe.initialize();
    relate message to toParticipant across R1007;
    if(not_empty fromParticipant)
      relate message to fromParticipant across R1008;
    end if;
    create object instance sm of MSG_SM;
    relate message to sm across R1018;
    sm.initialize();
    return true;
  end if;
else 
  // only create the message if it does not connect
  // to anything
  select any toPart from instances of SQ_P where (selected.Part_ID == param.to);
  select any fromPart from instances of SQ_P where (selected.Part_ID == param.from);
  if(empty toPart and empty fromPart)
    create object instance message of MSG_M;
    // create Packageable Element supertype and hook up to this package.
    create object instance pe of PE_PE;
    relate message to pe across R8001;
    relate pe to self across R8000;
    pe.type = ElementTypeConstants::MESSAGE;
    pe.initialize();
    create object instance sm of MSG_SM;
    create object instance mic of COMM_MIC;
    relate message to sm across R1018;
    sm.initialize();
    // set a flag indicating that this participates in
    // a communication
    message.participatesInCommunication = true;
    return true;
  else
    return false;
  end if;
end if;

return false;
',
	1,
	'',
	6978);
INSERT INTO O_TPARM
	VALUES (6979,
	6977,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (6980,
	6977,
	'fromIsImported',
	316,
	0,
	'',
	6979,
	'');
INSERT INTO O_TPARM
	VALUES (6981,
	6977,
	'to',
	296,
	0,
	'',
	6980,
	'');
INSERT INTO O_TPARM
	VALUES (6982,
	6977,
	'toIsImported',
	316,
	0,
	'',
	6981,
	'');
INSERT INTO O_TFR
	VALUES (6983,
	2798,
	'newASyncMessage',
	'',
	316,
	1,
	'// This operation handles associatin creation for both the Sequence and
// the Communication Asyncronous Synchronous Message.
//
select any fromParticipant from instances of SQ_P where (selected.Part_ID == param.from);
select any toParticipant from instances of SQ_P where (selected.Part_ID == param.to);
if not_empty toParticipant
  // This is a Sequence Asyncronous Message.
  
  // it only matters that there is a toParticipant
  if(not_empty toParticipant)
    create object instance message of MSG_M;
    // create Packageable Element supertype and hook up to this package.
    create object instance pe of PE_PE;
    relate message to pe across R8001;
    relate pe to self across R8000;
    pe.type = ElementTypeConstants::MESSAGE;
    pe.initialize();
    relate message to toParticipant across R1007;
    if(not_empty fromParticipant)
      relate message to fromParticipant across R1008;
    end if;
    create object instance am of MSG_AM;
    relate message to am across R1018;
    am.initialize();
    return true;
  end if;
else 
  // only create the message if it does not connect
  // to anything
  select any toPart from instances of SQ_P where (selected.Part_ID == param.to);
  select any fromPart from instances of SQ_P where (selected.Part_ID == param.from);
  if(empty toPart and empty fromPart)
    create object instance message of MSG_M;
    // create Packageable Element supertype and hook up to this package.
    create object instance pe of PE_PE;
    relate message to pe across R8001;
    relate pe to self across R8000;
    pe.type = ElementTypeConstants::MESSAGE;
    pe.initialize();
    create object instance am of MSG_AM;
    create object instance mic of COMM_MIC;
    relate message to am across R1018;
    am.initialize();
    // set a flag indicating that this participates in
    // a communication
    message.participatesInCommunication = true;
    return true;
  else
    return false;
  end if;
end if;
return false;
',
	1,
	'',
	6984);
INSERT INTO O_TPARM
	VALUES (6985,
	6983,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (6986,
	6983,
	'fromIsImported',
	316,
	0,
	'',
	6985,
	'');
INSERT INTO O_TPARM
	VALUES (6987,
	6983,
	'to',
	296,
	0,
	'',
	6986,
	'');
INSERT INTO O_TPARM
	VALUES (6988,
	6983,
	'toIsImported',
	316,
	0,
	'',
	6987,
	'');
INSERT INTO O_TFR
	VALUES (6989,
	2798,
	'newReturnMessage',
	'',
	316,
	1,
	'// This operation handles associatin creation for both the Sequence and
// the Communication Synchronous Message.
//
select any fromParticipant from instances of SQ_P where (selected.Part_ID == param.from);
select any toParticipant from instances of SQ_P where (selected.Part_ID == param.to);
if not_empty toParticipant
  // This is a Sequence Return Message.
  
  // it only matters that there is a toParticipant
  if(not_empty toParticipant)
    create object instance message of MSG_M;
    // create Packageable Element supertype and hook up to this package.
    create object instance pe of PE_PE;
    relate message to pe across R8001;
    relate pe to self across R8000;
    pe.type = ElementTypeConstants::MESSAGE;
    pe.initialize();
    relate message to toParticipant across R1007;
    if(not_empty fromParticipant)
      relate message to fromParticipant across R1008;
    end if;
    create object instance rm of MSG_R;
    relate rm to message across R1018;
    rm.initialize();
    return true;
  end if;
else
  // only create the message if it does not connect
  // to anything
  select any toPart from instances of SQ_P where (selected.Part_ID == param.to);
  select any fromPart from instances of SQ_P where (selected.Part_ID == param.from);
  if(empty toPart and empty fromPart)
    create object instance message of MSG_M;
    // create Packageable Element supertype and hook up to this package.
    create object instance pe of PE_PE;
    relate message to pe across R8001;
    relate pe to self across R8000;
    pe.type = ElementTypeConstants::MESSAGE;
    pe.initialize();
    create object instance rm of MSG_R;
    create object instance mic of COMM_MIC;
    relate message to rm across R1018;
    rm.initialize();
    return true;
  else
    return false;
  end if;
end if;
return false;
',
	1,
	'',
	6990);
INSERT INTO O_TPARM
	VALUES (6991,
	6989,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (6992,
	6989,
	'fromIsImported',
	316,
	0,
	'',
	6991,
	'');
INSERT INTO O_TPARM
	VALUES (6993,
	6989,
	'to',
	296,
	0,
	'',
	6992,
	'');
INSERT INTO O_TPARM
	VALUES (6994,
	6989,
	'toIsImported',
	316,
	0,
	'',
	6993,
	'');
INSERT INTO O_TFR
	VALUES (6995,
	2798,
	'newComponentParticipant',
	'',
	19,
	1,
	'create object instance participant of SQ_P;
create object instance cp of SQ_COP;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate participant to pe across R8001;
relate pe to self across R8000;
pe.type = ElementTypeConstants::INTERACTION_PARTICIPANT;
pe.initialize();
relate participant to cp across R930;
cp.initialize();',
	1,
	'',
	6996);
INSERT INTO O_TFR
	VALUES (6997,
	2798,
	'newIClass',
	'',
	19,
	1,
	'create object instance icl of O_IOBJ;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate icl to pe across R8001;
relate pe to self across R8000;
pe.type = ElementTypeConstants::IMPORTED_CLASS;
pe.initialize();
//
// Note that no class is assigned to this imported
// class at creation time. This is achieved by a separate
// Context Menu action.',
	1,
	'',
	6998);
INSERT INTO O_TFR
	VALUES (6999,
	2798,
	'newAssociative',
	'',
	316,
	1,
	'select any fromClass related by self->PE_PE[R8000]->O_OBJ[R8001] where (selected.Obj_ID == param.from);
if (param.fromIsImportedClass)
  select any fromIClass related by self->PE_PE[R8000]->O_IOBJ[R8001] where (selected.IObj_ID == param.from);
  if (not_empty fromIClass)
    select one fromClass related by fromIClass->O_OBJ[R101];
  end if;
end if;
select any toAssoc related by self->PE_PE[R8000]->R_REL[R8001] where (selected.Rel_ID == param.to);
// get the already related class in relationship instances
select many classes related by toAssoc->R_OIR[R201]->O_OBJ[R201];
for each clazz in classes
  if (clazz == fromClass)
    // A class cannot be it''s own link class
    return false;
  end if;
end for;
if (empty fromClass or empty toAssoc)
  // One of the elements was not found
  return false;
end if;
select one simp related by toAssoc->R_SIMP[R206];
if (empty simp)
  // Only simple associations can have link classes attached. 
  return false;
else
  if (param.fromIsImportedClass)
    simp.migrateToLinked(using: fromClass.Obj_ID, imported_id: param.from);
  else
    simp.migrateToLinked(using: fromClass.Obj_ID, imported_id: GD::NULL_UNIQUE_ID());
  end if;
  return true;
end if;',
	1,
	'',
	7000);
INSERT INTO O_TPARM
	VALUES (7001,
	6999,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (7002,
	6999,
	'fromIsImportedClass',
	316,
	0,
	'',
	7001,
	'');
INSERT INTO O_TPARM
	VALUES (7003,
	6999,
	'to',
	296,
	0,
	'',
	7002,
	'');
INSERT INTO O_TPARM
	VALUES (7004,
	6999,
	'toIsImportedClass',
	316,
	0,
	'',
	7003,
	'');
INSERT INTO O_TFR
	VALUES (7005,
	2798,
	'newSuperType',
	'',
	316,
	1,
	'select any fromClass related by self->PE_PE[R8000]->O_OBJ[R8001] where (selected.Obj_ID == param.from);
select any fromIClass related by self->PE_PE[R8000]->O_IOBJ[R8001] where (selected.IObj_ID == param.from);
if (param.fromIsImportedClass)
  if (not_empty fromIClass)
    select one fromClass related by fromIClass->O_OBJ[R101];
  end if;
end if;
if (not_empty fromClass)
  create object instance assoc of R_REL;
  // create Packageable Element supertype and hook up to this package.
  create object instance pe of PE_PE;
  relate assoc to pe across R8001;
  relate pe to self across R8000;
  pe.type = ElementTypeConstants::ASSOCIATION;
  pe.initialize();
  assoc.initialize();
  create object instance oir of R_OIR;
  relate assoc to fromClass across R201 using oir;
  create object instance rto of R_RTO;
  relate oir to rto across R203;
  create object instance subsup of R_SUBSUP;
  relate subsup to assoc across R206;
  create object instance supertype of R_SUPER;
  relate supertype to subsup across R212;
  relate supertype to rto across R204;
  if (param.fromIsImportedClass)
    if (not_empty fromIClass)
      relate oir to fromIClass across R202;
    end if;
  end if;
  return true;
end if;
return false;',
	1,
	'',
	6999);
INSERT INTO O_TPARM
	VALUES (7006,
	7005,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (7007,
	7005,
	'fromIsImportedClass',
	316,
	0,
	'',
	7006,
	'');
INSERT INTO O_TPARM
	VALUES (7008,
	7005,
	'to',
	296,
	0,
	'',
	7007,
	'');
INSERT INTO O_TPARM
	VALUES (7009,
	7005,
	'toIsImportedClass',
	316,
	0,
	'',
	7008,
	'');
INSERT INTO O_TFR
	VALUES (7010,
	2798,
	'newSubtype',
	'',
	316,
	1,
	'select any fromClass related by self->PE_PE[R8000]->O_OBJ[R8001] where (selected.Obj_ID == param.from);
if (param.fromIsImportedClass)
  select any fromIClass related by self->PE_PE[R8000]->O_IOBJ[R8001] where (selected.IObj_ID == param.from);
  if (not_empty fromIClass)
    select one fromClass related by fromIClass->O_OBJ[R101];
  end if;
end if;
if (not_empty fromClass)
  select any toAssoc related by self->PE_PE[R8000]->R_REL[R8001] where (selected.Rel_ID == param.to);
  if (not_empty toAssoc)
    select one subsup related by toAssoc->R_SUBSUP[R206];
    if (not_empty subsup)
      select one superClass related by subsup->R_SUPER[R212]->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201];
      if (fromClass != superClass) // A class cannot be its own supertype . . . . .
        isAlreadySubClass = false;
        select many subClasses related by subsup->R_SUB[R213]->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201];
        for each subClass in subClasses
          if (fromClass == subClass)
            isAlreadySubClass = true;
            break;
          end if;
        end for;
        if (not isAlreadySubClass) // A class cannot be a subtype more than once . . . . . 
          create object instance cir of R_OIR;
          relate fromClass to toAssoc across R201 using cir;
          if (param.fromIsImportedClass)
            select any fromIClass related by self->PE_PE[R8000]->O_IOBJ[R8001] where
                                       (selected.IObj_ID == param.from);
            relate cir to fromIClass across R202;
          end if;
          create object instance rgo of R_RGO;
          relate cir to rgo across R203;
          create object instance subtype of R_SUB;
          relate rgo to subtype across R205;
          relate subtype to subsup across R213;
          if ( toAssoc.isFormalized() )
            // add referential attributes
            unused_oid = fromClass.findUnusedIdentifier();
            select one sup_rto related by subsup->R_SUPER[R212]->R_RTO[R204];
            select many oida_set related by sup_rto->O_ID[R109]->O_OIDA[R105];
            for each oida in oida_set
              newAttr_id = oida.addReference(rel_id: toAssoc.Rel_ID,
                  rto_obj_id: sup_rto.Obj_ID, rto_oir_id: sup_rto.OIR_ID, 
                  rgo_obj_id: rgo.Obj_ID, rgo_oir_id: rgo.OIR_ID,
                  id: unused_oid);
            end for;
          end if;
          return true;
        end if; // already sub class
      end if; // not own supertype
    end if; // association is supertype / subtype
  end if;  // association found
end if;  // class found
return false;',
	1,
	'',
	7005);
INSERT INTO O_TPARM
	VALUES (7011,
	7010,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (7012,
	7010,
	'fromIsImportedClass',
	316,
	0,
	'',
	7011,
	'');
INSERT INTO O_TPARM
	VALUES (7013,
	7010,
	'to',
	296,
	0,
	'',
	7012,
	'');
INSERT INTO O_TPARM
	VALUES (7014,
	7010,
	'toIsImportedClass',
	316,
	0,
	'',
	7013,
	'');
INSERT INTO O_TFR
	VALUES (7015,
	2798,
	'newExternalEntity',
	'',
	19,
	1,
	'create object instance ee of S_EE;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate ee to pe across R8001;
relate pe to self across R8000;
pe.type = ElementTypeConstants::EE;
pe.initialize();
ee.initialize();',
	1,
	'',
	7010);
INSERT INTO O_TFR
	VALUES (7016,
	2798,
	'newFunction',
	'',
	19,
	1,
	'create object instance fn of S_SYNC;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate fn to pe across R8001;
relate pe to self across R8000;
pe.type = ElementTypeConstants::FUNCTION;
pe.initialize();
create object instance fip of S_FIP;
fn.initialize();',
	1,
	'',
	7017);
INSERT INTO O_TFR
	VALUES (7018,
	2798,
	'getPckgCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many pckgs related by self->PE_PE[R8000]->EP_PKG[R8001];
return cardinality pckgs;',
	1,
	'',
	7019);
INSERT INTO O_TFR
	VALUES (7020,
	2798,
	'getPckgId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many pckgs related by self->PE_PE[R8000]->EP_PKG[R8001];
// We''re preincrementing the index
count = -1;
for each pckg in pckgs
  if (not_empty pckg)
      count = count+1;
  end if;
  if (count == param.index)
      return pckg.Package_ID;  
  end if;
end for;
return id;',
	1,
	'',
	7018);
INSERT INTO O_TPARM
	VALUES (7021,
	7020,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7022,
	2798,
	'getActivityCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many activities related by self->EP_SPKG[R1400]->A_A[R1402];
return cardinality activities;',
	1,
	'',
	7020);
INSERT INTO O_TFR
	VALUES (7023,
	2798,
	'getActivityId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many activities related by self->EP_SPKG[R1400]->A_A[R1402];
// We''re preincrementing the index
count = -1;
for each activity in activities
  if (not_empty activity)
      count = count+1;
  end if;
  if (count == param.index)
      return activity.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7022);
INSERT INTO O_TPARM
	VALUES (7024,
	7023,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7025,
	2798,
	'getCommunicationCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many communications related by self->EP_SPKG[R1400]->COMM_COMM[R1402];
return cardinality communications;',
	1,
	'',
	7023);
INSERT INTO O_TFR
	VALUES (7026,
	2798,
	'getCommunicationId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many communications related by self->EP_SPKG[R1400]->COMM_COMM[R1402];
// We''re preincrementing the index
count = -1;
for each communication in communications
  if (not_empty communication)
      count = count+1;
  end if;
  if (count == param.index)
      return communication.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7025);
INSERT INTO O_TPARM
	VALUES (7027,
	7026,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7028,
	2798,
	'getCompPckgCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many compPckgs related by self->EP_SPKG[R1400]->CP_CP[R1402];
return cardinality compPckgs;',
	1,
	'',
	7026);
INSERT INTO O_TFR
	VALUES (7029,
	2798,
	'getCompPckgId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many compPckgs related by self->EP_SPKG[R1400]->CP_CP[R1402];
// We''re preincrementing the index
count = -1;
for each compPckg in compPckgs
  if (not_empty compPckg)
      count = count+1;
  end if;
  if (count == param.index)
      return compPckg.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7028);
INSERT INTO O_TPARM
	VALUES (7030,
	7029,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7031,
	2798,
	'getDatatypePckgCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many datatypePckgs related by self->EP_SPKG[R1400]->S_DPK[R1402];
return cardinality datatypePckgs;',
	1,
	'',
	7029);
INSERT INTO O_TFR
	VALUES (7032,
	2798,
	'getDatatypePckgId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many datatypePckgs related by self->EP_SPKG[R1400]->S_DPK[R1402];
// We''re preincrementing the index
count = -1;
for each datatypePckg in datatypePckgs
  if (not_empty datatypePckg)
      count = count+1;
  end if;
  if (count == param.index)
      return datatypePckg.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7031);
INSERT INTO O_TPARM
	VALUES (7033,
	7032,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7034,
	2798,
	'getInterfacePckgCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many interfacePckgs related by self->EP_SPKG[R1400]->IP_IP[R1402];
return cardinality interfacePckgs;',
	1,
	'',
	7032);
INSERT INTO O_TFR
	VALUES (7035,
	2798,
	'getInterfacePckgId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many interfacePckgs related by self->EP_SPKG[R1400]->IP_IP[R1402];
// We''re preincrementing the index
count = -1;
for each interfacePckg in interfacePckgs
  if (not_empty interfacePckg)
      count = count+1;
  end if;
  if (count == param.index)
      return interfacePckg.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7034);
INSERT INTO O_TPARM
	VALUES (7036,
	7035,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7037,
	2798,
	'getSequenceId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many sequences related by self->EP_SPKG[R1400]->SQ_S[R1402];
// We''re preincrementing the index
count = -1;
for each sequence in sequences
  if (not_empty sequence)
      count = count+1;
  end if;
  if (count == param.index)
      return sequence.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7035);
INSERT INTO O_TPARM
	VALUES (7038,
	7037,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7039,
	2798,
	'getSequenceCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many sequences related by self->EP_SPKG[R1400]->SQ_S[R1402];
return cardinality sequences;',
	1,
	'',
	7037);
INSERT INTO O_TFR
	VALUES (7040,
	2798,
	'getUseCaseCount',
	'',
	298,
	1,
	'select many usecases related by self->PE_PE[R8000]->SQ_P[R8001]->IA_UCP[R930];
return cardinality usecases;',
	1,
	'',
	7039);
INSERT INTO O_TFR
	VALUES (7041,
	2798,
	'getUseCaseId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many usecases related by self->PE_PE[R8000]->SQ_P[R8001]->IA_UCP[R930];
// We''re preincrementing the index
count = -1;
for each usecase in usecases
  count = count + 1;
  if(count == param.index)
    return usecase.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7040);
INSERT INTO O_TPARM
	VALUES (7042,
	7041,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7043,
	2798,
	'collectVisibleElementsForName',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Package::collectVisibleElementsForName()
// This operation is recursive. It is designed to be called in multiple places,
// both when preparing selection lists and from the parser.
// It originally gets called from the place where a reference is being evaluated
// for visibility. The originating package id is the id of the package that
// contains the reference being evaluated. The originating call takes the form:
// pkg.collectVisibleElementsForName(name:"element name or *",
//                 type:ElementTypeConstants::requiredType,
//                          considerPublicOnly:false, considerParents:true,
//                                          originatingPkgID:self.Package_ID,
//                                       delegatingPkgID: GD::NULL_UNIQUE_ID(),
//                       findFirst:<true for parser use, false for picker use>);
// If findFirst is true, this operation can returns a newline delimited string
// list of duplicate names, if duplicates are found. Otherwise it returns the
// empty string.
// See also: Component.collectElementsForName()
select any originatingPackagePE from instances of PE_PE where
                            selected.Element_ID == param.originatingContainerID;
select one originatingPackage related by originatingPackagePE->EP_PKG[R8001];
if self == originatingPackage
  select any resultSet related by self->PE_SRS[R8005] where
                    selected.Name == param.name and selected.Type == param.type;
  if not_empty resultSet
    // search has already been made and cached, just return immediately;
    return;
  else
    // create the search set
    create object instance resultSet of PE_SRS;
    resultSet.Name = param.name;
    resultSet.Type = param.type;
    relate self to resultSet across R8005;
  end if;
  // Visit all child elements
  select many elements related by self->PE_PE[R8000];
  for each element in elements
    // visit all elements, regardless of visibility
    element.collectVisibleElementsForName(name:param.name, type:param.type,
          descending:true, originatingContainerID: param.originatingContainerID,
                                          delegatingPkgID:GD::NULL_UNIQUE_ID(),
                                         collectGlobally:param.collectGlobally);
  end for;
else // not originating package
  // Visit all child elements
  select many elements related by self->PE_PE[R8000];
  for each element in elements
    // visit all elements, if they are visible
    if element.getVisibilityValue() == Visibility::Public or
                                                   param.descending == false and
                           element.getVisibilityValue() == Visibility::Protected
      element.collectVisibleElementsForName(name:param.name, type:param.type,
         descending:true, originatingContainerID: param.originatingContainerID,
                                         delegatingPkgID:param.delegatingPkgID,
                                         collectGlobally:param.collectGlobally);
    end if;
  end for;
end if;
if param.descending == false
  // We are ascending the hierarchy. Consider all parents,
  select one parentPkg related by self->PE_PE[R8001]->EP_PKG[R8000];
  if not_empty parentPkg
    select one parentPkgElem related by parentPkg->PE_PE[R8001];
    if not_empty parentPkgElem
      parentPkgElem.collectVisibleElementsForName(name:param.name,
                                    type:param.type, descending:false,
                       originatingContainerID: param.originatingContainerID,
                                               delegatingPkgID:self.Package_ID,
                                         collectGlobally:param.collectGlobally);
    else
      // TODO this covers the case that system level packages do not have
      // a Packageable Element supertype. We must arrange it so that they do
      // or else they will not be collected. See the way System level data
      // types are upgraded so that they can be collected.
      parentPkg.collectVisibleElementsForName(name:param.name, type:param.type,
         descending:false, originatingContainerID: param.originatingContainerID,
        delegatingPkgID:self.Package_ID, collectGlobally:param.collectGlobally);
    end if;
  else
    // Are we under a component?
    select one parentComponent related by self->PE_PE[R8001]->C_C[R8003];
    if not_empty parentComponent
      parentComponent.collectVisibleElementsForName(name:param.name,
        type:param.type, originatingContainerID: param.originatingContainerID,
                                         delegatingContainerID:self.Package_ID,
                                         collectGlobally:param.collectGlobally);
    else
      select one system related by self->S_SYS[R1401];
      if not_empty system
        system.collectVisibleElementsForName(name:param.name, descending:false,
        type:param.type, originatingContainerID: param.originatingContainerID,
                                         delegatingContainerID:self.Package_ID,
                                         collectGlobally:param.collectGlobally);
              end if;
            end if;
  end if;
end if;',
	1,
	'',
	7041);
INSERT INTO O_TPARM
	VALUES (7044,
	7043,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (7045,
	7043,
	'type',
	2878,
	0,
	'',
	7044,
	'');
INSERT INTO O_TPARM
	VALUES (7046,
	7043,
	'descending',
	316,
	0,
	'',
	7045,
	'');
INSERT INTO O_TPARM
	VALUES (7047,
	7043,
	'originatingContainerID',
	296,
	0,
	'',
	7046,
	'');
INSERT INTO O_TPARM
	VALUES (7048,
	7043,
	'delegatingPkgID',
	296,
	0,
	'',
	7047,
	'');
INSERT INTO O_TPARM
	VALUES (7049,
	7043,
	'collectGlobally',
	316,
	0,
	'',
	7048,
	'');
INSERT INTO O_TFR
	VALUES (7050,
	2798,
	'getQualifiedName',
	'',
	322,
	1,
	'//Package::getQualifiedName()
result = "";
select one package related by self->PE_PE[R8001]->EP_PKG[R8000];
if not_empty package
  result = package.getQualifiedName();
else
  select one comp related by self->PE_PE[R8001]->C_C[R8003];
  if not_empty comp
    result = comp.getQualifiedName();
  else
    select one system related by self->S_SYS[R1401];
    if not_empty system
      result = system.Name;
    end if;
  end if;
end if;
if result != ""
  result = result + "::";
end if;
result = result + self.Name;
return result;',
	1,
	'',
	7043);
INSERT INTO O_TFR
	VALUES (7051,
	2798,
	'newLink',
	'',
	316,
	1,
	'select any fromParticipant from instances of SQ_P where (selected.Part_ID == param.from);
select any toParticipant from instances of SQ_P where (selected.Part_ID == param.to);
// it only matters that there is a toParticipant
if(not_empty toParticipant) and (not_empty fromParticipant)
  create object instance link of COMM_LNK;
  relate link to toParticipant across R1134;
  relate link to fromParticipant across R1133;
  link.initialize();
  return true;
end if;
return false;
',
	1,
	'',
	7052);
INSERT INTO O_TPARM
	VALUES (7053,
	7051,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (7054,
	7051,
	'fromIsImported',
	316,
	0,
	'',
	7053,
	'');
INSERT INTO O_TPARM
	VALUES (7055,
	7051,
	'to',
	296,
	0,
	'',
	7054,
	'');
INSERT INTO O_TPARM
	VALUES (7056,
	7051,
	'toIsImported',
	316,
	0,
	'',
	7055,
	'');
INSERT INTO O_TFR
	VALUES (6865,
	2798,
	'pasteUserDatatype',
	'',
	19,
	1,
	'select any udt from instances of S_UDT where (selected.DT_ID == param.id);
if(not_empty udt)  
  // select the previous dt
  select one dt related by udt->S_DT[R17];
  // guarantee a unique name for the pasted dt
  dt.Name = ::getUniqueInitialNameInParent(instance:dt.convertToInstance(),
  						name:dt.Name, parent:self.convertToInstance());
  select one pe related by dt->PE_PE[R8001];
  relate pe to self across R8000;
end if;',
	1,
	'',
	6863);
INSERT INTO O_TPARM
	VALUES (7057,
	6865,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6867,
	2798,
	'pasteActorParticipant',
	'',
	19,
	1,
	'select any actor from instances of SQ_AP where (selected.Part_ID == param.id);
if(not_empty actor)
  select one part related by actor->SQ_P[R930];
  select one pe related by part->PE_PE[R8001];
  relate self to pe across R8000;
end if;
',
	1,
	'',
	6864);
INSERT INTO O_TPARM
	VALUES (7058,
	6867,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6869,
	2798,
	'pasteUseCaseParticipant',
	'',
	19,
	1,
	'select any ucp from instances of IA_UCP where (selected.Part_ID == param.id);
if(not_empty ucp)
  select one pe related by ucp->SQ_P[R930]->PE_PE[R8001];
  relate self to pe across R8000;
end if;',
	1,
	'',
	6866);
INSERT INTO O_TPARM
	VALUES (7059,
	6869,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6875,
	2798,
	'pasteAssociation',
	'',
	19,
	1,
	'// This operation handles association paste for both the Use Case Association
// and the Class Association.  
//

// first see if this is Use Case
select any uca from instances of UC_UCA where (selected.Assoc_ID == param.id);
if(not_empty uca)
  select one pe related by uca->PE_PE[R8001];
  relate self to pe across R8000;
  return;
end if;

// now see if this is a class association
select any rel from instances of R_REL where (selected.Rel_ID == param.id);
if(not_empty rel)
  select one pe related by rel->PE_PE[R8001];
  select one existingPkg related by pe->EP_PKG[R8000];
  relateToPkg = true;
  if(not_empty existingPkg)
    if(existingPkg != self)
      unrelate existingPkg from pe across R8001;
    else
      relateToPkg = false;
    end if;
  end if;
  if(relateToPkg)
    select many assocs related by self->PE_PE[R8000]->R_REL[R8001];
    for each assoc in assocs
      // if this other association''s number is 
      // greater than this association''s number
      if (assoc.Numb >= rel.Numb)
        // have this association''s number be just greater 
        // than this other association''s number
        rel.Numb = assoc.Numb + 1;
      end if;
    end for;      
    relate self to pe across R8000;
  end if;
end if;

',
	1,
	'',
	6868);
INSERT INTO O_TPARM
	VALUES (7060,
	6875,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6877,
	2798,
	'pasteSendSignal',
	'',
	19,
	1,
	'select any ss from instances of A_SS where (selected.Id == param.id);
if(not_empty ss)
  select one pe related by ss->A_ACT[R1107]->A_N[R1105]->PE_PE[R8001];
  relate self to pe across R8000;
end if;',
	1,
	'',
	6874);
INSERT INTO O_TPARM
	VALUES (7061,
	6877,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6879,
	2798,
	'pasteActivityDiagramAction',
	'',
	19,
	1,
	'select any ga from instances of A_GA where (selected.Id == param.id);
if(not_empty ga)
  select one pe related by ga->A_ACT[R1107]->A_N[R1105]->PE_PE[R8001];  
  relate self to pe across R8000;
end if;',
	1,
	'',
	6876);
INSERT INTO O_TPARM
	VALUES (7062,
	6879,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6881,
	2798,
	'pasteModelClass',
	'',
	19,
	1,
	'select any cl from instances of O_OBJ where (selected.Obj_ID == param.id);
if(not_empty cl)
  select one pe related by cl->PE_PE[R8001];
  relate self to pe across R8000;

  select many attributes related by cl->O_ATTR[R102];
  // handle pasting of attributes
  for each attribute in attributes
    result = cl.removeIncompleteReferential(id:attribute.Attr_ID);
  end for;
  cl.rename(new_name: ::getUniqueInitialNameInParent(instance:cl.convertToInstance(),
  						name:cl.Name, parent:self.convertToInstance()));
  cl.removeIncompleteNonLocalEvents();
end if;',
	1,
	'',
	6878);
INSERT INTO O_TPARM
	VALUES (7063,
	6881,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6883,
	2798,
	'pasteAcceptEventAction',
	'',
	19,
	1,
	'select any aea from instances of A_AEA where (selected.Id == param.id);
if(not_empty aea)
  select one pe related by aea->A_AE[R1112]->A_ACT[R1107]->A_N[R1105]
                                                                 ->PE_PE[R8001];  
  relate self to pe across R8000;
end if;',
	1,
	'',
	6880);
INSERT INTO O_TPARM
	VALUES (7064,
	6883,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6885,
	2798,
	'pasteAcceptTimeEventAction',
	'',
	19,
	1,
	'select any ate from instances of A_ATE where (selected.Id == param.id);
if(not_empty ate)
  select one pe related by ate->A_AE[R1112]->A_ACT[R1107]->A_N[R1105]
                                                                 ->PE_PE[R8001];  
  relate self to pe across R8000;
end if;',
	1,
	'',
	6882);
INSERT INTO O_TPARM
	VALUES (7065,
	6885,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6887,
	2798,
	'pasteComponent',
	'',
	19,
	1,
	'select any comp from instances of C_C where (selected.Id == param.id);
if(not_empty comp)
  select one pe related by comp->PE_PE[R8001];
  relate self to pe across R8000;
  comp.rename(new_name: ::getUniqueInitialNameInParent(instance:comp.convertToInstance(),
                name:comp.Name, parent:self.convertToInstance()));
  select one system related by self->S_SYS[R1405];
  comp.associatePackagesWithSystem(id:system.Sys_ID);
  // for any non local event below this package
  // remove incomplete ones (those that are not
  // resolvable)
  comp.removeIncompleteSignalEvents();
end if;',
	1,
	'',
	6884);
INSERT INTO O_TPARM
	VALUES (7066,
	6887,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6894,
	2798,
	'pasteProvision',
	'',
	19,
	1,
	'select any provision from instances of C_P
                                      where (selected.Provision_Id == param.id);
if(not_empty provision)
  // dispose any satisfactions that are not complete
  // this can occur because the export includes them
  // regardless of whether or not they are complete
  select many satisfactions related by provision->C_SF[R4002];
  for each satisfaction in satisfactions
    select one requirement related by satisfaction->C_R[R4002];
    if(not_empty requirement
                     and Util::isProxy(element:requirement.convertToInstance()))
      // if this satisfaction is connected to an imported requirement, that
      // is not a proxy, we do not want to dispose
      select one importedReq related by satisfaction->CL_IR[R4706];
      if(empty importedReq 
                      or Util::isProxy(element:importedReq.convertToInstance()))
        satisfaction.dispose();
      end if;
    end if;
  end for;
end if;
',
	1,
	'',
	6888);
INSERT INTO O_TPARM
	VALUES (7067,
	6894,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6900,
	2798,
	'pasteRequirement',
	'',
	19,
	1,
	'// just need this to exist for the infrastructure to allow the copy',
	1,
	'',
	6893);
INSERT INTO O_TPARM
	VALUES (7068,
	6900,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6902,
	2798,
	'pasteInterface',
	'',
	19,
	1,
	'select any interface from instances of C_I where (selected.Id == param.id);
if(not_empty interface)
  select one pe related by interface->PE_PE[R8001];
  relate self to pe across R8000;
  interface.Name = ::getUniqueInitialNameInParent(instance:interface.convertToInstance(), 
    name:interface.Name, parent:self.convertToInstance());
end if;',
	1,
	'',
	6899);
INSERT INTO O_TPARM
	VALUES (7069,
	6902,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6904,
	2798,
	'pasteConstantSpecification',
	'',
	19,
	1,
	'select any csp from instances of CNST_CSP where (selected.Constant_Spec_ID == param.id);
if(not_empty csp)
  select one pe related by csp->PE_PE[R8001];
  relate self to pe across R8000;
end if;',
	1,
	'',
	6901);
INSERT INTO O_TPARM
	VALUES (7070,
	6904,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6906,
	2798,
	'pasteEnumerationDatatype',
	'',
	19,
	1,
	'select any enum from instances of S_EDT where (selected.DT_ID == param.id);
if(not_empty enum)
  // select the previous dt
  select one dt related by enum->S_DT[R17];
  // guarantee a unique name for the pasted dt
  dt.Name = ::getUniqueInitialNameInParent(instance:dt.convertToInstance(),
                        name:dt.Name, parent:self.convertToInstance());
  select one pe related by dt->PE_PE[R8001];
  relate pe to self across R8000; 
end if;',
	1,
	'',
	6903);
INSERT INTO O_TPARM
	VALUES (7071,
	6906,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6908,
	2798,
	'pasteStructuredDatatype',
	'',
	19,
	1,
	'select any sdt from instances of S_SDT where (selected.DT_ID == param.id);
if(not_empty sdt)
  select one dt related by sdt->S_DT[R17];
  // guarantee a unique name for the pasted dt
  dt.Name = ::getUniqueInitialNameInParent(instance:dt.convertToInstance(),
                        name:dt.Name, parent:self.convertToInstance());
  select one pe related by dt->PE_PE[R8001];
  relate pe to self across R8000;
end if;',
	1,
	'',
	6905);
INSERT INTO O_TPARM
	VALUES (7072,
	6908,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6914,
	2798,
	'pasteGeneralization',
	'',
	19,
	1,
	'select any gen from instances of UC_G where (selected.Assoc_ID == param.id);
if(not_empty gen)
  select one assoc related by gen->UC_UCA[R1210];
  select one pe related by assoc->PE_PE[R8001];
  relate self to pe across R8000;
end if;',
	1,
	'',
	6907);
INSERT INTO O_TPARM
	VALUES (7073,
	6914,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6920,
	2798,
	'pasteInclude',
	'',
	19,
	1,
	'select any inc from instances of UC_I where (selected.Assoc_ID == param.id);
if(not_empty inc)
  select one pe related by inc->UC_UCA[R1210]->PE_PE[R8001];
  relate self to pe across R8000;
end if;',
	1,
	'',
	6913);
INSERT INTO O_TPARM
	VALUES (7074,
	6920,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6926,
	2798,
	'pasteExtend',
	'',
	19,
	1,
	'select any extend from instances of UC_E where (selected.Assoc_ID == param.id);
if(not_empty extend)
  select one association related by extend->UC_UCA[R1210];
  select one pe related by association->PE_PE[R8001];
  relate self to pe across R8000;
end if;',
	1,
	'',
	6919);
INSERT INTO O_TPARM
	VALUES (7075,
	6926,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6932,
	2798,
	'pasteActivityPartition',
	'',
	19,
	1,
	'select any ap from instances of A_AP where (selected.Id == param.id);
if(not_empty ap)
  select one pe related by ap->PE_PE[R8001];
  relate self to pe across R8000;
end if;',
	1,
	'',
	6925);
INSERT INTO O_TPARM
	VALUES (7076,
	6932,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6934,
	2798,
	'pasteObjectNode',
	'',
	19,
	1,
	'select any obj from instances of A_OBJ where (selected.Id == param.id);
if(not_empty obj)
  select one pe related by obj->A_N[R1105]->PE_PE[R8001];
  relate self to pe across R8000;
end if;',
	1,
	'',
	6931);
INSERT INTO O_TPARM
	VALUES (7077,
	6934,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6940,
	2798,
	'pasteActivityEdge',
	'',
	19,
	1,
	'select any ae from instances of A_E where (selected.Id == param.id);
if(not_empty ae)
  select one pe related by ae->PE_PE[R8001];
  relate self to pe across R8000;
end if;',
	1,
	'',
	6933);
INSERT INTO O_TPARM
	VALUES (7078,
	6940,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6946,
	2798,
	'pasteForkJoinNode',
	'',
	19,
	1,
	'select any fj from instances of A_FJ where (selected.Id == param.id);
if(not_empty fj)
  select one pe related by fj->A_CTL[R1106]->A_N[R1105]->PE_PE[R8001];
  relate self to pe across R8000;
end if;',
	1,
	'',
	6939);
INSERT INTO O_TPARM
	VALUES (7079,
	6946,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6948,
	2798,
	'pasteDecisionMergeNode',
	'',
	19,
	1,
	'select any dmn from instances of A_DM where (selected.Id == param.id);
if(not_empty dmn)
  select one pe related by dmn->A_CTL[R1106]->A_N[R1105]->PE_PE[R8001];
  relate self to pe across R8000;
end if;',
	1,
	'',
	6945);
INSERT INTO O_TPARM
	VALUES (7080,
	6948,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6950,
	2798,
	'pasteInitialNode',
	'',
	19,
	1,
	'select any ini from instances of A_INI where (selected.Id == param.id);
if(not_empty ini)
  select one pe related by ini->A_CTL[R1106]->A_N[R1105]->PE_PE[R8001];
  relate self to pe across R8000;
end if;',
	1,
	'',
	6947);
INSERT INTO O_TPARM
	VALUES (7081,
	6950,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6952,
	2798,
	'pasteActivityFinalNode',
	'',
	19,
	1,
	'select any afn from instances of A_AF where (selected.Id == param.id);
if(not_empty afn)
  select one pe related by afn->A_CTL[R1106]->A_N[R1105]->PE_PE[R8001];
  relate self to pe across R8000;
end if;',
	1,
	'',
	6949);
INSERT INTO O_TPARM
	VALUES (7082,
	6952,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6954,
	2798,
	'pasteFlowFinalNode',
	'',
	19,
	1,
	'select any ff from instances of A_FF where (selected.Id == param.id);
if(not_empty ff)
  select one pe related by ff->A_CTL[R1106]->A_N[R1105]->PE_PE[R8001];
  relate self to pe across R8000;
end if;',
	1,
	'',
	6951);
INSERT INTO O_TPARM
	VALUES (7083,
	6954,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6956,
	2798,
	'pasteClassInstanceParticipant',
	'',
	19,
	1,
	'select any cip from instances of SQ_CIP where (selected.Part_ID == param.id);
if(not_empty cip)
  select one part related by cip->SQ_P[R930];
  select one pe related by part->PE_PE[R8001];
  relate self to pe across R8000;
end if;',
	1,
	'',
	6953);
INSERT INTO O_TPARM
	VALUES (7084,
	6956,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6958,
	2798,
	'pasteExternalEntityParticipant',
	'',
	19,
	1,
	'select any eep from instances of SQ_EEP where (selected.Part_ID == param.id);
if(not_empty eep)
  select one part related by eep->SQ_P[R930];
  select one pe related by part->PE_PE[R8001];
  relate self to pe across R8000;
end if;',
	1,
	'',
	6955);
INSERT INTO O_TPARM
	VALUES (7085,
	6958,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6964,
	2798,
	'pasteLifeSpan',
	'',
	19,
	1,
	'select any ls from instances of SQ_LS where (selected.Part_ID == param.id);
if(not_empty ls)
  select one pe related by ls->SQ_P[R930]->PE_PE[R8001];
  relate self to pe across R8000;
end if;',
	1,
	'',
	6957);
INSERT INTO O_TPARM
	VALUES (7086,
	6964,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6966,
	2798,
	'pasteClassParticipant',
	'',
	19,
	1,
	'select any cp from instances of SQ_CP where (selected.Part_ID == param.id);
if(not_empty cp)
  select one part related by cp->SQ_P[R930];
  select one pe related by part->PE_PE[R8001];
  relate self to pe across R8000;
end if;',
	1,
	'',
	6963);
INSERT INTO O_TPARM
	VALUES (7087,
	6966,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6972,
	2798,
	'pasteTimingMark',
	'',
	19,
	1,
	'// just need this to exist for the infrastructure to allow the copy',
	1,
	'',
	6965);
INSERT INTO O_TPARM
	VALUES (7088,
	6972,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6978,
	2798,
	'pasteTimeSpan',
	'',
	19,
	1,
	'// just need this to exist for the infrastructure to allow the copy',
	1,
	'',
	6971);
INSERT INTO O_TPARM
	VALUES (7089,
	6978,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6984,
	2798,
	'pasteSynchronousMessage',
	'',
	19,
	1,
	'select any sm from instances of MSG_SM where (selected.Msg_ID == param.id);
if(not_empty sm)
  select one pe related by sm->MSG_M[R1018]->PE_PE[R8001];
  relate self to pe across R8000;
end if;',
	1,
	'',
	6977);
INSERT INTO O_TPARM
	VALUES (7090,
	6984,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6990,
	2798,
	'pasteAsynchronousMessage',
	'',
	19,
	1,
	'select any am from instances of MSG_AM where (selected.Msg_ID == param.id);
if(not_empty am)
  select one message related by am->MSG_M[R1018];
  select one pe related by message->PE_PE[R8001];
  relate self to pe across R8000;
end if;',
	1,
	'',
	6983);
INSERT INTO O_TPARM
	VALUES (7091,
	6990,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7052,
	2798,
	'pasteReturnMessage',
	'',
	19,
	1,
	'select any rm from instances of MSG_R where (selected.Msg_ID == param.id);
if(not_empty rm)
  select one pe related by rm->MSG_M[R1018]->PE_PE[R8001];
  relate self to pe across R8000;
end if;',
	1,
	'',
	6989);
INSERT INTO O_TPARM
	VALUES (7092,
	7052,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6996,
	2798,
	'pasteCommunicationLink',
	'',
	19,
	1,
	'// nothing to do, it will be fully copied',
	1,
	'',
	7051);
INSERT INTO O_TPARM
	VALUES (7093,
	6996,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (6998,
	2798,
	'pasteComponentParticipant',
	'',
	19,
	1,
	'select any cop from instances of SQ_COP where (selected.Part_ID == param.id);
if(not_empty cop)
  select one part related by cop->SQ_P[R930];
  select one pe related by part->PE_PE[R8001];
  relate self to pe across R8000;
end if;',
	1,
	'',
	6995);
INSERT INTO O_TPARM
	VALUES (7094,
	6998,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7000,
	2798,
	'pasteImportedClass',
	'',
	19,
	1,
	'select any iobj from instances of O_IOBJ where (selected.IObj_ID == param.id);
if(not_empty iobj)
  select one pe related by iobj->PE_PE[R8001];
  relate self to pe across R8000;
end if;',
	1,
	'',
	6997);
INSERT INTO O_TPARM
	VALUES (7095,
	7000,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7017,
	2798,
	'pasteExternalEntity',
	'',
	19,
	1,
	'select any ee from instances of S_EE where (selected.EE_ID == param.id);
if(not_empty ee)
  select one pe related by ee->PE_PE[R8001];
  relate self to pe across R8000;
  ee.Name = ::getUniqueInitialNameInParent(instance:ee.convertToInstance(),
    name:ee.Name, parent:self.convertToInstance());
end if;',
	1,
	'',
	7015);
INSERT INTO O_TPARM
	VALUES (7096,
	7017,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7019,
	2798,
	'pasteFunction',
	'',
	19,
	1,
	'select any sync from instances of S_SYNC where (selected.Sync_ID == param.id);
if(not_empty sync)
  select one pe related by sync->PE_PE[R8001];
  relate self to pe across R8000;
  sync.Name = ::getUniqueInitialNameInParent(instance:sync.convertToInstance(),
    name:sync.Name, parent:self.convertToInstance());
end if;',
	1,
	'',
	7016);
INSERT INTO O_TPARM
	VALUES (7097,
	7019,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7098,
	2798,
	'clearScope',
	'',
	19,
	1,
	'// Package.clearScope()
// dispose all search results
select many srs related by self->PE_SRS[R8005];
for each sr in srs
  sr.dispose();
end for;',
	1,
	'',
	7050);
INSERT INTO O_TFR
	VALUES (7099,
	2798,
	'getContainingComponentId',
	'',
	296,
	1,
	'// Package.getContainingComponentId()
select one package related by self->PE_PE[R8001]->EP_PKG[R8000];
select one component related by self->PE_PE[R8001]->C_C[R8003];
if not_empty package
  return package.getContainingComponentId();
end if;
if not_empty component
  return component.Id;
end if;
return GD::NULL_UNIQUE_ID();',
	1,
	'',
	7098);
INSERT INTO O_TFR
	VALUES (7100,
	2798,
	'initializeClasses',
	'',
	19,
	1,
	'// Package.initializeClasses()
// Initialize classes ready for Verifier execution
select any compInst from instances of I_EXE where
                               selected.Execution_Engine_ID == param.compInstID;
select many classes related by self->PE_PE[R8000]->O_OBJ[R8001];
select many packages related by self->PE_PE[R8000]->EP_PKG[R8001];
for each package in packages
  package.initializeClasses(compInstID:param.compInstID);
end for;',
	1,
	'',
	7099);
INSERT INTO O_TPARM
	VALUES (7101,
	7100,
	'compInstID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7102,
	2798,
	'isExecutingOrIsChildExecuting',
	'',
	316,
	1,
	'// Package.isExecutingOrIsChildExecuting()
select one compInst related by self->I_EXE[R2970];
if not_empty compInst
  return true;
end if;
select many packages related by self->PE_PE[R8000]->EP_PKG[R8001];
for each childPkg in packages
  if childPkg.isExecutingOrIsChildExecuting()
    return true;
  end if;
end for;
select many components related by self->PE_PE[R8000]->C_C[R8001];
for each component in components
  if component.isExecutingOrIsChildExecuting();
    return true;
  end if;
end for;
select many compRefs related by self->PE_PE[R8000]->CL_IC[R8001];
for each compRef in compRefs
  if compRef.isExecuting()
    return true;
  end if; 
end for;
return false;',
	1,
	'',
	7100);
INSERT INTO O_TFR
	VALUES (7103,
	2798,
	'isExecutingOrOwnsExecutableElements',
	'',
	316,
	1,
	'// Package.isExecutingOrOwnsExecutableElements()
return self.isExecutingOrIsChildExecuting() or
                     self.ownsExecutableElementsOrChildOwnsExecutableElements();',
	1,
	'',
	7102);
INSERT INTO O_TFR
	VALUES (7104,
	2798,
	'ownsExecutableElementsOrChildOwnsExecutableElements',
	'',
	316,
	1,
	'// Package.ownsExecutableElementsOrChildOwnsExecutableElements()
select any func related by self->PE_PE[R8000]->S_SYNC[R8001];
if not_empty func
  return true; 
end if;
select any modelClass related by self->PE_PE[R8000]->O_OBJ[R8001];
if not_empty modelClass
  return true; 
end if;
select any comp related by self->PE_PE[R8000]->C_C[R8001];
if not_empty comp
  return true; 
end if;
select any compR related by self->PE_PE[R8000]->CL_IC[R8001];
if not_empty compR
  return true; 
end if;
select many packages related by self->PE_PE[R8000]->EP_PKG[R8001];
for each childPkg in packages
  if childPkg.ownsExecutableElementsOrChildOwnsExecutableElements()
    return true;
  end if;
end for;
return false;',
	1,
	'',
	7103);
INSERT INTO O_TFR
	VALUES (7105,
	2798,
	'pasteComponentReference',
	'',
	19,
	1,
	'select any cr from instances of CL_IC where (selected.Id == param.id);
if(not_empty cr)
  select one pe related by cr->PE_PE[R8001];
  relate self to pe across R8000;
end if;
',
	1,
	'',
	7104);
INSERT INTO O_TPARM
	VALUES (7106,
	7105,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7107,
	2798,
	'pasteClassAsLink',
	'',
	19,
	1,
	'self.pasteAssociation(id:param.id);
',
	1,
	'',
	7105);
INSERT INTO O_TPARM
	VALUES (7108,
	7107,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7109,
	2798,
	'pasteClassAsSubtype',
	'',
	19,
	1,
	'select any subtype from instances of R_SUB where (selected.OIR_ID == param.id);
if(not_empty subtype)
  select one assoc related by subtype->R_SUBSUP[R213]->R_REL[R206];
  self.pasteAssociation(id:assoc.Rel_ID);
end if;
',
	1,
	'',
	7107);
INSERT INTO O_TPARM
	VALUES (7110,
	7109,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7111,
	2798,
	'pasteBinaryAssociation',
	'',
	19,
	1,
	'select any binaryAssoc from instances of UC_BA where (selected.Assoc_ID == param.id);
if(not_empty binaryAssoc)
  select one association related by binaryAssoc->UC_UCA[R1210];
  select one pe related by association->PE_PE[R8001];
  relate self to pe across R8000;
end if;',
	1,
	'',
	7109);
INSERT INTO O_TPARM
	VALUES (7112,
	7111,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7113,
	2798,
	'canCopyCoreDataType',
	'',
	316,
	1,
	'return false;',
	1,
	'',
	7111);
INSERT INTO O_TPARM
	VALUES (7114,
	7113,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7115,
	2798,
	'canCopyUserDataType',
	'',
	316,
	1,
	'select any udt from instances of S_UDT where (selected.DT_ID == param.id);
if(not_empty udt)
  if(udt.Gen_Type == 0)
    return true;
  end if;
end if;
return false;',
	1,
	'',
	7113);
INSERT INTO O_TPARM
	VALUES (7116,
	7115,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7117,
	2798,
	'newComponentPackage',
	'',
	19,
	1,
	'create object instance package of CP_CP;
create object instance sp of EP_SPKG;
relate self to sp across R1400;
relate package to sp across R1402;
select any system from instances of S_SYS
                                  where (selected.Sys_ID == self.getSystemId());
relate package to system across R4606;
package.initialize();',
	1,
	'',
	7115);
INSERT INTO O_TFR
	VALUES (7118,
	2798,
	'newInterfacePackage',
	'',
	19,
	1,
	'create object instance interfacePackage of IP_IP;
create object instance sp of EP_SPKG;
relate sp to interfacePackage across R1402;
relate sp to self across R1400;
select any system from instances of S_SYS
                                  where (selected.Sys_ID == self.getSystemId());
relate system to interfacePackage across R4304;
interfacePackage.initialize();',
	1,
	'',
	7117);
INSERT INTO O_TFR
	VALUES (7119,
	2798,
	'newActivity',
	'',
	19,
	1,
	'create object instance a of A_A;
create object instance sp of EP_SPKG;
relate self to sp across R1400;
relate a to sp across R1402;
a.initialize();',
	1,
	'',
	7118);
INSERT INTO O_TFR
	VALUES (7120,
	2798,
	'newUseCasePackage',
	'',
	19,
	1,
	'create object instance ucc of UC_UCC;
create object instance sp of EP_SPKG;
relate self to sp across R1400;
relate sp to ucc across R1402;
ucc.initialize();',
	1,
	'',
	7119);
INSERT INTO O_TFR
	VALUES (7121,
	2798,
	'newSequence',
	'',
	19,
	1,
	'create object instance sequence of SQ_S;
create object instance sp of EP_SPKG;
relate self to sp across R1400;
relate sp to sequence across R1402;
sequence.initialize();',
	1,
	'',
	7120);
INSERT INTO O_TFR
	VALUES (7122,
	2798,
	'newCommunication',
	'',
	19,
	1,
	'create object instance comm of COMM_COMM;
create object instance sp of EP_SPKG;
relate sp to self across R1400;
relate comm to sp across R1402;
comm.initialize();',
	1,
	'',
	7121);
INSERT INTO O_TFR
	VALUES (7123,
	2798,
	'newDatatypePackage',
	'',
	19,
	1,
	'create object instance dPkg of S_DPK;
create object instance sp of EP_SPKG;
relate self to sp across R1400;
relate sp to dPkg across R1402;
dPkg.initialize();',
	1,
	'',
	7122);
INSERT INTO O_TFR
	VALUES (7124,
	2798,
	'newPackageParticipant',
	'',
	19,
	1,
	'create object instance participant of SQ_P;
create object instance pp of SQ_PP;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate participant to pe across R8001;
relate pe to self across R8000;
pe.type = ElementTypeConstants::INTERACTION_PARTICIPANT;
pe.initialize();
relate participant to pp across R930;
pp.initialize();',
	1,
	'',
	7123);
INSERT INTO O_TFR
	VALUES (7125,
	2798,
	'pastePackageParticipant',
	'',
	19,
	1,
	'select any pp from instances of SQ_PP where (selected.Part_ID == param.id);
if(not_empty pp)
  select one pe related by pp->SQ_P[R930]->PE_PE[R8001];
  relate self to pe across R8000;
end if;',
	1,
	'',
	7124);
INSERT INTO O_TPARM
	VALUES (7126,
	7125,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7127,
	2798,
	'getUdtCount',
	'',
	298,
	1,
	'select many udts related by self->PE_PE[R8000]->S_DT[R8001]->S_UDT[R17];
return cardinality udts;',
	1,
	'',
	7125);
INSERT INTO O_TFR
	VALUES (7128,
	2798,
	'getUdtId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many udts related by self->PE_PE[R8000]->S_DT[R8001]->S_UDT[R17];
// We''re preincrementing the index
count = -1;
for each udt in udts
  count = count + 1;
  if(count == param.index)
    return udt.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7127);
INSERT INTO O_TPARM
	VALUES (7129,
	7128,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7130,
	2798,
	'getActorCount',
	'',
	298,
	1,
	'select many actors related by self->PE_PE[R8000]->SQ_P[R8001]->SQ_AP[R930];
return cardinality actors;',
	1,
	'',
	7128);
INSERT INTO O_TFR
	VALUES (7131,
	2798,
	'getActorId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many actors related by self->PE_PE[R8000]->SQ_P[R8001]->SQ_AP[R930];
// We''re preincrementing the index
count = -1;
for each actor in actors
  count = count + 1;
  if (count == param.index)
    return actor.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7130);
INSERT INTO O_TPARM
	VALUES (7132,
	7131,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7133,
	2798,
	'getSendSigActionCount',
	'',
	298,
	1,
	'select many sends related by self->PE_PE[R8000]->A_N[R8001]->A_ACT[R1105]
                                                                  ->A_SS[R1107];
return cardinality sends;',
	1,
	'',
	7131);
INSERT INTO O_TFR
	VALUES (7134,
	2798,
	'getSendSigActionId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many elems related by self->PE_PE[R8000]->A_N[R8001]->A_ACT[R1105]
                                                                  ->A_SS[R1107];
// We''re preincrementing the index
count = -1;
for each elem in elems
  count = count + 1;
  if(count == param.index)
    return elem.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7133);
INSERT INTO O_TPARM
	VALUES (7135,
	7134,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7136,
	2798,
	'getAcceptEvtActionCount',
	'',
	298,
	1,
	'select many elems related by self->PE_PE[R8000]->A_N[R8001]->A_ACT[R1105]
                                                    ->A_AE[R1107]->A_AEA[R1112];
return cardinality elems;',
	1,
	'',
	7134);
INSERT INTO O_TFR
	VALUES (7137,
	2798,
	'getAcceptEvtActionId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many elems related by self->PE_PE[R8000]->A_N[R8001]->A_ACT[R1105]
                                                    ->A_AE[R1107]->A_AEA[R1112];
// We''re preincrementing the index
count = -1;
for each elem in elems
  count = count + 1;
  if(count == param.index)
    return elem.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7136);
INSERT INTO O_TPARM
	VALUES (7138,
	7137,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7139,
	2798,
	'getAcceptTimeEvtActionCount',
	'',
	298,
	1,
	'select many elems related by self->PE_PE[R8000]->A_N[R8001]->A_ACT[R1105]
                                                    ->A_AE[R1107]->A_ATE[R1112];
return cardinality elems;',
	1,
	'',
	7137);
INSERT INTO O_TFR
	VALUES (7140,
	2798,
	'getAcceptTimeEvtActionId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many elems related by self->PE_PE[R8000]->A_N[R8001]->A_ACT[R1105]
                                                    ->A_AE[R1107]->A_ATE[R1112];
// We''re preincrementing the index
count = -1;
for each elem in elems
  count = count + 1;
  if(count == param.index)
    return elem.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7139);
INSERT INTO O_TPARM
	VALUES (7141,
	7140,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7142,
	2798,
	'getActionCount',
	'',
	298,
	1,
	'select many elems related by self->PE_PE[R8000]->A_N[R8001]->A_ACT[R1105]
                                                                  ->A_GA[R1107];
return cardinality elems;',
	1,
	'',
	7140);
INSERT INTO O_TFR
	VALUES (7143,
	2798,
	'getActionId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many elems related by self->PE_PE[R8000]->A_N[R8001]->A_ACT[R1105]
                                                                  ->A_GA[R1107];
// We''re preincrementing the index
count = -1;
for each elem in elems
  count = count + 1;
  if(count == param.index)
    return elem.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7142);
INSERT INTO O_TPARM
	VALUES (7144,
	7143,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7145,
	2798,
	'getClassCount',
	'',
	298,
	1,
	'select many elems related by self->PE_PE[R8000]->O_OBJ[R8001];
return cardinality elems;',
	1,
	'',
	7143);
INSERT INTO O_TFR
	VALUES (7146,
	2798,
	'getClassId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many elems related by self->PE_PE[R8000]->O_OBJ[R8001];
// We''re preincrementing the index
count = -1;
for each elem in elems
  count = count + 1;
  if(count == param.index)
    return elem.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7145);
INSERT INTO O_TPARM
	VALUES (7147,
	7146,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7148,
	2798,
	'getComponentCount',
	'',
	298,
	1,
	'select many elems related by self->PE_PE[R8000]->C_C[R8001];
return cardinality elems;',
	1,
	'',
	7146);
INSERT INTO O_TFR
	VALUES (7149,
	2798,
	'getComponentId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many elems related by self->PE_PE[R8000]->C_C[R8001];
// We''re preincrementing the index
count = -1;
for each elem in elems
  count = count + 1;
  if (count == param.index)
    return elem.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7148);
INSERT INTO O_TPARM
	VALUES (7150,
	7149,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7151,
	2798,
	'getCompRefCount',
	'',
	298,
	1,
	'select many elems related by self->PE_PE[R8000]->CL_IC[R8001];
return cardinality elems;',
	1,
	'',
	7149);
INSERT INTO O_TFR
	VALUES (7152,
	2798,
	'getCompRefId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many elems related by self->PE_PE[R8000]->CL_IC[R8001];
// We''re preincrementing the index
count = -1;
for each elem in elems
  count = count + 1;
  if(count == param.index)
    return elem.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7151);
INSERT INTO O_TPARM
	VALUES (7153,
	7152,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7154,
	2798,
	'getIfaceCount',
	'',
	298,
	1,
	'select many elems related by self->PE_PE[R8000]->C_I[R8001];
return cardinality elems;',
	1,
	'',
	7152);
INSERT INTO O_TFR
	VALUES (7155,
	2798,
	'getIfaceId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many elems related by self->PE_PE[R8000]->C_I[R8001];
// We''re preincrementing the index
count = -1;
for each elem in elems
  count = count + 1;
  if(count == param.index)
    return elem.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7154);
INSERT INTO O_TPARM
	VALUES (7156,
	7155,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7157,
	2798,
	'getConstSpecCount',
	'',
	298,
	1,
	'select many elems related by self->PE_PE[R8000]->CNST_CSP[R8001];
return cardinality elems;',
	1,
	'',
	7155);
INSERT INTO O_TFR
	VALUES (7158,
	2798,
	'getConstSpecId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many elems related by self->PE_PE[R8000]->CNST_CSP[R8001];
// We''re preincrementing the index
count = -1;
for each elem in elems
  count = count + 1;
  if(count == param.index)
    return elem.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7157);
INSERT INTO O_TPARM
	VALUES (7159,
	7158,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7160,
	2798,
	'getSDTCount',
	'',
	298,
	1,
	'select many elems related by self->PE_PE[R8000]->S_DT[R8001]->S_SDT[R17];
return cardinality elems;',
	1,
	'',
	7158);
INSERT INTO O_TFR
	VALUES (7161,
	2798,
	'getSDTId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many elems related by self->PE_PE[R8000]->S_DT[R8001]->S_SDT[R17];
// We''re preincrementing the index
count = -1;
for each elem in elems
  count = count + 1;
  if(count == param.index)
    return elem.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7160);
INSERT INTO O_TPARM
	VALUES (7162,
	7161,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7163,
	2798,
	'getEDTCount',
	'',
	298,
	1,
	'select many elems related by self->PE_PE[R8000]->S_DT[R8001]->S_EDT[R17];
return cardinality elems;',
	1,
	'',
	7161);
INSERT INTO O_TFR
	VALUES (7164,
	2798,
	'getEDTId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many elems related by self->PE_PE[R8000]->S_DT[R8001]->S_EDT[R17];
// We''re preincrementing the index
count = -1;
for each elem in elems
  count = count + 1;
  if(count == param.index)
    return elem.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7163);
INSERT INTO O_TPARM
	VALUES (7165,
	7164,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7166,
	2798,
	'getCompPartCount',
	'',
	298,
	1,
	'select many elems related by self->PE_PE[R8000]->SQ_P[R8001]->SQ_COP[R930];
return cardinality elems;',
	1,
	'',
	7164);
INSERT INTO O_TFR
	VALUES (7167,
	2798,
	'getCompPartId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many elems related by self->PE_PE[R8000]->SQ_P[R8001]->SQ_COP[R930];
// We''re preincrementing the index
count = -1;
for each elem in elems
  count = count + 1;
  if(count == param.index)
    return elem.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7166);
INSERT INTO O_TPARM
	VALUES (7168,
	7167,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7169,
	2798,
	'getInstanceCount',
	'',
	298,
	1,
	'select many elems related by self->PE_PE[R8000]->SQ_P[R8001]->SQ_CIP[R930];
return cardinality elems;',
	1,
	'',
	7167);
INSERT INTO O_TFR
	VALUES (7170,
	2798,
	'getInstanceId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many elems related by self->PE_PE[R8000]->SQ_P[R8001]->SQ_CIP[R930];
// We''re preincrementing the index
count = -1;
for each elem in elems
  count = count + 1;
  if (count == param.index)
    return elem.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7169);
INSERT INTO O_TPARM
	VALUES (7171,
	7170,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7172,
	2798,
	'getEECount',
	'',
	298,
	1,
	'select many elems related by self->PE_PE[R8000]->S_EE[R8001];
return cardinality elems;',
	1,
	'',
	7170);
INSERT INTO O_TFR
	VALUES (7173,
	2798,
	'getEEId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many elems related by self->PE_PE[R8000]->S_EE[R8001];
// We''re preincrementing the index
count = -1;
for each elem in elems
  count = count + 1;
  if(count == param.index)
    return elem.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7172);
INSERT INTO O_TPARM
	VALUES (7174,
	7173,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7175,
	2798,
	'getPkgPartCount',
	'',
	298,
	1,
	'select many elems related by self->PE_PE[R8000]->SQ_P[R8001]->SQ_PP[R930];
return cardinality elems;',
	1,
	'',
	7173);
INSERT INTO O_TFR
	VALUES (7176,
	2798,
	'getPkgPartId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many elems related by self->PE_PE[R8000]->SQ_P[R8001]->SQ_PP[R930];
// We''re preincrementing the index
count = -1;
for each elem in elems
  count = count + 1;
  if(count == param.index)
    return elem.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7175);
INSERT INTO O_TPARM
	VALUES (7177,
	7176,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7178,
	2798,
	'getClassPartCount',
	'',
	298,
	1,
	'select many elems related by self->PE_PE[R8000]->SQ_P[R8001]->SQ_CP[R930];
return cardinality elems;',
	1,
	'',
	7176);
INSERT INTO O_TFR
	VALUES (7179,
	2798,
	'getClassPartId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many elems related by self->PE_PE[R8000]->SQ_P[R8001]->SQ_CP[R930];
// We''re preincrementing the index
count = -1;
for each elem in elems
  count = count + 1;
  if (count == param.index)
    return elem.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7178);
INSERT INTO O_TPARM
	VALUES (7180,
	7179,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7181,
	2798,
	'getObjectNodeCount',
	'',
	298,
	1,
	'select many elems related by self->PE_PE[R8000]->A_N[R8001]->A_OBJ[R1105];
return cardinality elems;',
	1,
	'',
	7179);
INSERT INTO O_TFR
	VALUES (7182,
	2798,
	'getObjectNodeId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many elems related by self->PE_PE[R8000]->A_N[R8001]->A_OBJ[R1105];
// We''re preincrementing the index
count = -1;
for each elem in elems
  count = count + 1;
  if(count == param.index)
    return elem.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7181);
INSERT INTO O_TPARM
	VALUES (7183,
	7182,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7184,
	2798,
	'getDecMergeNodeCount',
	'',
	298,
	1,
	'select many elems related by self->PE_PE[R8000]->A_N[R8001]->A_CTL[R1105]
                                                                  ->A_DM[R1106];
return cardinality elems;',
	1,
	'',
	7182);
INSERT INTO O_TFR
	VALUES (7185,
	2798,
	'getDecMergeNodeId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many elems related by self->PE_PE[R8000]->A_N[R8001]->A_CTL[R1105]
                                                                  ->A_DM[R1106];
// We''re preincrementing the index
count = -1;
for each elem in elems
  count = count + 1;
  if(count == param.index)
    return elem.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7184);
INSERT INTO O_TPARM
	VALUES (7186,
	7185,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7187,
	2798,
	'getInitNodeCount',
	'',
	298,
	1,
	'select many elems related by self->PE_PE[R8000]->A_N[R8001]->A_CTL[R1105]
                                                                 ->A_INI[R1106];
return cardinality elems;',
	1,
	'',
	7185);
INSERT INTO O_TFR
	VALUES (7188,
	2798,
	'getInitNodeId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many elems related by self->PE_PE[R8000]->A_N[R8001]->A_CTL[R1105]
                                                                 ->A_INI[R1106];
// We''re preincrementing the index
count = -1;
for each elem in elems
  count = count + 1;
  if(count == param.index)
    return elem.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7187);
INSERT INTO O_TPARM
	VALUES (7189,
	7188,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7190,
	2798,
	'getActFinalNodeCount',
	'',
	298,
	1,
	'select many elems related by self->PE_PE[R8000]->A_N[R8001]->A_CTL[R1105]
                                                                  ->A_AF[R1106];
return cardinality elems;',
	1,
	'',
	7188);
INSERT INTO O_TFR
	VALUES (7191,
	2798,
	'getActFinalNodeId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many elems related by self->PE_PE[R8000]->A_N[R8001]->A_CTL[R1105]
                                                                  ->A_AF[R1106];
// We''re preincrementing the index
count = -1;
for each elem in elems
  count = count + 1;
  if(count == param.index)
    return elem.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7190);
INSERT INTO O_TPARM
	VALUES (7192,
	7191,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7193,
	2798,
	'getFlowFinalNodeCount',
	'',
	298,
	1,
	'select many elems related by self->PE_PE[R8000]->A_N[R8001]->A_CTL[R1105]
                                                                  ->A_FF[R1106];
return cardinality elems;',
	1,
	'',
	7191);
INSERT INTO O_TFR
	VALUES (7194,
	2798,
	'getFlowFinalNodeId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many elems related by self->PE_PE[R8000]->A_N[R8001]->A_CTL[R1105]
                                                                  ->A_FF[R1106];
// We''re preincrementing the index
count = -1;
for each elem in elems
  count = count + 1;
  if(count == param.index)
    return elem.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7193);
INSERT INTO O_TPARM
	VALUES (7195,
	7194,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7196,
	2798,
	'getIClassCount',
	'',
	298,
	1,
	'select many elems related by self->PE_PE[R8000]->O_IOBJ[R8001];
return cardinality elems;',
	1,
	'',
	7194);
INSERT INTO O_TFR
	VALUES (7197,
	2798,
	'getIClassId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many elems related by self->PE_PE[R8000]->O_IOBJ[R8001];
// We''re preincrementing the index
count = -1;
for each elem in elems
  count = count + 1;
  if(count == param.index)
    return elem.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7196);
INSERT INTO O_TPARM
	VALUES (7198,
	7197,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7199,
	2798,
	'getEEPartCount',
	'',
	298,
	1,
	'select many elems related by self->PE_PE[R8000]->SQ_P[R8001]->SQ_EEP[R930];
return cardinality elems;',
	1,
	'',
	7197);
INSERT INTO O_TFR
	VALUES (7200,
	2798,
	'getEEPartId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many elems related by self->PE_PE[R8000]->SQ_P[R8001]->SQ_EEP[R930];
// We''re preincrementing the index
count = -1;
for each elem in elems
  count = count + 1;
  if (count == param.index)
    return elem.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7199);
INSERT INTO O_TPARM
	VALUES (7201,
	7200,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7202,
	2798,
	'removeIncompleteSignalEvents',
	'',
	19,
	1,
	'// select all classes under this package and remove any
// incomplete non local events
select many classes related by self->PE_PE[R8000]->O_OBJ[R8001];
for each cls in classes
  cls.removeIncompleteNonLocalEvents();
end for;
// do the same for all child packages
select many packages related by self->PE_PE[R8000]->EP_PKG[R8001];
for each package in packages
  package.removeIncompleteSignalEvents();
end for;
// also do the same for components
select many components related by self->PE_PE[R8000]->C_C[R8001];
for each component in components
  component.removeIncompleteSignalEvents();
end for;',
	1,
	'',
	7200);
INSERT INTO O_TFR
	VALUES (7203,
	2798,
	'pasteImportedProvision',
	'',
	19,
	1,
	'select any iPro from instances of CL_IP where (selected.Id == param.id);
if(not_empty iPro)
  // dispose any satisfactions that are not complete
  // this can occur because the export includes them
  // regardless of whether or not they are complete
  select many satisfactions related by iPro->CL_IPINS[R4705]->C_SF[R4705];
  for each satisfaction in satisfactions
    select one requirement related by satisfaction->C_R[R4002];
    if(not_empty requirement
                     and Util::isProxy(element:requirement.convertToInstance()))
      // if this satisfaction is connected to an imported requirement, that
      // is not a proxy, we do not want to dispose
      select one importedReq related by satisfaction->CL_IR[R4706];
      if(empty importedReq 
                      or Util::isProxy(element:importedReq.convertToInstance()))
        satisfaction.dispose();
      end if;
    end if;
  end for;
end if;',
	1,
	'',
	7202);
INSERT INTO O_TPARM
	VALUES (7204,
	7203,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7205,
	2798,
	'pasteImportedRequirement',
	'',
	19,
	1,
	'// nothing to do here',
	1,
	'',
	7203);
INSERT INTO O_TPARM
	VALUES (7206,
	7205,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7207,
	2798,
	'isContainedBy',
	'',
	316,
	1,
	'// Package.isContainedBy() GenericPackages only
select one component related by self->PE_PE[R8001]->C_C[R8003];
select one package related by self->PE_PE[R8001]->EP_PKG[R8000];
if not_empty component
  select one pe related by component->PE_PE[R8001];
  if not empty pe and pe.Element_ID == param.element_id
    return true;
  else
    return component.isContainedBy(element_id:param.element_id);
  end if;
elif not_empty package
  select one pe related by package->PE_PE[R8001];
  if not empty pe and pe.Element_ID == param.element_id
    return true;
  else
    return package.isContainedBy(element_id:param.element_id);
  end if;
else
  return false;
end if;
',
	1,
	'',
	7205);
INSERT INTO O_TPARM
	VALUES (7208,
	7207,
	'element_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7209,
	2798,
	'collectReferencesForSynchronization',
	'',
	19,
	1,
	'/**
 *  Call on all children under this package to gather required synchronization
 *  elements
 */
if(param.syncType == SynchronizationType::Pull)
  // collect direct component reference children
  select many componentRefs related by self->PE_PE[R8000]->CL_IC[R8001];
  for each componentRef in componentRefs
    Util::addElementToList(elementList:param.referenceList,
                                      element:componentRef.convertToInstance());
    componentRef.collectReferencesForSynchronization(
                    referenceList:param.referenceList, syncType:param.syncType);
  end for;
end if;
// collect references from nested packages
select many pkgs related by self->PE_PE[R8000]->EP_PKG[R8001];
for each pkg in pkgs
  pkg.collectReferencesForSynchronization(referenceList:param.referenceList,
                                                       syncType:param.syncType);
end for;
// collect references from all interfaces under this package
select many interfaces related by self->PE_PE[R8000]->C_I[R8001];
for each interface in interfaces
  interface.collectReferencesForSynchronization(
                    referenceList:param.referenceList, syncType:param.syncType);
end for;
// collect reference for all components under this package
select many components related by self->PE_PE[R8000]->C_C[R8001];
for each component in components
  component.collectReferencesForSynchronization(
                    referenceList:param.referenceList, syncType:param.syncType);
end for;
// now for specialized packages
select many packages related by self->EP_PIP[R1403]->EP_PKG[R1404];
for each package in packages
  package.collectReferencesForSynchronization(referenceList:param.referenceList,
                                                       syncType:param.syncType);
end for;
select many componentPkgs related by self->EP_SPKG[R1400]->CP_CP[R1402];
for each componentPkg in componentPkgs
  componentPkg.collectReferencesForSynchronization(
                    referenceList:param.referenceList, syncType:param.syncType);
end for;
select many interfacePkgs related by self->EP_SPKG[R1400]->IP_IP[R1402];
for each interfacePkg in interfacePkgs
  interfacePkg.collectReferencesForSynchronization(
                    referenceList:param.referenceList, syncType:param.syncType);
end for;',
	1,
	'',
	7207);
INSERT INTO O_TPARM
	VALUES (7210,
	7209,
	'referenceList',
	317,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (7211,
	7209,
	'syncType',
	3500,
	0,
	'',
	7210,
	'');
INSERT INTO O_TFR
	VALUES (7212,
	2798,
	'hasRealizedComponents',
	'',
	316,
	1,
	'//Package::hasRealizedComponents()
result = false;
select many packages related by self->PE_PE[R8000]->EP_PKG[R8001];
for each package in packages
  if package.hasRealizedComponents() == true
    result = true;
    break;
  end if;
end for;
select many components related by self->PE_PE[R8000]->C_C[R8001];
for each component in components
  if component.hasRealizedComponents() == true
    result = true;
    break;
  end if;
end for;
select many compRefs related by self->PE_PE[R8000]->CL_IC[R8001];
for each compRef in compRefs
  select one component related by compRef->C_C[R4201];
  if not_empty component and component.hasRealizedComponents() == true
    result = true;
    break;
  end if;
end for;
return result;',
	1,
	'',
	7209);
INSERT INTO O_NBATTR
	VALUES (7213,
	2798);
INSERT INTO O_BATTR
	VALUES (7213,
	2798);
INSERT INTO O_ATTR
	VALUES (7213,
	2798,
	7214,
	'Name',
	'Full Name: Package Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (7215,
	2798);
INSERT INTO O_BATTR
	VALUES (7215,
	2798);
INSERT INTO O_ATTR
	VALUES (7215,
	2798,
	7213,
	'Descrip',
	'Full Name: Package Description',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (2798,
	705,
	0,
	754,
	6810,
	6812,
	6811,
	7216,
	7217,
	0,
	0,
	'',
	'System Model',
	'Sys_ID',
	'R1401.''directly contained under''');
INSERT INTO O_RATTR
	VALUES (7216,
	2798,
	754,
	705,
	1,
	'Sys_ID');
INSERT INTO O_ATTR
	VALUES (7216,
	2798,
	2825,
	'Sys_ID',
	'',
	'',
	'Sys_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2798,
	705,
	0,
	754,
	6823,
	6825,
	6824,
	7214,
	7218,
	0,
	0,
	'',
	'System Model',
	'Sys_ID',
	'R1405');
INSERT INTO O_RATTR
	VALUES (7214,
	2798,
	754,
	705,
	1,
	'Sys_ID');
INSERT INTO O_ATTR
	VALUES (7214,
	2798,
	7216,
	'Direct_Sys_ID',
	'',
	'Direct_',
	'Sys_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2798,
	26,
	0,
	25,
	868,
	2833,
	870,
	2825,
	7219,
	0,
	0,
	'',
	'Packageable Element',
	'Element_ID',
	'R8001');
INSERT INTO O_RATTR
	VALUES (2825,
	2798,
	25,
	26,
	0,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (2825,
	2798,
	0,
	'Package_ID',
	'',
	'',
	'Package_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (7220,
	2798);
INSERT INTO O_BATTR
	VALUES (7220,
	2798);
INSERT INTO O_ATTR
	VALUES (7220,
	2798,
	7215,
	'Num_Rng',
	'Full Name: Number Range
Description:  The number range start is used when classes and associations are created in the package.  The number range start is used as the default auto-numbering start value in for the newly created class number and newly created association number. 
min_value: 0
max_value: 9999',
	'',
	'Num_Rng',
	0,
	298,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2798);
INSERT INTO O_OIDA
	VALUES (2825,
	2798,
	0,
	'Package_ID');
INSERT INTO O_ID
	VALUES (1,
	2798);
INSERT INTO O_ID
	VALUES (2,
	2798);
-- BP 7.1 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (7221,
	'Domain',
	'A domain (S_DOM) consists of one or more subsystems (S_SS) that each contain an information model that abstracts a portion of the data for the domain: classes (O_OBJ), associations (R_REL), etc.  Breaking a domain into subsystems allows the complexity of the domain to be more easily managed: 1) subsystems are components and can be checked out individually allowing parallelism in development of the models and 2) breaking up a domain into smaller units is easier to understand.  A subsystem is composed of classes that tend to cluster, i.e., they have few associations that span subsystem boundaries.  Inter-subsystem associations, communications, and accesses are captured in the Subsystem Relationship Model (SRM), Subsystem Communication Model (SCM), and Subsystem Access Model (SAM) respectively.',
	'S',
	1,
	1,
	7222);
INSERT INTO S_SID
	VALUES (1,
	7221);
INSERT INTO O_IOBJ
	VALUES (7223,
	2322,
	5,
	7221,
	'Association',
	'R_REL');
INSERT INTO O_IOBJ
	VALUES (7224,
	7225,
	5,
	7221,
	'Communication Path',
	'CA_COMM');
INSERT INTO O_IOBJ
	VALUES (7226,
	7227,
	5,
	7221,
	'Access Path',
	'CA_ACC');
INSERT INTO O_IOBJ
	VALUES (7228,
	30,
	5,
	7221,
	'Model Class',
	'O_OBJ');
INSERT INTO O_IOBJ
	VALUES (7229,
	1050,
	5,
	7221,
	'Imported Class',
	'O_IOBJ');
INSERT INTO R_SIMP
	VALUES (7230);
INSERT INTO R_REL
	VALUES (7230,
	1,
	'CrossComponent:true',
	7221);
INSERT INTO R_PART
	VALUES (699,
	7230,
	7231,
	0,
	0,
	'is first level of partitioning for');
INSERT INTO O_RTIDA
	VALUES (712,
	699,
	0,
	7230,
	7231);
INSERT INTO R_RTO
	VALUES (699,
	7230,
	7231,
	0);
INSERT INTO R_OIR
	VALUES (699,
	7230,
	7231,
	0);
INSERT INTO R_FORM
	VALUES (701,
	7230,
	7232,
	1,
	1,
	'is partitioned into');
INSERT INTO R_RGO
	VALUES (701,
	7230,
	7232);
INSERT INTO R_OIR
	VALUES (701,
	7230,
	7232,
	0);
INSERT INTO R_SIMP
	VALUES (7233);
INSERT INTO R_REL
	VALUES (7233,
	7,
	'CrossComponent:true',
	7221);
INSERT INTO R_PART
	VALUES (701,
	7233,
	7234,
	0,
	0,
	'is a presence of an an external entity in');
INSERT INTO O_RTIDA
	VALUES (717,
	701,
	0,
	7233,
	7234);
INSERT INTO R_RTO
	VALUES (701,
	7233,
	7234,
	0);
INSERT INTO R_OIR
	VALUES (701,
	7233,
	7234,
	0);
INSERT INTO R_FORM
	VALUES (7235,
	7233,
	7236,
	1,
	1,
	'contains');
INSERT INTO R_RGO
	VALUES (7235,
	7233,
	7236);
INSERT INTO R_OIR
	VALUES (7235,
	7233,
	7236,
	0);
INSERT INTO R_SIMP
	VALUES (7237);
INSERT INTO R_REL
	VALUES (7237,
	9,
	'',
	7221);
INSERT INTO R_PART
	VALUES (2820,
	7237,
	7238,
	0,
	0,
	'is a presence in subsystem model of');
INSERT INTO O_RTIDA
	VALUES (3570,
	2820,
	0,
	7237,
	7238);
INSERT INTO R_RTO
	VALUES (2820,
	7237,
	7238,
	0);
INSERT INTO R_OIR
	VALUES (2820,
	7237,
	7238,
	0);
INSERT INTO R_FORM
	VALUES (7235,
	7237,
	7239,
	1,
	1,
	'is represented by');
INSERT INTO R_RGO
	VALUES (7235,
	7237,
	7239);
INSERT INTO R_OIR
	VALUES (7235,
	7237,
	7239,
	0);
INSERT INTO R_SIMP
	VALUES (7240);
INSERT INTO R_REL
	VALUES (7240,
	10,
	'',
	7221);
INSERT INTO R_PART
	VALUES (2820,
	7240,
	7241,
	0,
	0,
	'is vehicle of communication for');
INSERT INTO O_RTIDA
	VALUES (3570,
	2820,
	0,
	7240,
	7241);
INSERT INTO R_RTO
	VALUES (2820,
	7240,
	7241,
	0);
INSERT INTO R_OIR
	VALUES (2820,
	7240,
	7241,
	0);
INSERT INTO R_FORM
	VALUES (6622,
	7240,
	7242,
	1,
	1,
	'can receive asynchronous communication via');
INSERT INTO R_RGO
	VALUES (6622,
	7240,
	7242);
INSERT INTO R_OIR
	VALUES (6622,
	7240,
	7242,
	0);
INSERT INTO R_SIMP
	VALUES (7243);
INSERT INTO R_REL
	VALUES (7243,
	12,
	'',
	7221);
INSERT INTO R_PART
	VALUES (2820,
	7243,
	7244,
	0,
	0,
	'is data for events of');
INSERT INTO O_RTIDA
	VALUES (3570,
	2820,
	0,
	7243,
	7244);
INSERT INTO R_RTO
	VALUES (2820,
	7243,
	7244,
	0);
INSERT INTO R_OIR
	VALUES (2820,
	7243,
	7244,
	0);
INSERT INTO R_FORM
	VALUES (7245,
	7243,
	7246,
	1,
	1,
	'can asynchronously communicate via');
INSERT INTO R_RGO
	VALUES (7245,
	7243,
	7246);
INSERT INTO R_OIR
	VALUES (7245,
	7243,
	7246,
	0);
INSERT INTO R_SIMP
	VALUES (7247);
INSERT INTO R_REL
	VALUES (7247,
	14,
	'CrossComponent:true',
	7221);
INSERT INTO R_PART
	VALUES (699,
	7247,
	7248,
	0,
	1,
	'defines types available within');
INSERT INTO O_RTIDA
	VALUES (712,
	699,
	0,
	7247,
	7248);
INSERT INTO R_RTO
	VALUES (699,
	7247,
	7248,
	0);
INSERT INTO R_OIR
	VALUES (699,
	7247,
	7248,
	0);
INSERT INTO R_FORM
	VALUES (32,
	7247,
	7249,
	1,
	1,
	'contains defined');
INSERT INTO R_RGO
	VALUES (32,
	7247,
	7249);
INSERT INTO R_OIR
	VALUES (32,
	7247,
	7249,
	0);
INSERT INTO R_SIMP
	VALUES (7250);
INSERT INTO R_REL
	VALUES (7250,
	16,
	'CrossComponent:true',
	7221);
INSERT INTO R_PART
	VALUES (32,
	7250,
	7251,
	0,
	0,
	'is defined by');
INSERT INTO O_RTIDA
	VALUES (156,
	32,
	0,
	7250,
	7251);
INSERT INTO R_RTO
	VALUES (32,
	7250,
	7251,
	0);
INSERT INTO R_OIR
	VALUES (32,
	7250,
	7251,
	0);
INSERT INTO R_FORM
	VALUES (7245,
	7250,
	7252,
	1,
	1,
	'defines the type of');
INSERT INTO R_RGO
	VALUES (7245,
	7250,
	7252);
INSERT INTO R_OIR
	VALUES (7245,
	7250,
	7252,
	0);
INSERT INTO R_SIMP
	VALUES (7253);
INSERT INTO R_REL
	VALUES (7253,
	8,
	'CrossComponent:true',
	7221);
INSERT INTO R_PART
	VALUES (699,
	7253,
	7254,
	0,
	0,
	'interacts with');
INSERT INTO O_RTIDA
	VALUES (712,
	699,
	0,
	7253,
	7254);
INSERT INTO R_RTO
	VALUES (699,
	7253,
	7254,
	0);
INSERT INTO R_OIR
	VALUES (699,
	7253,
	7254,
	0);
INSERT INTO R_FORM
	VALUES (2820,
	7253,
	7255,
	1,
	1,
	'interacts with');
INSERT INTO R_RGO
	VALUES (2820,
	7253,
	7255);
INSERT INTO R_OIR
	VALUES (2820,
	7253,
	7255,
	0);
INSERT INTO R_SUBSUP
	VALUES (7256);
INSERT INTO R_REL
	VALUES (7256,
	17,
	'',
	7221);
INSERT INTO R_SUPER
	VALUES (32,
	7256,
	7257);
INSERT INTO O_RTIDA
	VALUES (156,
	32,
	0,
	7256,
	7257);
INSERT INTO R_RTO
	VALUES (32,
	7256,
	7257,
	0);
INSERT INTO R_OIR
	VALUES (32,
	7256,
	7257,
	0);
INSERT INTO R_SUB
	VALUES (7258,
	7256,
	7259);
INSERT INTO R_RGO
	VALUES (7258,
	7256,
	7259);
INSERT INTO R_OIR
	VALUES (7258,
	7256,
	7259,
	0);
INSERT INTO R_SUB
	VALUES (7260,
	7256,
	7261);
INSERT INTO R_RGO
	VALUES (7260,
	7256,
	7261);
INSERT INTO R_OIR
	VALUES (7260,
	7256,
	7261,
	0);
INSERT INTO R_SUB
	VALUES (7262,
	7256,
	7263);
INSERT INTO R_RGO
	VALUES (7262,
	7256,
	7263);
INSERT INTO R_OIR
	VALUES (7262,
	7256,
	7263,
	0);
INSERT INTO R_SUB
	VALUES (7264,
	7256,
	7265);
INSERT INTO R_RGO
	VALUES (7264,
	7256,
	7265);
INSERT INTO R_OIR
	VALUES (7264,
	7256,
	7265,
	0);
INSERT INTO R_SUB
	VALUES (988,
	7256,
	7266);
INSERT INTO R_RGO
	VALUES (988,
	7256,
	7266);
INSERT INTO R_OIR
	VALUES (988,
	7256,
	7266,
	0);
INSERT INTO R_SIMP
	VALUES (7267);
INSERT INTO R_REL
	VALUES (7267,
	20,
	'CrossComponent:true',
	7221);
INSERT INTO R_PART
	VALUES (32,
	7267,
	7268,
	0,
	0,
	'return value defined by');
INSERT INTO O_RTIDA
	VALUES (156,
	32,
	0,
	7267,
	7268);
INSERT INTO R_RTO
	VALUES (32,
	7267,
	7268,
	0);
INSERT INTO R_OIR
	VALUES (32,
	7267,
	7268,
	0);
INSERT INTO R_FORM
	VALUES (6,
	7267,
	7269,
	1,
	1,
	'defines the return value');
INSERT INTO R_RGO
	VALUES (6,
	7267,
	7269);
INSERT INTO R_OIR
	VALUES (6,
	7267,
	7269,
	0);
INSERT INTO R_SIMP
	VALUES (7270);
INSERT INTO R_REL
	VALUES (7270,
	21,
	'',
	7221);
INSERT INTO R_PART
	VALUES (6,
	7270,
	7271,
	0,
	0,
	'contains');
INSERT INTO O_RTIDA
	VALUES (16,
	6,
	0,
	7270,
	7271);
INSERT INTO R_RTO
	VALUES (6,
	7270,
	7271,
	0);
INSERT INTO R_OIR
	VALUES (6,
	7270,
	7271,
	0);
INSERT INTO R_FORM
	VALUES (46,
	7270,
	7272,
	1,
	1,
	'is part of');
INSERT INTO R_RGO
	VALUES (46,
	7270,
	7272);
INSERT INTO R_OIR
	VALUES (46,
	7270,
	7272,
	0);
INSERT INTO R_SIMP
	VALUES (7273);
INSERT INTO R_REL
	VALUES (7273,
	19,
	'',
	7221);
INSERT INTO R_FORM
	VALUES (6,
	7273,
	7274,
	1,
	1,
	'uses');
INSERT INTO R_RGO
	VALUES (6,
	7273,
	7274);
INSERT INTO R_OIR
	VALUES (6,
	7273,
	7274,
	0);
INSERT INTO R_PART
	VALUES (2820,
	7273,
	7275,
	0,
	0,
	'provides access to');
INSERT INTO O_RTIDA
	VALUES (3570,
	2820,
	0,
	7273,
	7275);
INSERT INTO R_RTO
	VALUES (2820,
	7273,
	7275,
	0);
INSERT INTO R_OIR
	VALUES (2820,
	7273,
	7275,
	0);
INSERT INTO R_SIMP
	VALUES (7276);
INSERT INTO R_REL
	VALUES (7276,
	15,
	'CrossComponent:true',
	7221);
INSERT INTO R_PART
	VALUES (32,
	7276,
	7277,
	0,
	0,
	'is defined by');
INSERT INTO O_RTIDA
	VALUES (156,
	32,
	0,
	7276,
	7277);
INSERT INTO R_RTO
	VALUES (32,
	7276,
	7277,
	0);
INSERT INTO R_OIR
	VALUES (32,
	7276,
	7277,
	0);
INSERT INTO R_FORM
	VALUES (7278,
	7276,
	7279,
	1,
	1,
	'defines the type of');
INSERT INTO R_RGO
	VALUES (7278,
	7276,
	7279);
INSERT INTO R_OIR
	VALUES (7278,
	7276,
	7279,
	0);
INSERT INTO R_SIMP
	VALUES (7280);
INSERT INTO R_REL
	VALUES (7280,
	22,
	'CrossComponent:true',
	7221);
INSERT INTO R_PART
	VALUES (32,
	7280,
	7281,
	0,
	0,
	'is defined by');
INSERT INTO O_RTIDA
	VALUES (156,
	32,
	0,
	7280,
	7281);
INSERT INTO R_RTO
	VALUES (32,
	7280,
	7281,
	0);
INSERT INTO R_OIR
	VALUES (32,
	7280,
	7281,
	0);
INSERT INTO R_FORM
	VALUES (46,
	7280,
	7282,
	1,
	1,
	'defines the type of');
INSERT INTO R_RGO
	VALUES (46,
	7280,
	7282);
INSERT INTO R_OIR
	VALUES (46,
	7280,
	7282,
	0);
INSERT INTO R_SIMP
	VALUES (7283);
INSERT INTO R_REL
	VALUES (7283,
	11,
	'',
	7221);
INSERT INTO R_FORM
	VALUES (7278,
	7283,
	7284,
	1,
	1,
	'can be accessed synchronously via');
INSERT INTO R_RGO
	VALUES (7278,
	7283,
	7284);
INSERT INTO R_OIR
	VALUES (7278,
	7283,
	7284,
	0);
INSERT INTO R_PART
	VALUES (2820,
	7283,
	7285,
	0,
	0,
	'is data for');
INSERT INTO O_RTIDA
	VALUES (3570,
	2820,
	0,
	7283,
	7285);
INSERT INTO R_RTO
	VALUES (2820,
	7283,
	7285,
	0);
INSERT INTO R_OIR
	VALUES (2820,
	7283,
	7285,
	0);
INSERT INTO R_ASSOC
	VALUES (7286);
INSERT INTO R_REL
	VALUES (7286,
	13,
	'',
	7221);
INSERT INTO R_AONE
	VALUES (7245,
	7286,
	7287,
	1,
	1,
	'may carry');
INSERT INTO O_RTIDA
	VALUES (7288,
	7245,
	0,
	7286,
	7287);
INSERT INTO O_RTIDA
	VALUES (7289,
	7245,
	0,
	7286,
	7287);
INSERT INTO R_RTO
	VALUES (7245,
	7286,
	7287,
	0);
INSERT INTO R_OIR
	VALUES (7245,
	7286,
	7287,
	0);
INSERT INTO R_AOTH
	VALUES (6622,
	7286,
	7290,
	1,
	1,
	'is carried via');
INSERT INTO O_RTIDA
	VALUES (6637,
	6622,
	0,
	7286,
	7290);
INSERT INTO O_RTIDA
	VALUES (6638,
	6622,
	0,
	7286,
	7290);
INSERT INTO R_RTO
	VALUES (6622,
	7286,
	7290,
	0);
INSERT INTO R_OIR
	VALUES (6622,
	7286,
	7290,
	0);
INSERT INTO R_ASSR
	VALUES (7291,
	7286,
	7292,
	0);
INSERT INTO R_RGO
	VALUES (7291,
	7286,
	7292);
INSERT INTO R_OIR
	VALUES (7291,
	7286,
	7292,
	0);
INSERT INTO R_SIMP
	VALUES (1315);
INSERT INTO R_REL
	VALUES (1315,
	2,
	'',
	7221);
INSERT INTO R_PART
	VALUES (701,
	1315,
	1317,
	0,
	1,
	'is contained in');
INSERT INTO O_RTIDA
	VALUES (717,
	701,
	0,
	1315,
	1317);
INSERT INTO R_RTO
	VALUES (701,
	1315,
	1317,
	0);
INSERT INTO R_OIR
	VALUES (701,
	1315,
	1317,
	0);
INSERT INTO R_FORM
	VALUES (30,
	1315,
	1316,
	1,
	1,
	'is decomposed into');
INSERT INTO R_RGO
	VALUES (30,
	1315,
	1316);
INSERT INTO R_OIR
	VALUES (30,
	1315,
	1316,
	7228);
INSERT INTO R_SIMP
	VALUES (7293);
INSERT INTO R_REL
	VALUES (7293,
	4,
	'',
	7221);
INSERT INTO R_PART
	VALUES (701,
	7293,
	7294,
	0,
	1,
	'abstracts associations between classes in');
INSERT INTO O_RTIDA
	VALUES (717,
	701,
	0,
	7293,
	7294);
INSERT INTO R_RTO
	VALUES (701,
	7293,
	7294,
	0);
INSERT INTO R_OIR
	VALUES (701,
	7293,
	7294,
	0);
INSERT INTO R_FORM
	VALUES (2322,
	7293,
	7295,
	1,
	1,
	'contains');
INSERT INTO R_RGO
	VALUES (2322,
	7293,
	7295);
INSERT INTO R_OIR
	VALUES (2322,
	7293,
	7295,
	7223);
INSERT INTO R_SIMP
	VALUES (7296);
INSERT INTO R_REL
	VALUES (7296,
	5,
	'

Notes:

',
	7221);
INSERT INTO R_PART
	VALUES (701,
	7296,
	7297,
	0,
	0,
	'abstracts asynchronous communication between classes in');
INSERT INTO O_RTIDA
	VALUES (717,
	701,
	0,
	7296,
	7297);
INSERT INTO R_RTO
	VALUES (701,
	7296,
	7297,
	0);
INSERT INTO R_OIR
	VALUES (701,
	7296,
	7297,
	0);
INSERT INTO R_FORM
	VALUES (7225,
	7296,
	7298,
	1,
	1,
	'contains');
INSERT INTO R_RGO
	VALUES (7225,
	7296,
	7298);
INSERT INTO R_OIR
	VALUES (7225,
	7296,
	7298,
	7224);
INSERT INTO R_SIMP
	VALUES (7299);
INSERT INTO R_REL
	VALUES (7299,
	6,
	'

Notes:

',
	7221);
INSERT INTO R_PART
	VALUES (701,
	7299,
	7300,
	0,
	0,
	'abstracts synchronous data access between classes in');
INSERT INTO O_RTIDA
	VALUES (717,
	701,
	0,
	7299,
	7300);
INSERT INTO R_RTO
	VALUES (701,
	7299,
	7300,
	0);
INSERT INTO R_OIR
	VALUES (701,
	7299,
	7300,
	0);
INSERT INTO R_FORM
	VALUES (7227,
	7299,
	7301,
	1,
	1,
	'contains');
INSERT INTO R_RGO
	VALUES (7227,
	7299,
	7301);
INSERT INTO R_OIR
	VALUES (7227,
	7299,
	7301,
	7226);
INSERT INTO R_SIMP
	VALUES (1352);
INSERT INTO R_REL
	VALUES (1352,
	3,
	'',
	7221);
INSERT INTO R_PART
	VALUES (701,
	1352,
	1354,
	0,
	0,
	'represents a class from another subsystem in');
INSERT INTO O_RTIDA
	VALUES (717,
	701,
	0,
	1352,
	1354);
INSERT INTO R_RTO
	VALUES (701,
	1352,
	1354,
	0);
INSERT INTO R_OIR
	VALUES (701,
	1352,
	1354,
	0);
INSERT INTO R_FORM
	VALUES (1050,
	1352,
	1353,
	1,
	1,
	'can contain classs from other subsystems via');
INSERT INTO R_RGO
	VALUES (1050,
	1352,
	1353);
INSERT INTO R_OIR
	VALUES (1050,
	1352,
	1353,
	7229);
INSERT INTO R_SIMP
	VALUES (7302);
INSERT INTO R_REL
	VALUES (7302,
	27,
	'',
	7221);
INSERT INTO R_PART
	VALUES (7262,
	7302,
	7303,
	0,
	0,
	'is defined by');
INSERT INTO O_RTIDA
	VALUES (7304,
	7262,
	0,
	7302,
	7303);
INSERT INTO R_RTO
	VALUES (7262,
	7302,
	7303,
	0);
INSERT INTO R_OIR
	VALUES (7262,
	7302,
	7303,
	0);
INSERT INTO R_FORM
	VALUES (39,
	7302,
	7305,
	1,
	1,
	'defines');
INSERT INTO R_RGO
	VALUES (39,
	7302,
	7305);
INSERT INTO R_OIR
	VALUES (39,
	7302,
	7305,
	0);
INSERT INTO R_SIMP
	VALUES (7306);
INSERT INTO R_REL
	VALUES (7306,
	23,
	'CrossComponent:true',
	7221);
INSERT INTO R_FORM
	VALUES (8,
	7306,
	7307,
	1,
	1,
	'defines');
INSERT INTO R_RGO
	VALUES (8,
	7306,
	7307);
INSERT INTO R_OIR
	VALUES (8,
	7306,
	7307,
	0);
INSERT INTO R_PART
	VALUES (699,
	7306,
	7308,
	0,
	0,
	'is defined in ');
INSERT INTO O_RTIDA
	VALUES (712,
	699,
	0,
	7306,
	7308);
INSERT INTO R_RTO
	VALUES (699,
	7306,
	7308,
	0);
INSERT INTO R_OIR
	VALUES (699,
	7306,
	7308,
	0);
INSERT INTO R_SIMP
	VALUES (7309);
INSERT INTO R_REL
	VALUES (7309,
	25,
	'CrossComponent:true',
	7221);
INSERT INTO R_FORM
	VALUES (8,
	7309,
	7310,
	1,
	1,
	'defines return type');
INSERT INTO R_RGO
	VALUES (8,
	7309,
	7310);
INSERT INTO R_OIR
	VALUES (8,
	7309,
	7310,
	0);
INSERT INTO R_PART
	VALUES (32,
	7309,
	7311,
	0,
	0,
	'has return type of');
INSERT INTO O_RTIDA
	VALUES (156,
	32,
	0,
	7309,
	7311);
INSERT INTO R_RTO
	VALUES (32,
	7309,
	7311,
	0);
INSERT INTO R_OIR
	VALUES (32,
	7309,
	7311,
	0);
INSERT INTO R_SIMP
	VALUES (7312);
INSERT INTO R_REL
	VALUES (7312,
	24,
	'',
	7221);
INSERT INTO R_PART
	VALUES (8,
	7312,
	7313,
	0,
	0,
	'is defined for');
INSERT INTO O_RTIDA
	VALUES (11,
	8,
	0,
	7312,
	7313);
INSERT INTO R_RTO
	VALUES (8,
	7312,
	7313,
	0);
INSERT INTO R_OIR
	VALUES (8,
	7312,
	7313,
	0);
INSERT INTO R_FORM
	VALUES (48,
	7312,
	7314,
	1,
	1,
	'defines');
INSERT INTO R_RGO
	VALUES (48,
	7312,
	7314);
INSERT INTO R_OIR
	VALUES (48,
	7312,
	7314,
	0);
INSERT INTO R_SIMP
	VALUES (7315);
INSERT INTO R_REL
	VALUES (7315,
	26,
	'CrossComponent:true',
	7221);
INSERT INTO R_FORM
	VALUES (48,
	7315,
	7316,
	1,
	1,
	'describes type of');
INSERT INTO R_RGO
	VALUES (48,
	7315,
	7316);
INSERT INTO R_OIR
	VALUES (48,
	7315,
	7316,
	0);
INSERT INTO R_PART
	VALUES (32,
	7315,
	7317,
	0,
	0,
	'is typed by ');
INSERT INTO O_RTIDA
	VALUES (156,
	32,
	0,
	7315,
	7317);
INSERT INTO R_RTO
	VALUES (32,
	7315,
	7317,
	0);
INSERT INTO R_OIR
	VALUES (32,
	7315,
	7317,
	0);
INSERT INTO R_SIMP
	VALUES (7318);
INSERT INTO R_REL
	VALUES (7318,
	28,
	'',
	7221);
INSERT INTO R_PART
	VALUES (705,
	7318,
	7319,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (754,
	705,
	0,
	7318,
	7319);
INSERT INTO R_RTO
	VALUES (705,
	7318,
	7319,
	0);
INSERT INTO R_OIR
	VALUES (705,
	7318,
	7319,
	0);
INSERT INTO R_FORM
	VALUES (699,
	7318,
	7320,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (699,
	7318,
	7320);
INSERT INTO R_OIR
	VALUES (699,
	7318,
	7320,
	0);
INSERT INTO R_SIMP
	VALUES (7321);
INSERT INTO R_REL
	VALUES (7321,
	29,
	'',
	7221);
INSERT INTO R_PART
	VALUES (699,
	7321,
	7322,
	0,
	1,
	'is contained in');
INSERT INTO O_RTIDA
	VALUES (712,
	699,
	0,
	7321,
	7322);
INSERT INTO R_RTO
	VALUES (699,
	7321,
	7322,
	0);
INSERT INTO R_OIR
	VALUES (699,
	7321,
	7322,
	0);
INSERT INTO R_FORM
	VALUES (3523,
	7321,
	7323,
	1,
	1,
	'contains');
INSERT INTO R_RGO
	VALUES (3523,
	7321,
	7323);
INSERT INTO R_OIR
	VALUES (3523,
	7321,
	7323,
	0);
INSERT INTO R_ASSOC
	VALUES (7324);
INSERT INTO R_REL
	VALUES (7324,
	31,
	'',
	7221);
INSERT INTO R_AONE
	VALUES (3523,
	7324,
	7325,
	0,
	0,
	'is contained in');
INSERT INTO O_RTIDA
	VALUES (3566,
	3523,
	0,
	7324,
	7325);
INSERT INTO R_RTO
	VALUES (3523,
	7324,
	7325,
	0);
INSERT INTO R_OIR
	VALUES (3523,
	7324,
	7325,
	0);
INSERT INTO R_AOTH
	VALUES (8,
	7324,
	7326,
	1,
	1,
	'contains');
INSERT INTO O_RTIDA
	VALUES (11,
	8,
	0,
	7324,
	7326);
INSERT INTO R_RTO
	VALUES (8,
	7324,
	7326,
	0);
INSERT INTO R_OIR
	VALUES (8,
	7324,
	7326,
	0);
INSERT INTO R_ASSR
	VALUES (7327,
	7324,
	7328,
	0);
INSERT INTO R_RGO
	VALUES (7327,
	7324,
	7328);
INSERT INTO R_OIR
	VALUES (7327,
	7324,
	7328,
	0);
INSERT INTO R_SIMP
	VALUES (7329);
INSERT INTO R_REL
	VALUES (7329,
	30,
	'',
	7221);
INSERT INTO R_PART
	VALUES (3523,
	7329,
	7330,
	0,
	0,
	'contains children of');
INSERT INTO O_RTIDA
	VALUES (3566,
	3523,
	0,
	7329,
	7330);
INSERT INTO R_RTO
	VALUES (3523,
	7329,
	7330,
	0);
INSERT INTO R_OIR
	VALUES (3523,
	7329,
	7330,
	0);
INSERT INTO R_FORM
	VALUES (7331,
	7329,
	7332,
	0,
	1,
	'is parent to other packages via');
INSERT INTO R_RGO
	VALUES (7331,
	7329,
	7332);
INSERT INTO R_OIR
	VALUES (7331,
	7329,
	7332,
	0);
INSERT INTO R_SIMP
	VALUES (7333);
INSERT INTO R_REL
	VALUES (7333,
	32,
	'',
	7221);
INSERT INTO R_PART
	VALUES (7331,
	7333,
	7334,
	0,
	1,
	'is child via');
INSERT INTO O_RTIDA
	VALUES (7335,
	7331,
	0,
	7333,
	7334);
INSERT INTO R_RTO
	VALUES (7331,
	7333,
	7334,
	0);
INSERT INTO R_OIR
	VALUES (7331,
	7333,
	7334,
	0);
INSERT INTO R_FORM
	VALUES (3523,
	7333,
	7336,
	1,
	1,
	'contains');
INSERT INTO R_RGO
	VALUES (3523,
	7333,
	7336);
INSERT INTO R_OIR
	VALUES (3523,
	7333,
	7336,
	0);
INSERT INTO R_ASSOC
	VALUES (7337);
INSERT INTO R_REL
	VALUES (7337,
	33,
	'',
	7221);
INSERT INTO R_AONE
	VALUES (7338,
	7337,
	7339,
	0,
	0,
	'is contained in');
INSERT INTO O_RTIDA
	VALUES (7340,
	7338,
	0,
	7337,
	7339);
INSERT INTO R_RTO
	VALUES (7338,
	7337,
	7339,
	0);
INSERT INTO R_OIR
	VALUES (7338,
	7337,
	7339,
	0);
INSERT INTO R_AOTH
	VALUES (2820,
	7337,
	7341,
	1,
	1,
	'contains');
INSERT INTO O_RTIDA
	VALUES (3570,
	2820,
	0,
	7337,
	7341);
INSERT INTO R_RTO
	VALUES (2820,
	7337,
	7341,
	0);
INSERT INTO R_OIR
	VALUES (2820,
	7337,
	7341,
	0);
INSERT INTO R_ASSR
	VALUES (7342,
	7337,
	7343,
	0);
INSERT INTO R_RGO
	VALUES (7342,
	7337,
	7343);
INSERT INTO R_OIR
	VALUES (7342,
	7337,
	7343,
	0);
INSERT INTO R_SIMP
	VALUES (7344);
INSERT INTO R_REL
	VALUES (7344,
	34,
	'',
	7221);
INSERT INTO R_PART
	VALUES (7338,
	7344,
	7345,
	0,
	0,
	'contains children of');
INSERT INTO O_RTIDA
	VALUES (7340,
	7338,
	0,
	7344,
	7345);
INSERT INTO R_RTO
	VALUES (7338,
	7344,
	7345,
	0);
INSERT INTO R_OIR
	VALUES (7338,
	7344,
	7345,
	0);
INSERT INTO R_FORM
	VALUES (7346,
	7344,
	7347,
	0,
	1,
	'is parent to other packages via');
INSERT INTO R_RGO
	VALUES (7346,
	7344,
	7347);
INSERT INTO R_OIR
	VALUES (7346,
	7344,
	7347,
	0);
INSERT INTO R_SIMP
	VALUES (7348);
INSERT INTO R_REL
	VALUES (7348,
	35,
	'',
	7221);
INSERT INTO R_PART
	VALUES (7346,
	7348,
	7349,
	0,
	1,
	'is child via');
INSERT INTO O_RTIDA
	VALUES (7350,
	7346,
	0,
	7348,
	7349);
INSERT INTO R_RTO
	VALUES (7346,
	7348,
	7349,
	0);
INSERT INTO R_OIR
	VALUES (7346,
	7348,
	7349,
	0);
INSERT INTO R_FORM
	VALUES (7338,
	7348,
	7351,
	1,
	1,
	'contains');
INSERT INTO R_RGO
	VALUES (7338,
	7348,
	7351);
INSERT INTO R_OIR
	VALUES (7338,
	7348,
	7351,
	0);
INSERT INTO R_SIMP
	VALUES (7352);
INSERT INTO R_REL
	VALUES (7352,
	36,
	'',
	7221);
INSERT INTO R_PART
	VALUES (699,
	7352,
	7353,
	0,
	1,
	'is contained in');
INSERT INTO O_RTIDA
	VALUES (712,
	699,
	0,
	7352,
	7353);
INSERT INTO R_RTO
	VALUES (699,
	7352,
	7353,
	0);
INSERT INTO R_OIR
	VALUES (699,
	7352,
	7353,
	0);
INSERT INTO R_FORM
	VALUES (7338,
	7352,
	7354,
	1,
	1,
	'contains');
INSERT INTO R_RGO
	VALUES (7338,
	7352,
	7354);
INSERT INTO R_OIR
	VALUES (7338,
	7352,
	7354,
	0);
INSERT INTO R_SIMP
	VALUES (7355);
INSERT INTO R_REL
	VALUES (7355,
	37,
	'',
	7221);
INSERT INTO R_PART
	VALUES (936,
	7355,
	7356,
	0,
	0,
	'contains children of');
INSERT INTO O_RTIDA
	VALUES (943,
	936,
	0,
	7355,
	7356);
INSERT INTO R_RTO
	VALUES (936,
	7355,
	7356,
	0);
INSERT INTO R_OIR
	VALUES (936,
	7355,
	7356,
	0);
INSERT INTO R_FORM
	VALUES (7357,
	7355,
	7358,
	0,
	1,
	'is parent to other packages via');
INSERT INTO R_RGO
	VALUES (7357,
	7355,
	7358);
INSERT INTO R_OIR
	VALUES (7357,
	7355,
	7358,
	0);
INSERT INTO R_SIMP
	VALUES (7359);
INSERT INTO R_REL
	VALUES (7359,
	38,
	'',
	7221);
INSERT INTO R_FORM
	VALUES (936,
	7359,
	7360,
	1,
	1,
	'contains');
INSERT INTO R_RGO
	VALUES (936,
	7359,
	7360);
INSERT INTO R_OIR
	VALUES (936,
	7359,
	7360,
	0);
INSERT INTO R_PART
	VALUES (7357,
	7359,
	7361,
	0,
	1,
	'is child via');
INSERT INTO O_RTIDA
	VALUES (7362,
	7357,
	0,
	7359,
	7361);
INSERT INTO R_RTO
	VALUES (7357,
	7359,
	7361,
	0);
INSERT INTO R_OIR
	VALUES (7357,
	7359,
	7361,
	0);
INSERT INTO R_ASSOC
	VALUES (7363);
INSERT INTO R_REL
	VALUES (7363,
	39,
	'',
	7221);
INSERT INTO R_AOTH
	VALUES (936,
	7363,
	7364,
	0,
	1,
	'is contained in');
INSERT INTO O_RTIDA
	VALUES (943,
	936,
	0,
	7363,
	7364);
INSERT INTO R_RTO
	VALUES (936,
	7363,
	7364,
	0);
INSERT INTO R_OIR
	VALUES (936,
	7363,
	7364,
	0);
INSERT INTO R_AONE
	VALUES (32,
	7363,
	7365,
	1,
	1,
	'contains');
INSERT INTO O_RTIDA
	VALUES (156,
	32,
	0,
	7363,
	7365);
INSERT INTO R_RTO
	VALUES (32,
	7363,
	7365,
	0);
INSERT INTO R_OIR
	VALUES (32,
	7363,
	7365,
	0);
INSERT INTO R_ASSR
	VALUES (7366,
	7363,
	7367,
	0);
INSERT INTO R_RGO
	VALUES (7366,
	7363,
	7367);
INSERT INTO R_OIR
	VALUES (7366,
	7363,
	7367,
	0);
INSERT INTO R_SIMP
	VALUES (7368);
INSERT INTO R_REL
	VALUES (7368,
	40,
	'',
	7221);
INSERT INTO R_PART
	VALUES (699,
	7368,
	7369,
	0,
	1,
	'is contained in');
INSERT INTO O_RTIDA
	VALUES (712,
	699,
	0,
	7368,
	7369);
INSERT INTO R_RTO
	VALUES (699,
	7368,
	7369,
	0);
INSERT INTO R_OIR
	VALUES (699,
	7368,
	7369,
	0);
INSERT INTO R_FORM
	VALUES (936,
	7368,
	7370,
	1,
	1,
	'contains');
INSERT INTO R_RGO
	VALUES (936,
	7368,
	7370);
INSERT INTO R_OIR
	VALUES (936,
	7368,
	7370,
	0);
INSERT INTO R_SIMP
	VALUES (7371);
INSERT INTO R_REL
	VALUES (7371,
	42,
	'',
	7221);
INSERT INTO R_PART
	VALUES (701,
	7371,
	7372,
	0,
	0,
	'contains');
INSERT INTO O_RTIDA
	VALUES (717,
	701,
	0,
	7371,
	7372);
INSERT INTO R_RTO
	VALUES (701,
	7371,
	7372,
	0);
INSERT INTO R_OIR
	VALUES (701,
	7371,
	7372,
	0);
INSERT INTO R_FORM
	VALUES (7373,
	7371,
	7374,
	0,
	1,
	'is child via');
INSERT INTO R_RGO
	VALUES (7373,
	7371,
	7374);
INSERT INTO R_OIR
	VALUES (7373,
	7371,
	7374,
	0);
INSERT INTO R_SIMP
	VALUES (7375);
INSERT INTO R_REL
	VALUES (7375,
	41,
	'',
	7221);
INSERT INTO R_FORM
	VALUES (7373,
	7375,
	7376,
	1,
	1,
	'is parent to other packages via');
INSERT INTO R_RGO
	VALUES (7373,
	7375,
	7376);
INSERT INTO R_OIR
	VALUES (7373,
	7375,
	7376,
	0);
INSERT INTO R_PART
	VALUES (701,
	7375,
	7377,
	0,
	0,
	'contains children of');
INSERT INTO O_RTIDA
	VALUES (717,
	701,
	0,
	7375,
	7377);
INSERT INTO R_RTO
	VALUES (701,
	7375,
	7377,
	0);
INSERT INTO R_OIR
	VALUES (701,
	7375,
	7377,
	0);
INSERT INTO R_ASSOC
	VALUES (7378);
INSERT INTO R_REL
	VALUES (7378,
	43,
	'',
	7221);
INSERT INTO R_AOTH
	VALUES (699,
	7378,
	7379,
	0,
	1,
	'is top level of subsystems');
INSERT INTO O_RTIDA
	VALUES (712,
	699,
	0,
	7378,
	7379);
INSERT INTO R_RTO
	VALUES (699,
	7378,
	7379,
	0);
INSERT INTO R_OIR
	VALUES (699,
	7378,
	7379,
	0);
INSERT INTO R_AONE
	VALUES (701,
	7378,
	7380,
	1,
	1,
	'has top level subsystems');
INSERT INTO O_RTIDA
	VALUES (717,
	701,
	0,
	7378,
	7380);
INSERT INTO R_RTO
	VALUES (701,
	7378,
	7380,
	0);
INSERT INTO R_OIR
	VALUES (701,
	7378,
	7380,
	0);
INSERT INTO R_ASSR
	VALUES (7381,
	7378,
	7382,
	0);
INSERT INTO R_RGO
	VALUES (7381,
	7378,
	7382);
INSERT INTO R_OIR
	VALUES (7381,
	7378,
	7382,
	0);
INSERT INTO R_SIMP
	VALUES (7383);
INSERT INTO R_REL
	VALUES (7383,
	44,
	'',
	7221);
INSERT INTO R_PART
	VALUES (7264,
	7383,
	7384,
	0,
	0,
	'has parent');
INSERT INTO O_RTIDA
	VALUES (7385,
	7264,
	0,
	7383,
	7384);
INSERT INTO R_RTO
	VALUES (7264,
	7383,
	7384,
	0);
INSERT INTO R_OIR
	VALUES (7264,
	7383,
	7384,
	0);
INSERT INTO R_FORM
	VALUES (55,
	7383,
	7386,
	1,
	1,
	'has member');
INSERT INTO R_RGO
	VALUES (55,
	7383,
	7386);
INSERT INTO R_OIR
	VALUES (55,
	7383,
	7386,
	0);
INSERT INTO R_SIMP
	VALUES (7387);
INSERT INTO R_REL
	VALUES (7387,
	45,
	'CrossComponent:true',
	7221);
INSERT INTO R_PART
	VALUES (32,
	7387,
	7388,
	0,
	0,
	'is defined by');
INSERT INTO O_RTIDA
	VALUES (156,
	32,
	0,
	7387,
	7388);
INSERT INTO R_RTO
	VALUES (32,
	7387,
	7388,
	0);
INSERT INTO R_OIR
	VALUES (32,
	7387,
	7388,
	0);
INSERT INTO R_FORM
	VALUES (55,
	7387,
	7389,
	1,
	1,
	'defines the type of');
INSERT INTO R_RGO
	VALUES (55,
	7387,
	7389);
INSERT INTO R_OIR
	VALUES (55,
	7387,
	7389,
	0);
INSERT INTO R_SIMP
	VALUES (7390);
INSERT INTO R_REL
	VALUES (7390,
	46,
	'',
	7221);
INSERT INTO R_PART
	VALUES (55,
	7390,
	7391,
	0,
	1,
	'succeeds');
INSERT INTO O_RTIDA
	VALUES (231,
	55,
	0,
	7390,
	7391);
INSERT INTO O_RTIDA
	VALUES (232,
	55,
	0,
	7390,
	7391);
INSERT INTO R_RTO
	VALUES (55,
	7390,
	7391,
	0);
INSERT INTO R_OIR
	VALUES (55,
	7390,
	7391,
	0);
INSERT INTO R_FORM
	VALUES (55,
	7390,
	7392,
	0,
	1,
	'precedes');
INSERT INTO R_RGO
	VALUES (55,
	7390,
	7392);
INSERT INTO R_OIR
	VALUES (55,
	7390,
	7392,
	0);
INSERT INTO R_ASSOC
	VALUES (7393);
INSERT INTO R_REL
	VALUES (7393,
	47,
	'CrossComponent:true',
	7221);
INSERT INTO R_AONE
	VALUES (699,
	7393,
	7394,
	1,
	1,
	'is suppressed in');
INSERT INTO O_RTIDA
	VALUES (712,
	699,
	0,
	7393,
	7394);
INSERT INTO R_RTO
	VALUES (699,
	7393,
	7394,
	0);
INSERT INTO R_OIR
	VALUES (699,
	7393,
	7394,
	0);
INSERT INTO R_AOTH
	VALUES (32,
	7393,
	7395,
	1,
	1,
	'contains suppressed');
INSERT INTO O_RTIDA
	VALUES (156,
	32,
	0,
	7393,
	7395);
INSERT INTO R_RTO
	VALUES (32,
	7393,
	7395,
	0);
INSERT INTO R_OIR
	VALUES (32,
	7393,
	7395,
	0);
INSERT INTO R_ASSR
	VALUES (7396,
	7393,
	7397,
	0);
INSERT INTO R_RGO
	VALUES (7396,
	7393,
	7397);
INSERT INTO R_OIR
	VALUES (7396,
	7393,
	7397,
	0);
INSERT INTO R_SIMP
	VALUES (7398);
INSERT INTO R_REL
	VALUES (7398,
	49,
	'',
	7221);
INSERT INTO R_PART
	VALUES (46,
	7398,
	7399,
	0,
	1,
	'specifies occurrences of');
INSERT INTO O_RTIDA
	VALUES (211,
	46,
	0,
	7398,
	7399);
INSERT INTO R_RTO
	VALUES (46,
	7398,
	7399,
	0);
INSERT INTO R_OIR
	VALUES (46,
	7398,
	7399,
	0);
INSERT INTO R_FORM
	VALUES (59,
	7398,
	7400,
	1,
	1,
	'may have');
INSERT INTO R_RGO
	VALUES (59,
	7398,
	7400);
INSERT INTO R_OIR
	VALUES (59,
	7398,
	7400,
	0);
INSERT INTO R_SIMP
	VALUES (7401);
INSERT INTO R_REL
	VALUES (7401,
	50,
	'',
	7221);
INSERT INTO R_PART
	VALUES (6,
	7401,
	7402,
	0,
	1,
	'defines return value dimensions for');
INSERT INTO O_RTIDA
	VALUES (16,
	6,
	0,
	7401,
	7402);
INSERT INTO R_RTO
	VALUES (6,
	7401,
	7402,
	0);
INSERT INTO R_OIR
	VALUES (6,
	7401,
	7402,
	0);
INSERT INTO R_FORM
	VALUES (59,
	7401,
	7403,
	1,
	1,
	'return value may have');
INSERT INTO R_RGO
	VALUES (59,
	7401,
	7403);
INSERT INTO R_OIR
	VALUES (59,
	7401,
	7403,
	0);
INSERT INTO R_SIMP
	VALUES (7404);
INSERT INTO R_REL
	VALUES (7404,
	51,
	'',
	7221);
INSERT INTO R_PART
	VALUES (8,
	7404,
	7405,
	0,
	1,
	'defines return value dimensions for');
INSERT INTO O_RTIDA
	VALUES (11,
	8,
	0,
	7404,
	7405);
INSERT INTO R_RTO
	VALUES (8,
	7404,
	7405,
	0);
INSERT INTO R_OIR
	VALUES (8,
	7404,
	7405,
	0);
INSERT INTO R_FORM
	VALUES (59,
	7404,
	7406,
	1,
	1,
	'return value may have');
INSERT INTO R_RGO
	VALUES (59,
	7404,
	7406);
INSERT INTO R_OIR
	VALUES (59,
	7404,
	7406,
	0);
INSERT INTO R_SIMP
	VALUES (7407);
INSERT INTO R_REL
	VALUES (7407,
	52,
	'',
	7221);
INSERT INTO R_PART
	VALUES (48,
	7407,
	7408,
	0,
	1,
	'specifies occurrences of');
INSERT INTO O_RTIDA
	VALUES (215,
	48,
	0,
	7407,
	7408);
INSERT INTO R_RTO
	VALUES (48,
	7407,
	7408,
	0);
INSERT INTO R_OIR
	VALUES (48,
	7407,
	7408,
	0);
INSERT INTO R_FORM
	VALUES (59,
	7407,
	7409,
	1,
	1,
	'may have');
INSERT INTO R_RGO
	VALUES (59,
	7407,
	7409);
INSERT INTO R_OIR
	VALUES (59,
	7407,
	7409,
	0);
INSERT INTO R_SIMP
	VALUES (7410);
INSERT INTO R_REL
	VALUES (7410,
	53,
	'',
	7221);
INSERT INTO R_PART
	VALUES (55,
	7410,
	7411,
	0,
	1,
	'specifies occurrences of');
INSERT INTO O_RTIDA
	VALUES (231,
	55,
	0,
	7410,
	7411);
INSERT INTO O_RTIDA
	VALUES (232,
	55,
	0,
	7410,
	7411);
INSERT INTO R_RTO
	VALUES (55,
	7410,
	7411,
	0);
INSERT INTO R_OIR
	VALUES (55,
	7410,
	7411,
	0);
INSERT INTO R_FORM
	VALUES (59,
	7410,
	7412,
	1,
	1,
	'may have');
INSERT INTO R_RGO
	VALUES (59,
	7410,
	7412);
INSERT INTO R_OIR
	VALUES (59,
	7410,
	7412,
	0);
INSERT INTO R_SIMP
	VALUES (7413);
INSERT INTO R_REL
	VALUES (7413,
	54,
	'',
	7221);
INSERT INTO R_PART
	VALUES (48,
	7413,
	7414,
	0,
	1,
	'succeeds');
INSERT INTO O_RTIDA
	VALUES (215,
	48,
	0,
	7413,
	7414);
INSERT INTO R_RTO
	VALUES (48,
	7413,
	7414,
	0);
INSERT INTO R_OIR
	VALUES (48,
	7413,
	7414,
	0);
INSERT INTO R_FORM
	VALUES (48,
	7413,
	7415,
	0,
	1,
	'precedes');
INSERT INTO R_RGO
	VALUES (48,
	7413,
	7415);
INSERT INTO R_OIR
	VALUES (48,
	7413,
	7415,
	0);
INSERT INTO R_SIMP
	VALUES (7416);
INSERT INTO R_REL
	VALUES (7416,
	55,
	'',
	7221);
INSERT INTO R_PART
	VALUES (46,
	7416,
	7417,
	0,
	1,
	'succeeds');
INSERT INTO O_RTIDA
	VALUES (211,
	46,
	0,
	7416,
	7417);
INSERT INTO R_RTO
	VALUES (46,
	7416,
	7417,
	0);
INSERT INTO R_OIR
	VALUES (46,
	7416,
	7417,
	0);
INSERT INTO R_FORM
	VALUES (46,
	7416,
	7418,
	0,
	1,
	'precedes');
INSERT INTO R_RGO
	VALUES (46,
	7416,
	7418);
INSERT INTO R_OIR
	VALUES (46,
	7416,
	7418,
	0);
INSERT INTO R_SIMP
	VALUES (7419);
INSERT INTO R_REL
	VALUES (7419,
	56,
	'',
	7221);
INSERT INTO R_PART
	VALUES (39,
	7419,
	7420,
	0,
	1,
	'succeeds');
INSERT INTO O_RTIDA
	VALUES (172,
	39,
	0,
	7419,
	7420);
INSERT INTO R_RTO
	VALUES (39,
	7419,
	7420,
	0);
INSERT INTO R_OIR
	VALUES (39,
	7419,
	7420,
	0);
INSERT INTO R_FORM
	VALUES (39,
	7419,
	7421,
	0,
	1,
	'precedes');
INSERT INTO R_RGO
	VALUES (39,
	7419,
	7421);
INSERT INTO R_OIR
	VALUES (39,
	7419,
	7421,
	0);
INSERT INTO R_SIMP
	VALUES (7422);
INSERT INTO R_REL
	VALUES (7422,
	18,
	'',
	7221);
INSERT INTO R_PART
	VALUES (32,
	7422,
	7423,
	0,
	0,
	'are defined within');
INSERT INTO O_RTIDA
	VALUES (156,
	32,
	0,
	7422,
	7423);
INSERT INTO R_RTO
	VALUES (32,
	7422,
	7423,
	0);
INSERT INTO R_OIR
	VALUES (32,
	7422,
	7423,
	0);
INSERT INTO R_FORM
	VALUES (7260,
	7422,
	7424,
	1,
	1,
	'defines domain of');
INSERT INTO R_RGO
	VALUES (7260,
	7422,
	7424);
INSERT INTO R_OIR
	VALUES (7260,
	7422,
	7424,
	0);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (7260,
	'User Data Type',
	11,
	'S_UDT',
	'User Data Types are those data types which have been created by the analyst and derived from the core data types.  ',
	7221);
INSERT INTO O_TFR
	VALUES (7425,
	7260,
	'dispose',
	'The dispose operation for this class.',
	19,
	1,
	'select one cdt related by self->S_DT[R18];
unrelate self from cdt across R18;
select one dt related by self->S_DT[R17];
unrelate self from dt across R17;
delete object instance self;',
	1,
	'',
	7426);
INSERT INTO O_TFR
	VALUES (7427,
	7260,
	'rename',
	'Rename this user data type.',
	19,
	1,
	'select one dt related by self->S_DT[R17];
dummy = dt.rename(new_name:param.new_name);
',
	1,
	'',
	7428);
INSERT INTO O_TPARM
	VALUES (7429,
	7427,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7430,
	7260,
	'get_name',
	'Return the name of this user data type.',
	322,
	1,
	'select one dt related by self->S_DT[R17];
if (empty dt)
  return "";
else
  return dt.Name;
end if;',
	1,
	'',
	7431);
INSERT INTO O_TFR
	VALUES (7432,
	7260,
	'get_style',
	'',
	784,
	1,
	'return Style::Box;',
	1,
	'',
	7433);
INSERT INTO O_TFR
	VALUES (7434,
	7260,
	'get_text_style',
	'',
	784,
	1,
	'return Style::None;',
	1,
	'',
	7432);
INSERT INTO O_TPARM
	VALUES (7435,
	7434,
	'comp_num',
	298,
	0,
	'',
	7436,
	'');
INSERT INTO O_TPARM
	VALUES (7437,
	7434,
	'ent_num',
	298,
	0,
	'',
	7435,
	'');
INSERT INTO O_TPARM
	VALUES (7436,
	7434,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7438,
	7260,
	'get_compartments',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	7439);
INSERT INTO O_TFR
	VALUES (7431,
	7260,
	'get_entries',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	7438);
INSERT INTO O_TPARM
	VALUES (7440,
	7431,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7439,
	7260,
	'get_compartment_text',
	'',
	322,
	1,
	'result = "";
if (param.at == Justification::Center_in_X)
  result = "dataType";
elif (param.at == Justification::Center)
  select one coreDt related by self->S_DT[R18];
  select one selfDt related by self->S_DT[R17];
  if ( not_empty coreDt and not_empty selfDt )
    result = selfDt.Name + GD::newline() + "{ " + coreDt.Name + " }";
  else
    result = ::getOrphanedElementName();
  end if;
  if not_empty selfDt
    select one pe related by selfDt->PE_PE[R8001];
    if not_empty pe
      result = pe.getVisibilityAdornment() + result;
    end if;
  end if;
end if;
return result;',
	1,
	'',
	7425);
INSERT INTO O_TPARM
	VALUES (7441,
	7439,
	'comp_num',
	298,
	0,
	'',
	7442,
	'');
INSERT INTO O_TPARM
	VALUES (7443,
	7439,
	'ent_num',
	298,
	0,
	'',
	7441,
	'');
INSERT INTO O_TPARM
	VALUES (7442,
	7439,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7433,
	7260,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.DT_ID;',
	1,
	'',
	7430);
INSERT INTO O_TFR
	VALUES (7428,
	7260,
	'isAllowedCoreType',
	'',
	316,
	1,
	'if(param.typeName == "inst_ref<Object>")
  return false;
elif(param.typeName == "inst_ref_set<Object>")
  return false;
elif(param.typeName == "same_as<Base_Attribute>")
  return false;
elif(param.typeName == "state<State_Model>")
  return false;
elif(param.typeName == "void")
  return false;
elif(param.typeName == "inst<Event>")
  return false;
elif(param.typeName == "date")
  return false;
elif(param.typeName == "timestamp")
  return false;
elif(param.typeName == "inst_ref<Timer>")
  return false;
end if;
return true;',
	1,
	'',
	7434);
INSERT INTO O_TPARM
	VALUES (7444,
	7428,
	'typeName',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7445,
	7260,
	'changeCoreType',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one dt related by self->S_DT[R18];
select any new_dt related by self->S_DT[R17]->S_DOM[R14]->S_DT[R14] 
                                          where selected.Name == param.typeName;

select one packageableElem related by self->S_DT[R17]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;

if isInGenericPackage
  // Note that this operation calls collectVisibleElementsForName
  id = packageableElem.resolveDataTypeRelativeToSelf(default_name:param.typeName,
                                                          expected_name:param.typeName);                                                          
  select any new_dt related by package->PE_VIS[R8002]->
                       PE_PE[R8002]->S_DT[R8001] where selected.DT_ID == id;
  if (empty new_dt)
    select any new_dt related by component->PE_CVS[R8004]->
                     PE_PE[R8004]->S_DT[R8001] where selected.DT_ID == id;
  end if;	
else
  // see if this dt is defined at the system level
  if(empty new_dt)
    select any system related by self->S_DT[R17]->SLD_SDINP[R4401]->S_SYS[R4402];
    if(not_empty system)
      dt_id = system.getCoreTypeId(name:param.typeName);
      select any pe from instances of PE_PE where selected.Element_ID == dt_id;
      select one new_dt related by pe->S_DT[R8001];
    end if;
  end if;
end if;

if(not_empty new_dt)
  unrelate self from dt across R18;
  relate self to new_dt across R18;
end if;
',
	1,
	'',
	7446);
INSERT INTO O_TPARM
	VALUES (7447,
	7445,
	'typeName',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7448,
	7260,
	'canDelete',
	'',
	316,
	1,
	' return (self.Gen_Type == 0);',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (7449,
	7260,
	'canRename',
	'',
	316,
	1,
	' return (self.Gen_Type == 0);',
	1,
	'',
	7450);
INSERT INTO O_TFR
	VALUES (7451,
	7260,
	'resolveDatatype',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one proxyCoretype related by self->S_DT[R18];
if(not_empty proxyCoretype and not Util::isProxy(element:self.convertToInstance()))
  isInGenericPackage = false;
  select one system related by self->S_DT[R17]->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405];
  if (not_empty system)
    isInGenericPackage = true;
  else
    select one component related by self->S_DT[R17]->PE_PE[R8001]->C_C[R8003];
    if (not_empty component)
      rootCompIdInPkg = component.getRootComponentId();
      select any rootComponent from instances of C_C where (selected.Id == rootCompIdInPkg);
      select one system related by rootComponent->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405];
    end if;
    if (not_empty system)
      isInGenericPackage = true;
    end if;
  end if;
  name = proxyCoretype.Name;
  unrelate proxyCoretype from self across R18;
  if (isInGenericPackage)
	select one selfPe related by self->S_DT[R17]->PE_PE[R8001];
	dt_id = selfPe.resolveDataTypeRelativeToSelf(default_name:"integer",
                                                            expected_name:name);
    select any pe from instances of PE_PE where selected.Element_ID == dt_id;
    select one resolvedDT related by pe->S_DT[R8001]; 
    if(not_empty resolvedDT)
      relate resolvedDT to self across R18;
    end if;
  else
    select any system related by self->S_DT[R17]->SLD_SDINP[R4401]
    															 ->S_SYS[R4402];
    if empty system
      select any system related by self->S_DT[R17]->
                                       PE_PE[R8001]->G_EIS[R9100]->S_SYS[R9100];
    end if;
    if(not_empty system)
      // this is a system level dt only allow resolution
      // to a system level data type
      dt_id = system.getCoreTypeId(name:name);
      select any pe from instances of PE_PE where selected.Element_ID == dt_id;
      select one resolvedDT related by pe->S_DT[R8001]; 
      if(empty resolvedDT)
        dt_id = system.getCoreTypeId(name:"integer");
        select any pe from instances of PE_PE where selected.Element_ID == dt_id;
        select one resolvedDT related by pe->S_DT[R8001]; 
      end if;
      if(not_empty resolvedDT)
        relate resolvedDT to self across R18;
      end if;
    else
      select one domain related by self->S_DT[R17]->S_DOM[R14];
      id = domain.resolveDataTypeRelativeToSelf(default_name:"integer",
  													        expected_name:name);
      select any resolvedDT related by domain->S_DT[R14]
                                                 where (selected.DT_ID == id);
      if(empty resolvedDT)
        select one domSys related by domain->CN_DC[R4204]->C_C[R4204]
        	                                       ->CP_CP[R4608]->S_SYS[R4606];
        select any resolvedDT related by domSys->SLD_SDINP[R4402]->S_DT[R4401]
      	                                       where (selected.DT_ID == id);
        if empty resolvedDT and not_empty domSys and domSys.useGlobals
          select any resolvedDT related by domSys->G_EIS[R9100]->
                       PE_PE[R9100]->S_DT[R8001] where (selected.DT_ID == id);
        end if;
      end if;
      if(not_empty resolvedDT)
        relate resolvedDT to self across R18;
      end if;
    end if; // not_empty system 
  end if;    
end if;  // isInGenericPackage',
	1,
	'',
	7427);
INSERT INTO O_TFR
	VALUES (7450,
	7260,
	'canReferToDataType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// select the dt
select one dt related by self->S_DT[R18];
if(not_empty dt)
  select one packageableElem related by self->S_DT[R17]->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = not_empty package or not_empty component;

  if (isInGenericPackage)
    return packageableElem.canReferToDataType(dtID:dt.DT_ID, dtName: dt.Name);
  end if;

  // if the data type package is at the system
  // level we can use the data type as long as
  // this element belongs to a formal component
  select one udtDTPkg related by self->S_DT[R17]->S_DIP[R39]->S_DPK[R39];
  select one dtPkg related by dt->S_DIP[R39]->S_DPK[R39];
  if(udtDTPkg.isDomainLevel())
    dom_id = udtDTPkg.getDomainId();
    select any domain from instances of S_DOM
                                              where (selected.Dom_ID == dom_id);
    if(not dtPkg.isDomainLevel())
      if(domain.participatesInSystem())
        return true;
      else
        return false;
      end if;
    else
      // otherwise the DT must be in the same domain
      select one dtDomain related by dt->S_DOM[R14];
      if(dtDomain == domain)
        return true;
      end if;
    end if;  
  else
    // the dt can be used as long as it is defined at the system
    // level
    if(not dtPkg.isDomainLevel())
      return true;
    end if;
  end if;
end if;
return false;',
	1,
	'',
	7448);
INSERT INTO O_TFR
	VALUES (7426,
	7260,
	'convertToInstance',
	'Translate:native',
	317,
	1,
	'return this;',
	0,
	'',
	7445);
INSERT INTO O_TFR
	VALUES (7446,
	7260,
	'canUseDataType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// User Data Type.canUseDataType()
select one packageableElem related by self->S_DT[R17]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
select one selfDt related by self->S_DT[R17];
isInGenericPackage = not_empty package or not_empty component;
if isInGenericPackage
  // Find the previously created visibility list
  select any resultSet related by package->PE_SRS[R8005] where
        selected.Name == "" and selected.Type == ElementTypeConstants::DATATYPE;
  select any dt related by resultSet->PE_VIS[R8006]->
                     PE_PE[R8002]->S_DT[R8001] where selected.DT_ID == param.id;
  if not_empty component
    // Find the previously created visibility list
    select any compResultSet related by component->PE_CRS[R8007] where
        selected.Name == "" and selected.Type == ElementTypeConstants::DATATYPE;
    select any dt related by compResultSet->PE_CVS[R8008]->
                     PE_PE[R8004]->S_DT[R8001] where selected.DT_ID == param.id;
  end if;
  if(not_empty dt)
    if(self.isAllowedCoreType(typeName:dt.Name))
      // do not include the existing selection
      select one existingDT related by self->S_DT[R18];
      if(existingDT != dt and dt != selfDt)
        return true;
      end if;
    end if;
  end if;
  return false;
else
  select one domain related by self->S_DT[R17]->S_DOM[R14];
  if(not_empty domain)
    if(domain.participatesInSystem())
      // system level check both the system
      // and the domain for the dt
      select one system related by domain->CN_DC[R4204]->C_C[R4204]->CP_CP[R4608]
                                                                 ->S_SYS[R4606];
      select any dt related by system->SLD_SDINP[R4402]->S_DT[R4401]
                                             where (selected.DT_ID == param.id);
      if empty dt and not_empty system and system.useGlobals
        select any pe related by system->G_EIS[R9100]->PE_PE[R9100]
                                          where selected.Element_ID == param.id;
        select one dt related by pe->S_DT[R8001]; 
      end if;
      if(empty dt)
        select any dt related by domain->S_DT[R14]
                                             where (selected.DT_ID == param.id);
      end if;
      if(not_empty dt)
        if(self.isAllowedCoreType(typeName:dt.Name))
          select one existingDT related by self->S_DT[R18];
          if(existingDT != dt and dt != selfDt)
            return true;
          end if;
        end if;
      end if;
    else
      // only check the domain for the dt
      select any dt related by domain->S_DT[R14]
                                             where (selected.DT_ID == param.id);
      if(not_empty dt)
        if(self.isAllowedCoreType(typeName:dt.Name))
          select one existingDT related by self->S_DT[R18];
          if(existingDT != dt and dt != selfDt)
            return true;
          end if;
        end if;
      end if;
    end if;
  else
    // defined at the system level
    select any system related by self->S_DT[R17]->SLD_SDINP[R4401]->S_SYS[R4402];
    if empty system
      // User Data type is in a package . . . 
      select one system related by self->S_DT[R17]->PE_PE[R8001]->
                                                    EP_PKG[R8000]->S_SYS[R1405];
    end if;
    select any dt related by system->SLD_SDINP[R4402]->S_DT[R4401]
                                             where (selected.DT_ID == param.id);
    if empty dt and not_empty system and system.useGlobals
      select any pe related by system->G_EIS[R9100]->PE_PE[R9100]
                                          where selected.Element_ID == param.id;
      select one dt related by pe->S_DT[R8001]; 
    end if;
    if(not_empty dt)
      if(self.isAllowedCoreType(typeName:dt.Name))
        select one existingDT related by self->S_DT[R18];
        if(existingDT != dt and dt != selfDt)
          return true;
        end if;
      end if;
    end if;
  end if;
  return false;
end if;',
	1,
	'',
	7449);
INSERT INTO O_TPARM
	VALUES (7452,
	7446,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7453,
	7260,
	'actionFilter',
	'',
	316,
	1,
	'if(param.name == "can")
	if(param.value == "SetType")
		if(self.Gen_Type == 0)
      // do not allow setting type of
      // builtin UDTs
			return true;
		end if;
	end if;
	if param.value == "make public"
		select one pe related by self->S_DT[R17]->PE_PE[R8001];
		select one pkg related by pe->EP_PKG[R8000];
		if not_empty pkg
			if not_empty pe 
				return pe.Visibility != Visibility::Public;
			end if;
		end if;
	end if;
	if param.value == "make protected"
		select one pe related by self->S_DT[R17]->PE_PE[R8001];
		select one pkg related by pe->EP_PKG[R8000];
		if not_empty pkg
    		if not_empty pe 
      			return pe.Visibility != Visibility::Protected;
    		end if;
  		end if;
  	end if;
	if param.value == "make private"
		select one pe related by self->S_DT[R17]->PE_PE[R8001];
		select one pkg related by pe->EP_PKG[R8000];
		if not_empty pkg
    		if not_empty pe 
      			return pe.Visibility != Visibility::Private;
    		end if;
  		end if;
  	end if;
end if;
return false;

',
	1,
	'',
	7451);
INSERT INTO O_TPARM
	VALUES (7454,
	7453,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (7455,
	7453,
	'value',
	322,
	0,
	'',
	7454,
	'');
INSERT INTO O_TFR
	VALUES (7456,
	7260,
	'getConfigurationInheritanceElementId',
	'',
	317,
	1,
	'select one coreType related by self->S_DT[R18];
if(not_empty coreType)
  return coreType.convertToInstance();
end if;
return self.convertToInstance();',
	1,
	'',
	7453);
INSERT INTO O_TFR
	VALUES (7457,
	7260,
	'getCoreType',
	'',
	296,
	1,
	'/**
 *  Recursively locate the final S_DT across R18
 */
select one coreType related by self->S_DT[R18];
select one udt related by coreType->S_UDT[R17];
if(not_empty udt)
  return udt.getCoreType();
end if;
return coreType.DT_ID;',
	1,
	'',
	7456);
INSERT INTO O_TFR
	VALUES (7458,
	7260,
	'isReferringToDefaultDataType',
	'',
	316,
	1,
	'select one dt related by self->S_DT[R18];
elementType = Util::getSimpleClassName(element:self.convertToInstance());
if(dt.Name == S_DT::getDefaultDataTypeName(elementType:elementType))
  return true;
end if;
return false;
',
	1,
	'',
	7457);
INSERT INTO O_TFR
	VALUES (7459,
	7260,
	'checkIntegrity',
	'',
	19,
	1,
	'// create an integrity issue if there are any other data types under
// the same package with the same name
select one dt related by self->S_DT[R17];
select one package related by dt->PE_PE[R8001]->EP_PKG[R8000];
select one component related by dt->PE_PE[R8001]->C_C[R8003];
if(not empty component)
  pkgId = component.getPackageId();
  select any package from instances of EP_PKG
                                           where (selected.Package_ID == pkgId);
end if;
select one system related by package->S_SYS[R1405];
sys_id = GD::NULL_UNIQUE_ID();
if(not_empty system)
  sys_id = system.Sys_ID;
end if;
select many dts related by dt->PE_PE[R8001]->EP_PKG[R8000]
                                                    ->PE_PE[R8000]->S_DT[R8001];
if(empty dts)
  select many dts related by dt->PE_PE[R8001]->C_C[R8003]
                                                    ->PE_PE[R8003]->S_DT[R8001];
end if;
for each otherDt in dts
  if(otherDt != dt and otherDt.Name == dt.Name)
    MI_IM::createIssue(sys_id:sys_id, description:
           "Found another data type under the same package with a " +
                                                          "matching name.",
                                       severity:Severity::Error, name:dt.Name,
                       path:dt.getPath(path:"", includeSelf:true),
                              id:dt.DT_ID, element:self.convertToInstance());
  end if;
end for;',
	1,
	'',
	7458);
INSERT INTO O_TFR
	VALUES (7460,
	7260,
	'getDescription',
	'',
	322,
	1,
	'select one dt related by self->S_DT[R17];
return dt.Descrip;',
	1,
	'',
	7459);
INSERT INTO O_NBATTR
	VALUES (7461,
	7260);
INSERT INTO O_BATTR
	VALUES (7461,
	7260);
INSERT INTO O_ATTR
	VALUES (7461,
	7260,
	7462,
	'Gen_Type',
	'Full Name: User Defined Type Type
Data Domain: 0 = user defined, 1 = date, 2 = timestamp, 3 = inst_ref\<Timer\>
enum0: User Defined
enum1: date
enum2: timestamp
enum3: inst_ref<Timer>

impl_detail: true
readonly: true
',
	'',
	'Gen_Type',
	0,
	298,
	'',
	'');
INSERT INTO O_REF
	VALUES (7260,
	32,
	0,
	156,
	7256,
	7261,
	7257,
	7463,
	7464,
	0,
	0,
	'',
	'Data Type',
	'DT_ID',
	'R17');
INSERT INTO O_RATTR
	VALUES (7463,
	7260,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (7463,
	7260,
	0,
	'DT_ID',
	'',
	'',
	'Element_ID',
	2,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (7260,
	32,
	0,
	156,
	7422,
	7424,
	7423,
	7462,
	7465,
	0,
	0,
	'',
	'Data Type',
	'DT_ID',
	'R18.''are defined within''');
INSERT INTO O_RATTR
	VALUES (7462,
	7260,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (7462,
	7260,
	7463,
	'CDT_DT_ID',
	'',
	'CDT_',
	'DT_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	7260);
INSERT INTO O_OIDA
	VALUES (7463,
	7260,
	0,
	'DT_ID');
INSERT INTO O_ID
	VALUES (1,
	7260);
INSERT INTO O_ID
	VALUES (2,
	7260);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (705,
	'System Model',
	18,
	'S_SYS',
	'A system is described by one or more models, each drawn from different subject matters. Each subject matter model is called a domain.
-----------
PEI:true',
	7221);
INSERT INTO O_TFR
	VALUES (7466,
	705,
	'dispose',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.

// Note that since R28 crosses a model root boundary, this
// select will return the empty set with the current MC-Java implementation
select many dom_set related by self->S_DOM[R28];
for each dom in dom_set
  dom.dispose();
end for;
select many compDiagrams related by self->CP_CP[R4602];
for each compDiagram in compDiagrams
  compDiagram.dispose();
end for;
select many interfaces related by self->IP_IP[R4302];
for each interface in interfaces
  interface.dispose();
end for;
select many systemDTPkgs related by self->SLD_SDP[R4400]->S_DPK[R4400];
for each systemDTPkg in systemDTPkgs
  systemDTPkg.dispose();
end for;
select many sequences related by self->SQ_S[R950];
for each sequence in sequences
  unrelate self from sequence across R950;
  sequence.dispose();
end for;
select many ucs related by self->UC_UCC[R1211];
for each uc in ucs
  unrelate self from uc across R1211;
  uc.dispose();
end for;
select many comms related by self->COMM_COMM[R1136];
for each comm in comms
  unrelate self from comm across R1136;
  comm.dispose();
end for;
select many activities related by self->A_A[R1113];
for each activity in activities
  unrelate self from activity across R1113;
  activity.dispose();
end for;

select many packages related by self->EP_PKG[R1401];
for each package in packages 
 unrelate self from package across R1401;
 package.dispose();
end for;

select many packages related by self->EP_PKG[R1405];
for each package in packages 
 unrelate self from package across R1405;
 package.dispose();
end for;


select many interfacePackages related by self->IP_IP[R4304];
for each interfacePackage in interfacePackages 
 unrelate self from interfacePackage across R4304;
 interfacePackage.dispose();
end for;

select many systemConstantsInPackage related by self->SLD_SCINP[R4404];
for each systemConstantInPackage in systemConstantsInPackage 
 unrelate self from systemConstantInPackage across R4404;
end for;


select many systemDataTypesInPackage related by self->SLD_SDINP[R4402];
for each systemDataTypeInPackage in systemDataTypesInPackage 
 unrelate self from systemDataTypeInPackage across R4402;
end for;


select many componentPackages related by self->CP_CP[R4606];
for each componentPackage in componentPackages
  unrelate self from componentPackage across R4606;
  componentPackage.dispose();
end for;
 
select many globalElements related by self->G_EIS[R9100];
for each globalElement in globalElements
  select one pe related by globalElement->PE_PE[R9100];
  unrelate self from pe across R9100 using globalElement;
end for;

delete object instance self;
',
	1,
	'',
	7467);
INSERT INTO O_TFR
	VALUES (7468,
	705,
	'newComponentPackage',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
create object instance compPackage of CP_CP;
create object instance sp of EP_SPKG;
relate compPackage to sp across R1402;
relate self to compPackage across R4602;
relate self to compPackage across R4606;
compPackage.initialize();',
	1,
	'',
	7469);
INSERT INTO O_TFR
	VALUES (7470,
	705,
	'newInterfacePackage',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
create object instance interfaceDiagram of IP_IP;
create object instance sp of EP_SPKG;
relate interfaceDiagram to sp across R1402;
relate self to interfaceDiagram across R4302;
relate self to interfaceDiagram across R4304;
interfaceDiagram.initialize();',
	1,
	'',
	7468);
INSERT INTO O_TFR
	VALUES (7471,
	705,
	'newSystemDTPkg',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
create object instance datatypePkg of S_DPK;
create object instance sp of EP_SPKG;
relate datatypePkg to sp across R1402;
create object instance sysDtPkg of SLD_SDP;
relate self to datatypePkg across R4400 using sysDtPkg;
datatypePkg.initialize();',
	1,
	'',
	7472);
INSERT INTO O_TFR
	VALUES (7467,
	705,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'return this;',
	0,
	'',
	7473);
INSERT INTO O_TFR
	VALUES (7474,
	705,
	'pasteDataTypePackage',
	'Currently renamed to disable support.',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any dtpkg from instances of S_DPK where (selected.Package_ID == param.id);
if(not_empty dtpkg)
  // guarantee a unique name for the pasted dt package
  dtpkg.Name = ::getUniqueInitialNameInParent(instance:dtpkg.convertToInstance(),
  						name:dtpkg.Name, parent:self.convertToInstance());
  dtpkg.associateWithSystem(sysID:self.Sys_ID);
  // convert child dts to system level ones
  dtpkg.associateDTSWithSystem(sys_id:self.Sys_ID);
  // convert child constant specs to system level ones
  dtpkg.associateCSPsWithSystem(sys_id:self.Sys_ID);
  // before removing any core dts from this package
  // we must resolve any user dts to new core types
  dtpkg.handleUserDataTypeResolution();
end if;',
	1,
	'',
	7475);
INSERT INTO O_TPARM
	VALUES (7476,
	7474,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7473,
	705,
	'canCopyDataTypePackage',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any dtPackage related by self->SLD_SDP[R4400]->S_DPK[R4400] where (selected.Package_ID == param.id);
if(not_empty dtPackage)
  if(dtPackage.Name != ::getCoreDatatypesPackageName())
    return true;
  end if;
end if;
return false;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (7477,
	7473,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7478,
	705,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Sys_ID;',
	1,
	'',
	7466);
INSERT INTO O_TFR
	VALUES (7479,
	705,
	'pasteInterfacePackage',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any ifacePkg from instances of IP_IP where (selected.Package_ID == param.id);
if(not_empty ifacePkg)
  // guarantee a unique name for the pasted dt package
  ifacePkg.Name = ::getUniqueInitialNameInParent(instance:ifacePkg.convertToInstance(),
  						name:ifacePkg.Name, parent:self.convertToInstance());
  ifacePkg.associateWithSystem(sysID:self.Sys_ID);  
  ifacePkg.associatePackageWithSystem(sysID:self.Sys_ID);
end if;',
	1,
	'',
	7480);
INSERT INTO O_TPARM
	VALUES (7481,
	7479,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7475,
	705,
	'pasteComponentPackage',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any compPkg from instances of CP_CP where (selected.Package_ID == param.id);
if(not_empty compPkg)
  // guarantee a unique name for the pasted component package
  compPkg.Name = ::getUniqueInitialNameInParent(instance:compPkg.convertToInstance(),
  						name:compPkg.Name, parent:self.convertToInstance());
  compPkg.associateWithSystem(sysID:self.Sys_ID);  
  // associate component packages with the system 
  compPkg.associatePackageWithSystem(sysID:self.Sys_ID);
  // remove any non local events that cannot be resolved
  compPkg.removeIncompleteSignalEvents();
end if;',
	1,
	'',
	7482);
INSERT INTO O_TPARM
	VALUES (7483,
	7475,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7480,
	705,
	'pasteDomain',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any domain from instances of S_DOM where (selected.Dom_ID == param.id);
if(not_empty domain)
  // guarantee a unique name for the pasted domain
  domain.Name = ::getUniqueInitialNameInParent(instance:domain.convertToInstance(),
  						name:domain.Name, parent:self.convertToInstance());
  // deassociate the pasted pkg with original parent
  select one prevSystem related by domain->S_SYS[R28];
  if(not_empty prevSystem)
    unrelate domain from prevSystem across R28;
  end if;
  // associate with new system
  relate domain to self across R28;
  // remove any non local events that cannot be resolved
  domain.removeIncompleteSignalEvents();
end if;',
	1,
	'',
	7474);
INSERT INTO O_TPARM
	VALUES (7484,
	7480,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7472,
	705,
	'newSequence',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
create object instance sequence of SQ_S;
create object instance sp of EP_SPKG;
relate sequence to sp across R1402;
relate self to sequence across R950;
sequence.initialize();',
	1,
	'',
	7485);
INSERT INTO O_TFR
	VALUES (7469,
	705,
	'newCommunication',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
create object instance comm of COMM_COMM;
create object instance sp of EP_SPKG;
relate comm to sp across R1402;
relate comm to self across R1136;
comm.initialize();',
	1,
	'',
	7486);
INSERT INTO O_TFR
	VALUES (7487,
	705,
	'newUseCasePackage',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
create object instance ucc of UC_UCC;
create object instance sp of EP_SPKG;
relate ucc to sp across R1402;
relate self to ucc across R1211;
ucc.initialize();',
	1,
	'',
	7471);
INSERT INTO O_TFR
	VALUES (7486,
	705,
	'newActivity',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
create object instance a of A_A;
create object instance sp of EP_SPKG;
relate a to sp across R1402;
relate self to a across R1113;
a.initialize();',
	1,
	'',
	7478);
INSERT INTO O_TFR
	VALUES (7485,
	705,
	'newPackage',
	'',
	19,
	1,
	'create object instance package of EP_PKG;
create object instance pe of PE_PE;
relate pe to package across R8001;
relate package to self across R1401;
relate package to self across R1405;
pe.type = ElementTypeConstants::PACKAGE;
pe.initialize();
package.initialize();',
	1,
	'',
	7470);
INSERT INTO O_TFR
	VALUES (7488,
	705,
	'pastePackage',
	'',
	19,
	1,
	'select any pkg from instances of EP_PKG where (selected.Package_ID == param.id);
if(not_empty pkg)
  select one directSystem related by pkg->S_SYS[R1401];
  if(not_empty directSystem)
    unrelate pkg from directSystem across R1401;
  end if;
  select one system related by pkg->S_SYS[R1405];
  if(not_empty system)
    unrelate pkg from system across R1405;
  end if;
  relate self to pkg across R1401;
  relate self to pkg across R1405;
  // guarantee a unique name for the pasted dt package
  pkg.Name = ::getUniqueInitialNameInParent(instance:pkg.convertToInstance(),
  						name:pkg.Name, parent:self.convertToInstance());
  // association all children with this
  // system
  pkg.associateWithSystem(sysID:self.Sys_ID);
  // for any non local event below this package
  // remove incomplete ones (those that are not
  // resolvable)
  pkg.removeIncompleteSignalEvents();
end if;',
	1,
	'',
	7479);
INSERT INTO O_TPARM
	VALUES (7489,
	7488,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7490,
	705,
	'pasteActivity',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any activity from instances of A_A
                                        where (selected.Package_ID == param.id);
if(not_empty activity)
  // guarantee a unique name for the pasted element
  activity.Name = ::getUniqueInitialNameInParent
                                         (instance:activity.convertToInstance(),
     					   name:activity.Name, parent:self.convertToInstance());
  activity.associateWithSystem(sysID:self.Sys_ID);
end if;',
	1,
	'',
	7487);
INSERT INTO O_TPARM
	VALUES (7491,
	7490,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7482,
	705,
	'pasteCommunication',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any comm from instances of COMM_COMM
                                        where (selected.Package_ID == param.id);
if(not_empty comm)
  // guarantee a unique name for the pasted element
  comm.Name = ::getUniqueInitialNameInParent (instance:comm.convertToInstance(),
     					   name:comm.Name, parent:self.convertToInstance());
  comm.associateWithSystem(sysID:self.Sys_ID);
end if;',
	1,
	'',
	7490);
INSERT INTO O_TPARM
	VALUES (7492,
	7482,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7493,
	705,
	'pasteSequence',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any seq from instances of SQ_S where (selected.Package_ID == param.id);
if(not_empty seq)
  // guarantee a unique name for the pasted element
  seq.Name = ::getUniqueInitialNameInParent (instance:seq.convertToInstance(),
         					    name:seq.Name, parent:self.convertToInstance());
  seq.associateWithSystem(sysID:self.Sys_ID);
end if;',
	1,
	'',
	7488);
INSERT INTO O_TPARM
	VALUES (7494,
	7493,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7495,
	705,
	'pasteUseCaseDiagram',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any ucd from instances of UC_UCC where (selected.Package_ID == param.id);
if(not_empty ucd)
  // guarantee a unique name for the pasted element
  ucd.Name = ::getUniqueInitialNameInParent (instance:ucd.convertToInstance(),
         					    name:ucd.Name, parent:self.convertToInstance());
  ucd.associateWithSystem(sysID:self.Sys_ID);
end if;',
	1,
	'',
	7493);
INSERT INTO O_TPARM
	VALUES (7496,
	7495,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7497,
	705,
	'getPckgCount',
	'',
	298,
	1,
	'select many pckgs related by self->EP_PKG[R1401];
return cardinality pckgs;',
	1,
	'',
	7495);
INSERT INTO O_TFR
	VALUES (7498,
	705,
	'getPckgId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many pckgs related by self->EP_PKG[R1401];
// We''re preincrementing the index
count = -1;
for each pckg in pckgs
  if (not_empty pckg)
      count = count+1;
  end if;
  if (count == param.index)
      return pckg.Package_ID;  
  end if;
end for;
return id;',
	1,
	'',
	7497);
INSERT INTO O_TPARM
	VALUES (7499,
	7498,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7500,
	705,
	'getSysDTPckgCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many sysDTPckgs related by self->S_DPK[R4400];
return cardinality sysDTPckgs;',
	1,
	'',
	7498);
INSERT INTO O_TFR
	VALUES (7501,
	705,
	'getSysDTPckgId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many sysDTPckgs related by self->S_DPK[R4400];
// We''re preincrementing the index
count = -1;
for each sysDTPckg in sysDTPckgs
  if (not_empty sysDTPckg)
      count = count+1;
  end if;
  if (count == param.index)
      return sysDTPckg.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7500);
INSERT INTO O_TPARM
	VALUES (7502,
	7501,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7503,
	705,
	'getInterfacePckgCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many interfacePckgs related by self->IP_IP[R4302];
return cardinality interfacePckgs;',
	1,
	'',
	7501);
INSERT INTO O_TFR
	VALUES (7504,
	705,
	'getInterfacePckgId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many interfacePckgs related by self->IP_IP[R4302];
// We''re preincrementing the index
count = -1;
for each interfacePckg in interfacePckgs
  if (not_empty interfacePckg)
      count = count+1;
  end if;
  if (count == param.index)
      return interfacePckg.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7503);
INSERT INTO O_TPARM
	VALUES (7505,
	7504,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7506,
	705,
	'getCompPckgCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many compPckgs related by self->CP_CP[R4602];
return cardinality compPckgs;',
	1,
	'',
	7504);
INSERT INTO O_TFR
	VALUES (7507,
	705,
	'getCompPckgId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many compPckgs related by self->CP_CP[R4602];
// We''re preincrementing the index
count = -1;
for each compPckg in compPckgs
  if (not_empty compPckg)
      count = count+1;
  end if;
  if (count == param.index)
      return compPckg.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7506);
INSERT INTO O_TPARM
	VALUES (7508,
	7507,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7509,
	705,
	'getSequenceCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many sequences related by self->SQ_S[R950];
return cardinality sequences;',
	1,
	'',
	7507);
INSERT INTO O_TFR
	VALUES (7510,
	705,
	'getSequenceId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many sequences related by self->SQ_S[R950];
// We''re preincrementing the index
count = -1;
for each sequence in sequences
  if (not_empty sequence)
      count = count+1;
  end if;
  if (count == param.index)
      return sequence.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7509);
INSERT INTO O_TPARM
	VALUES (7511,
	7510,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7512,
	705,
	'getCommunicationCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many communications related by self->COMM_COMM[R1136];
return cardinality communications;',
	1,
	'',
	7510);
INSERT INTO O_TFR
	VALUES (7513,
	705,
	'getCommunicationId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many communications related by self->COMM_COMM[R1136];
// We''re preincrementing the index
count = -1;
for each communication in communications
  if (not_empty communication)
      count = count+1;
  end if;
  if (count == param.index)
      return communication.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7512);
INSERT INTO O_TPARM
	VALUES (7514,
	7513,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7515,
	705,
	'getUsecaseCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many usecases related by self->UC_UCC[R1211];
return cardinality usecases;',
	1,
	'',
	7513);
INSERT INTO O_TFR
	VALUES (7516,
	705,
	'getUsecaseId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many usecases related by self->UC_UCC[R1211];
// We''re preincrementing the index
count = -1;
for each usecase in usecases
  if (not_empty usecase)
      count = count+1;
  end if;
  if (count == param.index)
      return usecase.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7515);
INSERT INTO O_TPARM
	VALUES (7517,
	7516,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7518,
	705,
	'getActivityCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many activities related by self->A_A[R1113];
return cardinality activities;',
	1,
	'',
	7516);
INSERT INTO O_TFR
	VALUES (7519,
	705,
	'getActivityId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many activities related by self->A_A[R1113];
// We''re preincrementing the index
count = -1;
for each activity in activities
  if (not_empty activity)
      count = count+1;
  end if;
  if (count == param.index)
      return activity.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7518);
INSERT INTO O_TPARM
	VALUES (7520,
	7519,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7521,
	705,
	'collectVisibleElementsForName',
	'',
	19,
	1,
	'// System Model.collectVisibleElementsForName()
select any originatingPE from instances of PE_PE where
                            selected.Element_ID == param.originatingContainerID;
select one originatingComp related by originatingPE->C_C[R8001];
select one originatingPackage related by originatingPE->EP_PKG[R8001];
select many pkgs related by self->EP_PKG[R1401];
for each pkg in pkgs
  // Don''t revisit a child package that delegated the search upwards
  if pkg.Package_ID != param.delegatingContainerID
    select one pe related by pkg->PE_PE[R8001];
    // Don''t visit pacakges that are private
    if (pe.Visibility == Visibility::Public or
	     (param.descending == false and pe.Visibility == Visibility::Protected))
      pkg.collectVisibleElementsForName(name:param.name, type:param.type,
                    descending: true,
                        originatingContainerID: param.originatingContainerID,
                                          delegatingPkgID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:false);
    end if;
  end if;
end for;
select any resultSet related by originatingPackage->PE_SRS[R8005] where
                    selected.Name == param.name and selected.Type == param.type;
select any compResSet related by originatingComp->PE_CRS[R8007] where
                    selected.Name == param.name and selected.Type == param.type;
if not param.descending and self.useGlobals
  select many globals related by self->G_EIS[R9100]->PE_PE[R9100];
  for each global in globals
    global.collectVisibleElementsForName(name:param.name, type:param.type,
                                             descending: param.descending,
                        originatingContainerID:param.originatingContainerID,
                                  delegatingPkgID:param.delegatingContainerID,
                                                         collectGlobally:false);
  end for;
end if;
if param.type == ElementTypeConstants::DATATYPE and not param.descending
  select many dts related by self->SLD_SDINP[R4402]->S_DT[R4401];
  for each dt in dts
    if param.name == "" or dt.Name == param.name
      select one pe related by dt->PE_PE[R8001];
      if not_empty pe
        if not_empty originatingPackage
          create object instance visibility of PE_VIS;
          relate pe to originatingPackage across R8002 using visibility;
          relate visibility to resultSet across R8006;
        elif not_empty originatingComp
          create object instance visibility of PE_CVS;
          relate pe to originatingComp across R8004 using visibility;
          relate visibility to compResSet across R8008;
        end if;
      end if;
    end if;
  end for;
elif param.type == ElementTypeConstants::INTERFACE
  select many interfacePkgs related by self->IP_IP[R4304];
  for each interfacePkg in interfacePkgs
    select many interfaces related by interfacePkg->C_I[R4303];
    for each interface in interfaces
      if param.name == "" or interface.Name == param.name
        select one pe related by interface->PE_PE[R8001];
        if not_empty pe
          if not_empty originatingPackage
            create object instance visibility of PE_VIS;
            relate pe to originatingPackage across R8002 using visibility;
            relate visibility to resultSet across R8006;
          elif not_empty originatingComp
            create object instance visibility of PE_CVS;
            relate pe to originatingComp across R8004 using visibility;
            relate visibility to compResSet across R8008;
          end if;
        end if;
      end if;
    end for;
  end for;
elif param.type == ElementTypeConstants::COMPONENT
  select many componentPkgs related by self->CP_CP[R4602];
  for each componentPkg in componentPkgs
    select many components related by componentPkg->C_C[R4608];
    for each component in components
      if param.name == "" or component.Name == param.name
        select one pe related by component->PE_PE[R8001];
        if not_empty pe
          if not_empty originatingPackage
            create object instance visibility of PE_VIS;
            relate pe to originatingPackage across R8002 using visibility;
            relate visibility to resultSet across R8006;
          elif not_empty originatingComp
            create object instance visibility of PE_CVS;
            relate pe to originatingComp across R8004 using visibility;
            relate visibility to compResSet across R8008;
          end if;
        end if;
      end if;
    end for;
  end for;
elif param.type == ElementTypeConstants::PACKAGE
  select many packages related by self->EP_PKG[R1401];
  for each package in packages
    if param.name == "" or package.Name == param.name
      select one pe related by package->PE_PE[R8001];
      if(not_empty pe)
        if(not_empty originatingPackage)
          create object instance visibility of PE_VIS;
          relate pe to originatingPackage across R8002 using visibility;
          relate visibility to resultSet across R8006;
        elif not_empty originatingComp
          create object instance visibility of PE_CVS;
          relate pe to originatingComp across R8004 using visibility;
          relate visibility to compResSet across R8008;            
        end if;
      end if;
    end if;
  end for;      
end if;
// Continue to search all models?
if param.descending == false and param.collectGlobally and
    PREF::getSystemBoolean(systemName:self.Name,
                     name:"com.mentor.nucleus.bp.ui.project.references") == true
  select many systems from instances of S_SYS;
  for each system in systems
    if system != self and system.useGlobals
      system.collectVisibleElementsForName(name:param.name, descending: true,
        type:param.type, originatingContainerID: param.originatingContainerID,
                                    delegatingContainerID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:false);
    end if;
  end for;
end if;
',
	1,
	'',
	7519);
INSERT INTO O_TPARM
	VALUES (7522,
	7521,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (7523,
	7521,
	'type',
	2878,
	0,
	'',
	7522,
	'');
INSERT INTO O_TPARM
	VALUES (7524,
	7521,
	'originatingContainerID',
	296,
	0,
	'',
	7523,
	'');
INSERT INTO O_TPARM
	VALUES (7525,
	7521,
	'delegatingContainerID',
	296,
	0,
	'',
	7524,
	'');
INSERT INTO O_TPARM
	VALUES (7526,
	7521,
	'descending',
	316,
	0,
	'',
	7525,
	'');
INSERT INTO O_TPARM
	VALUES (7527,
	7521,
	'collectGlobally',
	316,
	0,
	'',
	7526,
	'');
INSERT INTO O_TFR
	VALUES (7528,
	705,
	'actionFilter',
	'',
	316,
	1,
	'result = false;
if(param.name == "can")
  if(param.value == "upgradeToGlobals")
    result = not self.useGlobals;
  elif(param.value == "upgradeToGenerics")
    select many doms related by self->S_DOM[R28];
    select many cps related by self->CP_CP[R4602];
    select many ifps related by self->IP_IP[R4302];
    select many sysDtPs related by self->S_DPK[R4400];
    select many seqDiags related by self->SQ_S[R950];
    select many ucs related by self->UC_UCC[R1211];
    select many coms related by self->COMM_COMM[R1136];
    select many acts related by self->A_A[R1113];
    select many pkgs related by self->EP_PKG[R1401];
    spPkgCount = cardinality doms + cardinality cps + cardinality ifps +
      cardinality sysDtPs + cardinality seqDiags + cardinality ucs +
      cardinality coms + cardinality acts;
    for each pkg in pkgs
     spPkgCount = spPkgCount + pkg.getActivityCount();
     spPkgCount = spPkgCount + pkg.getCommunicationCount();
     spPkgCount = spPkgCount + pkg.getCompPckgCount();
     spPkgCount = spPkgCount + pkg.getDatatypePckgCount();
     spPkgCount = spPkgCount + pkg.getInterfacePckgCount();
     spPkgCount = spPkgCount + pkg.getSequenceCount();
    end for;
    result = spPkgCount > 0;
  end if;
end if;
return result;',
	1,
	'',
	7521);
INSERT INTO O_TPARM
	VALUES (7529,
	7528,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (7530,
	7528,
	'value',
	322,
	0,
	'',
	7529,
	'');
INSERT INTO O_TFR
	VALUES (7531,
	705,
	'getCoreTypeId',
	'',
	296,
	1,
	'// System.getCoreTypeId()
if self.useGlobals
  select any coreDt related by self->G_EIS[R9100]->PE_PE[R9100]->S_DT[R8001]
                                              where selected.Name == param.name;
  if not_empty coreDt
    return coreDt.DT_ID;
  end if;
else
  select any coreDt related by self->SLD_SDINP[R4402]->S_DT[R4401]
                                              where selected.Name == param.name;
  if not_empty coreDt
    return coreDt.DT_ID;
  end if;
end if;
return GD::NULL_UNIQUE_ID();
',
	1,
	'',
	7528);
INSERT INTO O_TPARM
	VALUES (7532,
	7531,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7533,
	705,
	'collectReferencesForSynchronization',
	'',
	19,
	1,
	'/**
 *  Call on each root package to collect references
 */
select many pkgs related by self->EP_PKG[R1405];
for each pkg in pkgs
  pkg.collectReferencesForSynchronization(referenceList:param.referenceList,
                                                       syncType:param.syncType);
end for;
// specialized
select many componentPkgs related by self->CP_CP[R4602];
for each componentPkg in componentPkgs
  componentPkg.collectReferencesForSynchronization(
                    referenceList:param.referenceList, syncType:param.syncType);
end for;
select many interfacePkgs related by self->IP_IP[R4302];
for each interfacePkg in interfacePkgs
  interfacePkg.collectReferencesForSynchronization(
                    referenceList:param.referenceList, syncType:param.syncType);
end for;',
	1,
	'',
	7531);
INSERT INTO O_TPARM
	VALUES (7534,
	7533,
	'referenceList',
	317,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (7535,
	7533,
	'syncType',
	3500,
	0,
	'',
	7534,
	'');
INSERT INTO O_NBATTR
	VALUES (754,
	705);
INSERT INTO O_BATTR
	VALUES (754,
	705);
INSERT INTO O_ATTR
	VALUES (754,
	705,
	0,
	'Sys_ID',
	'',
	'',
	'Sys_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (7536,
	705);
INSERT INTO O_BATTR
	VALUES (7536,
	705);
INSERT INTO O_ATTR
	VALUES (7536,
	705,
	754,
	'Name',
	'Full Name: System Name
The name of the System under analysis.',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (7537,
	705);
INSERT INTO O_BATTR
	VALUES (7537,
	705);
INSERT INTO O_ATTR
	VALUES (7537,
	705,
	7536,
	'useGlobals',
	'User_Visible:false',
	'',
	'useGlobals',
	0,
	316,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	705);
INSERT INTO O_OIDA
	VALUES (754,
	705,
	0,
	'Sys_ID');
INSERT INTO O_ID
	VALUES (1,
	705);
INSERT INTO O_ID
	VALUES (2,
	705);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (7373,
	'Subsystem in Subsystem',
	30,
	'S_SIS',
	'Subsystem in Subsystem represents Subsystems that are nested within other Subsystems.',
	7221);
INSERT INTO O_TFR
	VALUES (7538,
	7373,
	'dispose',
	'Dispose this subsystem in subsytem.',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one pss related by self->S_SS[R41];
unrelate self from pss across R41;
select one css related by self->S_SS[R42];
unrelate self from css across R42;
delete object instance self;


',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (7373,
	701,
	0,
	717,
	7375,
	7376,
	7377,
	7539,
	7540,
	0,
	0,
	'',
	'Subsystem',
	'SS_ID',
	'R41');
INSERT INTO O_RATTR
	VALUES (7539,
	7373,
	717,
	701,
	1,
	'SS_ID');
INSERT INTO O_ATTR
	VALUES (7539,
	7373,
	0,
	'Parent_SS_ID',
	'',
	'Parent_',
	'SS_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (7373,
	701,
	0,
	717,
	7371,
	7374,
	7372,
	7541,
	7542,
	0,
	0,
	'',
	'Subsystem',
	'SS_ID',
	'R42');
INSERT INTO O_RATTR
	VALUES (7541,
	7373,
	717,
	701,
	1,
	'SS_ID');
INSERT INTO O_ATTR
	VALUES (7541,
	7373,
	7539,
	'Child_SS_ID',
	'',
	'Child_',
	'SS_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	7373);
INSERT INTO O_OIDA
	VALUES (7541,
	7373,
	0,
	'Child_SS_ID');
INSERT INTO O_OIDA
	VALUES (7539,
	7373,
	0,
	'Parent_SS_ID');
INSERT INTO O_ID
	VALUES (1,
	7373);
INSERT INTO O_ID
	VALUES (2,
	7373);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (7381,
	'Subsystem in Domain',
	31,
	'S_SID',
	'Subsytem in Domain represents Subsytem packages at the top, domain, level.  In other words Subsystem packages that are not nested within other Subsystem packages.',
	7221);
INSERT INTO O_REF
	VALUES (7381,
	699,
	0,
	712,
	7378,
	7382,
	7379,
	7543,
	7544,
	0,
	0,
	'',
	'Domain',
	'Dom_ID',
	'R43');
INSERT INTO O_RATTR
	VALUES (7543,
	7381,
	712,
	699,
	1,
	'Dom_ID');
INSERT INTO O_ATTR
	VALUES (7543,
	7381,
	0,
	'Dom_ID',
	'',
	'',
	'Dom_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (7381,
	701,
	0,
	717,
	7378,
	7382,
	7380,
	7545,
	7546,
	0,
	0,
	'',
	'Subsystem',
	'SS_ID',
	'R43');
INSERT INTO O_RATTR
	VALUES (7545,
	7381,
	717,
	701,
	1,
	'SS_ID');
INSERT INTO O_ATTR
	VALUES (7545,
	7381,
	7543,
	'SS_ID',
	'',
	'',
	'SS_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	7381);
INSERT INTO O_OIDA
	VALUES (7545,
	7381,
	0,
	'SS_ID');
INSERT INTO O_OIDA
	VALUES (7543,
	7381,
	0,
	'Dom_ID');
INSERT INTO O_ID
	VALUES (1,
	7381);
INSERT INTO O_ID
	VALUES (2,
	7381);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (701,
	'Subsystem',
	2,
	'S_SS',
	'A subsystem (S_SS) is based on the partitioning of an entire domain (S_DOM). The number of subsystems in a domain is dependent upon the domain subject matter and complexity. A subsystem is composed of classes which tend to cluster, i.e., classes which have many  associations with one another but few associations with classes in different clusters. Inter-subsystem associations, asynchronous communications, and synchronous accesses are captured in the Subsystem Relationship Model, Subsystem Communication Model and Subsystem Access Model, respectively.',
	7221);
INSERT INTO O_TFR
	VALUES (7547,
	701,
	'get_compartment_text',
	'A Subsystem shows its name, it''s prefix letters and the Class numbers
it contains.
-----------------------------------------------------------------------------------
Bridge:GD',
	322,
	1,
	'result = "";
if (param.at == Justification::Center_in_X)
  result = "subsystem";
elif (param.at == Justification::Center)
  result = self.Name;
  select many objs related by self->O_OBJ[R2];
  if (self.Prefix != "" OR not_empty objs)
    result = result + GD::newline() +"{"; 
  end if;
  if (self.Prefix != "")
    result = result + self.Prefix;
  end if;
  max = 0;
  min = GD::max_number();
  for each obj in objs
    if (obj.Numb > max)
      max = obj.Numb;
    end if;
    if (obj.Numb < min)
      min = obj.Numb;
    end if;
  end for;
  if (max != 0)
    if (self.Prefix != "")
      result = result + ", ";
    end if;
    if (max == min)
      result = result + GD::int_to_string(value:max);
    else
      result = result + GD::int_to_string(value:min) + " - " + GD::int_to_string(value:max);
    end if;
  end if;
  if (self.Prefix != "" OR not_empty objs)
    result = result + "}";
  end if;
end if;
return result;',
	1,
	'',
	7548);
INSERT INTO O_TPARM
	VALUES (7549,
	7547,
	'comp_num',
	298,
	0,
	'',
	7550,
	'');
INSERT INTO O_TPARM
	VALUES (7551,
	7547,
	'ent_num',
	298,
	0,
	'',
	7549,
	'');
INSERT INTO O_TPARM
	VALUES (7550,
	7547,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7552,
	701,
	'get_compartments',
	'A Subsystem has just one compartment.
-----------------------------------------------------------------------------------
Bridge:GD',
	298,
	1,
	'return 1;',
	1,
	'',
	7547);
INSERT INTO O_TFR
	VALUES (7553,
	701,
	'get_style',
	'A Subsystem is shown as a package symbol (called a Folder by the
Graphics Domain).
-----------------------------------------------------------------------------------
Bridge:GD',
	784,
	1,
	'return Style::Folder;',
	1,
	'',
	7554);
INSERT INTO O_TFR
	VALUES (7555,
	701,
	'get_entries',
	'A Subsystem always just has one entry, the name and keyletters.
-----------------------------------------------------------------------------------
Bridge:GD',
	298,
	1,
	'return 1;',
	1,
	'',
	7552);
INSERT INTO O_TPARM
	VALUES (7556,
	7555,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7557,
	701,
	'get_text_style',
	'A Subsystem has no special style.
-----------------------------------------------------------------------------------
Bridge:GD',
	784,
	1,
	'return Style::None;',
	1,
	'',
	7553);
INSERT INTO O_TPARM
	VALUES (7558,
	7557,
	'comp_num',
	298,
	0,
	'',
	7559,
	'');
INSERT INTO O_TPARM
	VALUES (7560,
	7557,
	'ent_num',
	298,
	0,
	'',
	7558,
	'');
INSERT INTO O_TPARM
	VALUES (7559,
	7557,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7561,
	701,
	'newClass',
	'Create a new Class in this Subsystem',
	19,
	1,
	'create object instance cl of O_OBJ;
relate self to cl across R2;

cl.initialize();
',
	1,
	'',
	7562);
INSERT INTO O_TFR
	VALUES (7563,
	701,
	'newIClass',
	'Create a new Imported Class in this Subsystem.',
	19,
	1,
	'create object instance icl of O_IOBJ;
relate self to icl across R3;
//
// Note that no class is assigned to this imported
// class at creation time. This is achieved by a separate
// Context Menu action.',
	1,
	'',
	7564);
INSERT INTO O_TFR
	VALUES (7554,
	701,
	'get_ooa_id',
	'The ooa_id of a Subsystem is it''s SS_ID.
-----------------------------------------------------------------------------------
Bridge:GD',
	296,
	1,
	'return self.SS_ID;',
	1,
	'',
	7555);
INSERT INTO O_TFR
	VALUES (7565,
	701,
	'initialize',
	'Initialize a new subsystem instance.',
	19,
	1,
	'self.Name = ::getUniqueInitialName( 
    instance: self.convertToInstance(), 
    candidateName: "Unnamed Subsystem" );',
	1,
	'',
	7557);
INSERT INTO O_TFR
	VALUES (7566,
	701,
	'dispose',
	'The dispose operation for Subsytem.',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one dom related by self->S_DOM[R1];
if (not_empty dom)
  unrelate self from dom across R1;
end if;
select one sid related by self->S_SID[R43];
if not_empty sid
  select one tdom related by sid->S_DOM[R43];
  if not_empty tdom
  unrelate self from tdom across R43 using sid;
  end if;
  delete object instance sid;
end if;
select many csss related by self->S_SIS[R41]->S_SS[R42];
for each css in csss
  css.dispose();
end for;
// First get rid of the associations, since they involve model classes
// and may be spanning subsystems
select many rels related by self->R_REL[R4];
for each rel in rels
  rel.dispose();
end for;
select many iobjs related by self->O_IOBJ[R3];
for each iobj in iobjs
  iobj.dispose();
end for;
select many cps related by self->CA_COMM[R5];
for each cp in cps
  cp.dispose();
end for;
select many aps related by self->CA_ACC[R6];
for each ap in aps
  ap.dispose();
end for;
select many eems related by self->S_EEM[R7];
for each eem in eems
  eem.dispose();
end for;
// and delete classes last
select many objs related by self->O_OBJ[R2];
for each obj in objs
  obj.dispose();
end for;
select one sis related by self->S_SIS[R42];
if (not_empty sis)
   sis.dispose();
end if;
// dispose any sequences related to this subsystem
select many sequences related by self->SQ_S[R914];
for each sequence in sequences
  sequence.dispose();
end for;
// dispose any communications related to this ss
select many comms related by self->COMM_COMM[R1131];
for each comm in comms
  comm.dispose();
end for;
// dispose any use cases
select many uccs related by self->UC_UCC[R1202];
for each ucc in uccs
  ucc.dispose();
end for;
// dispose all activites related to this subsystem
select many acts related by self->A_A[R1108];
for each act in acts
  act.dispose();
end for;
// Finally delete self
delete object instance self;',
	1,
	'',
	7567);
INSERT INTO O_TFR
	VALUES (7568,
	701,
	'newSubsystem',
	'Create a child subsystem package inside this subsystem.',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
create object instance sis of S_SIS;
create object instance child of S_SS;
relate sis to child across R42;
relate self to sis across R41;
select one dom related by self->S_DOM[R1];
relate dom to child across R1;
child.initialize();',
	1,
	'',
	7569);
INSERT INTO O_TFR
	VALUES (7570,
	701,
	'newAssociation',
	'',
	316,
	1,
	'select any fromClass related by self->O_OBJ[R2] where (selected.Obj_ID == param.from);
select any fromIClass related by self->O_IOBJ[R3] where (selected.IObj_ID == param.from);
if (param.fromIsImportedClass)
  if (not_empty fromIClass)
    select one fromClass related by fromIClass->O_OBJ[R101];
  end if;
end if;
select any toClass related by self->O_OBJ[R2] where (selected.Obj_ID == param.to);
select any toIClass related by self->O_IOBJ[R3] where (selected.IObj_ID == param.to);
if (param.toIsImportedClass)
  if (not_empty toIClass)
    select one toClass related by toIClass->O_OBJ[R101];
  end if;
end if;
//
if (not_empty fromClass and not_empty toClass)
  create object instance assoc of R_REL;
  relate self to assoc across R4;
  assoc.initialize();
  create object instance simp of R_SIMP;
  relate simp to assoc across R206;
  //
  create object instance fromOIR of R_OIR;
  relate fromClass to assoc across R201 using fromOIR;
  create object instance fromRTO of R_RTO;
  relate fromOIR to fromRTO across R203;
  create object instance fromPART of R_PART;
  relate fromPART to fromRTO across R204;
  relate fromPART to simp across R207;
  if (param.fromIsImportedClass)
    if (not_empty fromIClass)
      relate fromOIR to fromIClass across R202;
    end if;
  end if;
  //
  create object instance toOIR of R_OIR;
  relate toClass to assoc across R201 using toOIR;
  create object instance toRTO of R_RTO;
  relate toOIR to toRTO across R203;
  create object instance toPART of R_PART;
  relate toPART to toRTO across R204;
  relate toPART to simp across R207;
  if (param.toIsImportedClass)
    if (not_empty toIClass)
      relate toOIR to toIClass across R202;
    end if;
  end if;
  return true;
end if;
// One of the elements was not found
return false;',
	1,
	'',
	7571);
INSERT INTO O_TPARM
	VALUES (7572,
	7570,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (7573,
	7570,
	'to',
	296,
	0,
	'',
	7574,
	'');
INSERT INTO O_TPARM
	VALUES (7574,
	7570,
	'fromIsImportedClass',
	316,
	0,
	'',
	7572,
	'');
INSERT INTO O_TPARM
	VALUES (7575,
	7570,
	'toIsImportedClass',
	316,
	0,
	'',
	7573,
	'');
INSERT INTO O_TFR
	VALUES (7562,
	701,
	'newAssociative',
	'',
	316,
	1,
	'select any fromClass related by self->O_OBJ[R2] where (selected.Obj_ID == param.from);
if (param.fromIsImportedClass)
  select any fromIClass related by self->O_IOBJ[R3] where (selected.IObj_ID == param.from);
  if (not_empty fromIClass)
    select one fromClass related by fromIClass->O_OBJ[R101];
  end if;
end if;
select any toAssoc related by self->R_REL[R4] where (selected.Rel_ID == param.to);
// get the already related class in relationship instances
select many classes related by toAssoc->R_OIR[R201]->O_OBJ[R201];
for each clazz in classes
  if (clazz == fromClass)
    // A class cannot be it''s own link class
    return false;
  end if;
end for;
if (empty fromClass or empty toAssoc)
  // One of the elements was not found
  return false;
end if;
select one simp related by toAssoc->R_SIMP[R206];
if (empty simp)
  // Only simple associations can have link classes attached. 
  return false;
else
  if (param.fromIsImportedClass)
    simp.migrateToLinked(using: fromClass.Obj_ID, imported_id: param.from);
  else
    simp.migrateToLinked(using: fromClass.Obj_ID, imported_id: GD::NULL_UNIQUE_ID());
  end if;
  return true;
end if;',
	1,
	'',
	7570);
INSERT INTO O_TPARM
	VALUES (7576,
	7562,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (7577,
	7562,
	'to',
	296,
	0,
	'',
	7578,
	'');
INSERT INTO O_TPARM
	VALUES (7578,
	7562,
	'fromIsImportedClass',
	316,
	0,
	'',
	7576,
	'');
INSERT INTO O_TPARM
	VALUES (7579,
	7562,
	'toIsImportedClass',
	316,
	0,
	'',
	7577,
	'');
INSERT INTO O_TFR
	VALUES (7580,
	701,
	'newSubtype',
	'',
	316,
	1,
	'select any fromClass related by self->O_OBJ[R2] where (selected.Obj_ID == param.from);
if (param.fromIsImportedClass)
  select any fromIClass related by self->O_IOBJ[R3] where (selected.IObj_ID == param.from);
  if (not_empty fromIClass)
    select one fromClass related by fromIClass->O_OBJ[R101];
  end if;
end if;
if (not_empty fromClass)
  select any toAssoc related by self->R_REL[R4] where (selected.Rel_ID == param.to);
  if (not_empty toAssoc)
    select one subsup related by toAssoc->R_SUBSUP[R206];
    if (not_empty subsup)
      select one superClass related by subsup->R_SUPER[R212]->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201];
      if (fromClass != superClass) // A class cannot be its own supertype . . . . .
        isAlreadySubClass = false;
        select many subClasses related by subsup->R_SUB[R213]->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201];
        for each subClass in subClasses
          if (fromClass == subClass)
            isAlreadySubClass = true;
            break;
          end if;
        end for;
        if (not isAlreadySubClass) // A class cannot be a subtype more than once . . . . . 
          create object instance cir of R_OIR;
          relate fromClass to toAssoc across R201 using cir;
          if (param.fromIsImportedClass)
            select any fromIClass related by self->O_IOBJ[R3] where
                                       (selected.IObj_ID == param.from);
            relate cir to fromIClass across R202;
          end if;
          create object instance rgo of R_RGO;
          relate cir to rgo across R203;
          create object instance subtype of R_SUB;
          relate rgo to subtype across R205;
          relate subtype to subsup across R213;
          if ( toAssoc.isFormalized() )
            // add referential attributes
            unused_oid = fromClass.findUnusedIdentifier();
            select one sup_rto related by subsup->R_SUPER[R212]->R_RTO[R204];
            select many oida_set related by sup_rto->O_ID[R109]->O_OIDA[R105];
            for each oida in oida_set
              newAttr_id = oida.addReference(rel_id: toAssoc.Rel_ID,
                  rto_obj_id: sup_rto.Obj_ID, rto_oir_id: sup_rto.OIR_ID, 
                  rgo_obj_id: rgo.Obj_ID, rgo_oir_id: rgo.OIR_ID,
                  id: unused_oid);
            end for;
          end if;
          return true;
        end if; // already sub class
      end if; // not own supertype
    end if; // association is supertype / subtype
  end if;  // association found
end if;  // class found
return false;',
	1,
	'',
	7568);
INSERT INTO O_TPARM
	VALUES (7581,
	7580,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (7582,
	7580,
	'to',
	296,
	0,
	'',
	7583,
	'');
INSERT INTO O_TPARM
	VALUES (7583,
	7580,
	'fromIsImportedClass',
	316,
	0,
	'',
	7581,
	'');
INSERT INTO O_TPARM
	VALUES (7584,
	7580,
	'toIsImportedClass',
	316,
	0,
	'',
	7582,
	'');
INSERT INTO O_TFR
	VALUES (7585,
	701,
	'newSuperType',
	'',
	316,
	1,
	'select any fromClass related by self->O_OBJ[R2] where (selected.Obj_ID == param.from);
select any fromIClass related by self->O_IOBJ[R3] where (selected.IObj_ID == param.from);
if (param.fromIsImportedClass)
  if (not_empty fromIClass)
    select one fromClass related by fromIClass->O_OBJ[R101];
  end if;
end if;
if (not_empty fromClass)
  create object instance assoc of R_REL;
  relate self to assoc across R4;
  assoc.initialize();
  create object instance oir of R_OIR;
  relate assoc to fromClass across R201 using oir;
  create object instance rto of R_RTO;
  relate oir to rto across R203;
  create object instance subsup of R_SUBSUP;
  relate subsup to assoc across R206;
  create object instance supertype of R_SUPER;
  relate supertype to subsup across R212;
  relate supertype to rto across R204;
  if (param.fromIsImportedClass)
    if (not_empty fromIClass)
      relate oir to fromIClass across R202;
    end if;
  end if;
  return true;
end if;
return false;',
	1,
	'',
	7580);
INSERT INTO O_TPARM
	VALUES (7586,
	7585,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (7587,
	7585,
	'to',
	296,
	0,
	'',
	7588,
	'');
INSERT INTO O_TPARM
	VALUES (7588,
	7585,
	'fromIsImportedClass',
	316,
	0,
	'',
	7586,
	'');
INSERT INTO O_TPARM
	VALUES (7589,
	7585,
	'toIsImportedClass',
	316,
	0,
	'',
	7587,
	'');
INSERT INTO O_TFR
	VALUES (7569,
	701,
	'newSequence',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
create object instance sequence of SQ_S;
create object instance sp of EP_SPKG;
relate sequence to sp across R1402;
relate self to sequence across R914;
sequence.initialize();',
	1,
	'',
	7563);
INSERT INTO O_TFR
	VALUES (7548,
	701,
	'getPath',
	'',
	322,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
path = self.Name;
if(param.path != "")
  path = path + "::" + param.path;
end if;
select one domain related by self->S_SID[R43]->S_DOM[R43];
if(not_empty domain)
  return domain.getPath(path:path);
else
  select one spkg related by self->S_SIS[R42]->S_SS[R41];
  if(not_empty spkg)
    return spkg.getPath(path:path);
  end if;
end if;
return path;',
	1,
	'',
	7566);
INSERT INTO O_TPARM
	VALUES (7590,
	7548,
	'path',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7564,
	701,
	'newCommunication',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
create object instance communication of COMM_COMM;
create object instance sp of EP_SPKG;
relate communication to sp across R1402;
relate self to communication across R1131;
communication.initialize();',
	1,
	'',
	7561);
INSERT INTO O_TFR
	VALUES (7591,
	701,
	'newUseCasePackage',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
create object instance ucc of UC_UCC;
create object instance sp of EP_SPKG;
relate ucc to sp across R1402;
relate self to ucc across R1202;
ucc.initialize();',
	1,
	'',
	7585);
INSERT INTO O_TFR
	VALUES (7571,
	701,
	'newActivity',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
create object instance a of A_A;
create object instance sp of EP_SPKG;
relate a to sp across R1402;
relate self to a across R1108;
a.initialize();',
	1,
	'',
	7565);
INSERT INTO O_TFR
	VALUES (7567,
	701,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'// just return this instance as an Object
return this;',
	0,
	'',
	7592);
INSERT INTO O_TFR
	VALUES (7593,
	701,
	'pasteModelClass',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any clazz from instances of O_OBJ where (selected.Obj_ID == param.id);
if(not_empty clazz)
  select one existingSS related by clazz->S_SS[R2];
  if(not_empty existingSS)
    unrelate clazz from existingSS across R2;
  end if;
  relate clazz to self across R2;
  select many attributes related by clazz->O_ATTR[R102];
  // handle pasting of attributes
  for each attribute in attributes
    result = clazz.removeIncompleteReferential(id:attribute.Attr_ID);
  end for;
  clazz.rename(new_name: ::getUniqueInitialNameInParent(instance:clazz.convertToInstance(),
  						name:clazz.Name, parent:self.convertToInstance()));
  clazz.removeIncompleteNonLocalEvents();
end if;',
	1,
	'',
	7594);
INSERT INTO O_TPARM
	VALUES (7595,
	7593,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7596,
	701,
	'pasteAssociation',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any association from instances of R_REL where (selected.Rel_ID == param.id);
if(not_empty association)
  relateToSS = true;
  select one subsystem related by association->S_SS[R4];
  if(not_empty subsystem)
    if(subsystem != self)
      unrelate association from subsystem across R4;
    else
      relateToSS = false;
    end if;
  end if;
  if(relateToSS)
    select any existingAssoc related by self->R_REL[R4] where (selected.Numb == association.Numb);
    if(not_empty existingAssoc)
      // for each assocation associated with this subsystem
      select many assocs related by self->R_REL[R4];
      for each assoc in assocs
        // if this other association''s number is 
        // greater than this association''s number
        if (assoc.Numb >= association.Numb)
          // have this association''s number be just greater 
          // than this other association''s number
          association.Numb = assoc.Numb + 1;
        end if;
      end for;      
    end if;
    relate self to association across R4;
  end if;
end if;',
	1,
	'',
	7597);
INSERT INTO O_TPARM
	VALUES (7598,
	7596,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7599,
	701,
	'pasteClassAsLink',
	'',
	19,
	1,
	'self.pasteAssociation(id:param.id);',
	1,
	'',
	7596);
INSERT INTO O_TPARM
	VALUES (7600,
	7599,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7601,
	701,
	'pasteClassAsSubtype',
	'',
	19,
	1,
	'select any subtype from instances of R_SUB where (selected.OIR_ID == param.id);
if(not_empty subtype)
  select one assoc related by subtype->R_SUBSUP[R213]->R_REL[R206];
  self.pasteAssociation(id:assoc.Rel_ID);
end if;',
	1,
	'',
	7599);
INSERT INTO O_TPARM
	VALUES (7602,
	7601,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7594,
	701,
	'pasteImportedClass',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any iobj from instances of O_IOBJ where (selected.IObj_ID == param.id);
if(not_empty iobj)
  select one existingSS related by iobj->S_SS[R3];
  if(not_empty existingSS)
    unrelate iobj from existingSS across R3;
  end if;
  relate self to iobj across R3;
end if;',
	1,
	'',
	7603);
INSERT INTO O_TPARM
	VALUES (7604,
	7594,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7605,
	701,
	'pasteSubsystem',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any subsystem from instances of S_SS where (selected.SS_ID == param.id);
if(not_empty subsystem)
  select one existingDOM related by subsystem->S_DOM[R1];
  if(not_empty existingDOM)
    unrelate subsystem from existingDOM across R1;
  end if;
  select one existingSIS related by subsystem->S_SIS[R42];
  if(not_empty existingSIS)
    select one existingSS related by existingSIS->S_SS[R41];
    if(not_empty existingSS)
      unrelate existingSIS from existingSS across R41;
    end if;
  end if;
  subsystem.Name = ::getUniqueInitialNameInParent(instance:subsystem.convertToInstance(),
  						name:subsystem.Name, parent:self.convertToInstance());
  select one domain related by self->S_DOM[R1];
  subsystem.associateChildSubsystemsToDomain(dom_id:domain.Dom_ID);
  if(empty existingSIS)
    // this was not a nested subsystem originally
    // create the necessary S_SIS and dispose
    // of the S_SID
    create object instance existingSIS of S_SIS;
    select one sid related by subsystem->S_SID[R43];
    if(not_empty sid)
      select one existingDOM related by sid->S_DOM[R43];
      unrelate subsystem from existingDOM across R43 using sid;
      delete object instance sid;
    end if;
  end if;
  relate self to existingSIS across R41;
  relate subsystem to existingSIS across R42;
  relate subsystem to domain across R1;
  subsystem.removeIncompleteNonLocalEvents();
end if;',
	1,
	'',
	7606);
INSERT INTO O_TPARM
	VALUES (7607,
	7605,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7592,
	701,
	'associateChildSubsystemsToDomain',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
/*
 *  For every child subsystem we update R1 to the domain with the given id.
 */
select any domain from instances of S_DOM where (selected.Dom_ID == param.dom_id);
if(not_empty domain)
  select many childSSs related by self->S_SIS[R41]->S_SS[R42];
  for each childSS in childSSs
    select one existingDom related by childSS->S_DOM[R1];
    unrelate childSS from existingDom across R1;
    relate childSS to domain across R1;
    childSS.associateChildSubsystemsToDomain(dom_id:param.dom_id);
  end for;
end if;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (7608,
	7592,
	'dom_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7609,
	701,
	'removeIncompleteNonLocalEvents',
	'',
	19,
	1,
	'// for every state machine remove any non-local events
// if necessary
select many clazzes related by self->O_OBJ[R2];
for each clazz in clazzes
  clazz.removeIncompleteNonLocalEvents();
end for;
// for all nested subsystems do the same
select many subsystems related by self->S_SIS[R41]->S_SS[R42];
for each subsystem in subsystems
  subsystem.removeIncompleteNonLocalEvents();
end for;',
	1,
	'',
	7610);
INSERT INTO O_TFR
	VALUES (7597,
	701,
	'pasteActivity',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any activity from instances of A_A
                                        where (selected.Package_ID == param.id);
if(not_empty activity)
  // guarantee a unique name for the pasted element
  activity.Name = ::getUniqueInitialNameInParent
                                         (instance:activity.convertToInstance(),
     					   name:activity.Name, parent:self.convertToInstance());
  activity.associateWithSubsystem(ssID:self.SS_ID);
end if;',
	1,
	'',
	7591);
INSERT INTO O_TPARM
	VALUES (7611,
	7597,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7603,
	701,
	'pasteCommunication',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any comm from instances of COMM_COMM
                                        where (selected.Package_ID == param.id);
if(not_empty comm)
  // guarantee a unique name for the pasted element
  comm.Name = ::getUniqueInitialNameInParent (instance:comm.convertToInstance(),
     					   name:comm.Name, parent:self.convertToInstance());
  comm.associateWithSubsystem(ssID:self.SS_ID);
end if;',
	1,
	'',
	7601);
INSERT INTO O_TPARM
	VALUES (7612,
	7603,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7606,
	701,
	'pasteSequence',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any seq from instances of SQ_S where (selected.Package_ID == param.id);
if(not_empty seq)
  // guarantee a unique name for the pasted element
  seq.Name = ::getUniqueInitialNameInParent (instance:seq.convertToInstance(),
         					    name:seq.Name, parent:self.convertToInstance());
  seq.associateWithSubsystem(ssID:self.SS_ID);
end if;',
	1,
	'',
	7593);
INSERT INTO O_TPARM
	VALUES (7613,
	7606,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7610,
	701,
	'pasteUseCaseDiagram',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any ucd from instances of UC_UCC where (selected.Package_ID == param.id);
if(not_empty ucd)
  // guarantee a unique name for the pasted element
  ucd.Name = ::getUniqueInitialNameInParent (instance:ucd.convertToInstance(),
         					    name:ucd.Name, parent:self.convertToInstance());
  ucd.associateWithSubsystem(ssID:self.SS_ID);
end if;',
	1,
	'',
	7605);
INSERT INTO O_TPARM
	VALUES (7614,
	7610,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7615,
	701,
	'getContainingComponentId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one domain related by self->S_DOM[R1];
return domain.getContainingComponentId();',
	1,
	'',
	7609);
INSERT INTO O_TFR
	VALUES (7616,
	701,
	'getClassCount',
	'',
	298,
	1,
	'select many classes related by self->O_OBJ[R2];
return cardinality classes;',
	1,
	'',
	7615);
INSERT INTO O_TFR
	VALUES (7617,
	701,
	'getClassId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many classes related by self->O_OBJ[R2];
// We''re preincrementing the index
count = -1;
for each modelClass in classes
  if (not_empty modelClass)
      count = count+1;
  end if;
  if (count == param.index)
      return modelClass.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7616);
INSERT INTO O_TPARM
	VALUES (7618,
	7617,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7619,
	701,
	'getImportedClassCount',
	'',
	298,
	1,
	'select many importedClasses related by self->O_IOBJ[R3];
return cardinality importedClasses;',
	1,
	'',
	7617);
INSERT INTO O_TFR
	VALUES (7620,
	701,
	'getImportedClassId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many importedClasses related by self->O_IOBJ[R3];
// We''re preincrementing the index
count = -1;
for each importedClass in importedClasses
  if (not_empty importedClass)
      count = count+1;
  end if;
  if (count == param.index)
      return importedClass.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7619);
INSERT INTO O_TPARM
	VALUES (7621,
	7620,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7622,
	701,
	'getSubsystemCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many subsystems related by self->S_SIS[R41]->S_SS[R42];
return cardinality subsystems;',
	1,
	'',
	7620);
INSERT INTO O_TFR
	VALUES (7623,
	701,
	'getSubsystemId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many subsystems related by self->S_SIS[R41]->S_SS[R42];
// We''re preincrementing the index
count = -1;
for each subsystem in subsystems
  if (not_empty subsystem)
      count = count+1;
  end if;
  
  if (count == param.index)
      return subsystem.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7622);
INSERT INTO O_TPARM
	VALUES (7624,
	7623,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7625,
	701,
	'getSequenceCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many sequences related by self->SQ_S[R914];
return cardinality sequences;',
	1,
	'',
	7623);
INSERT INTO O_TFR
	VALUES (7626,
	701,
	'getSequenceId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many sequences related by self->SQ_S[R914];
// We''re preincrementing the index
count = -1;
for each sequence in sequences
  if (not_empty sequence)
      count = count+1;
  end if;
  
  if (count == param.index)
      return sequence.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7625);
INSERT INTO O_TPARM
	VALUES (7627,
	7626,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7628,
	701,
	'getCommunicationCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many communications related by self->COMM_COMM[R1131];
return cardinality communications;',
	1,
	'',
	7626);
INSERT INTO O_TFR
	VALUES (7629,
	701,
	'getCommunicationId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many communications related by self->COMM_COMM[R1131];
// We''re preincrementing the index
count = -1;
for each communication in communications
  if (not_empty communication)
      count = count+1;
  end if;
  
  if (count == param.index)
      return communication.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7628);
INSERT INTO O_TPARM
	VALUES (7630,
	7629,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7631,
	701,
	'getUseCaseCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many useCases related by self->UC_UCC[R1202];
return cardinality useCases;',
	1,
	'',
	7629);
INSERT INTO O_TFR
	VALUES (7632,
	701,
	'getUseCaseId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many usecases related by self->UC_UCC[R1202];
// We''re preincrementing the index
count = -1;
for each usecase in usecases
  if (not_empty usecase)
      count = count+1;
  end if;
  if (count == param.index)
      return usecase.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7631);
INSERT INTO O_TPARM
	VALUES (7633,
	7632,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7634,
	701,
	'getActivityCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many activities related by self->A_A[R1108];
return cardinality activities;',
	1,
	'',
	7632);
INSERT INTO O_TFR
	VALUES (7635,
	701,
	'getActivityId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many activities related by self->A_A[R1108];
// We''re preincrementing the index
count = -1;
for each activity in activities
  if (not_empty activity)
      count = count+1;
  end if;
  if (count == param.index)
      return activity.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7634);
INSERT INTO O_TPARM
	VALUES (7636,
	7635,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7637,
	701,
	'getSystemId',
	'',
	296,
	1,
	'// Domain.getSystemId()
select one domain related by self->S_DOM[R1];
if not_empty domain
  return domain.getSystemId();
end if;
USER::logError(msg:"Subsystem.getSystemId()::No domain found.",path:self.getPath(path:self.Name));
return GD::NULL_UNIQUE_ID();',
	1,
	'',
	7635);
INSERT INTO O_TFR
	VALUES (7638,
	701,
	'removeIncompleteSignalEvents',
	'',
	19,
	1,
	'// for every state machine remove any signal events
// if necessary
select many clazzes related by self->O_OBJ[R2];
for each clazz in clazzes
  clazz.removeIncompleteSignalEvents();
end for;
// for all nested subsystems do the same
select many subsystems related by self->S_SIS[R41]->S_SS[R42];
for each subsystem in subsystems
  subsystem.removeIncompleteSignalEvents();
end for;',
	1,
	'',
	7637);
INSERT INTO O_NBATTR
	VALUES (717,
	701);
INSERT INTO O_BATTR
	VALUES (717,
	701);
INSERT INTO O_ATTR
	VALUES (717,
	701,
	0,
	'SS_ID',
	'Full Name: Subsystem Identifier
Description: Unique identifier for the subsystem within the domain',
	'',
	'SS_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (7639,
	701);
INSERT INTO O_BATTR
	VALUES (7639,
	701);
INSERT INTO O_ATTR
	VALUES (7639,
	701,
	717,
	'Name',
	'Full Name: Subsystem Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (7640,
	701);
INSERT INTO O_BATTR
	VALUES (7640,
	701);
INSERT INTO O_ATTR
	VALUES (7640,
	701,
	7639,
	'Descrip',
	'Full Name: Subsystem Description',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (7641,
	701);
INSERT INTO O_BATTR
	VALUES (7641,
	701);
INSERT INTO O_ATTR
	VALUES (7641,
	701,
	7640,
	'Prefix',
	'Full Name: Subsystem Prefix
Description: The subsystem keyletter prefix is used when classes are created in the subsystem.  The subsystem keyletter prefix is used as the default prefix in the class keyletters.
',
	'',
	'Prefix',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (7642,
	701);
INSERT INTO O_BATTR
	VALUES (7642,
	701);
INSERT INTO O_ATTR
	VALUES (7642,
	701,
	7641,
	'Num_Rng',
	'Full Name: Number Range
Description:  The subsystem number range start is used when classes and associations are created in the subsystem.  The subsystem number range start is used as the default auto-numbering start value in for the newly created class number and newly created association number. 
min_value: 0
max_value: 9999
',
	'',
	'Num_Rng',
	0,
	298,
	'',
	'');
INSERT INTO O_REF
	VALUES (701,
	699,
	0,
	712,
	7230,
	7232,
	7231,
	7643,
	7644,
	0,
	0,
	'',
	'Domain',
	'Dom_ID',
	'R1');
INSERT INTO O_RATTR
	VALUES (7643,
	701,
	712,
	699,
	1,
	'Dom_ID');
INSERT INTO O_ATTR
	VALUES (7643,
	701,
	7642,
	'Dom_ID',
	'',
	'',
	'Dom_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (7645,
	701);
INSERT INTO O_BATTR
	VALUES (7645,
	701);
INSERT INTO O_ATTR
	VALUES (7645,
	701,
	7643,
	'Config_ID',
	'Full Name: Configuration Identifier',
	'',
	'Config_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	701);
INSERT INTO O_OIDA
	VALUES (717,
	701,
	0,
	'SS_ID');
INSERT INTO O_ID
	VALUES (1,
	701);
INSERT INTO O_ID
	VALUES (2,
	701);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (7264,
	'Structured Data Type',
	33,
	'S_SDT',
	'',
	7221);
INSERT INTO O_TFR
	VALUES (7646,
	7264,
	'newMember',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
create object instance mbr of S_MBR;
relate self to mbr across R44;
select any dom from instances of S_DOM;
select any int_dt related by dom->S_DT[R14] where
                                                     selected.Name == "integer";
if(not_empty dom and empty int_dt)
  // if the int data type was not found
  // and the domain is not empty this
  // structured dt is at the domain level
  // but within a formal component
  // so we locate the int type at the system
  // level
  select one system related by dom->CN_DC[R4204]->C_C[R4204]->CP_CP[R4608]
                                   ->S_SYS[R4606];
  intdt_id = GD::NULL_UNIQUE_ID();
  if not_empty system
    intdt_id = system.getCoreTypeId(name:"integer");
  end if;
  select any pe from instances of PE_PE where selected.Element_ID == intdt_id;
  select one int_dt related by pe->S_DT[R8001]; 
end if;
// If no integer data type was found, this structured dt is in a system
// package other than the default one.  We need to search for the integer
// data type through the associations with the determined system.
if(empty int_dt)
  select one dpkg related by self->S_DT[R17]->S_DIP[R39]->S_DPK[R39];
  if (not_empty dpkg)
    select any sys from instances of S_SYS where (selected.Sys_ID == dpkg.getSystemId());
    intdt_id = GD::NULL_UNIQUE_ID();
    if not_empty sys
      intdt_id = sys.getCoreTypeId(name:"integer");
    end if;
    select any pe from instances of PE_PE where selected.Element_ID == intdt_id;
    select one int_dt related by pe->S_DT[R8001]; 
  else
    // See if this is in the generic package
    select one sys related by self->S_DT[R17]->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405];
    intdt_id = GD::NULL_UNIQUE_ID();
    if not_empty sys
      intdt_id = sys.getCoreTypeId(name:"integer");
    end if;
    select any pe from instances of PE_PE where selected.Element_ID == intdt_id;
    select one int_dt related by pe->S_DT[R8001]; 
    if (empty int_dt)
      select any int_dt related by sys->EP_PKG[R1405]->PE_PE[R8000]->S_DT[R8001] where (selected.Name == "integer");
    end if;
  end if;
end if;
relate mbr to int_dt across R45;
mbr.initialize(newname:"Unnamed Structured Member");',
	1,
	'',
	7647);
INSERT INTO O_TFR
	VALUES (7648,
	7264,
	'dispose',
	'',
	19,
	1,
	'select many members related by self->S_MBR[R44];
for each member in members
  unrelate self from member across R44;
  member.dispose();
end for;
select one dt related by self->S_DT[R17];
unrelate self from dt across R17;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (7649,
	7264,
	'get_compartment_text',
	'',
	322,
	1,
	'result = "";
if (param.comp_num == 1)
  if (param.at == Justification::Center_in_X)
    result = "dataType";
    result = result + GD::newline();
    select one selfDt related by self->S_DT[R17];
    if ( not_empty selfDt )
      result = result + selfDt.Name;
      select one pe related by selfDt->PE_PE[R8001];
      if not_empty pe
        result = pe.getVisibilityAdornment() + result;
      end if;
    else
      result = result + ::getOrphanedElementName();
    end if;
  end if;
else
  select any member related by self->S_MBR[R44] where (selected.Previous_Member_ID == GD::NULL_UNIQUE_ID());
  if (param.at == Justification::Left)
    cursor = param.ent_num;
    while (not_empty member AND cursor > 1)
      select one member related by member->S_MBR[R46.''precedes''];
      cursor = cursor - 1;
    end while;
    if (empty member) 
      return "";
    end if;
    result = member.Name;
    result = result + member.Dimensions;
    select one dt related by member->S_DT[R45];
    if (not_empty dt)
      result = result + ":" + dt.Name;
    end if;
  end if;
end if;
return result;',
	1,
	'',
	7648);
INSERT INTO O_TPARM
	VALUES (7650,
	7649,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (7651,
	7649,
	'comp_num',
	298,
	0,
	'',
	7650,
	'');
INSERT INTO O_TPARM
	VALUES (7652,
	7649,
	'ent_num',
	298,
	0,
	'',
	7651,
	'');
INSERT INTO O_TFR
	VALUES (7653,
	7264,
	'get_compartments',
	'',
	298,
	1,
	'return 2;',
	1,
	'',
	7649);
INSERT INTO O_TFR
	VALUES (7654,
	7264,
	'get_style',
	'',
	784,
	1,
	'return Style::Box;',
	1,
	'',
	7655);
INSERT INTO O_TFR
	VALUES (7647,
	7264,
	'get_text_style',
	'',
	784,
	1,
	'return Style::None;',
	1,
	'',
	7654);
INSERT INTO O_TPARM
	VALUES (7656,
	7647,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (7657,
	7647,
	'comp_num',
	298,
	0,
	'',
	7656,
	'');
INSERT INTO O_TPARM
	VALUES (7658,
	7647,
	'ent_num',
	298,
	0,
	'',
	7657,
	'');
INSERT INTO O_TFR
	VALUES (7659,
	7264,
	'get_entries',
	'',
	298,
	1,
	'if (param.comp_num == 1)
  return 1;
else
  select many members related by self->S_MBR[R44];
  return cardinality members;
end if;',
	1,
	'',
	7653);
INSERT INTO O_TPARM
	VALUES (7660,
	7659,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7661,
	7264,
	'get_name',
	'',
	322,
	1,
	'select one dt related by self->S_DT[R17];
if (empty dt)
  return "";
else
  return dt.Name;
end if;',
	1,
	'',
	7659);
INSERT INTO O_TFR
	VALUES (7662,
	7264,
	'rename',
	'',
	19,
	1,
	'select one dt related by self->S_DT[R17];
dt.Name = param.new_name;
',
	1,
	'',
	7646);
INSERT INTO O_TPARM
	VALUES (7663,
	7662,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7655,
	7264,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.DT_ID;',
	1,
	'',
	7661);
INSERT INTO O_TFR
	VALUES (7664,
	7264,
	'actionFilter',
	'',
	316,
	1,
	'if(param.name == "can")
	if param.value == "make public"
		select one pe related by self->S_DT[R17]->PE_PE[R8001];
		select one pkg related by pe->EP_PKG[R8000];
		if not_empty pkg
			if not_empty pe 
				return pe.Visibility != Visibility::Public;
			end if;
		end if;
	end if;
	if param.value == "make protected"
		select one pe related by self->S_DT[R17]->PE_PE[R8001];
		select one pkg related by pe->EP_PKG[R8000];
		if not_empty pkg
    		if not_empty pe 
      			return pe.Visibility != Visibility::Protected;
    		end if;
  		end if;
  	end if;
	if param.value == "make private"
		select one pe related by self->S_DT[R17]->PE_PE[R8001];
		select one pkg related by pe->EP_PKG[R8000];
		if not_empty pkg
    		if not_empty pe 
      			return pe.Visibility != Visibility::Private;
    		end if;
  		end if;
  	end if;
end if;
return false;',
	1,
	'',
	7662);
INSERT INTO O_TPARM
	VALUES (7665,
	7664,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (7666,
	7664,
	'value',
	322,
	0,
	'',
	7665,
	'');
INSERT INTO O_TFR
	VALUES (7667,
	7264,
	'pasteStructureMember',
	'',
	19,
	1,
	'select any member from instances of S_MBR
                                         where (selected.Member_ID == param.id);
if(not_empty member)
  select one existingSDT related by member->S_SDT[R44];
  if(not_empty existingSDT)
    unrelate member from existingSDT across R44;
  end if;
  relate member to self across R44;
  self.addMemberToOrder(id:member.Member_ID);
end if;',
	1,
	'',
	7664);
INSERT INTO O_TPARM
	VALUES (7668,
	7667,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7669,
	7264,
	'addMemberToOrder',
	'',
	19,
	1,
	'select any member from instances of S_MBR
                                         where (selected.Member_ID == param.id);
if(not_empty member)
  ::changeNotificationEnablement(enabled:false);
  select many peers related by self->S_MBR[R44];
  for each peer in peers
    if (peer != member)
      select one predecessor related by peer->S_MBR[R46.''precedes''];
      if (empty predecessor)
        relate member to peer across R46.''succeeds'';
      end if;
    end if;
  end for;
  ::changeNotificationEnablement(enabled:true);
end if;
',
	1,
	'',
	7667);
INSERT INTO O_TPARM
	VALUES (7670,
	7669,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7671,
	7264,
	'checkIntegrity',
	'',
	19,
	1,
	'// create an integrity issue if there are any other data types under
// the same package with the same name
select one dt related by self->S_DT[R17];
select one package related by dt->PE_PE[R8001]->EP_PKG[R8000];
select one component related by dt->PE_PE[R8001]->C_C[R8003];
if(not empty component)
  pkgId = component.getPackageId();
  select any package from instances of EP_PKG
                                           where (selected.Package_ID == pkgId);
end if;
select one system related by package->S_SYS[R1405];
sys_id = GD::NULL_UNIQUE_ID();
if(not_empty system)
  sys_id = system.Sys_ID;
end if;
select many dts related by dt->PE_PE[R8001]->EP_PKG[R8000]
                                                    ->PE_PE[R8000]->S_DT[R8001];
if(empty dts)
  select many dts related by dt->PE_PE[R8001]->C_C[R8003]
                                                    ->PE_PE[R8003]->S_DT[R8001];
end if;
for each otherDt in dts
  if(otherDt != dt and otherDt.Name == dt.Name)
    MI_IM::createIssue(sys_id:sys_id, description:
           "Found another data type under the same package with a " +
                                                          "matching name.",
                                       severity:Severity::Error, name:dt.Name,
                       path:dt.getPath(path:"", includeSelf:true),
                              id:dt.DT_ID, element:self.convertToInstance());
  end if;
end for;',
	1,
	'',
	7669);
INSERT INTO O_TFR
	VALUES (7672,
	7264,
	'convertToInstance',
	'Translate:native',
	317,
	1,
	'return this;',
	0,
	'',
	7671);
INSERT INTO O_TFR
	VALUES (7673,
	7264,
	'getDescription',
	'',
	322,
	1,
	'select one dt related by self->S_DT[R17];
return dt.Descrip;',
	1,
	'',
	7672);
INSERT INTO O_REF
	VALUES (7264,
	32,
	0,
	156,
	7256,
	7265,
	7257,
	7385,
	7674,
	0,
	0,
	'',
	'Data Type',
	'DT_ID',
	'R17');
INSERT INTO O_RATTR
	VALUES (7385,
	7264,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (7385,
	7264,
	0,
	'DT_ID',
	'',
	'',
	'Element_ID',
	2,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	7264);
INSERT INTO O_OIDA
	VALUES (7385,
	7264,
	0,
	'DT_ID');
INSERT INTO O_ID
	VALUES (1,
	7264);
INSERT INTO O_ID
	VALUES (2,
	7264);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (55,
	'Structure Member',
	34,
	'S_MBR',
	'',
	7221);
INSERT INTO O_TFR
	VALUES (7675,
	55,
	'initialize',
	'',
	19,
	1,
	'select one sdt related by self->S_SDT[R44];
sdt.addMemberToOrder(id:self.Member_ID);
name = param.newname;
success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:true);    
if ( success!="") 
 self.Name=success;
else 
 self.dispose();
end if;     ',
	1,
	'',
	7676);
INSERT INTO O_TPARM
	VALUES (7677,
	7675,
	'newname',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7678,
	55,
	'dispose',
	'',
	19,
	1,
	'// Structure Member.dispose()
select one sdt related by self->S_SDT[R44];
if (not_empty sdt)
  unrelate self from sdt across R44;
end if;
select one datatype related by self->S_DT[R45];
unrelate self from datatype across R45;
select one successor related by self->S_MBR[R46.''precedes''];
select one predecessor related by self->S_MBR[R46.''succeeds''];
if (not empty successor)
  unrelate self from successor across R46.''precedes'';
end if;
if (not empty predecessor)
  unrelate self from predecessor across R46.''succeeds'';
end if;
if (not_empty successor and not_empty predecessor)
  relate successor to predecessor across R46.''succeeds'';
end if;
select many memBrValues related by self->V_MVL[R836];
for each membrValue in memBrValues
  unrelate membrValue from self across R836;
  select one value related by membrValue->V_VAL[R801];
  if not_empty value
    value.dispose();
  end if;
end for;
select many dims related by self->S_DIM[R53];
for each dim in dims
  unrelate self from dim across R53;
  delete object instance dim;
end for;
delete object instance self;

',
	1,
	'',
	7679);
INSERT INTO O_TFR
	VALUES (7680,
	55,
	'moveUp',
	'',
	19,
	1,
	'::changeNotificationEnablement(enabled:false);
select one prev_mbr related by self->S_MBR[R46.''succeeds''];
select one prev_prev_mbr related by prev_mbr->S_MBR[R46.''succeeds''];
select one next_mbr related by self->S_MBR[R46.''precedes''];

if ( not_empty prev_prev_mbr )
  unrelate prev_mbr from prev_prev_mbr across R46.''succeeds'';
end if;
if ( not_empty next_mbr )
  unrelate next_mbr from self across R46.''succeeds'';
end if;
unrelate self from prev_mbr across R46.''succeeds'';

if ( not_empty prev_prev_mbr )
  relate self to prev_prev_mbr across R46.''succeeds'';
end if;
// want to enable listeners at the last possible moment
if ( empty next_mbr )
  ::changeNotificationEnablement(enabled:true);
end if;
relate prev_mbr to self across R46.''succeeds'';
if ( not_empty next_mbr )
  ::changeNotificationEnablement(enabled:true);
  relate next_mbr to prev_mbr across R46.''succeeds'';
end if;
',
	1,
	'',
	7681);
INSERT INTO O_TFR
	VALUES (7681,
	55,
	'moveDown',
	'',
	19,
	1,
	'::changeNotificationEnablement(enabled:false);
select one next_mbr related by self->S_MBR[R46.''precedes''];
select one prev_mbr related by self->S_MBR[R46.''succeeds''];
select one next_next_mbr related by next_mbr->S_MBR[R46.''precedes''];

if ( not_empty next_next_mbr )
  unrelate next_next_mbr from next_mbr across R46.''succeeds'';
end if;
if ( not_empty prev_mbr )
  unrelate self from prev_mbr across R46.''succeeds'';
end if;
unrelate next_mbr from self across R46.''succeeds'';

if ( not_empty prev_mbr )
  relate next_mbr to prev_mbr across R46.''succeeds'';
end if;
   
// want to enable listeners at the last possible moment
if ( empty next_next_mbr )
  ::changeNotificationEnablement(enabled:true);
end if;
relate self to next_mbr across R46.''succeeds'';
if ( not_empty next_next_mbr )
  ::changeNotificationEnablement(enabled:true);
  relate next_next_mbr to self across R46.''succeeds'';
end if;',
	1,
	'',
	7682);
INSERT INTO O_TFR
	VALUES (7683,
	55,
	'changeType',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one old_dt related by self->S_DT[R45];

select one packageableElem related by self->S_SDT[R44]->S_DT[R17]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;

if (isInGenericPackage)
    select one system related by packageableElem->EP_PKG[R8001]->S_SYS[R1405];
    if (empty system and not_empty component)
      rootCompIdInPkg = component.getRootComponentId();
      select any rootComponent from instances of C_C where (selected.Id == rootCompIdInPkg);
      select one system related by rootComponent->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405];
    end if;
    
    id = packageableElem.resolveDataTypeRelativeToSelf(default_name:"integer",
                                                            expected_name:param.typeName);                                                          
    select any new_dt related by system->SLD_SDINP[R4402]->S_DT[R4401]
                                     where (selected.DT_ID == id);
    if empty new_dt and not_empty system and system.useGlobals
      select any pe related by system->G_EIS[R9100]->PE_PE[R9100]
                                                where selected.Element_ID == id;
      select one dt related by pe->S_DT[R8001]; 
    end if;
    if (empty new_dt)
      select any new_dt related by system->EP_PKG[R1405]->PE_PE[R8000]->S_DT[R8001]
                                     where (selected.DT_ID == id);
    end if;
    if ( not_empty new_dt )
      unrelate self from old_dt across R45;
      relate self to new_dt across R45;
    end if;
else
  select any new_dt related by self->S_SDT[R44]->S_DT[R17]->S_DOM[R14]->S_DT[R14] 
                                            where selected.Name == param.typeName;
  // see if this dt is defined at the system level
  if(empty new_dt)
    select any system related by self->S_SDT[R44]->S_DT[R17]->
                                                   SLD_SDINP[R4401]->S_SYS[R4402];
    if(not_empty system)
      dt_id = system.getCoreTypeId(name:param.typeName);
      select any pe from instances of PE_PE where selected.Element_ID == dt_id;
      select one new_dt related by pe->S_DT[R8001]; 
    end if;
  end if;
  if ( not_empty new_dt )
    unrelate self from old_dt across R45;
    relate self to new_dt across R45;
  end if;
end if;
',
	1,
	'',
	7684);
INSERT INTO O_TPARM
	VALUES (7685,
	7683,
	'typeName',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7686,
	55,
	'actionFilter',
	'',
	316,
	1,
	'if (param.name == "can" )
  if ( param.value == "move up" )
    select one prev_attr related by self->S_MBR[R46.''succeeds''];
    return not_empty prev_attr;
  elif ( param.value == "move down" )
    select one next_attr related by self->S_MBR[R46.''precedes''];
    return not_empty next_attr;
  end if;
end if;
return false;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (7687,
	7686,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (7688,
	7686,
	'value',
	322,
	0,
	'',
	7687,
	'');
INSERT INTO O_TFR
	VALUES (7689,
	55,
	'rename',
	'',
	19,
	1,
	'self.Name = param.new_name;',
	1,
	'',
	7680);
INSERT INTO O_TPARM
	VALUES (7690,
	7689,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7691,
	55,
	'isAllowedType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Structure Member.isAllowedType()
// Anything that is allowed for a parameter is allowed as a structure member
select one packageableElem related by self->S_SDT[R44]->S_DT[R17]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;
if isInGenericPackage
  return packageableElem.isAllowedType(isReturnType:false,
                                                       typeName:param.typeName);
else
  select one dpkg related by self->S_SDT[R44]->S_DT[R17]->S_DIP[R39]->S_DPK[R39];
  select any sys from instances of S_SYS
                                  where (selected.Sys_ID == dpkg.getSystemId());
  if(not_empty sys)
    // this member''s dt is contained at the system level
    return Util::isAllowedParameterType(system:sys.convertToInstance(),
                                                       typeName:param.typeName);
  else
    // this member''''s dt is contained at the domain level
    // see if this domain is the formal content of a component
    select one domain related by self ->S_SDT[R44]->S_DT[R17]->S_DOM[R14];
    if(not_empty domain)
      select one system related by domain->S_SYS[R28];
      if(not_empty system)
        // this domain is not the formal content
        // of a component, just check domain level
        // dts
        return S_DT::isAllowedParameterType( typeName: param.typeName,
                                   			dom_id: domain.get_ooa_id());
      else
        // this domain is the formal content of
        // a component, first check the domain
        // level dts, then the system level ones
        result = S_DT::isAllowedParameterType( typeName: param.typeName,
                                   			dom_id: domain.get_ooa_id());
        if(not result)
          // nothing valid, now check the system
          select one dt_system related by domain->CN_DC[R4204]->C_C[R4204]
                                                   ->CP_CP[R4608]->S_SYS[R4606];
          return Util::isAllowedParameterType(
                                           system:dt_system.convertToInstance(),
                                                       typeName:param.typeName);
        else
          return result;
        end if;
      end if;
    end if;
  end if;
  return false;
end if;',
	1,
	'',
	7675);
INSERT INTO O_TPARM
	VALUES (7692,
	7691,
	'typeName',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7693,
	55,
	'resolveDataType',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one dtProxy related by self->S_DT[R45];
if(not_empty dtProxy and not Util::isProxy(element:self.convertToInstance()))
  name = dtProxy.Name;
  unrelate dtProxy from self across R45;
  
  select one packageableElem related by self->S_SDT[R44]->S_DT[R17]->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = not_empty package or not_empty component;
  if isInGenericPackage
    // Note that this operation calls collectVisibleElementsForName
    id = packageableElem.resolveDataTypeRelativeToSelf(default_name:"integer",
                                                            expected_name:name);                                                          
    select any resolvedDt related by package->PE_VIS[R8002]->
                         PE_PE[R8002]->S_DT[R8001] where selected.DT_ID == id;
    if (empty resolvedDt)
      select any resolvedDt related by component->PE_CVS[R8004]->
                       PE_PE[R8004]->S_DT[R8001] where selected.DT_ID == id;
    end if;	
    if not_empty resolvedDt
      relate resolvedDt to self across R45;
    end if;
  else
    select any system related by self->S_SDT[R44]->S_DT[R17]->SLD_SDINP[R4401]
                                                                 ->S_SYS[R4402];
    if(not empty system)
      // this is a system data type only allow resolving dts
      // from the system level
      dt_id = system.getCoreTypeId(name:name);
      select any pe from instances of PE_PE where selected.Element_ID == dt_id;
      select one resolvedDT related by pe->S_DT[R8001]; 
      if(empty resolvedDT)
        dt_id = system.getCoreTypeId(name:"integer");
        select any pe from instances of PE_PE where selected.Element_ID == dt_id;
        select one resolvedDT related by pe->S_DT[R8001]; 
      end if;
      if(not_empty resolvedDT)
        relate resolvedDT to self across R45;
      end if;
    else
      select one domain related by self->S_SDT[R44]->S_DT[R17]->S_DOM[R14];  
      id = domain.resolveDataTypeRelativeToSelf(default_name:"integer",
    								                          expected_name:name);
      select any resolvedDT related by domain->S_DT[R14]
    											   where (selected.DT_ID == id);
      if(empty resolvedDT)
        // if the data type was not found local to the domain
        // check for a system level data type
        select one system related by domain->CN_DC[R4204]->C_C[R4204]
        	         ->CP_CP[R4608]->S_SYS[R4606];
        select any resolvedDT related by system->SLD_SDINP[R4402]->S_DT[R4401]
        	                                       where (selected.DT_ID == id);
        if empty resolvedDT and not_empty system and system.useGlobals
          select any pe related by system->G_EIS[R9100]->PE_PE[R9100]
                                                where selected.Element_ID == id;
          select one resolvedDT related by pe->S_DT[R8001]; 
        end if;
      end if;
      if(not_empty resolvedDT)
        relate resolvedDT to self across R45;
      end if;
    end if;
  end if;
end if;',
	1,
	'',
	7694);
INSERT INTO O_TFR
	VALUES (7676,
	55,
	'getDimensionsCnt',
	'',
	298,
	1,
	'select many dims related by self->S_DIM[R53];
dimensions = cardinality dims;
return dimensions;
',
	1,
	'',
	7678);
INSERT INTO O_TFR
	VALUES (7694,
	55,
	'resizeDimensions',
	'',
	19,
	1,
	'// If the number of dimensions has increased then add dimensions
while (param.numDimensions > self.getDimensionsCnt())
  create object instance dim of S_DIM;
  dim.dimensionCount = self.getDimensionsCnt();
  relate dim to self across R53;
end while;

// If the number of dimensions has decreased then remove dimensions
while (param.numDimensions < self.getDimensionsCnt())
  select any dim related by self->S_DIM[R53] where (selected.dimensionCount == (self.getDimensionsCnt()-1));
  unrelate dim from self across R53;
  delete object instance dim;
end while;

// Update the specific dimension that was passed-in if its elementCount has 
// changed.
if (param.numDimensions > 0) 
  select any dim related by self->S_DIM[R53] where (selected.dimensionCount == param.dimension);
  if (dim.elementCount != param.elementCount)
    dim.elementCount = param.elementCount;
  end if;
end if;
',
	1,
	'',
	7689);
INSERT INTO O_TPARM
	VALUES (7695,
	7694,
	'numDimensions',
	298,
	0,
	'',
	7696,
	'');
INSERT INTO O_TPARM
	VALUES (7697,
	7694,
	'dimension',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (7696,
	7694,
	'elementCount',
	298,
	0,
	'',
	7697,
	'');
INSERT INTO O_TFR
	VALUES (7698,
	55,
	'canReferToDataType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// select the dt
select one dt related by self->S_DT[R45];
if(not_empty dt)
  select one packageableElem related by self->S_SDT[R44]->S_DT[R17]->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = not_empty package or not_empty component;

  if (isInGenericPackage)
    return packageableElem.canReferToDataType(dtID:dt.DT_ID, dtName: dt.Name);
  else
    // if the data type package is at the system
    // level we can use the data type as long as
    // this element belongs to a formal component
    select one mbrDTPkg related by self->S_SDT[R44]->S_DT[R17]->S_DIP[R39]
           ->S_DPK[R39];
    select one dtPkg related by dt->S_DIP[R39]->S_DPK[R39];
    if(mbrDTPkg.isDomainLevel())
      dom_id = mbrDTPkg.getDomainId();
      select any domain from instances of S_DOM
                   where (selected.Dom_ID == dom_id);
      if(not dtPkg.isDomainLevel())
        if(domain.participatesInSystem())
          return true;
        else
          return false;
        end if;
      else
        // otherwise the DT must be in the same domain
        select one dtDomain related by dt->S_DOM[R14];
        if(dtDomain == domain)
          return true;
        end if;
      end if;  
    else
      // the dt can be used as long as it is defined at the system
      // level
      if(not dtPkg.isDomainLevel())
        return true;
      end if;
    end if;
  end if;
end if;
return false;
',
	1,
	'',
	7686);
INSERT INTO O_TFR
	VALUES (7679,
	55,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.
Translate: native
',
	317,
	1,
	'return this;',
	0,
	'',
	7683);
INSERT INTO O_TFR
	VALUES (7682,
	55,
	'isReferringToDefaultDataType',
	'',
	316,
	1,
	'select one dt related by self->S_DT[R45];
elementType = Util::getSimpleClassName(element:self.convertToInstance());
if(dt.Name == S_DT::getDefaultDataTypeName(elementType:elementType))
  return true;
end if;
return false;
',
	1,
	'',
	7691);
INSERT INTO O_TFR
	VALUES (7684,
	55,
	'canUseDataType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Structure Member.canUseDataType()
select one packageableElem related by self->S_SDT[R44]->S_DT[R17]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;
if isInGenericPackage
  // Find the previously created visibility list
  select any resultSet related by package->PE_SRS[R8005] where
        selected.Name == "" and selected.Type == ElementTypeConstants::DATATYPE;
  select any dt related by resultSet->PE_VIS[R8006]->
                     PE_PE[R8002]->S_DT[R8001] where selected.DT_ID == param.id;
  if not_empty component
    // Find the previously created visibility list
    select any compResultSet related by component->PE_CRS[R8007] where
        selected.Name == "" and selected.Type == ElementTypeConstants::DATATYPE;
    select any dt related by compResultSet->PE_CVS[R8008]->
                     PE_PE[R8004]->S_DT[R8001] where selected.DT_ID == param.id;
  end if;
  if(not_empty dt)
    if(self.isAllowedType(typeName:dt.Name))
      return true;
    end if;
  end if;
  return false;
else
  select one domain related by self->S_SDT[R44]->S_DT[R17]->S_DOM[R14];
  if(not_empty domain)
    if(domain.participatesInSystem())
      // system level check both the system
      // and the domain for the dt
      select one system related by domain->CN_DC[R4204]->C_C[R4204]->CP_CP[R4608]
                                                                 ->S_SYS[R4606];
      select any dt related by system->SLD_SDINP[R4402]->S_DT[R4401]
                                             where (selected.DT_ID == param.id);
      if empty dt and not_empty system and system.useGlobals
        select any pe related by system->G_EIS[R9100]->PE_PE[R9100]
                                          where selected.Element_ID == param.id;
        select one dt related by pe->S_DT[R8001]; 
      end if;
      if(empty dt)
        select any dt related by domain->S_DT[R14]
                                             where (selected.DT_ID == param.id);
      end if;
      if(not_empty dt)
        if(self.isAllowedType(typeName:dt.Name))
          return true;
        end if;
      end if;
    else
      // only check the domain for the dt
      select any dt related by domain->S_DT[R14]
                                             where (selected.DT_ID == param.id);
      if(not_empty dt)
        if(self.isAllowedType(typeName:dt.Name))
          return true;
        end if;
      end if;
    end if;
  else
    // defined at the system level
    select any system related by self->S_SDT[R44]->S_DT[R17]->
                                                 SLD_SDINP[R4401]->S_SYS[R4402];
    select any dt related by system->SLD_SDINP[R4402]->S_DT[R4401]
                                             where (selected.DT_ID == param.id);
    if empty dt and not_empty system and system.useGlobals
      select any pe related by system->G_EIS[R9100]->PE_PE[R9100]
                                          where selected.Element_ID == param.id;
      select one dt related by pe->S_DT[R8001]; 
    end if;
    if(not_empty dt)
      if(self.isAllowedType(typeName:dt.Name))
        return true;
      end if;
    end if;
  end if;
  return false;
end if;',
	1,
	'',
	7698);
INSERT INTO O_TPARM
	VALUES (7699,
	7684,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7700,
	55,
	'checkIntegrity',
	'',
	19,
	1,
	'/**
 *  Create an integrity issue if there are any other members in the same
 *  SDT with a matching name
 */
select one sdt related by self->S_SDT[R44];
select one dt related by sdt->S_DT[R17];
select one package related by dt->PE_PE[R8001]->EP_PKG[R8000];
select one component related by dt->PE_PE[R8001]->C_C[R8003];
if(not empty component)
  pkgId = component.getPackageId();
  select any package from instances of EP_PKG
                                           where (selected.Package_ID == pkgId);
end if;
select one system related by package->S_SYS[R1405];
sys_id = GD::NULL_UNIQUE_ID();
if(not_empty system)
  sys_id = system.Sys_ID;
end if;
select many members related by sdt->S_MBR[R44];
for each member in members
  if(member != self and member.Name == self.Name)
    MI_IM::createIssue(sys_id:sys_id, description:
         "Found another member under the same structured data type with a " +
                                                          "matching name.",
                                      severity:Severity::Error, name:self.Name,
                  path:dt.getPath(path:"", includeSelf:true) + "::" + self.Name,
                    id:self.Member_ID, element:self.convertToInstance());
  end if;
end for;',
	1,
	'',
	7693);
INSERT INTO O_NBATTR
	VALUES (7701,
	55);
INSERT INTO O_BATTR
	VALUES (7701,
	55);
INSERT INTO O_ATTR
	VALUES (7701,
	55,
	231,
	'Name',
	'Full Name: Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (7702,
	55);
INSERT INTO O_BATTR
	VALUES (7702,
	55);
INSERT INTO O_ATTR
	VALUES (7702,
	55,
	7701,
	'Descrip',
	'Full Name: Description',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (231,
	55);
INSERT INTO O_BATTR
	VALUES (231,
	55);
INSERT INTO O_ATTR
	VALUES (231,
	55,
	0,
	'Member_ID',
	'',
	'',
	'Member_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (7703,
	55);
INSERT INTO O_BATTR
	VALUES (7703,
	55);
INSERT INTO O_ATTR
	VALUES (7703,
	55,
	7704,
	'Dimensions',
	'Full Name: Array Dimensions',
	'',
	'Dimensions',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (55,
	7264,
	0,
	7385,
	7383,
	7386,
	7384,
	232,
	7705,
	0,
	0,
	'',
	'Structured Data Type',
	'DT_ID',
	'R44');
INSERT INTO O_REF
	VALUES (55,
	55,
	0,
	232,
	7390,
	7392,
	7391,
	232,
	7706,
	7705,
	0,
	'',
	'Structure Member',
	'Parent_DT_DT_ID',
	'R46');
INSERT INTO O_RATTR
	VALUES (232,
	55,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (232,
	55,
	7702,
	'Parent_DT_DT_ID',
	'',
	'Parent_DT_',
	'Element_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (55,
	32,
	0,
	156,
	7387,
	7389,
	7388,
	7707,
	7708,
	0,
	0,
	'',
	'Data Type',
	'DT_ID',
	'R45');
INSERT INTO O_RATTR
	VALUES (7707,
	55,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (7707,
	55,
	232,
	'DT_ID',
	'',
	'',
	'Element_ID',
	2,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (55,
	55,
	0,
	231,
	7390,
	7392,
	7391,
	7704,
	7709,
	0,
	0,
	'',
	'Structure Member',
	'Member_ID',
	'R46');
INSERT INTO O_RATTR
	VALUES (7704,
	55,
	231,
	55,
	1,
	'Member_ID');
INSERT INTO O_ATTR
	VALUES (7704,
	55,
	7707,
	'Previous_Member_ID',
	'',
	'Previous_',
	'Member_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	55);
INSERT INTO O_OIDA
	VALUES (231,
	55,
	0,
	'Member_ID');
INSERT INTO O_OIDA
	VALUES (232,
	55,
	0,
	'Parent_DT_DT_ID');
INSERT INTO O_ID
	VALUES (1,
	55);
INSERT INTO O_ID
	VALUES (2,
	55);
-- BP 7.1 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (7710,
	'Package Linking',
	'// This is used by schema_gen to ignore this subsystem (for publication)
TRANSLATE_FOR_EXTERNAL_USE:FALSE',
	'PL',
	300,
	1,
	0);
INSERT INTO O_IOBJ
	VALUES (7711,
	699,
	0,
	7710,
	'Domain',
	'S_DOM');
INSERT INTO O_IOBJ
	VALUES (7712,
	7338,
	0,
	7710,
	'External Entity Package',
	'S_EEPK');
INSERT INTO O_IOBJ
	VALUES (7713,
	3523,
	0,
	7710,
	'Function Package',
	'S_FPK');
INSERT INTO R_ASSOC
	VALUES (7714);
INSERT INTO R_REL
	VALUES (7714,
	300,
	'CrossComponent:true',
	7710);
INSERT INTO R_AONE
	VALUES (699,
	7714,
	7715,
	0,
	0,
	'is container');
INSERT INTO O_RTIDA
	VALUES (712,
	699,
	0,
	7714,
	7715);
INSERT INTO R_RTO
	VALUES (699,
	7714,
	7715,
	0);
INSERT INTO R_OIR
	VALUES (699,
	7714,
	7715,
	7711);
INSERT INTO R_AOTH
	VALUES (7338,
	7714,
	7716,
	1,
	1,
	'contains');
INSERT INTO O_RTIDA
	VALUES (7340,
	7338,
	0,
	7714,
	7716);
INSERT INTO R_RTO
	VALUES (7338,
	7714,
	7716,
	0);
INSERT INTO R_OIR
	VALUES (7338,
	7714,
	7716,
	7712);
INSERT INTO R_ASSR
	VALUES (7717,
	7714,
	7718,
	0);
INSERT INTO R_RGO
	VALUES (7717,
	7714,
	7718);
INSERT INTO R_OIR
	VALUES (7717,
	7714,
	7718,
	0);
INSERT INTO R_ASSOC
	VALUES (7719);
INSERT INTO R_REL
	VALUES (7719,
	301,
	'CrossComponent:true',
	7710);
INSERT INTO R_AONE
	VALUES (3523,
	7719,
	7720,
	1,
	1,
	'contains');
INSERT INTO O_RTIDA
	VALUES (3566,
	3523,
	0,
	7719,
	7720);
INSERT INTO R_RTO
	VALUES (3523,
	7719,
	7720,
	0);
INSERT INTO R_OIR
	VALUES (3523,
	7719,
	7720,
	7713);
INSERT INTO R_AOTH
	VALUES (699,
	7719,
	7721,
	0,
	0,
	'is container');
INSERT INTO O_RTIDA
	VALUES (712,
	699,
	0,
	7719,
	7721);
INSERT INTO R_RTO
	VALUES (699,
	7719,
	7721,
	0);
INSERT INTO R_OIR
	VALUES (699,
	7719,
	7721,
	7711);
INSERT INTO R_ASSR
	VALUES (7722,
	7719,
	7723,
	0);
INSERT INTO R_RGO
	VALUES (7722,
	7719,
	7723);
INSERT INTO R_OIR
	VALUES (7722,
	7719,
	7723,
	0);
INSERT INTO S_SIS
	VALUES (7221,
	7710);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (7722,
	'Function Package in Domain',
	300,
	'PL_FPID',
	'',
	7710);
INSERT INTO O_REF
	VALUES (7722,
	3523,
	0,
	3566,
	7719,
	7723,
	7720,
	7724,
	7725,
	0,
	0,
	'',
	'Function Package',
	'FunPack_ID',
	'R301');
INSERT INTO O_RATTR
	VALUES (7724,
	7722,
	3566,
	3523,
	1,
	'FunPack_ID');
INSERT INTO O_ATTR
	VALUES (7724,
	7722,
	0,
	'FunPack_ID',
	'',
	'',
	'FunPack_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (7722,
	699,
	0,
	712,
	7719,
	7723,
	7721,
	7726,
	7727,
	0,
	0,
	'',
	'Domain',
	'Dom_ID',
	'R301');
INSERT INTO O_RATTR
	VALUES (7726,
	7722,
	712,
	699,
	1,
	'Dom_ID');
INSERT INTO O_ATTR
	VALUES (7726,
	7722,
	7724,
	'Dom_ID',
	'',
	'',
	'Dom_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	7722);
INSERT INTO O_OIDA
	VALUES (7724,
	7722,
	0,
	'FunPack_ID');
INSERT INTO O_OIDA
	VALUES (7726,
	7722,
	0,
	'Dom_ID');
INSERT INTO O_ID
	VALUES (1,
	7722);
INSERT INTO O_ID
	VALUES (2,
	7722);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (7717,
	'External Entity Package in Domain',
	1,
	'PL_EEPID',
	'',
	7710);
INSERT INTO O_REF
	VALUES (7717,
	699,
	0,
	712,
	7714,
	7718,
	7715,
	7728,
	7729,
	0,
	0,
	'',
	'Domain',
	'Dom_ID',
	'R300');
INSERT INTO O_RATTR
	VALUES (7728,
	7717,
	712,
	699,
	1,
	'Dom_ID');
INSERT INTO O_ATTR
	VALUES (7728,
	7717,
	0,
	'Dom_ID',
	'',
	'',
	'Dom_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (7717,
	7338,
	0,
	7340,
	7714,
	7718,
	7716,
	7730,
	7731,
	0,
	0,
	'',
	'External Entity Package',
	'EEPack_ID',
	'R300');
INSERT INTO O_RATTR
	VALUES (7730,
	7717,
	7340,
	7338,
	1,
	'EEPack_ID');
INSERT INTO O_ATTR
	VALUES (7730,
	7717,
	7728,
	'EEPack_ID',
	'',
	'',
	'EEPack_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	7717);
INSERT INTO O_OIDA
	VALUES (7728,
	7717,
	0,
	'Dom_ID');
INSERT INTO O_OIDA
	VALUES (7730,
	7717,
	0,
	'EEPack_ID');
INSERT INTO O_ID
	VALUES (1,
	7717);
INSERT INTO O_ID
	VALUES (2,
	7717);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (988,
	'Instance Reference Data Type',
	32,
	'S_IRDT',
	'This class captures the datatypes that a user may create to represent instance
reference of a model class.',
	7221);
INSERT INTO O_TFR
	VALUES (7732,
	988,
	'dispose',
	'',
	19,
	1,
	'select one dt related by self->S_DT[R17];
unrelate self from dt across R17;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (7733,
	988,
	'rename',
	'',
	19,
	1,
	'select one dt related by self->S_DT[R17];
dummy = dt.rename(new_name:param.new_name);',
	1,
	'',
	7734);
INSERT INTO O_TPARM
	VALUES (7735,
	7733,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7736,
	988,
	'get_name',
	'Returns the name of this instance reference data type.',
	322,
	1,
	'select one dt related by self->S_DT[R17];
if (empty dt)
  return "";
else
  return dt.Name;
end if;',
	1,
	'',
	7732);
INSERT INTO O_TFR
	VALUES (7734,
	988,
	'get_ooa_id',
	'Returns the unique ID of this instance reference data type.',
	296,
	1,
	'return self.DT_ID;',
	1,
	'',
	7736);
INSERT INTO O_NBATTR
	VALUES (7737,
	988);
INSERT INTO O_BATTR
	VALUES (7737,
	988);
INSERT INTO O_ATTR
	VALUES (7737,
	988,
	7738,
	'isSet',
	'User_Visible:false',
	'',
	'isSet',
	0,
	316,
	'',
	'');
INSERT INTO O_REF
	VALUES (988,
	32,
	0,
	156,
	7256,
	7266,
	7257,
	7738,
	7739,
	0,
	0,
	'',
	'Data Type',
	'DT_ID',
	'R17');
INSERT INTO O_RATTR
	VALUES (7738,
	988,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (7738,
	988,
	0,
	'DT_ID',
	'',
	'',
	'Element_ID',
	2,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (988,
	30,
	0,
	150,
	1093,
	1095,
	1094,
	7740,
	7741,
	0,
	0,
	'',
	'Model Class',
	'Obj_ID',
	'R123');
INSERT INTO O_RATTR
	VALUES (7740,
	988,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (7740,
	988,
	7737,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	988);
INSERT INTO O_OIDA
	VALUES (7738,
	988,
	0,
	'DT_ID');
INSERT INTO O_ID
	VALUES (1,
	988);
INSERT INTO O_ID
	VALUES (2,
	988);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (48,
	'Function Parameter',
	17,
	'S_SPARM',
	'A parameter to a function (S_SYNC) is called a function parameter (S_SPARM).  Function parameters are either passed in by value, or by reference.  Function parameters can be accessed by using the param keyword from within a function action specification.',
	7221);
INSERT INTO O_TFR
	VALUES (7742,
	48,
	'dispose',
	'The dispose operation for this class.',
	19,
	1,
	'// Function Parameter.dispose()
//
// Domain Subsystem
select one func related by self->S_SYNC[R24];
unrelate self from func across R24;
select one dt related by self->S_DT[R26];
unrelate self from dt across R26;
//
select one successor related by self->S_SPARM[R54.''precedes''];
select one predecessor related by self->S_SPARM[R54.''succeeds''];
if (not empty successor)
  unrelate self from successor across R54.''precedes'';
end if;
if (not empty predecessor)
  unrelate self from predecessor across R54.''succeeds'';
end if;
if (not_empty successor and not_empty predecessor)
  relate successor to predecessor across R54.''succeeds'';
end if;
//
// Value Subsystem
select many pvs related by self->V_PVL[R832];
for each pv in pvs
  unrelate self from pv across R832;
end for;
//
select many dims related by self->S_DIM[R52];
for each dim in dims
  unrelate self from dim across R52;
  delete object instance dim;
end for;
//
// Finally, delete self
delete object instance self;',
	1,
	'',
	7743);
INSERT INTO O_TFR
	VALUES (7744,
	48,
	'initialize',
	'The initialization operation for this class.  Set the name and return value to defaults.',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one function related by self->S_SYNC[R24];
function.addParameterToOrder(id:self.SParm_ID);
isInGenericPkg = false;
select one pkg related by self->S_SYNC[R24]->PE_PE[R8001]->EP_PKG[R8000];
if (not_empty pkg)
  isInGenericPkg = true;
end if;

if (isInGenericPkg)
    select one system related by pkg->S_SYS[R1405];
    def_dt_id = GD::NULL_UNIQUE_ID();
    if not_empty system
      def_dt_id = system.getCoreTypeId(name:"integer");
    end if;
    select any pe from instances of PE_PE where selected.Element_ID == def_dt_id;
    select one def_dt related by pe->S_DT[R8001]; 
    if(not_empty def_dt)
      relate self to def_dt across R26;
    end if;
else
  select any dom from instances of S_DOM;
  select one component related by dom->CN_DC[R4204]->C_C[R4204];
  if(not_empty component)
    // this bridge is part of a formal component
    // get the default data type from the system
    select one system related by component->CP_CP[R4608]->S_SYS[R4606];
    def_dt_id = GD::NULL_UNIQUE_ID();
    if not_empty system
      def_dt_id = system.getCoreTypeId(name:"integer");
    end if;
    select any pe from instances of PE_PE where selected.Element_ID == def_dt_id;
    select one def_dt related by pe->S_DT[R8001]; 
    if(not_empty def_dt)
      relate self to def_dt across R26;
    end if;
  else
    // this bridge is part of a stand alone domain
    // get the default data type from the domain
    select any def_dt related by dom->S_DT[R14] where selected.Name == "integer";
    if(not_empty def_dt)
      relate self to def_dt across R26;
    end if;
  end if;
end if;  
name = ::getUniqueInitialName( 
	instance: self.convertToInstance(), 
    candidateName: "Unnamed Parameter");
success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:true);    
if ( success!="") 
 self.Name=success;
else 
 self.dispose();
end if;     
    ',
	1,
	'',
	7745);
INSERT INTO O_TFR
	VALUES (7746,
	48,
	'isAllowedType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// if this element is at the system level check the
// system level data types, otherwise check the 
// domain
// Function Parameter.isAllowedType()
select one packageableElem related by self->S_SYNC[R24]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;
if isInGenericPackage
  return packageableElem.isAllowedType(isReturnType:false,
                                                       typeName:param.typeName);
else
  select one domain related by self->S_SYNC[R24]->S_DOM[R23];
  if(not_empty domain)
    select one system related by domain->S_SYS[R28];
    if(not_empty system)
      return S_DT::isAllowedParameterType( typeName: param.typeName,
                                   			dom_id: domain.get_ooa_id() );
    else
      // first check the domain level
      result = S_DT::isAllowedParameterType( typeName: param.typeName,
                                   			dom_id: domain.get_ooa_id() );
      if(not result)
        // if nothing valid check the system level
        select one system related by domain->CN_DC[R4204]->C_C[R4204]
      											   ->CP_CP[R4608]->S_SYS[R4606];
        return Util::isAllowedParameterType(system:system.convertToInstance(),
                                                       typeName:param.typeName);
      else
        return result;
      end if;
    end if;
  end if;
  return false;
end if;',
	1,
	'',
	7744);
INSERT INTO O_TPARM
	VALUES (7747,
	7746,
	'typeName',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7743,
	48,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'// just return this instance as an Object
return this;',
	0,
	'',
	7748);
INSERT INTO O_TFR
	VALUES (7745,
	48,
	'getValue',
	'',
	317,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return GD::NULL_INSTANCE(); ',
	1,
	'',
	7749);
INSERT INTO O_TPARM
	VALUES (7750,
	7745,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7751,
	48,
	'setValue',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	7752);
INSERT INTO O_TPARM
	VALUES (7753,
	7751,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (7754,
	7751,
	'value',
	317,
	0,
	'',
	7753,
	'');
INSERT INTO O_TPARM
	VALUES (7755,
	7751,
	'member_id',
	296,
	0,
	'',
	7754,
	'');
INSERT INTO O_TFR
	VALUES (7752,
	48,
	'resolveDatatype',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one dtProxy related by self->S_DT[R26];
if(not_empty dtProxy and not Util::isProxy(element:self.convertToInstance()))
  name = dtProxy.Name;
  unrelate dtProxy from self across R26;
  
  select one packageableElem related by self->S_SYNC[R24]->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = not_empty package or not_empty component;
  if isInGenericPackage
    id = packageableElem.resolveDataTypeRelativeToSelf(default_name:"integer",
                                                            expected_name:name);                                                          
    select any resolvedDt related by package->PE_VIS[R8002]->
                         PE_PE[R8002]->S_DT[R8001] where selected.DT_ID == id;
    if (empty resolvedDt)
      select any resolvedDt related by component->PE_CVS[R8004]->
                       PE_PE[R8004]->S_DT[R8001] where selected.DT_ID == id;
    end if;	
    if not_empty resolvedDt
      relate resolvedDt to self across R26;
    end if;
  else
    select one domain related by self->S_SYNC[R24]->S_FIP[R31]->S_FPK[R31]
                                                   ->PL_FPID[R301]->S_DOM[R301];
    id = domain.resolveDataTypeRelativeToSelf(default_name:"integer",
    													    expected_name:name);
    select any resolvedDT related by domain->S_DT[R14]
    											   where (selected.DT_ID == id);
    if(empty resolvedDT)
      // if the data type was not found local to the domain
      // check for a system level data type
      select one domSys related by domain->CN_DC[R4204]->C_C[R4204]
        	                                       ->CP_CP[R4608]->S_SYS[R4606];
      select any resolvedDT related by domSys->SLD_SDINP[R4402]->S_DT[R4401]
        	                                       where (selected.DT_ID == id);
      if empty resolvedDT and not_empty domSys and domSys.useGlobals
        select any pe related by domSys->G_EIS[R9100]->PE_PE[R9100]
                                                where selected.Element_ID == id;
        select one resolvedDT related by pe->S_DT[R8001]; 
      end if;
    end if;
    if(not_empty resolvedDT)
      relate resolvedDT to self across R26;
    end if;
  end if;
end if;',
	1,
	'',
	7756);
INSERT INTO O_TFR
	VALUES (7749,
	48,
	'getDimensionsCnt',
	'',
	298,
	1,
	'select many dims related by self->S_DIM[R52];
dimensions = cardinality dims;
return dimensions;
',
	1,
	'',
	7742);
INSERT INTO O_TFR
	VALUES (7756,
	48,
	'resizeDimensions',
	'',
	19,
	1,
	'// If the number of dimensions has increased then add dimensions
while (param.numDimensions > self.getDimensionsCnt())
  create object instance dim of S_DIM;
  dim.dimensionCount = self.getDimensionsCnt();
  relate dim to self across R52;
end while;

// If the number of dimensions has decreased then remove dimensions
while (param.numDimensions < self.getDimensionsCnt())
  select any dim related by self->S_DIM[R52] where (selected.dimensionCount == (self.getDimensionsCnt()-1));
  unrelate dim from self across R52;
  delete object instance dim;
end while;

// Update the specific dimension that was passed-in if its elementCount has 
// changed.
if (param.numDimensions > 0) 
  select any dim related by self->S_DIM[R52] where (selected.dimensionCount == param.dimension);
  if (dim.elementCount != param.elementCount)
    dim.elementCount = param.elementCount;
  end if;
end if;
',
	1,
	'',
	7757);
INSERT INTO O_TPARM
	VALUES (7758,
	7756,
	'dimension',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (7759,
	7756,
	'numDimensions',
	298,
	0,
	'',
	7760,
	'');
INSERT INTO O_TPARM
	VALUES (7760,
	7756,
	'elementCount',
	298,
	0,
	'',
	7758,
	'');
INSERT INTO O_TFR
	VALUES (7757,
	48,
	'moveUp',
	'',
	19,
	1,
	'::changeNotificationEnablement(enabled:false);
select one prev_attr related by self->S_SPARM[R54.''succeeds''];
select one prev_prev_attr related by prev_attr->S_SPARM[R54.''succeeds''];
select one next_attr related by self->S_SPARM[R54.''precedes''];

if ( not_empty prev_prev_attr )
  unrelate prev_attr from prev_prev_attr across R54.''succeeds'';
end if;
if ( not_empty next_attr )
  unrelate next_attr from self across R54.''succeeds'';
end if;
unrelate self from prev_attr across R54.''succeeds'';

if ( not_empty prev_prev_attr )
  relate self to prev_prev_attr across R54.''succeeds'';
end if;
// want to enable listeners at the last possible moment
if ( empty next_attr )
  ::changeNotificationEnablement(enabled:true);
end if;
relate prev_attr to self across R54.''succeeds'';
if ( not_empty next_attr )
  ::changeNotificationEnablement(enabled:true);
  relate next_attr to prev_attr across R54.''succeeds'';
end if;
',
	1,
	'',
	7761);
INSERT INTO O_TFR
	VALUES (7761,
	48,
	'moveDown',
	'',
	19,
	1,
	'::changeNotificationEnablement(enabled:false);
select one next_attr related by self->S_SPARM[R54.''precedes''];
select one prev_attr related by self->S_SPARM[R54.''succeeds''];
select one next_next_attr related by next_attr->S_SPARM[R54.''precedes''];

if ( not_empty next_next_attr )
  unrelate next_next_attr from next_attr across R54.''succeeds'';
end if;
if ( not_empty prev_attr )
  unrelate self from prev_attr across R54.''succeeds'';
end if;
unrelate next_attr from self across R54.''succeeds'';

if ( not_empty prev_attr )
  relate next_attr to prev_attr across R54.''succeeds'';
end if;
   
// want to enable listeners at the last possible moment
if ( empty next_next_attr )
  ::changeNotificationEnablement(enabled:true);
end if;
relate self to next_attr across R54.''succeeds'';
if ( not_empty next_next_attr )
  ::changeNotificationEnablement(enabled:true);
  relate next_next_attr to self across R54.''succeeds'';
end if;
',
	1,
	'',
	7762);
INSERT INTO O_TFR
	VALUES (7763,
	48,
	'actionFilter',
	'',
	316,
	1,
	'if (param.name == "can" )
  if ( param.value == "move up" )
    select one prev_attr related by self->S_SPARM[R54.''succeeds''];
    return not_empty prev_attr;
  elif ( param.value == "move down" )
    select one next_attr related by self->S_SPARM[R54.''precedes''];
    return not_empty next_attr;
  end if;
end if;
return false;
',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (7764,
	7763,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (7765,
	7763,
	'value',
	322,
	0,
	'',
	7764,
	'');
INSERT INTO O_TFR
	VALUES (7766,
	48,
	'canReferToDataType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// select the dt
select one dt related by self->S_DT[R26];
if(not_empty dt)
  select one packageableElem related by self->S_SYNC[R24]->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = not_empty package or not_empty component;

  if (isInGenericPackage)
    return packageableElem.canReferToDataType(dtID:dt.DT_ID, dtName: dt.Name);
  else
    // if the data type package is at the system
    // level we can use the data type as long as
    // this element belongs to a formal component
    select one domain related by self->S_SYNC[R24]->S_DOM[R23];
    select one dtPkg related by dt->S_DIP[R39]->S_DPK[R39];
    if(not dtPkg.isDomainLevel())
      if(domain.participatesInSystem())
        return true;
      else
        return false;
      end if;
    else
      // otherwise the DT must be in the same domain
      select one dtDomain related by dt->S_DOM[R14];
      if(dtDomain == domain)
        return true;
      end if;
    end if;
  end if;
end if;
return false;
',
	1,
	'',
	7763);
INSERT INTO O_TFR
	VALUES (7762,
	48,
	'isReferringToDefaultDataType',
	'',
	316,
	1,
	'select one dt related by self->S_DT[R26];
elementType = Util::getSimpleClassName(element:self.convertToInstance());
if(dt.Name == S_DT::getDefaultDataTypeName(elementType:elementType))
  return true;
end if;
return false;
',
	1,
	'',
	7746);
INSERT INTO O_TFR
	VALUES (7748,
	48,
	'canUseDataType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Function Parameter.canUseDataType()
select one packageableElem related by self->S_SYNC[R24]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;
if isInGenericPackage
  // Find the previously created visibility list
  select any resultSet related by package->PE_SRS[R8005] where
        selected.Name == "" and selected.Type == ElementTypeConstants::DATATYPE;
  select any dt related by resultSet->PE_VIS[R8006]->
                     PE_PE[R8002]->S_DT[R8001] where selected.DT_ID == param.id;
  if not_empty component
    // Find the previously created visibility list
    select any compResultSet related by component->PE_CRS[R8007] where
        selected.Name == "" and selected.Type == ElementTypeConstants::DATATYPE;
    select any dt related by compResultSet->PE_CVS[R8008]->
                     PE_PE[R8004]->S_DT[R8001] where selected.DT_ID == param.id;
  end if;
  if(not_empty dt)
    if(self.isAllowedType(typeName:dt.Name))
      return true;
    end if;
  end if;
  return false;
else
  select one domain related by self->S_SYNC[R24]->S_DOM[R23];
  if(domain.participatesInSystem())
    // system level check both the system
    // and the domain for the dt
    select one system related by domain->CN_DC[R4204]->C_C[R4204]->CP_CP[R4608]
                                                                 ->S_SYS[R4606];
    select any dt related by system->SLD_SDINP[R4402]->S_DT[R4401]
                                             where (selected.DT_ID == param.id);
    if empty dt and not_empty system and system.useGlobals
      select any pe related by system->G_EIS[R9100]->PE_PE[R9100]
                                          where selected.Element_ID == param.id;
      select one dt related by pe->S_DT[R8001]; 
    end if;
    if(empty dt)
      select any dt related by domain->S_DT[R14]
                                             where (selected.DT_ID == param.id);
    end if;
    if(not_empty dt)
      if(self.isAllowedType(typeName:dt.Name))
        return true;
      end if;
    end if;
  else
    // only check the domain for the dt
    select any dt related by domain->S_DT[R14] where (selected.DT_ID == param.id);
    if(not_empty dt)
      if(self.isAllowedType(typeName:dt.Name))
        return true;
      end if;
    end if;
  end if;
  return false;
end if;',
	1,
	'',
	7766);
INSERT INTO O_TPARM
	VALUES (7767,
	7748,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7768,
	48,
	'checkIntegrity',
	'',
	19,
	1,
	'/**
 *  Create an integrity issue if there are any other parameters in the same
 *  function with a matching name
 */
select one function related by self->S_SYNC[R24];
select one package related by function->PE_PE[R8001]->EP_PKG[R8000];
select one system related by package->S_SYS[R1405];
sys_id = GD::NULL_UNIQUE_ID();
if(not_empty system)
  sys_id = system.Sys_ID;
end if;
select many parameters related by function->S_SPARM[R24];
for each parameter in parameters
  if(parameter != self and parameter.Name == self.Name)
    MI_IM::createIssue(sys_id:sys_id, description:
         "Found another parameter under the same function with a " +
                                                          "matching name.",
                                      severity:Severity::Error, name:self.Name,
                                     path:function.getPath() + "::" + self.Name,
                    id:self.Sync_ID, element:self.convertToInstance());
  end if;
end for;',
	1,
	'',
	7751);
INSERT INTO O_NBATTR
	VALUES (215,
	48);
INSERT INTO O_BATTR
	VALUES (215,
	48);
INSERT INTO O_ATTR
	VALUES (215,
	48,
	0,
	'SParm_ID',
	'Full Name: Parameter Identifier',
	'',
	'SParm_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (7769,
	48);
INSERT INTO O_BATTR
	VALUES (7769,
	48);
INSERT INTO O_ATTR
	VALUES (7769,
	48,
	7770,
	'Name',
	'Full Name: Parameter Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (7771,
	48);
INSERT INTO O_BATTR
	VALUES (7771,
	48);
INSERT INTO O_ATTR
	VALUES (7771,
	48,
	7772,
	'By_Ref',
	'Full Name: By Reference Indicator
Description: Indicates whether or not this parameter is passed by reference
Data Domain: 0 = passed by value, 1 = passed by reference
enum0: By Value
enum1: By Reference
',
	'',
	'By_Ref',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (7773,
	48);
INSERT INTO O_BATTR
	VALUES (7773,
	48);
INSERT INTO O_ATTR
	VALUES (7773,
	48,
	7771,
	'Dimensions',
	'Full Name: Array Dimensions',
	'',
	'Dimensions',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (48,
	48,
	0,
	215,
	7413,
	7415,
	7414,
	7774,
	7775,
	0,
	0,
	'',
	'Function Parameter',
	'SParm_ID',
	'R54.''succeeds''');
INSERT INTO O_RATTR
	VALUES (7774,
	48,
	215,
	48,
	1,
	'SParm_ID');
INSERT INTO O_ATTR
	VALUES (7774,
	48,
	7773,
	'Previous_SParm_ID',
	'',
	'Previous_',
	'SParm_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (7776,
	48);
INSERT INTO O_BATTR
	VALUES (7776,
	48);
INSERT INTO O_ATTR
	VALUES (7776,
	48,
	7774,
	'Descrip',
	'Full Name: Description
Description:  A textual description of the function parameter.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (48,
	32,
	0,
	156,
	7315,
	7316,
	7317,
	7772,
	7777,
	0,
	0,
	'',
	'Data Type',
	'DT_ID',
	'R26.''is typed by ''');
INSERT INTO O_RATTR
	VALUES (7772,
	48,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (7772,
	48,
	7769,
	'DT_ID',
	'',
	'',
	'Element_ID',
	2,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (48,
	8,
	0,
	11,
	7312,
	7314,
	7313,
	7770,
	7778,
	0,
	0,
	'',
	'Function',
	'Sync_ID',
	'R24.''is defined for''');
INSERT INTO O_RATTR
	VALUES (7770,
	48,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (7770,
	48,
	215,
	'Sync_ID',
	'',
	'',
	'Sync_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	48);
INSERT INTO O_OIDA
	VALUES (215,
	48,
	0,
	'SParm_ID');
INSERT INTO O_ID
	VALUES (1,
	48);
INSERT INTO O_ID
	VALUES (2,
	48);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (7331,
	'Function Package in Package',
	21,
	'S_FPIP',
	'Function Package in Package represents Function Packages nested within other Function Packages.',
	7221);
INSERT INTO O_REF
	VALUES (7331,
	3523,
	0,
	3566,
	7329,
	7332,
	7330,
	7335,
	7779,
	0,
	0,
	'',
	'Function Package',
	'FunPack_ID',
	'R30');
INSERT INTO O_RATTR
	VALUES (7335,
	7331,
	3566,
	3523,
	1,
	'FunPack_ID');
INSERT INTO O_ATTR
	VALUES (7335,
	7331,
	0,
	'FunPack_ID',
	'',
	'',
	'FunPack_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	7331);
INSERT INTO O_OIDA
	VALUES (7335,
	7331,
	0,
	'FunPack_ID');
INSERT INTO O_ID
	VALUES (1,
	7331);
INSERT INTO O_ID
	VALUES (2,
	7331);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3523,
	'Function Package',
	19,
	'S_FPK',
	'Function Package represents a collection of domain functions.',
	7221);
INSERT INTO O_TFR
	VALUES (7780,
	3523,
	'initialize',
	'The initialization operation for this class.  ',
	19,
	1,
	'self.Name = ::getUniqueInitialName( 
    instance: self.convertToInstance(), 
    candidateName: "Unnamed Function Package");',
	1,
	'',
	7781);
INSERT INTO O_TFR
	VALUES (7782,
	3523,
	'dispose',
	'The dispose operation for this class.  It also disposes the associated Function Package in Package.',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one dom related by self->S_DOM[R29];
if (not_empty dom)
  unrelate dom from self across R29;
end if;
select many fns related by self->S_SYNC[R31];
for each fn in fns
  fn.dispose();
end for;
select one fpip related by self->S_FPIP[R30];
if (not_empty fpip)
  select many pkgs related by fpip->S_FPK[R32];
  for each pkg in pkgs
   unrelate fpip from pkg across R32;
    pkg.dispose();
  end for;
  unrelate self from fpip across R30;
  delete object instance fpip;
end if;
// for each sequence participant that this function
// package is associated with
select many fpps related by self->SQ_FPP[R932];
for each fpp in fpps
  fpp.unformalize();
end for;
if(empty dom)
  select one dom related by self->PL_FPID[R301]->S_DOM[R301];
end if;
select one fpid related by self->PL_FPID[R301];
if(not_empty fpid)
  unrelate self from dom across R301 using fpid;
  delete object instance fpid;
end if;
delete object instance self;',
	1,
	'',
	7783);
INSERT INTO O_TFR
	VALUES (7784,
	3523,
	'newFunction',
	'Create a new Function in this Function Package.',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one dom related by self->S_DOM[R29];
if (empty dom)
  select one rootPkg related by self->S_FPIP[R32]->S_FPK[R30];
  while (empty dom)
    select one dom related by rootPkg->S_DOM[R29];
    select one rootPkg related by rootPkg->S_FPIP[R32]->S_FPK[R30];
  end while;
end if;
create object instance fn of S_SYNC;
relate fn to dom across R23;
create object instance fip of S_FIP;
relate self to fn across R31 using fip;
fn.initialize();',
	1,
	'',
	7780);
INSERT INTO O_TFR
	VALUES (7785,
	3523,
	'newFunctionPackage',
	'Create a new Function Package inside this Function Package.
',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one helper related by self->S_FPIP[R30];
if (empty helper)
  create object instance helper of S_FPIP;
  relate self to helper across R30;
end if;
create object instance newFPkg of S_FPK;
relate helper to newFPkg across R32;
create object instance fPkgInDomain of PL_FPID;
select one domain related by self->PL_FPID[R301]->S_DOM[R301];
relate domain to newFPkg across R301 using fPkgInDomain;
newFPkg.initialize();',
	1,
	'',
	7784);
INSERT INTO O_TFR
	VALUES (7786,
	3523,
	'get_style',
	'',
	784,
	1,
	'return Style::Folder;',
	1,
	'',
	7787);
INSERT INTO O_TFR
	VALUES (7781,
	3523,
	'get_text_style',
	'',
	784,
	1,
	'return Style::None;',
	1,
	'',
	7786);
INSERT INTO O_TPARM
	VALUES (7788,
	7781,
	'comp_num',
	298,
	0,
	'',
	7789,
	'');
INSERT INTO O_TPARM
	VALUES (7790,
	7781,
	'ent_num',
	298,
	0,
	'',
	7788,
	'');
INSERT INTO O_TPARM
	VALUES (7789,
	7781,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7791,
	3523,
	'get_compartments',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	7792);
INSERT INTO O_TFR
	VALUES (7793,
	3523,
	'get_entries',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	7791);
INSERT INTO O_TPARM
	VALUES (7794,
	7793,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7792,
	3523,
	'get_compartment_text',
	'',
	322,
	1,
	'result = "";
if (param.at == Justification::Center_in_X)
  result = "function";
elif (param.at == Justification::Center)
  result = self.Name;
end if;
return result;',
	1,
	'',
	7795);
INSERT INTO O_TPARM
	VALUES (7796,
	7792,
	'comp_num',
	298,
	0,
	'',
	7797,
	'');
INSERT INTO O_TPARM
	VALUES (7798,
	7792,
	'ent_num',
	298,
	0,
	'',
	7796,
	'');
INSERT INTO O_TPARM
	VALUES (7797,
	7792,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7787,
	3523,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.FunPack_ID;',
	1,
	'',
	7793);
INSERT INTO O_TFR
	VALUES (7795,
	3523,
	'getPath',
	'',
	322,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one domain related by self->PL_FPID[R301]->S_DOM[R301];
result = self.Name;
select one fpip related by self->S_FPIP[R32]->S_FPK[R30];
while(not_empty fpip)
  result = fpip.Name + "::" + result;
  select one fpip related by fpip->S_FPIP[R32]->S_FPK[R30];
end while;
return domain.Name + "::" + result;',
	1,
	'',
	7782);
INSERT INTO O_TFR
	VALUES (7783,
	3523,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'// just return this instance as an Object
return this;',
	0,
	'',
	7799);
INSERT INTO O_TFR
	VALUES (7800,
	3523,
	'pasteFunctionPackage',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any pkg from instances of S_FPK where (selected.FunPack_ID == param.id);
if(not_empty pkg)
  // guarantee a unique name for the pasted package
  pkg.Name = ::getUniqueInitialNameInParent(instance:pkg.convertToInstance(),
  						name:pkg.Name, parent:self.convertToInstance());
  // unrelate from previous domain if any
  select one dom related by pkg->S_DOM[R29];
  if(not_empty dom)
    unrelate pkg from dom across R29;
  end if;
  
  // create the nesting classes
  select one funpkInpk related by pkg->S_FPIP[R32];
  if(not_empty funpkInpk)
    unrelate pkg from funpkInpk across R32;
  end if;
  
  select one destFunpkInpk related by self->S_FPIP[R30];
  if(empty destFunpkInpk)
    create object instance destFunpkInpk of S_FPIP;
    relate self to destFunpkInpk across R30;  
  end if;
  
  relate destFunpkInpk to pkg across R32;

  select one domain related by self->PL_FPID[R301]->S_DOM[R301];
  // now setup the links to the domain
  select one fpid related by pkg->PL_FPID[R301];
  if(not_empty fpid)
    select one prevDomain related by fpid->S_DOM[R301];
    unrelate pkg from prevDomain across R301 using fpid;
    relate pkg to domain across R301 using fpid;
  else
    create object instance fpid of PL_FPID;
    relate pkg to domain across R301 using fpid;
  end if;
  
  // do the same for any child packages
  pkg.associateChildPackagesToDomain(dom_id:domain.Dom_ID);
  
  // setup R23
  select many functions related by pkg->S_SYNC[R31];
  for each function in functions
    select one prevDomain related by function->S_DOM[R23];
    if(not_empty prevDomain)
      unrelate function from prevDomain across R23;
    end if;
    relate function to domain across R23;
  end for;
  pkg.associateChildPackageFunctionsToDomain(dom_id:domain.Dom_ID);
end if;',
	1,
	'',
	7785);
INSERT INTO O_TPARM
	VALUES (7801,
	7800,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7799,
	3523,
	'associateChildPackagesToDomain',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
/*
 *  For every child package, associate it to the given domain
 */
select any domain from instances of S_DOM where (selected.Dom_ID == param.dom_id);
if(not_empty domain)
  select many childPKGs related by self->S_FPIP[R30]->S_FPK[R32];
  for each child in childPKGs
    select one existingFPID related by child->PL_FPID[R301];
    select one existingDom related by existingFPID->S_DOM[R301];
    unrelate child from existingDom across R301 using existingFPID;
    relate child to domain across R301 using existingFPID;
    child.associateChildPackagesToDomain(dom_id:param.dom_id);
  end for;
end if;',
	1,
	'',
	7802);
INSERT INTO O_TPARM
	VALUES (7803,
	7799,
	'dom_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7802,
	3523,
	'associateChildPackageFunctionsToDomain',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
/*
 * Associate all child package''s functions with the given domain.
 */
select any domain from instances of S_DOM where (selected.Dom_ID == param.dom_id);
if(not_empty domain)
  select many childPkgs related by self->S_FPIP[R30]->S_FPK[R32];
  for each child in childPkgs
    select many functions related by child->S_FIP[R31]->S_SYNC[R31];
    for each function in functions
      select one prevDomain related by function->S_DOM[R23];
      unrelate function from prevDomain across R23;
      relate function to domain across R23;
    end for;
    child.associateChildPackageFunctionsToDomain(dom_id:param.dom_id);
  end for;
end if;
',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (7804,
	7802,
	'dom_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7805,
	3523,
	'getFunctionPckgCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many functionPckgs related by self->S_FPIP[R30]->S_FPK[R32];
return cardinality functionPckgs;',
	1,
	'',
	7800);
INSERT INTO O_TFR
	VALUES (7806,
	3523,
	'getFunctionPckgId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many functionPckgs related by self->S_FPIP[R30]->S_FPK[R32];
// We''re preincrementing the index
count = -1;
for each functionPckg in functionPckgs
  if (not_empty functionPckg)
      count = count+1;
  end if;
  if (count == param.index)
      return functionPckg.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7805);
INSERT INTO O_TPARM
	VALUES (7807,
	7806,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7808,
	3523,
	'pasteFunction',
	'',
	19,
	1,
	'select any function from instances of S_SYNC
                                           where (selected.Sync_ID == param.id);
if(not_empty function)
  select one existing related by function->S_FIP[R31]->S_FPK[R31];
  if(not_empty existing)
    select one fip related by function->S_FIP[R31];
    if(not_empty fip)
      unrelate function from existing across R31 using fip;
    end if;
  end if;
select one dom related by self->S_DOM[R29];
if (empty dom)
  select one rootPkg related by self->S_FPIP[R32]->S_FPK[R30];
  while (empty dom)
    select one dom related by rootPkg->S_DOM[R29];
    select one rootPkg related by rootPkg->S_FPIP[R32]->S_FPK[R30];
  end while;
end if;
  create object instance fip of S_FIP;
  relate function to self across R31 using fip;
  relate function to dom across R23;  
  function.Name = ::getUniqueInitialNameInParent(instance:function.convertToInstance(),
  						name:function.Name, parent:self.convertToInstance());
end if;',
	1,
	'',
	7806);
INSERT INTO O_TPARM
	VALUES (7809,
	7808,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_NBATTR
	VALUES (3566,
	3523);
INSERT INTO O_BATTR
	VALUES (3566,
	3523);
INSERT INTO O_ATTR
	VALUES (3566,
	3523,
	0,
	'FunPack_ID',
	'Full Name: Function Package identifier',
	'',
	'FunPack_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (7810,
	3523);
INSERT INTO O_BATTR
	VALUES (7810,
	3523);
INSERT INTO O_ATTR
	VALUES (7810,
	3523,
	3566,
	'Name',
	'Full Name: Function Package Name
Description: A name  that represents a package of functions.',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (3523,
	699,
	0,
	712,
	7321,
	7323,
	7322,
	7811,
	7812,
	0,
	0,
	'',
	'Domain',
	'Dom_ID',
	'R29');
INSERT INTO O_RATTR
	VALUES (7811,
	3523,
	712,
	699,
	1,
	'Dom_ID');
INSERT INTO O_ATTR
	VALUES (7811,
	3523,
	7810,
	'Dom_ID',
	'',
	'',
	'Dom_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (3523,
	7331,
	0,
	7335,
	7333,
	7336,
	7334,
	7813,
	7814,
	0,
	0,
	'',
	'Function Package in Package',
	'FunPack_ID',
	'R32');
INSERT INTO O_RATTR
	VALUES (7813,
	3523,
	3566,
	3523,
	1,
	'FunPack_ID');
INSERT INTO O_ATTR
	VALUES (7813,
	3523,
	7811,
	'Parent_FunPack_ID',
	'',
	'Parent_',
	'FunPack_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3523);
INSERT INTO O_OIDA
	VALUES (3566,
	3523,
	0,
	'FunPack_ID');
INSERT INTO O_ID
	VALUES (1,
	3523);
INSERT INTO O_ID
	VALUES (2,
	3523);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (7327,
	'Function in Package',
	20,
	'S_FIP',
	'Function in Package represents the functions contained within a particular package.',
	7221);
INSERT INTO O_REF
	VALUES (7327,
	3523,
	0,
	3566,
	7324,
	7328,
	7325,
	7815,
	7816,
	0,
	0,
	'',
	'Function Package',
	'FunPack_ID',
	'R31');
INSERT INTO O_RATTR
	VALUES (7815,
	7327,
	3566,
	3523,
	1,
	'FunPack_ID');
INSERT INTO O_ATTR
	VALUES (7815,
	7327,
	0,
	'FunPack_ID',
	'',
	'',
	'FunPack_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (7327,
	8,
	0,
	11,
	7324,
	7328,
	7326,
	7817,
	7818,
	0,
	0,
	'',
	'Function',
	'Sync_ID',
	'R31');
INSERT INTO O_RATTR
	VALUES (7817,
	7327,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (7817,
	7327,
	7815,
	'Sync_ID',
	'',
	'',
	'Sync_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	7327);
INSERT INTO O_OIDA
	VALUES (7815,
	7327,
	0,
	'FunPack_ID');
INSERT INTO O_OIDA
	VALUES (7817,
	7327,
	0,
	'Sync_ID');
INSERT INTO O_ID
	VALUES (1,
	7327);
INSERT INTO O_ID
	VALUES (2,
	7327);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (8,
	'Function',
	16,
	'S_SYNC',
	'A function (S_SYNC) is a method associated with the domain (S_DOM).  It can be thought of as a global function within the domain.  Functions can be synchronously called from action specifications or used to provide a definition for bridge method  in another domain.',
	7221);
INSERT INTO O_TFR
	VALUES (7819,
	8,
	'dispose',
	'The dispose operation for this class.  It also disposes of the associated Function in Package.',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Domain Subsystem
select one pe related by self->PE_PE[R8001];
if(not_empty pe)
  // PE_PE.dispose() will call back into this function at which time the
  // rest of the activity will execute.
  pe.dispose();
  return;
end if;
select many fparms related by self->S_SPARM[R24];
for each fparm in fparms
  fparm.dispose();
end for;
select one dt related by self->S_DT[R25];
unrelate self from dt across R25;
select one fip related by self->S_FIP[R31];
if (not_empty fip)
  select one fPkg related by fip->S_FPK[R31];
  unrelate self from fPkg across R31 using fip;
  delete object instance fip;
end if;
select one dom related by self->S_DOM[R23];
if (not_empty dom)
  unrelate self from dom across R23;
end if;
//
//Body Subsystem
select one body related by self->ACT_FNB[R695]->ACT_ACT[R698];
if (not_empty body)
  body.dispose();
end if;
//
// Invocation Subsystem
select many invs related by self->ACT_FNC[R675];
for each inv in invs
  unrelate self from inv across R675;
end for;
//
// Value Subsystem
select many fvs related by self->V_FNV[R827];
for each fv in fvs
  unrelate self from fv across R827;
end for;
//
// Wiring Subsystem
select many aws related by self->S_AW[R3201];
for each aw in aws
  unrelate self from aw across R3201;
end for;
// for each message that this function
// is associated with
select many fms related by self->MSG_F[R1010];
for each fm in fms
  select one message related by fm->MSG_SM[R1020];
  message.unformalize();
end for;
select many dims related by self->S_DIM[R51];
for each dim in dims
  unrelate self from dim across R51;
  delete object instance dim;
end for;
//
// Finally delete self
delete object instance self;',
	1,
	'',
	7820);
INSERT INTO O_TFR
	VALUES (7821,
	8,
	'initialize',
	'The initialization operation for this class.  Set the name and the return value to defaults.',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one packageableElem related by self->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;

if (isInGenericPackage)
   if (not_empty package)
     select one system related by package->S_SYS[R1405];
     def_dt_id = GD::NULL_UNIQUE_ID();
     if not_empty system
       def_dt_id = system.getCoreTypeId(name:"void");
     end if;
     select any pe from instances of PE_PE where selected.Element_ID == def_dt_id;
     select one def_dt related by pe->S_DT[R8001]; 
     if (not_empty def_dt)
        relate self to def_dt across R25;
     end if;
   else
     rootCompIdInPkg = component.getRootComponentId();
     select any rootComponent from instances of C_C where (selected.Id == rootCompIdInPkg);
     select one system related by rootComponent->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405];
     def_dt_id = GD::NULL_UNIQUE_ID();
     if not_empty system
       def_dt_id = system.getCoreTypeId(name:"void");
     end if;
     select any pe from instances of PE_PE where selected.Element_ID == def_dt_id;
     select one def_dt related by pe->S_DT[R8001]; 
     if (not_empty def_dt)
        relate self to def_dt across R25;
     end if;
   end if;
else
  select any dom from instances of S_DOM;
  select one component related by dom->CN_DC[R4204]->C_C[R4204];
  if(not_empty component)
    // this bridge is part of a formal component
    // get the default data type from the system
    select one system related by component->CP_CP[R4608]->S_SYS[R4606];
    def_dt_id = GD::NULL_UNIQUE_ID();
    if not_empty system
      def_dt_id = system.getCoreTypeId(name:"void");
    end if;
    select any pe from instances of PE_PE where selected.Element_ID == def_dt_id;
    select one def_dt related by pe->S_DT[R8001]; 
    if(not_empty def_dt)
      relate self to def_dt across R25;
    end if;
  else
    // this bridge is part of a stand alone domain
    // get the default data type from the domain
    select any def_dt related by dom->S_DT[R14] where selected.Name == "void";
    if(not_empty def_dt)
      relate self to def_dt across R25;
    end if;
  end if;
end if;
name = ::getUniqueInitialName( 
    instance: self.convertToInstance(), 
	candidateName: "Unnamed Function");
success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:true);    
if ( success!="") 
 self.Name=success;
else 
 self.dispose();
end if; 	
self.Suc_Pars = ParseStatus::parseInitial;
',
	1,
	'',
	7822);
INSERT INTO O_TFR
	VALUES (7823,
	8,
	'newParameter',
	'Create a new parameter for this function.
',
	19,
	1,
	'create object instance parm of S_SPARM;
relate self to parm across R24;
parm.initialize();
self.createMessageArgumentsForParameter(id:parm.SParm_ID);',
	1,
	'',
	7824);
INSERT INTO O_TFR
	VALUES (7825,
	8,
	'isAllowedReturnType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Function.isAllowedReturnType()
select one packageableElem related by self->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;
if isInGenericPackage
  if self.getReturnDimensionsCnt() != 0 and param.typeName == "void"
    return false;
  else
    return packageableElem.isAllowedType(isReturnType:true,
                                                       typeName:param.typeName);
  end if;
else
  if self.getReturnDimensionsCnt() != 0 and param.typeName == "void"
    return false;
  else
    // if this element is at the system level check the
    // system level data types, otherwise check the 
    // domain
    select one domain related by self->S_DOM[R23];
    if(not_empty domain)
      select one system related by domain->S_SYS[R28];
      if(not_empty system)
        return S_DT::isAllowedReturnType( typeName: param.typeName,
                                   			dom_id: domain.get_ooa_id() );
      else
        // first check the domain level
        result = S_DT::isAllowedReturnType( typeName: param.typeName,
                                   			dom_id: domain.get_ooa_id() );
        if(not result)
          // if nothing valid check the system level
          select one system related by domain->CN_DC[R4204]->C_C[R4204]
      											   ->CP_CP[R4608]->S_SYS[R4606];
          return Util::isAllowedReturnType(system:system.convertToInstance(),
                                                       typeName:param.typeName);
        else
          return result;
        end if;
      end if;
    end if;
  end if;
  return false;
end if;',
	1,
	'',
	7826);
INSERT INTO O_TPARM
	VALUES (7827,
	7825,
	'typeName',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7820,
	8,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'// just return this instance as an Object
return this;',
	0,
	'',
	7828);
INSERT INTO O_TFR
	VALUES (7822,
	8,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Sync_ID;',
	1,
	'',
	7829);
INSERT INTO O_TFR
	VALUES (7830,
	8,
	'resolveDatatype',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one dtProxy related by self->S_DT[R25];
if(not_empty dtProxy and not Util::isProxy(element:self.convertToInstance()))
  name = dtProxy.Name;
  unrelate dtProxy from self across R25;
  
  select one packageableElem related by self->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = not_empty package or not_empty component;
  if isInGenericPackage
    id = packageableElem.resolveDataTypeRelativeToSelf(default_name:"void",
                                                            expected_name:name);                                                          
    select any resolvedDt related by package->PE_VIS[R8002]->
                         PE_PE[R8002]->S_DT[R8001] where selected.DT_ID == id;
    if (empty resolvedDt)
      select any resolvedDt related by component->PE_CVS[R8004]->
                       PE_PE[R8004]->S_DT[R8001] where selected.DT_ID == id;
    end if;	
    if not_empty resolvedDt
      relate resolvedDt to self across R25;
    end if;
  else
    select one domain related by self->S_FIP[R31]->S_FPK[R31]->PL_FPID[R301]
                                                                  ->S_DOM[R301];
    id = domain.resolveDataTypeRelativeToSelf(default_name:"void",
    													    expected_name:name);
    select any resolvedDT related by domain->S_DT[R14]
    											   where (selected.DT_ID == id);
    if(empty resolvedDT)
      // if the data type was not found local to the domain
      // check for a system level data type
      select one domSys related by domain->CN_DC[R4204]->C_C[R4204]
        	                                       ->CP_CP[R4608]->S_SYS[R4606];
      select any resolvedDT related by domSys->SLD_SDINP[R4402]->S_DT[R4401]
        	                                       where (selected.DT_ID == id);
      if empty resolvedDT and not_empty domSys and domSys.useGlobals
        select any pe related by domSys->G_EIS[R9100]->PE_PE[R9100]
                                                where selected.Element_ID == id;
        select one resolvedDT related by pe->S_DT[R8001]; 
      end if;
    end if;
    if(not_empty resolvedDT)
      relate resolvedDT to self across R25;
    end if;
  end if;
end if;',
	1,
	'',
	7831);
INSERT INTO O_TFR
	VALUES (7824,
	8,
	'isVoid',
	'',
	316,
	1,
	'select one dt related by self->S_DT[R25];
return dt.Name == "void";',
	1,
	'',
	7832);
INSERT INTO O_TFR
	VALUES (7829,
	8,
	'getReturnDimensionsCnt',
	'',
	298,
	1,
	'select many dims related by self->S_DIM[R51];
dimensions = cardinality dims;
return dimensions;
',
	1,
	'',
	7819);
INSERT INTO O_TFR
	VALUES (7831,
	8,
	'resizeReturn_Dimensions',
	'',
	19,
	1,
	'// If the number of dimensions has increased then add dimensions
while (param.numDimensions > self.getReturnDimensionsCnt())
  create object instance dim of S_DIM;
  dim.dimensionCount = self.getReturnDimensionsCnt();
  relate dim to self across R51;
end while;

// If the number of dimensions has decreased then remove dimensions
while (param.numDimensions < self.getReturnDimensionsCnt())
  select any dim related by self->S_DIM[R51] where (selected.dimensionCount == (self.getReturnDimensionsCnt()-1));
  unrelate dim from self across R51;
  delete object instance dim;
end while;

// Update the specific dimension that was passed-in if its elementCount has 
// changed.
if (param.numDimensions > 0) 
  select any dim related by self->S_DIM[R51] where (selected.dimensionCount == param.dimension);
  if (dim.elementCount != param.elementCount)
    dim.elementCount = param.elementCount;
  end if;
end if;
',
	1,
	'',
	7823);
INSERT INTO O_TPARM
	VALUES (7833,
	7831,
	'dimension',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (7834,
	7831,
	'elementCount',
	298,
	0,
	'',
	7833,
	'');
INSERT INTO O_TPARM
	VALUES (7835,
	7831,
	'numDimensions',
	298,
	0,
	'',
	7834,
	'');
INSERT INTO O_TFR
	VALUES (7826,
	8,
	'initializeOrder',
	'',
	19,
	1,
	'// Alpha-sort the S_SPARM elements if they have not yet been ordered
select many peers related by self->S_SPARM[R24];
if (cardinality peers > 1)
    initialOrderingCheckPerformed = false;
	select any head related by self->S_SPARM[R24] where (selected.Sync_ID == GD::NULL_UNIQUE_ID());
	endOfList = head;
	loopCnt = 0;
	for each peer in peers
	  if ( not initialOrderingCheckPerformed)
	    select one predecessor related by peer->S_SPARM[R54.''precedes''];
	    select one successor related by peer->S_SPARM[R54.''succeeds''];
	    initialOrderingCheckPerformed = true;
	    if (not_empty  predecessor or not_empty  successor)
	      // Already ordered
	      break;
	    end if;
	    head = peer;
	    endOfList = peer;
	  end if;
	  
      if (loopCnt == 1)
        if (peer.Name < head.Name)
          relate peer to head across R54.''precedes'';
          endOfList = peer;
        else
          relate head to peer across R54.''precedes'';
          head = peer;
        end if;
      elif (loopCnt > 1)
        insertPoint = head;
        select one next related by head->S_SPARM[R54.''succeeds''];
        while (not_empty next)
          if (next.Name < peer.Name)
            break;
          else
            insertPoint = next;          
            select one next related by next->S_SPARM[R54.''succeeds''];
          end if;
        end while;
        
        if (empty next)
          // New end of list
          relate peer to endOfList across R54.''precedes'';   
          endOfList = peer;       
        else
          if ((insertPoint == head) and (peer.Name > head.Name))
            // New head
            relate head to peer across R54.''precedes'';
            head = peer;
          else
            unrelate next from insertPoint across R54.''precedes'';
            relate peer to insertPoint across R54.''precedes'';
            relate next to peer across R54.''precedes'';
          end if;          
        end if;
      end if;
      
      loopCnt = loopCnt + 1;
	end for;
end if;',
	1,
	'',
	7821);
INSERT INTO O_TFR
	VALUES (7828,
	8,
	'canReferToDataType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// select the dt
select one dt related by self->S_DT[R25];
if(not_empty dt)
  select one packageableElem related by self->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = not_empty package or not_empty component;

  if (isInGenericPackage)
    return packageableElem.canReferToDataType(dtID:dt.DT_ID, dtName: dt.Name);
  else
    // if the data type package is at the system
    // level we can use the data type as long as
    // this element belongs to a formal component
    select one domain related by self->S_DOM[R23];
    select one dtPkg related by dt->S_DIP[R39]->S_DPK[R39];
    if(not dtPkg.isDomainLevel())
      if(domain.participatesInSystem())
        return true;
      else
        return false;
      end if;
    else
      // otherwise the DT must be in the same domain
      select one dtDomain related by dt->S_DOM[R14];
      if(dtDomain == domain)
        return true;
      end if;
     end if;
  end if;
end if;
return false;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (7832,
	8,
	'isReferringToDefaultDataType',
	'',
	316,
	1,
	'select one dt related by self->S_DT[R25];
elementType = Util::getSimpleClassName(element:self.convertToInstance());
if(dt.Name == S_DT::getDefaultDataTypeName(elementType:elementType))
  return true;
end if;
return false;
',
	1,
	'',
	7825);
INSERT INTO O_TFR
	VALUES (7836,
	8,
	'getContainingComponentId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one domain related by self->S_DOM[R23];
isInGenericPackage = empty domain;
if isInGenericPackage
  select one package related by self->PE_PE[R8001]->EP_PKG[R8000];
  select one component related by self->PE_PE[R8001]->C_C[R8003];
  if not_empty package
    return package.getContainingComponentId();
  end if;
  if not_empty component
    return component.Id;
  end if;
  USER::logError(msg:"Function has no parent in Function.getContainingComponentId()",path:self.getPath());
  return GD::NULL_UNIQUE_ID();
end if;
return domain.getContainingComponentId();',
	1,
	'',
	7830);
INSERT INTO O_TFR
	VALUES (7837,
	8,
	'canUseDataType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Function.canUseDataType()
select one packageableElem related by self->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;
if isInGenericPackage
  // Find the previously created visibility list
  select any resultSet related by package->PE_SRS[R8005] where
        selected.Name == "" and selected.Type == ElementTypeConstants::DATATYPE;
  select any dt related by resultSet->PE_VIS[R8006]->
                     PE_PE[R8002]->S_DT[R8001] where selected.DT_ID == param.id;
  if not_empty component
    // Find the previously created visibility list
    select any compResultSet related by component->PE_CRS[R8007] where
        selected.Name == "" and selected.Type == ElementTypeConstants::DATATYPE;
    select any dt related by compResultSet->PE_CVS[R8008]->
                     PE_PE[R8004]->S_DT[R8001] where selected.DT_ID == param.id;
  end if;
  if(not_empty dt)
    if(self.isAllowedReturnType(typeName:dt.Name))
      return true;
    end if;
  end if;
  return false;
else
  select one domain related by self->S_DOM[R23];
  if(domain.participatesInSystem())
    // system level check both the system
    // and the domain for the dt
    select one system related by domain->CN_DC[R4204]->C_C[R4204]->CP_CP[R4608]
                                                                 ->S_SYS[R4606];
    select any dt related by system->SLD_SDINP[R4402]->S_DT[R4401]
                                             where (selected.DT_ID == param.id);
    if empty dt and not_empty system and system.useGlobals
      select any pe related by system->G_EIS[R9100]->PE_PE[R9100]
                                          where selected.Element_ID == param.id;
      select one dt related by pe->S_DT[R8001]; 
    end if;
    if(empty dt)
      select any dt related by domain->S_DT[R14]
                                             where (selected.DT_ID == param.id);
    end if;
    if(not_empty dt)
      if(self.isAllowedReturnType(typeName:dt.Name))
        return true;
      end if;
    end if;
  else
    // only check the domain for the dt
    select any dt related by domain->S_DT[R14] where (selected.DT_ID == param.id);
    if(not_empty dt)
      if(self.isAllowedReturnType(typeName:dt.Name))
        return true;
      end if;
    end if;
  end if;
  return false;
end if;',
	1,
	'',
	7836);
INSERT INTO O_TPARM
	VALUES (7838,
	7837,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7839,
	8,
	'getContainerId',
	'',
	296,
	1,
	'// Function.getContainerId()
select one component related by self->PE_PE[R8001]->C_C[R8003];
if not_empty component
  return component.Id;
else
  select one package related by self->PE_PE[R8001]->EP_PKG[R8000];
  if not_empty package
    return package.Package_ID;
  end if;
end if;
return GD::NULL_UNIQUE_ID();
',
	1,
	'',
	7837);
INSERT INTO O_TFR
	VALUES (7840,
	8,
	'pasteFunctionParameter',
	'',
	19,
	1,
	'select any parm from instances of S_SPARM
                                          where (selected.SParm_ID == param.id);
if(not_empty parm)
  select one existing related by parm->S_SYNC[R24];
  if(not_empty existing)
    unrelate existing from parm across R24;
  end if;
  relate parm to self across R24;  
  parm.Name = ::getUniqueInitialNameInParent(instance:parm.convertToInstance(),
  						name:parm.Name, parent:self.convertToInstance());
  self.addParameterToOrder(id:parm.SParm_ID);
  self.createMessageArgumentsForParameter(id:parm.SParm_ID);
end if;',
	1,
	'',
	7839);
INSERT INTO O_TPARM
	VALUES (7841,
	7840,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7842,
	8,
	'addParameterToOrder',
	'',
	19,
	1,
	'select any parameter from instances of S_SPARM
                                          where (selected.SParm_ID == param.id);
if(not_empty parameter)
  ::changeNotificationEnablement(enabled:false);
  select many peers related by self->S_SPARM[R24];
  for each peer in peers
    if (peer != parameter)
      select one predecessor related by peer->S_SPARM[R54.''precedes''];
      if (empty predecessor)
        relate parameter to peer across R54.''succeeds'';
      end if;
    end if;
  end for;
  ::changeNotificationEnablement(enabled:true);
end if;
',
	1,
	'',
	7840);
INSERT INTO O_TPARM
	VALUES (7843,
	7842,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7844,
	8,
	'createMessageArgumentsForParameter',
	'',
	19,
	1,
	'select any parameter from instances of S_SPARM
                                          where (selected.SParm_ID == param.id);
if(not_empty parameter)
  // for each message associated with this function
  // create a message argument
  select many messages related by self->MSG_F[R1010]->MSG_SM[R1020]->MSG_M[R1018];
  for each message in messages
    create object instance arg of MSG_A;
    create object instance fa of MSG_FA;
    relate fa to parameter across R1016;
    relate fa to arg across R1013;
    relate message to arg across R1001;  
  end for;
end if;',
	1,
	'',
	7842);
INSERT INTO O_TPARM
	VALUES (7845,
	7844,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7846,
	8,
	'getPath',
	'',
	322,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one packageableElem related by self->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;
result="";
if (isInGenericPackage)
  if (not_empty package)
    result=package.getPath(path:self.Name);
  else
    result=component.getPath(path:self.Name, includeSelf:true);
  end if;
else
  select one domain related by self->S_FPK[R31]->S_DOM[R29];
  select one fnpkg related by self->S_FPK[R31];
  result = fnpkg.Name;
  select one fpip related by fnpkg->S_FPIP[R32]->S_FPK[R30];
  while(not_empty fpip)
    result = fpip.Name + "::" + result;
    select one epip related by fpip->S_FPIP[R32]->S_FPK[R30];
  end while;
  result=domain.Name + "::" + result + "::" + self.Name;
end if;
return result;',
	1,
	'',
	7844);
INSERT INTO O_TFR
	VALUES (7847,
	8,
	'checkIntegrity',
	'',
	19,
	1,
	'/**
 *  Create integrity issues if there are any other functions with a
 *  matching signature
 */
select one package related by self->PE_PE[R8001]->EP_PKG[R8000];
select one system related by package->S_SYS[R1405];
sys_id = GD::NULL_UNIQUE_ID();
if(not_empty system)
  sys_id = system.Sys_ID;
end if;
select many functions related by package->PE_PE[R8000]->S_SYNC[R8001];
for each function in functions
  if(function != self and function.getSignature() == self.getSignature())
    MI_IM::createIssue(sys_id:sys_id, description:
               "Found another function under the same package with a " +
                                                          "matching signature."
          + GD::newline() + GD::newline() + "Signature: " + self.getSignature(),
                                       severity:Severity::Error, name:self.Name,
                           path:self.getPath(),
                             id:self.Sync_ID, element:self.convertToInstance());
  end if;
end for;',
	1,
	'',
	7846);
INSERT INTO O_TFR
	VALUES (7848,
	8,
	'getSignature',
	'',
	322,
	1,
	'/**
 *  Return a string representation of this functions signature
 */
signature = self.Name;
count = 0;
select many parameters related by self->S_SPARM[R24];
paramLength = cardinality parameters;
if(paramLength > 0)
  signature = signature + "(";
end if;
for each parameter in parameters
  select one type related by parameter->S_DT[R26];
  if(count > 0 and count != paramLength - 1)
    signature = signature + ", ";
  end if;
  signature = signature + type.Name;
  count = count + 1;
end for;
if(paramLength > 0)
  signature = signature + ")";
end if;
return signature;',
	1,
	'',
	7847);
INSERT INTO O_REF
	VALUES (8,
	699,
	0,
	712,
	7306,
	7307,
	7308,
	7849,
	7850,
	0,
	0,
	'',
	'Domain',
	'Dom_ID',
	'R23');
INSERT INTO O_RATTR
	VALUES (7849,
	8,
	712,
	699,
	1,
	'Dom_ID');
INSERT INTO O_ATTR
	VALUES (7849,
	8,
	11,
	'Dom_ID',
	'',
	'',
	'Dom_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (7851,
	8);
INSERT INTO O_BATTR
	VALUES (7851,
	8);
INSERT INTO O_ATTR
	VALUES (7851,
	8,
	7849,
	'Name',
	'Full Name: Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (7852,
	8);
INSERT INTO O_BATTR
	VALUES (7852,
	8);
INSERT INTO O_ATTR
	VALUES (7852,
	8,
	7851,
	'Descrip',
	'Full Name: Description',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (7853,
	8,
	'self.Action_Semantics = ::convertRelocatableTags(in:self.Action_Semantics_internal);
',
	1);
INSERT INTO O_BATTR
	VALUES (7853,
	8);
INSERT INTO O_ATTR
	VALUES (7853,
	8,
	7852,
	'Action_Semantics',
	'Full Name: Action Semantics Field
Description: Action Semantics for the function action
Persistent:false
',
	'',
	'Action_Semantics',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (7854,
	8);
INSERT INTO O_BATTR
	VALUES (7854,
	8);
INSERT INTO O_ATTR
	VALUES (7854,
	8,
	7855,
	'Suc_Pars',
	'Full Name: Successful Parse Indicator
Description: Indicates the status of the parse for the bridge action specification in the attribute Action_Semantics
Data Domain: 0=not parsed, 1 = parse successful, 2 = parse unsuccessful, 3 = parse on apply set but never been parsed
',
	'',
	'Suc_Pars',
	0,
	1224,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (7856,
	8);
INSERT INTO O_BATTR
	VALUES (7856,
	8);
INSERT INTO O_ATTR
	VALUES (7856,
	8,
	7853,
	'Action_Semantics_internal',
	'User_Visible:false',
	'',
	'Action_Semantics_internal',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (7857,
	8);
INSERT INTO O_BATTR
	VALUES (7857,
	8);
INSERT INTO O_ATTR
	VALUES (7857,
	8,
	7854,
	'Return_Dimensions',
	'Full Name: Return Array Dimensions
DynamicReadOnly:isVoid',
	'',
	'Return_Dimensions',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (8,
	32,
	0,
	156,
	7309,
	7310,
	7311,
	7855,
	7858,
	0,
	0,
	'',
	'Data Type',
	'DT_ID',
	'R25');
INSERT INTO O_RATTR
	VALUES (7855,
	8,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (7855,
	8,
	7856,
	'DT_ID',
	'',
	'',
	'Element_ID',
	2,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (8,
	26,
	0,
	25,
	868,
	2840,
	870,
	11,
	7859,
	0,
	0,
	'',
	'Packageable Element',
	'Element_ID',
	'R8001');
INSERT INTO O_RATTR
	VALUES (11,
	8,
	25,
	26,
	0,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (11,
	8,
	0,
	'Sync_ID',
	'Full Name: Function Identifier',
	'',
	'Sync_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	8);
INSERT INTO O_OIDA
	VALUES (11,
	8,
	0,
	'Sync_ID');
INSERT INTO O_ID
	VALUES (1,
	8);
INSERT INTO O_ID
	VALUES (2,
	8);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (7338,
	'External Entity Package',
	22,
	'S_EEPK',
	'External Entity Package represents a package of external entities.',
	7221);
INSERT INTO O_TFR
	VALUES (7860,
	7338,
	'initialize',
	'The initialization operation for this class.',
	19,
	1,
	'self.Name = ::getUniqueInitialName( 
	instance: self.convertToInstance(), 
    candidateName: "Unnamed External Entity Package");',
	1,
	'',
	7861);
INSERT INTO O_TFR
	VALUES (7862,
	7338,
	'dispose',
	'The dispose operation for this class.',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one dom related by self->S_DOM[R36];
if (not_empty dom)
  unrelate dom from self across R36;
end if;
select many ees related by self->S_EE[R33];
for each ee in ees
  ee.dispose();
end for;
select one epip related by self->S_EEPIP[R34];
if not_empty epip
  select many pkgs related by epip->S_EEPK[R35];
  for each pkg in pkgs
  unrelate epip from pkg across R35;
    pkg.dispose();
  end for;
  unrelate self from epip across R34;
  delete object instance epip;
end if;
if(empty dom)
  select one dom related by self->PL_EEPID[R300]->S_DOM[R300];
end if;
select one eepid related by self->PL_EEPID[R300];
if(not_empty eepid)
  unrelate self from dom across R300 using eepid;
  delete object instance eepid;
end if;
delete object instance self;',
	1,
	'',
	7863);
INSERT INTO O_TFR
	VALUES (7864,
	7338,
	'newExternalEntity',
	'Create a new External Entity in this External Entity Package.',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one dom related by self->S_DOM[R36];
if (empty dom)
  select one rootPkg related by self->S_EEPIP[R35]->S_EEPK[R34];
  while (empty dom)
    select one dom related by rootPkg->S_DOM[R36];
    select one rootPkg related by rootPkg->S_EEPIP[R35]->S_EEPK[R34];;
  end while;
end if;
create object instance ee of S_EE;
relate ee to dom across R8;
create object instance eip of S_EEIP;
relate self to ee across R33 using eip;
ee.initialize();',
	1,
	'',
	7860);
INSERT INTO O_TFR
	VALUES (7865,
	7338,
	'newExternalEntityPackage',
	'Create a new EE Package in this EE Package.',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one helper related by self->S_EEPIP[R34];
if (empty helper)
  create object instance helper of S_EEPIP;
  relate self to helper across R34;
end if;
create object instance newEpkg of S_EEPK;
relate helper to newEpkg across R35;
create object instance ePkgInDomain of PL_EEPID;
select one domain related by self->PL_EEPID[R300]->S_DOM[R300];
relate domain to newEpkg across R300 using ePkgInDomain;
newEpkg.initialize();
',
	1,
	'',
	7864);
INSERT INTO O_TFR
	VALUES (7866,
	7338,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.EEPack_ID;',
	1,
	'',
	7867);
INSERT INTO O_TFR
	VALUES (7868,
	7338,
	'get_style',
	'',
	784,
	1,
	'return Style::Folder;',
	1,
	'',
	7866);
INSERT INTO O_TFR
	VALUES (7861,
	7338,
	'get_text_style',
	'',
	784,
	1,
	'return Style::None;',
	1,
	'',
	7868);
INSERT INTO O_TPARM
	VALUES (7869,
	7861,
	'comp_num',
	298,
	0,
	'',
	7870,
	'');
INSERT INTO O_TPARM
	VALUES (7871,
	7861,
	'ent_num',
	298,
	0,
	'',
	7869,
	'');
INSERT INTO O_TPARM
	VALUES (7870,
	7861,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7872,
	7338,
	'get_compartments',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	7873);
INSERT INTO O_TFR
	VALUES (7867,
	7338,
	'get_entries',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	7872);
INSERT INTO O_TPARM
	VALUES (7874,
	7867,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7873,
	7338,
	'get_compartment_text',
	'',
	322,
	1,
	'result = "";
if (param.at == Justification::Center_in_X)
  result = "external entity";
elif (param.at == Justification::Center)
  result = self.Name;
end if;
return result;',
	1,
	'',
	7862);
INSERT INTO O_TPARM
	VALUES (7875,
	7873,
	'comp_num',
	298,
	0,
	'',
	7876,
	'');
INSERT INTO O_TPARM
	VALUES (7877,
	7873,
	'ent_num',
	298,
	0,
	'',
	7875,
	'');
INSERT INTO O_TPARM
	VALUES (7876,
	7873,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7863,
	7338,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'// just return this instance as an Object
return this;',
	0,
	'',
	7878);
INSERT INTO O_TFR
	VALUES (7879,
	7338,
	'pasteExternalEntity',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any ee from instances of S_EE where (selected.EE_ID == param.id);
if(not_empty ee)
  select one domain related by self->PL_EEPID[R300]->S_DOM[R300];
  select one previousDomain related by ee->S_DOM[R8];
  if(not_empty previousDomain)
    unrelate ee from previousDomain across R8;
  end if;
  // guarantee a unique name for the pasted package
  ee.Name = ::getUniqueInitialNameInParent(instance:ee.convertToInstance(),
  						name:ee.Name, parent:self.convertToInstance());
  relate ee to domain across R8;
  create object instance eeip of S_EEIP;
  relate ee to self across R33 using eeip;
end if;',
	1,
	'',
	7865);
INSERT INTO O_TPARM
	VALUES (7880,
	7879,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7881,
	7338,
	'pasteExternalEntityPackage',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any eepkg from instances of S_EEPK where (selected.EEPack_ID == param.id);
if(not_empty eepkg)
  // guarantee a unique name for the pasted package
  eepkg.Name = ::getUniqueInitialNameInParent(instance:eepkg.convertToInstance(),
  						name:eepkg.Name, parent:self.convertToInstance());
  select one prevDomain related by eepkg->S_DOM[R36];
  if(not_empty prevDomain)
    unrelate eepkg from prevDomain across R36;
  end if;

  // create the nesting packages
  // if necessary
  select one eepkInpk related by eepkg->S_EEPIP[R35];
  select one destEepkInpk related by self->S_EEPIP[R34];

  if(not_empty eepkInpk)
    unrelate eepkg from eepkInpk across R35;
  end if;

  if(empty destEepkInpk)
    // otherwise create a new instance
    create object instance destEepkInpk of S_EEPIP;
    relate destEepkInpk to self across R34;
  end if;
  relate eepkg to destEepkInpk across R35;

  select one domain related by self->PL_EEPID[R300]->S_DOM[R300];
  
  // associate child packages with new domain
  eepkg.associateChildPackagesToDomain(dom_id:domain.Dom_ID);
  
  // now setup the links to the domain
  select one eepid related by eepkg->PL_EEPID[R300];
  if(not_empty eepid)
    select one prevDomain related by eepid->S_DOM[R300];
    unrelate eepkg from prevDomain across R300 using eepid;
    relate eepkg to domain across R300 using eepid;
  else
    create object instance eepid of PL_EEPID;
    relate eepkg to domain across R300 using eepid;
  end if;
  
  // finally associate each ee under the copied
  // package with the domain pasted into
  select many childPkgs related by eepkg->S_EEPIP[R34]->S_EEPK[R35];
  for each childPkg in childPkgs
    select many ees related by childPkg->S_EEIP[R33]->S_EE[R33];
    for each ee in ees
      select one prevDom related by ee->S_DOM[R8];
      if(not_empty prevDom)
        unrelate ee from prevDom across R8;
      end if;
      relate ee to domain across R8;
    end for;
  end for;
  select many ees related by eepkg->S_EEIP[R33]->S_EE[R33];
  for each ee in ees
    select one prevDom related by ee->S_DOM[R8];
    if(not_empty prevDom)
      unrelate ee from prevDom across R8;
    end if;
    relate ee to domain across R8;
  end for;
end if;',
	1,
	'',
	7879);
INSERT INTO O_TPARM
	VALUES (7882,
	7881,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7878,
	7338,
	'associateChildPackagesToDomain',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
/*
 *  For every child package, associate it to the given domain
 */
select any domain from instances of S_DOM where (selected.Dom_ID == param.dom_id);
if(not_empty domain)
  select many childPKGs related by self->S_EEPIP[R34]->S_EEPK[R35];
  for each child in childPKGs
    select one existingEPID related by child->PL_EEPID[R300];
    select one existingDom related by existingEPID->S_DOM[R300];
    unrelate child from existingDom across R300 using existingEPID;
    relate child to domain across R300 using existingEPID;
    child.associateChildPackagesToDomain(dom_id:param.dom_id);
  end for;
end if;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (7883,
	7878,
	'dom_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7884,
	7338,
	'getExternalEntityCount',
	'',
	298,
	1,
	'select many externalEntities related by self->S_EE[R33];
return cardinality externalEntities;',
	1,
	'',
	7881);
INSERT INTO O_TFR
	VALUES (7885,
	7338,
	'getExternalEntityId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many externalEntities related by self->S_EE[R33];
// We''re preincrementing the index
count = -1;
for each externalEntity in externalEntities
  if (not_empty externalEntity)
      count = count+1;
  end if;
  if (count == param.index)
      return externalEntity.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7884);
INSERT INTO O_TPARM
	VALUES (7886,
	7885,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7887,
	7338,
	'getExternalEntityPckgCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many externalEntitiyPckgs related by self->S_EEPIP[R34]->S_EEPK[R35];
return cardinality externalEntitiyPckgs;',
	1,
	'',
	7885);
INSERT INTO O_TFR
	VALUES (7888,
	7338,
	'getExternalEntityPckgId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many externalEntitiyPckgs related by self->S_EEPIP[R34]->S_EEPK[R35];
// We''re preincrementing the index
count = -1;
for each externalEntitiyPckg in externalEntitiyPckgs
  if (not_empty externalEntitiyPckg)
      count = count+1;
  end if;
  if (count == param.index)
      return externalEntitiyPckg.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	7887);
INSERT INTO O_TPARM
	VALUES (7889,
	7888,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7890,
	7338,
	'getPath',
	'',
	322,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one domain related by self->PL_EEPID[R300]->S_DOM[R300];
result = self.Name;
select one epip related by self->S_EEPIP[R35]->S_EEPK[R34];
while(not_empty epip)
  result = epip.Name + "::" + result;
  select one epip related by epip->S_EEPIP[R35]->S_EEPK[R34];
end while;
return domain.Name + "::" + result;',
	1,
	'',
	7888);
INSERT INTO O_NBATTR
	VALUES (7340,
	7338);
INSERT INTO O_BATTR
	VALUES (7340,
	7338);
INSERT INTO O_ATTR
	VALUES (7340,
	7338,
	0,
	'EEPack_ID',
	'Full Name: External Entity Package Identifier
Description: An identifier for a package of external entities.',
	'',
	'EEPack_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (7891,
	7338);
INSERT INTO O_BATTR
	VALUES (7891,
	7338);
INSERT INTO O_ATTR
	VALUES (7891,
	7338,
	7340,
	'Name',
	'Full Name: External Entity Package Name
Description: A name for a package of external entities.',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (7338,
	699,
	0,
	712,
	7352,
	7354,
	7353,
	7892,
	7893,
	0,
	0,
	'',
	'Domain',
	'Dom_ID',
	'R36');
INSERT INTO O_RATTR
	VALUES (7892,
	7338,
	712,
	699,
	1,
	'Dom_ID');
INSERT INTO O_ATTR
	VALUES (7892,
	7338,
	7891,
	'Dom_ID',
	'',
	'',
	'Dom_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (7338,
	7346,
	0,
	7350,
	7348,
	7351,
	7349,
	7894,
	7895,
	0,
	0,
	'',
	'EE Package in Package',
	'EEPack_ID',
	'R35');
INSERT INTO O_RATTR
	VALUES (7894,
	7338,
	7340,
	7338,
	1,
	'EEPack_ID');
INSERT INTO O_ATTR
	VALUES (7894,
	7338,
	7892,
	'Parent_EEPack_ID',
	'',
	'Parent_',
	'EEPack_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	7338);
INSERT INTO O_OIDA
	VALUES (7340,
	7338,
	0,
	'EEPack_ID');
INSERT INTO O_ID
	VALUES (1,
	7338);
INSERT INTO O_ID
	VALUES (2,
	7338);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (7342,
	'External Entity in Package',
	23,
	'S_EEIP',
	' External Entity in Package represents the external entities contained within a particular package.',
	7221);
INSERT INTO O_REF
	VALUES (7342,
	7338,
	0,
	7340,
	7337,
	7343,
	7339,
	7896,
	7897,
	0,
	0,
	'',
	'External Entity Package',
	'EEPack_ID',
	'R33');
INSERT INTO O_RATTR
	VALUES (7896,
	7342,
	7340,
	7338,
	1,
	'EEPack_ID');
INSERT INTO O_ATTR
	VALUES (7896,
	7342,
	0,
	'EEPack_ID',
	'',
	'',
	'EEPack_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (7342,
	2820,
	0,
	3570,
	7337,
	7343,
	7341,
	7898,
	7899,
	0,
	0,
	'',
	'External Entity',
	'EE_ID',
	'R33');
INSERT INTO O_RATTR
	VALUES (7898,
	7342,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (7898,
	7342,
	7896,
	'EE_ID',
	'',
	'',
	'EE_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	7342);
INSERT INTO O_OIDA
	VALUES (7896,
	7342,
	0,
	'EEPack_ID');
INSERT INTO O_OIDA
	VALUES (7898,
	7342,
	0,
	'EE_ID');
INSERT INTO O_ID
	VALUES (1,
	7342);
INSERT INTO O_ID
	VALUES (2,
	7342);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (7235,
	'External Entity in Model',
	4,
	'S_EEM',
	'The external entity in model (S_EEM) represents the presence of an external entity (S_EE)  in a model such as the Communication Diagram or Synchronous Communication Diagram. The same external entity can be represented by more than one external entity in model in the same model to enhance model layout.',
	7221);
INSERT INTO O_TFR
	VALUES (7900,
	7235,
	'dispose',
	'The dispose operation for this class.',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one ss related by self->S_SS[R7];
if (not_empty ss)
  unrelate self from ss across R7;
end if;
select one ee related by self->S_EE[R9];
unrelate self from ee across R9;
select many eesmcs related by self->CA_EESMC[R402];
for each eesmc in eesmcs
  eesmc.dispose();
end for;
select many smeecs related by self->CA_SMEEC[R411];
for each smeec in smeecs
  smeec.dispose();
end for;
select many accpaths related by self->CA_SMEEA[R421]->CA_ACC[R415];
for each  accpath in accpaths
  accpath.dispose();
end for;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_NBATTR
	VALUES (7901,
	7235);
INSERT INTO O_BATTR
	VALUES (7901,
	7235);
INSERT INTO O_ATTR
	VALUES (7901,
	7235,
	0,
	'EEmod_ID',
	'Full Name: External Entity In Model Identifier',
	'',
	'EEmod_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (7902,
	7235);
INSERT INTO O_BATTR
	VALUES (7902,
	7235);
INSERT INTO O_ATTR
	VALUES (7902,
	7235,
	7903,
	'Modl_Typ',
	'Full Name: Model Type Indicator
Description: Indicates in which  type of model the External Entity resides.
Data Domain: 6 = Communication Diagram, 7 = Synchronous Communication Diagram',
	'',
	'Modl_Typ',
	0,
	298,
	'',
	'');
INSERT INTO O_REF
	VALUES (7235,
	701,
	0,
	717,
	7233,
	7236,
	7234,
	7904,
	7905,
	0,
	0,
	'',
	'Subsystem',
	'SS_ID',
	'R7');
INSERT INTO O_RATTR
	VALUES (7904,
	7235,
	717,
	701,
	1,
	'SS_ID');
INSERT INTO O_ATTR
	VALUES (7904,
	7235,
	7902,
	'SS_ID',
	'',
	'',
	'SS_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (7235,
	2820,
	0,
	3570,
	7237,
	7239,
	7238,
	7903,
	7906,
	0,
	0,
	'',
	'External Entity',
	'EE_ID',
	'R9');
INSERT INTO O_RATTR
	VALUES (7903,
	7235,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (7903,
	7235,
	7901,
	'EE_ID',
	'',
	'',
	'EE_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	7235);
INSERT INTO O_OIDA
	VALUES (7901,
	7235,
	0,
	'EEmod_ID');
INSERT INTO O_OIDA
	VALUES (7903,
	7235,
	0,
	'EE_ID');
INSERT INTO O_ID
	VALUES (1,
	7235);
INSERT INTO O_ID
	VALUES (2,
	7235);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (7245,
	'External Entity Event Data Item',
	7,
	'S_EEEDI',
	'Each external entity (S_EE) may have zero or more event data items that can be used as supplemental data for external entity events.  The event data items are kept in a pool so that they can be used by one or more external entity events.  When an instance of event data item is used in an event, an instance of S_EEEDT is created to represent the event as data in an event.',
	7221);
INSERT INTO O_TFR
	VALUES (7907,
	7245,
	'dispose',
	'The dispose operation for this class.',
	19,
	1,
	'select one dt related by self->S_DT[R16];
unrelate self from dt across R16;
select many eeedts related by self->S_EEEDT[R13];
for each eeedt in eeedts
  eeedt.dispose();
end for;
select one ee related by self->S_EE[R12];
if ( not_empty ee )
  unrelate self from ee across R12;
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (7908,
	7245,
	'isAllowedType',
	'',
	316,
	1,
	'select one domain related by self->S_EE[R12]->S_DOM[R8];
return S_DT::isAllowedParameterType( typeName: param.typeName,
                             			dom_id: domain.get_ooa_id());
',
	1,
	'',
	7907);
INSERT INTO O_TPARM
	VALUES (7909,
	7908,
	'typeName',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_NBATTR
	VALUES (7288,
	7245);
INSERT INTO O_BATTR
	VALUES (7288,
	7245);
INSERT INTO O_ATTR
	VALUES (7288,
	7245,
	0,
	'EEedi_ID',
	'Full Name: External Entity Event Data Item Identifier',
	'',
	'EEedi_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (7910,
	7245);
INSERT INTO O_BATTR
	VALUES (7910,
	7245);
INSERT INTO O_ATTR
	VALUES (7910,
	7245,
	7289,
	'Name',
	'Full Name: External Entity Event Data Item Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (7911,
	7245);
INSERT INTO O_BATTR
	VALUES (7911,
	7245);
INSERT INTO O_ATTR
	VALUES (7911,
	7245,
	7910,
	'Descrip',
	'Full Name: External Entity Event Data Item Description',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (7245,
	32,
	0,
	156,
	7250,
	7252,
	7251,
	7912,
	7913,
	0,
	0,
	'',
	'Data Type',
	'DT_ID',
	'R16');
INSERT INTO O_RATTR
	VALUES (7912,
	7245,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (7912,
	7245,
	7911,
	'DT_ID',
	'',
	'',
	'Element_ID',
	2,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (7245,
	2820,
	0,
	3570,
	7243,
	7246,
	7244,
	7289,
	7914,
	0,
	0,
	'',
	'External Entity',
	'EE_ID',
	'R12');
INSERT INTO O_RATTR
	VALUES (7289,
	7245,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (7289,
	7245,
	7288,
	'EE_ID',
	'',
	'',
	'EE_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	7245);
INSERT INTO O_OIDA
	VALUES (7288,
	7245,
	0,
	'EEedi_ID');
INSERT INTO O_OIDA
	VALUES (7289,
	7245,
	0,
	'EE_ID');
INSERT INTO O_ID
	VALUES (1,
	7245);
INSERT INTO O_ID
	VALUES (2,
	7245);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (7291,
	'External Entity Event Data',
	8,
	'S_EEEDT',
	'When an instance of event data item (S_EEEDI) is used in an event (S_EEEVT), an instance of S_EEEDT is created to represent the event as data in an event.  The supplemental data for an external entity event are instances of this class.',
	7221);
INSERT INTO O_TFR
	VALUES (7915,
	7291,
	'dispose',
	'The dispose operation for this class.',
	19,
	1,
	'select one eeevt related by self->S_EEEVT[R13];
select one eeedi related by self->S_EEEDI[R13];
unrelate eeevt from eeedi across R13 using self;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (7916,
	7291,
	'get_name',
	'',
	322,
	1,
	'select one eed_item related by self->S_EEEDI[R13];
if (not_empty eed_item)
  return eed_item.Name;
else
  return "";
end if;

',
	1,
	'',
	7915);
INSERT INTO O_REF
	VALUES (7291,
	6622,
	0,
	6637,
	7286,
	7292,
	7290,
	7917,
	7918,
	0,
	0,
	'',
	'External Entity Event',
	'EEevt_ID',
	'R13');
INSERT INTO O_RATTR
	VALUES (7917,
	7291,
	6637,
	6622,
	1,
	'EEevt_ID');
INSERT INTO O_ATTR
	VALUES (7917,
	7291,
	7919,
	'EEevt_ID',
	'',
	'',
	'EEevt_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (7291,
	7245,
	0,
	7288,
	7286,
	7292,
	7287,
	7920,
	7921,
	0,
	0,
	'',
	'External Entity Event Data Item',
	'EEedi_ID',
	'R13');
INSERT INTO O_RATTR
	VALUES (7920,
	7291,
	7288,
	7245,
	1,
	'EEedi_ID');
INSERT INTO O_ATTR
	VALUES (7920,
	7291,
	7917,
	'EEedi_ID',
	'',
	'',
	'EEedi_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (7291,
	6622,
	0,
	6638,
	7286,
	7292,
	7290,
	7919,
	7922,
	0,
	0,
	'',
	'External Entity Event',
	'EE_ID',
	'R13');
INSERT INTO O_REF
	VALUES (7291,
	7245,
	0,
	7289,
	7286,
	7292,
	7287,
	7919,
	7923,
	7922,
	0,
	'',
	'External Entity Event Data Item',
	'EE_ID',
	'R13');
INSERT INTO O_RATTR
	VALUES (7919,
	7291,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (7919,
	7291,
	0,
	'EE_ID',
	'',
	'',
	'EE_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	7291);
INSERT INTO O_OIDA
	VALUES (7920,
	7291,
	0,
	'EEedi_ID');
INSERT INTO O_OIDA
	VALUES (7917,
	7291,
	0,
	'EEevt_ID');
INSERT INTO O_OIDA
	VALUES (7919,
	7291,
	0,
	'EE_ID');
INSERT INTO O_ID
	VALUES (1,
	7291);
INSERT INTO O_ID
	VALUES (2,
	7291);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (6622,
	'External Entity Event',
	6,
	'S_EEEVT',
	'An external entity event (S_EEEVT) represents asynchronous communication between a class (O_OBJ) and an external entity (S_EE).  The communication is shown on the Communication Diagram.  Each external entity event is given a unique label and can have zero or more event data (S_EEEDT).',
	7221);
INSERT INTO O_TFR
	VALUES (7924,
	6622,
	'get_name',
	'Creates a string containing a descriptive name for the instance.',
	322,
	1,
	'select one ee related by self->S_EE[R10];
if ( not_empty ee )
  return ee.Name + "." + self.Drv_Lbl;
end if;
return "";
',
	1,
	'',
	7925);
INSERT INTO O_TFR
	VALUES (7925,
	6622,
	'dispose',
	'The dispose operation for this class.',
	19,
	1,
	'// Domain Subsystem
select one ee related by self->S_EE[R10];
unrelate self from ee across R10;
// 
// Communication and Access Subsystem
select many eeedts related by self->S_EEEDT[R13];
for each eeedt in eeedts
  eeedt.dispose();
end for;
select many smeecomms related by self->CA_SMEEE[R413];
for each smeecomm in smeecomms
  smeecomm.dispose();
end for;
//
// Event Subsystem
select many cees related by self->E_CEE[R708];
for each cee in cees
  unrelate self from cee across R708;
end for;
select many gees related by self->E_GEE[R709];
for each gee in gees
  unrelate self from gee across R709;
end for;
//
// Finally delete self
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_NBATTR
	VALUES (6637,
	6622);
INSERT INTO O_BATTR
	VALUES (6637,
	6622);
INSERT INTO O_ATTR
	VALUES (6637,
	6622,
	0,
	'EEevt_ID',
	'Full Name: External Entity Event Identifier',
	'',
	'EEevt_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (7926,
	6622);
INSERT INTO O_BATTR
	VALUES (7926,
	6622);
INSERT INTO O_ATTR
	VALUES (7926,
	6622,
	6638,
	'Numb',
	'Full Name: External Entity Event Number
min_value: 0
max_value: 9999
',
	'',
	'Numb',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (7927,
	6622);
INSERT INTO O_BATTR
	VALUES (7927,
	6622);
INSERT INTO O_ATTR
	VALUES (7927,
	6622,
	7926,
	'Mning',
	'Full Name: External Entity Event Meaning',
	'',
	'Mning',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (7928,
	6622);
INSERT INTO O_BATTR
	VALUES (7928,
	6622);
INSERT INTO O_ATTR
	VALUES (7928,
	6622,
	7927,
	'Is_Lbl_U',
	'Full Name: External Entity Event Label Unique Indicator
Description: This is a flag that indicates whether custom label keyletters are used for the External Entity Event.
Data Domain: 0 = External Entity keyletters are used, 1 = custom label keyletters are used
enum0: External Entity Keyletters
enum1: Custom Keyletters
',
	'',
	'Is_Lbl_U',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (7929,
	6622);
INSERT INTO O_BATTR
	VALUES (7929,
	6622);
INSERT INTO O_ATTR
	VALUES (7929,
	6622,
	7928,
	'Unq_Lbl',
	'Full Name: External Entity Event Unique Label
Description: Custom Key Letters for the External Entity Event',
	'',
	'Unq_Lbl',
	0,
	322,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (7930,
	6622,
	'If ( self. Is_Lbl_U == 0 )
  select one ee related by self->S_EE[R10];
  self.Drv_Lbl = ee.Key_Lett + GD::int_to_string(value:self.Numb);
else
  self.Drv_Lbl = self.Unq_Lbl + GD::int_to_string(value:self.Numb);
end if;
',
	1);
INSERT INTO O_BATTR
	VALUES (7930,
	6622);
INSERT INTO O_ATTR
	VALUES (7930,
	6622,
	7929,
	'Drv_Lbl',
	'Full Name: External Entity Event Derived Label
Description: contains  the event label derived by concatenating the keyletters and the event number.
Data Domain: 0 = derived label created by concatenating EE keyletters + event number, 1 = derived label created by concatenating Unq_Lbl with event number
',
	'',
	'Drv_Lbl',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (7931,
	6622);
INSERT INTO O_BATTR
	VALUES (7931,
	6622);
INSERT INTO O_ATTR
	VALUES (7931,
	6622,
	7930,
	'Descrip',
	'Full Name: External Entity Event Description',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (6622,
	2820,
	0,
	3570,
	7240,
	7242,
	7241,
	6638,
	7932,
	0,
	0,
	'',
	'External Entity',
	'EE_ID',
	'R10');
INSERT INTO O_RATTR
	VALUES (6638,
	6622,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (6638,
	6622,
	6637,
	'EE_ID',
	'',
	'',
	'EE_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	6622);
INSERT INTO O_OIDA
	VALUES (6637,
	6622,
	0,
	'EEevt_ID');
INSERT INTO O_OIDA
	VALUES (6638,
	6622,
	0,
	'EE_ID');
INSERT INTO O_ID
	VALUES (1,
	6622);
INSERT INTO O_ID
	VALUES (2,
	6622);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (7278,
	'External Entity Data Item',
	5,
	'S_EEDI',
	'An external entity data item is essentially an attribute of an external entity that can be accessed by a class (O_OBJ).  These synchronous Interactions between classes and external entities are shown on the Synchronous Communication Diagrams.  Support for external entity data items is currently absent from the tool.',
	7221);
INSERT INTO O_TFR
	VALUES (7933,
	7278,
	'dispose',
	'The dispose operation for this class.',
	19,
	1,
	'select one dt related by self->S_DT[R15];
unrelate self from dt across R15;
select one ee related by self->S_EE[R11];
unrelate self from ee across R11;
select many smeeds related by self->CA_SMEED[R423];
for each smeed in smeeds
  smeed.dispose();
end for;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (7934,
	7278,
	'isAllowedType',
	'',
	316,
	1,
	'select one domain related by self->S_EE[R11]->S_DOM[R8];
return S_DT::isAllowedParameterType( typeName: param.typeName,
                             		dom_id: domain.get_ooa_id());
',
	1,
	'',
	7933);
INSERT INTO O_TPARM
	VALUES (7935,
	7934,
	'typeName',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_NBATTR
	VALUES (7936,
	7278);
INSERT INTO O_BATTR
	VALUES (7936,
	7278);
INSERT INTO O_ATTR
	VALUES (7936,
	7278,
	0,
	'EEdi_ID',
	'Full Name: External Entity Data Item Identifier',
	'',
	'EEdi_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (7937,
	7278);
INSERT INTO O_BATTR
	VALUES (7937,
	7278);
INSERT INTO O_ATTR
	VALUES (7937,
	7278,
	7938,
	'Name',
	'Full Name: External Entity Data Item Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (7939,
	7278);
INSERT INTO O_BATTR
	VALUES (7939,
	7278);
INSERT INTO O_ATTR
	VALUES (7939,
	7278,
	7937,
	'Descrip',
	'Full Name: External Entity Data Item Description',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (7278,
	32,
	0,
	156,
	7276,
	7279,
	7277,
	7940,
	7941,
	0,
	0,
	'',
	'Data Type',
	'DT_ID',
	'R15');
INSERT INTO O_RATTR
	VALUES (7940,
	7278,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (7940,
	7278,
	7939,
	'DT_ID',
	'',
	'',
	'Element_ID',
	2,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (7278,
	2820,
	0,
	3570,
	7283,
	7284,
	7285,
	7938,
	7942,
	0,
	0,
	'',
	'External Entity',
	'EE_ID',
	'R11');
INSERT INTO O_RATTR
	VALUES (7938,
	7278,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (7938,
	7278,
	7936,
	'EE_ID',
	'',
	'',
	'EE_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	7278);
INSERT INTO O_OIDA
	VALUES (7936,
	7278,
	0,
	'EEdi_ID');
INSERT INTO O_OIDA
	VALUES (7938,
	7278,
	0,
	'EE_ID');
INSERT INTO O_ID
	VALUES (1,
	7278);
INSERT INTO O_ID
	VALUES (2,
	7278);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2820,
	'External Entity',
	3,
	'S_EE',
	'An external entity (S_EE) represents something outside of the domain (S_DOM) being modeled that interacts with classes (O_OBJ) within the domain. The interactions are shown by event communication paths on the Communication Diagrams and data access paths on the Synchronous Communication Diagrams. Each external entity is given a unique name and keyletters within a domain.',
	7221);
INSERT INTO O_TFR
	VALUES (7943,
	2820,
	'get_compartments',
	'An External Entity is shown as a package that has only one compartment.
-----------------------------------------------------------------------------------
Bridge:GD',
	298,
	1,
	'return 3;',
	1,
	'',
	7944);
INSERT INTO O_TFR
	VALUES (7945,
	2820,
	'get_style',
	'An External Entity is shown as a Package (called a Folder in the
Graphics Domain).
-----------------------------------------------------------------------------------
Bridge:GD',
	784,
	1,
	'return Style::Box;',
	1,
	'',
	7946);
INSERT INTO O_TFR
	VALUES (7944,
	2820,
	'get_compartment_text',
	'An External Entity shows only it''s name.
-----------------------------------------------------------------------------------
Bridge:GD',
	322,
	1,
	'result = "";
if (param.comp_num == 1)
  if (param.ent_num == 1)
    if (param.at == Justification::Center_in_X)
      result = "external entity";
      result = result + GD::newline();
      result = result + self.Label;
    end if;
  end if;
elif (param.comp_num == 2)
  if (param.at == Justification::Left)
    cursor = 1;
    select many eedis related by self->S_EEDI[R11];
    for each eedi in eedis
      if (cursor == param.ent_num)
        result = eedi.Name + " : ";
        select one ddt related by eedi->S_DT[R15];
        if ( not_empty ddt )
          result = result + ddt.Name;
        else
          result = result + ::getOrphanedElementName();
        end if;
        break;
      end if;
      cursor = cursor + 1;
    end for;
  end if;
elif (param.comp_num == 3)
  if (param.at == Justification::Left)
    cursor = 1;
    select many brs related by self->S_BRG[R19];
    if (not_empty brs and param.ent_num == 1)
      result = "operation";
      result = result + GD::newline();
    end if;
    for each br in brs
      if (cursor == param.ent_num)
        result = result + br.Name;
        select any bparm related by br->S_BPARM[R21] where (selected.Previous_BParm_ID == GD::NULL_UNIQUE_ID());
        if (not_empty bparm)
          result = result + "(";
          parm_separator = "";
          while (not_empty bparm)
            result = result + parm_separator;
            result = result + bparm.Name;
            result = result + bparm.Dimensions;
            result = result + " : ";
            select one pdt related by bparm->S_DT[R22];
            if ( not_empty pdt )
              result = result + pdt.Name;
            else
              result = result + ::getOrphanedElementName();
            end if;
            parm_separator = ", ";
            select one bparm related by bparm->S_BPARM[R55.''precedes''];
          end while;

          result = result + ")";
        end if;
        break;
      end if;
      cursor = cursor + 1;
    end for;
    result = result + " : ";
    select one rt related by br->S_DT[R20];
    if ( not_empty rt )
	  result = result + rt.Name;
	else
	  result = result + ::getOrphanedElementName();	  
	end if;
    if(not_empty rt and rt.Name != "void")
      result = result + br.Return_Dimensions;
    end if;
  end if;
end if;
return result;',
	1,
	'',
	7947);
INSERT INTO O_TPARM
	VALUES (7948,
	7944,
	'comp_num',
	298,
	0,
	'',
	7949,
	'');
INSERT INTO O_TPARM
	VALUES (7950,
	7944,
	'ent_num',
	298,
	0,
	'',
	7948,
	'');
INSERT INTO O_TPARM
	VALUES (7949,
	7944,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7951,
	2820,
	'get_entries',
	'An External Entity has only one entry, its name.
-----------------------------------------------------------------------------------
Bridge:GD',
	298,
	1,
	'if (param.comp_num == 1)
  return 1;
elif (param.comp_num ==2)
  select many eedis related by self->S_EEDI[R11];
  return cardinality eedis;
elif (param.comp_num == 3)
  select many brs related by self->S_BRG[R19];
  return cardinality brs;
else
  return 0;
end if;',
	1,
	'',
	7943);
INSERT INTO O_TPARM
	VALUES (7952,
	7951,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7953,
	2820,
	'get_text_style',
	'An External Entity requires no special text style for its label.
-----------------------------------------------------------------------------------
Bridge:GD',
	784,
	1,
	'return Style::None;',
	1,
	'',
	7945);
INSERT INTO O_TPARM
	VALUES (7954,
	7953,
	'comp_num',
	298,
	0,
	'',
	7955,
	'');
INSERT INTO O_TPARM
	VALUES (7956,
	7953,
	'ent_num',
	298,
	0,
	'',
	7954,
	'');
INSERT INTO O_TPARM
	VALUES (7955,
	7953,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7957,
	2820,
	'initialize',
	'Initialize a new External Entity instance.',
	19,
	1,
	'name = ::getUniqueInitialName( 
    instance: self.convertToInstance(), 
    candidateName: "Unnamed External Entity");
success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:true);    
if ( success!="") 
 self.Name=success;
 self.isRealized = true;
else 
 self.dispose();
end if;        ',
	1,
	'',
	7953);
INSERT INTO O_TFR
	VALUES (7958,
	2820,
	'dispose',
	'The dispose operation for this class.',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one pe related by self->PE_PE[R8001];
if(not_empty pe)
  // PE_PE.dispose() will call back into this function at which time the
  // rest of the activity will execute.
  pe.dispose();
  return;
end if;
select many eedis related by self->S_EEDI[R11];
for each eedi in eedis
  eedi.dispose();
end for;
select many brgs related by self->S_BRG[R19];
for each brg in brgs
  brg.dispose();
end for;
select one dom related by self->S_DOM[R8];
if ( not_empty dom )
  unrelate self from dom across R8;
end if;
select one eeip related by self->S_EEIP[R33];
if (not_empty eeip)
  select one eepk related by eeip->S_EEPK[R33];
  unrelate self from eepk across R33 using eeip;
  delete object instance eeip;
  select many eems related by self->S_EEM[R9];
  for each eem in eems
    eem.dispose();
  end for;
end if;   

select many eeevts related by self->S_EEEVT[R10];
for each eeevt in eeevts
  eeevt.dispose();
end for;
select many eeedis related by self->S_EEEDI[R12];
for each eeedi in eeedis
  eeedi.dispose();
end for;
// for each sequence participant that is associated with
// this External Entity
select many eeps related by self->SQ_EEP[R933];
for each eep in eeps
  // unformalize the participant
  eep.unformalize();
end for;
// check other subsystems
delete object instance self;',
	1,
	'',
	7959);
INSERT INTO O_TFR
	VALUES (7960,
	2820,
	'newBridgeOperation',
	'Create a new bridge for this external entity.
',
	19,
	1,
	'create object instance brg of S_BRG;
relate self to brg across R19;
brg.initialize();',
	1,
	'',
	7957);
INSERT INTO O_TFR
	VALUES (7946,
	2820,
	'get_ooa_id',
	'The ooa_id of an External Entity is its EE_ID
-----------------------------------------------------------
Bridge:GD',
	296,
	1,
	'return self.EE_ID;',
	1,
	'',
	7951);
INSERT INTO O_TFR
	VALUES (7947,
	2820,
	'getPath',
	'',
	322,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one packageableElem related by self->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;
result="";
if (isInGenericPackage)
  if (not_empty package)
    result=package.getPath(path:self.Name);
  else
    result=component.getPath(path:self.Name, includeSelf:true);
  end if;
else
  select one domain related by self->S_DOM[R8];
  select one epkg related by self->S_EEIP[R33]->S_EEPK[R33];
  result = epkg.Name;
  select one epip related by epkg->S_EEPIP[R35]->S_EEPK[R34];
  while(not_empty epip)
    result = epip.Name + "::" + result;
    select one epip related by epip->S_EEPIP[R35]->S_EEPK[R34];
  end while;
  result=domain.Name + "::" + result + "::" + self.Name;
end if;
return result;',
	1,
	'',
	7958);
INSERT INTO O_TFR
	VALUES (7959,
	2820,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'// just return this instance as an Object
return this;',
	0,
	'',
	0);
INSERT INTO O_TFR
	VALUES (7961,
	2820,
	'getContainingComponentId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// External Entity.getContainingComponentId()
select one domain related by self->S_DOM[R8];
isInGenericPackage = empty domain;
if isInGenericPackage
  select one package related by self->PE_PE[R8001]->EP_PKG[R8000];
  select one component related by self->PE_PE[R8001]->C_C[R8003];
  if not_empty package
    return package.getContainingComponentId();
  end if;
  if not_empty component
    return component.Id;
  end if;
  USER::logError(msg:"External Entity has no parent in External Entity.getContainingComponentId()",path:self.getPath());
  return GD::NULL_UNIQUE_ID();
end if;
return domain.getContainingComponentId();',
	1,
	'',
	7960);
INSERT INTO O_TFR
	VALUES (7962,
	2820,
	'getContainerId',
	'',
	296,
	1,
	'// External Entity.getContainerId()
select one component related by self->PE_PE[R8001]->C_C[R8003];
if not_empty component
  return component.Id;
else
  select one package related by self->PE_PE[R8001]->EP_PKG[R8000];
  if not_empty package
    return package.Package_ID;
  end if;
end if;
return GD::NULL_UNIQUE_ID();
',
	1,
	'',
	7961);
INSERT INTO O_TFR
	VALUES (7963,
	2820,
	'pasteBridge',
	'',
	19,
	1,
	'select any operation from instances of S_BRG
                                            where (selected.Brg_ID == param.id);
if(not_empty operation)
  select one ee related by operation->S_EE[R19];
  if(not_empty ee)
    unrelate operation from ee across R19;
  end if;
  relate operation to self across R19;
  operation.Name = ::getUniqueInitialNameInParent(
                                         instance:operation.convertToInstance(),
  						  name:operation.Name, parent:self.convertToInstance());
end if;',
	1,
	'',
	7962);
INSERT INTO O_TPARM
	VALUES (7964,
	7963,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_NBATTR
	VALUES (7965,
	2820);
INSERT INTO O_BATTR
	VALUES (7965,
	2820);
INSERT INTO O_ATTR
	VALUES (7965,
	2820,
	3570,
	'Name',
	'Full Name: External Entity Name
Description: Provides a name for the external entity.',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (7966,
	2820);
INSERT INTO O_BATTR
	VALUES (7966,
	2820);
INSERT INTO O_ATTR
	VALUES (7966,
	2820,
	7965,
	'Descrip',
	'Full Name: External Entity Description
Description: A textual description of the external entity which appears in a domains Subsystem Partition Model (SPM).',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (7967,
	2820);
INSERT INTO O_BATTR
	VALUES (7967,
	2820);
INSERT INTO O_ATTR
	VALUES (7967,
	2820,
	7966,
	'Key_Lett',
	'Full Name: External Entity Key Letters
The key letters assigned to an external entity on a domains SPM.',
	'',
	'Key_Lett',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (2820,
	699,
	0,
	712,
	7253,
	7255,
	7254,
	7968,
	7969,
	0,
	0,
	'',
	'Domain',
	'Dom_ID',
	'R8.''interacts with''');
INSERT INTO O_RATTR
	VALUES (7968,
	2820,
	712,
	699,
	1,
	'Dom_ID');
INSERT INTO O_ATTR
	VALUES (7968,
	2820,
	7967,
	'Dom_ID',
	'',
	'',
	'Dom_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2820,
	26,
	0,
	25,
	868,
	2839,
	870,
	3570,
	7970,
	0,
	0,
	'',
	'Packageable Element',
	'Element_ID',
	'R8001');
INSERT INTO O_RATTR
	VALUES (3570,
	2820,
	25,
	26,
	0,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (3570,
	2820,
	0,
	'EE_ID',
	'Full Name: External Entity Identifier
Description: Uniquely identifies the external entity in the domain.',
	'',
	'EE_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (7971,
	2820);
INSERT INTO O_BATTR
	VALUES (7971,
	2820);
INSERT INTO O_ATTR
	VALUES (7971,
	2820,
	7968,
	'Realized_Class_Path',
	'Full Name: Realized External Entity Path',
	'',
	'Realized_Class_Path',
	0,
	322,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (7972,
	2820,
	'extension = "";
if(self.isRealized)
  if(self.Realized_Class_Path != "")
    extension = " realized by " +
                     Util::getLastSegmentForPath(path:self.Realized_Class_Path);
  end if;
end if;
self.Label = self.Name + extension;',
	1);
INSERT INTO O_BATTR
	VALUES (7972,
	2820);
INSERT INTO O_ATTR
	VALUES (7972,
	2820,
	7971,
	'Label',
	'Full Name: External Entity Label',
	'',
	'Label',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (7973,
	2820);
INSERT INTO O_BATTR
	VALUES (7973,
	2820);
INSERT INTO O_ATTR
	VALUES (7973,
	2820,
	7972,
	'isRealized',
	'Full Name: Realized External Entity
Description: If true, Verifier will bind to an externally supplied implementation.',
	'',
	'isRealized',
	0,
	316,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2820);
INSERT INTO O_OIDA
	VALUES (3570,
	2820,
	0,
	'EE_ID');
INSERT INTO O_ID
	VALUES (1,
	2820);
INSERT INTO O_ID
	VALUES (2,
	2820);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (39,
	'Enumerator',
	15,
	'S_ENUM',
	'Enumerators are constants that have meaning to the analyst.  An enumeration data type (S_EDT) defines zero or more enumerators.  For example, Red, Blue, and Green are enumerators of the enumeration Color.',
	7221);
INSERT INTO O_TFR
	VALUES (7974,
	39,
	'dispose',
	'The dispose operation for this class.',
	19,
	1,
	'// Domain Subsystem
select one edt related by self->S_EDT[R27];
unrelate self from edt across R27;
//
select one successor related by self->S_ENUM[R56.''precedes''];
select one predecessor related by self->S_ENUM[R56.''succeeds''];
if (not empty successor)
  unrelate self from successor across R56.''precedes'';
end if;
if (not empty predecessor)
  unrelate self from predecessor across R56.''succeeds'';
end if;
if (not_empty successor and not_empty predecessor)
  relate successor to predecessor across R56.''succeeds'';
end if;
//
// Value Subsystem
select many litEnums related by self->V_LEN[R824];
for each litEnum in litEnums
  unrelate self from litEnum across R824;
end for;
//
// Finally, delete self
delete object instance self;',
	1,
	'',
	7975);
INSERT INTO O_TFR
	VALUES (7976,
	39,
	'initialize',
	'The initialization operation for this class.',
	19,
	1,
	'select one edt related by self->S_EDT[R27];
edt.addEnumeratorToOrder(id:self.Enum_ID);
name = ::getUniqueInitialName( 
    instance: self.convertToInstance(), 
    candidateName: "Unnamed Enumerator");
success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:true);    
if ( success!="") 
 self.Name=success;
else 
 self.dispose();
end if;     ',
	1,
	'',
	7974);
INSERT INTO O_TFR
	VALUES (7975,
	39,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'// just return this instance as an Object
return this;',
	0,
	'',
	7977);
INSERT INTO O_TFR
	VALUES (7978,
	39,
	'moveUp',
	'',
	19,
	1,
	'::changeNotificationEnablement(enabled:false);
select one prev_attr related by self->S_ENUM[R56.''succeeds''];
select one prev_prev_attr related by prev_attr->S_ENUM[R56.''succeeds''];
select one next_attr related by self->S_ENUM[R56.''precedes''];

if ( not_empty prev_prev_attr )
  unrelate prev_attr from prev_prev_attr across R56.''succeeds'';
end if;
if ( not_empty next_attr )
  unrelate next_attr from self across R56.''succeeds'';
end if;
unrelate self from prev_attr across R56.''succeeds'';

if ( not_empty prev_prev_attr )
  relate self to prev_prev_attr across R56.''succeeds'';
end if;
// want to enable listeners at the last possible moment
if ( empty next_attr )
  ::changeNotificationEnablement(enabled:true);
end if;
relate prev_attr to self across R56.''succeeds'';
if ( not_empty next_attr )
  ::changeNotificationEnablement(enabled:true);
  relate next_attr to prev_attr across R56.''succeeds'';
end if;
',
	1,
	'',
	7979);
INSERT INTO O_TFR
	VALUES (7979,
	39,
	'moveDown',
	'',
	19,
	1,
	'::changeNotificationEnablement(enabled:false);
select one next_attr related by self->S_ENUM[R56.''precedes''];
select one prev_attr related by self->S_ENUM[R56.''succeeds''];
select one next_next_attr related by next_attr->S_ENUM[R56.''precedes''];

if ( not_empty next_next_attr )
  unrelate next_next_attr from next_attr across R56.''succeeds'';
end if;
if ( not_empty prev_attr )
  unrelate self from prev_attr across R56.''succeeds'';
end if;
unrelate next_attr from self across R56.''succeeds'';

if ( not_empty prev_attr )
  relate next_attr to prev_attr across R56.''succeeds'';
end if;
   
// want to enable listeners at the last possible moment
if ( empty next_next_attr )
  ::changeNotificationEnablement(enabled:true);
end if;
relate self to next_attr across R56.''succeeds'';
if ( not_empty next_next_attr )
  ::changeNotificationEnablement(enabled:true);
  relate next_next_attr to self across R56.''succeeds'';
end if;
',
	1,
	'',
	7976);
INSERT INTO O_TFR
	VALUES (7977,
	39,
	'actionFilter',
	'',
	316,
	1,
	'if (param.name == "can" )
  if ( param.value == "move up" )
    select one prev_attr related by self->S_ENUM[R56.''succeeds''];
    return not_empty prev_attr;
  elif ( param.value == "move down" )
    select one next_attr related by self->S_ENUM[R56.''precedes''];
    return not_empty next_attr;
  end if;
end if;
return false;
',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (7980,
	7977,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (7981,
	7977,
	'value',
	322,
	0,
	'',
	7980,
	'');
INSERT INTO O_TFR
	VALUES (7982,
	39,
	'checkIntegrity',
	'',
	19,
	1,
	'// create an integrity issue if there are any other enumerators
// with the same name
select one edt related by self->S_EDT[R27];
select one dt related by edt->S_DT[R17];
select one package related by dt->PE_PE[R8001]->EP_PKG[R8000];
select one component related by dt->PE_PE[R8001]->C_C[R8003];
if(not empty component)
  pkgId = component.getPackageId();
  select any package from instances of EP_PKG
                                           where (selected.Package_ID == pkgId);
end if;
select one system related by package->S_SYS[R1405];
sys_id = GD::NULL_UNIQUE_ID();
if(not_empty system)
  sys_id = system.Sys_ID;
end if;
select many enumerators related by edt->S_ENUM[R27];
for each enumerator in enumerators
  if(enumerator != self and enumerator.Name == self.Name)
    MI_IM::createIssue(sys_id:sys_id, description:
       "Found another enumerator under the same enumeration data type with a" +
                                                          " matching name.",
                                       severity:Severity::Error, name:self.Name,
                  path:dt.getPath(path:"", includeSelf:true) + "::" + self.Name,
                             id:self.Enum_ID, element:self.convertToInstance());
  end if;
end for;',
	1,
	'',
	7978);
INSERT INTO O_NBATTR
	VALUES (172,
	39);
INSERT INTO O_BATTR
	VALUES (172,
	39);
INSERT INTO O_ATTR
	VALUES (172,
	39,
	0,
	'Enum_ID',
	'Full Name: Enumerator Identifier',
	'',
	'Enum_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (7983,
	39);
INSERT INTO O_BATTR
	VALUES (7983,
	39);
INSERT INTO O_ATTR
	VALUES (7983,
	39,
	172,
	'Name',
	'Full Name: Enumerator Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (7984,
	39);
INSERT INTO O_BATTR
	VALUES (7984,
	39);
INSERT INTO O_ATTR
	VALUES (7984,
	39,
	7983,
	'Descrip',
	'Full Name: Enumerator Description',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (39,
	39,
	0,
	172,
	7419,
	7421,
	7420,
	7985,
	7986,
	0,
	0,
	'',
	'Enumerator',
	'Enum_ID',
	'R56');
INSERT INTO O_RATTR
	VALUES (7985,
	39,
	172,
	39,
	1,
	'Enum_ID');
INSERT INTO O_ATTR
	VALUES (7985,
	39,
	7987,
	'Previous_Enum_ID',
	'',
	'Previous_',
	'Enum_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (39,
	7262,
	0,
	7304,
	7302,
	7305,
	7303,
	7987,
	7988,
	0,
	0,
	'',
	'Enumeration Data Type',
	'DT_ID',
	'R27');
INSERT INTO O_RATTR
	VALUES (7987,
	39,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (7987,
	39,
	7984,
	'EDT_DT_ID',
	'',
	'EDT_',
	'Element_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	39);
INSERT INTO O_OIDA
	VALUES (172,
	39,
	0,
	'Enum_ID');
INSERT INTO O_ID
	VALUES (1,
	39);
INSERT INTO O_ID
	VALUES (2,
	39);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (7262,
	'Enumeration Data Type',
	14,
	'S_EDT',
	'An enumeration is a data type represented by a set of constants called enumerators.  For example, an enumeration called Colors might have three enumerators Red, Blue, and Green.',
	7221);
INSERT INTO O_TFR
	VALUES (7989,
	7262,
	'dispose',
	'The dispose operation for this class.',
	19,
	1,
	'select many enums related by self->S_ENUM[R27];
for each enum in enums
  enum.dispose();
end for;
select one dt related by self->S_DT[R17];
unrelate self from dt across R17;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (7990,
	7262,
	'newEnumerator',
	'Create a new enumerator for this enumeration.',
	19,
	1,
	'create object instance enum of S_ENUM;
relate self to enum across R27;
enum.initialize();
',
	1,
	'',
	7991);
INSERT INTO O_TFR
	VALUES (7992,
	7262,
	'rename',
	'Rename this enumeration data type.',
	19,
	1,
	'select one dt related by self->S_DT[R17];
dt.Name = param.new_name;
',
	1,
	'',
	7990);
INSERT INTO O_TPARM
	VALUES (7993,
	7992,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7994,
	7262,
	'get_name',
	'Return the name of this enumeration data type.',
	322,
	1,
	'select one dt related by self->S_DT[R17];
if (empty dt)
  return "";
else
  return dt.Name;
end if;',
	1,
	'',
	7995);
INSERT INTO O_TFR
	VALUES (7996,
	7262,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.DT_ID;',
	1,
	'',
	7994);
INSERT INTO O_TFR
	VALUES (7997,
	7262,
	'get_compartment_text',
	'',
	322,
	1,
	'result = "";
if (param.comp_num == 1)
  if (param.at == Justification::Center_in_X)
   result = "enumeration";
    result = result + GD::newline();
    select one selfDt related by self->S_DT[R17];
    if ( not_empty selfDt )
      result = result + selfDt.Name;
      select one pe related by selfDt->PE_PE[R8001];
      if not_empty pe
        result = pe.getVisibilityAdornment() + result;
      end if;
    else
      result = result + ::getOrphanedElementName();
    end if;
  end if;
else
  if (param.at == Justification::Left)
    select any enum related by self->S_ENUM[R27] where (selected.Previous_Enum_ID == GD::NULL_UNIQUE_ID());
    cursor = param.ent_num;
    while (not_empty enum AND cursor > 1)
      select one enum related by enum->S_ENUM[R56.''precedes''];
      cursor = cursor - 1;
    end while;
    if (empty enum) 
      result = "";
    else
      result = enum.Name;
    end if;
  end if;
end if;
return result;',
	1,
	'',
	7989);
INSERT INTO O_TPARM
	VALUES (7998,
	7997,
	'comp_num',
	298,
	0,
	'',
	7999,
	'');
INSERT INTO O_TPARM
	VALUES (8000,
	7997,
	'ent_num',
	298,
	0,
	'',
	7998,
	'');
INSERT INTO O_TPARM
	VALUES (7999,
	7997,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8001,
	7262,
	'get_compartments',
	'',
	298,
	1,
	'return 2;',
	1,
	'',
	7997);
INSERT INTO O_TFR
	VALUES (7995,
	7262,
	'get_entries',
	'',
	298,
	1,
	'if (param.comp_num == 1)
  return 1;
else
  select many enums related by self->S_ENUM[R27];
  return cardinality enums;
end if;',
	1,
	'',
	8001);
INSERT INTO O_TPARM
	VALUES (8002,
	7995,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8003,
	7262,
	'get_style',
	'',
	784,
	1,
	'return Style::Box;',
	1,
	'',
	7996);
INSERT INTO O_TFR
	VALUES (8004,
	7262,
	'get_text_style',
	'',
	784,
	1,
	'return Style::None;',
	1,
	'',
	8003);
INSERT INTO O_TPARM
	VALUES (8005,
	8004,
	'comp_num',
	298,
	0,
	'',
	8006,
	'');
INSERT INTO O_TPARM
	VALUES (8007,
	8004,
	'ent_num',
	298,
	0,
	'',
	8005,
	'');
INSERT INTO O_TPARM
	VALUES (8006,
	8004,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (7991,
	7262,
	'initializeOrder',
	'',
	19,
	1,
	'// Alpha-sort the S_ENUM elements if they have not yet been ordered
select many peers related by self->S_ENUM[R27];
if (cardinality peers > 1)
    initialOrderingCheckPerformed = false;
	select any head related by self->S_ENUM[R27] where (selected.Enum_ID == GD::NULL_UNIQUE_ID());
	endOfList = head;
    loopCnt = 0;
	for each peer in peers
	  if ( not initialOrderingCheckPerformed )
	    select one predecessor related by peer->S_ENUM[R56.''precedes''];
	    select one successor related by peer->S_ENUM[R56.''succeeds''];
	    initialOrderingCheckPerformed = true;
	    if (not_empty  predecessor or not_empty  successor)
	      // Already ordered
	      break;
	    end if;
	    head = peer;
	    endOfList = peer;
	  end if;
	  
      if (loopCnt == 1)
        if (peer.Name < head.Name)
          relate peer to head across R56.''precedes'';
          endOfList = peer;
        else
          relate head to peer across R56.''precedes'';
          head = peer;
        end if;
      elif (loopCnt > 1)
        insertPoint = head;
        select one next related by head->S_ENUM[R56.''succeeds''];
        while (not_empty next)
          if (next.Name < peer.Name)
            break;
          else
            insertPoint = next;          
            select one next related by next->S_ENUM[R56.''succeeds''];
          end if;
        end while;
        
        if (empty next)
          // New end of list
          relate peer to endOfList across R56.''precedes'';   
          endOfList = peer;       
        else
          if ((insertPoint == head) and (peer.Name > head.Name))
            // New head
            relate head to peer across R56.''precedes'';
            head = peer;
          else
            unrelate next from insertPoint across R56.''precedes'';
            relate peer to insertPoint across R56.''precedes'';
            relate next to peer across R56.''precedes'';
          end if;          
        end if;
      end if;
      
      loopCnt = loopCnt + 1;
	end for;
end if;',
	1,
	'',
	8004);
INSERT INTO O_TFR
	VALUES (8008,
	7262,
	'actionFilter',
	'',
	316,
	1,
	'if(param.name == "can")
	if param.value == "make public"
		select one pe related by self->S_DT[R17]->PE_PE[R8001];
		select one pkg related by pe->EP_PKG[R8000];
		if not_empty pkg
			if not_empty pe 
				return pe.Visibility != Visibility::Public;
			end if;
		end if;
	end if;
	if param.value == "make protected"
		select one pe related by self->S_DT[R17]->PE_PE[R8001];
		select one pkg related by pe->EP_PKG[R8000];
		if not_empty pkg
    		if not_empty pe 
      			return pe.Visibility != Visibility::Protected;
    		end if;
  		end if;
  	end if;
	if param.value == "make private"
		select one pe related by self->S_DT[R17]->PE_PE[R8001];
		select one pkg related by pe->EP_PKG[R8000];
		if not_empty pkg
    		if not_empty pe 
      			return pe.Visibility != Visibility::Private;
    		end if;
  		end if;
  	end if;
end if;
return false;',
	1,
	'',
	7992);
INSERT INTO O_TPARM
	VALUES (8009,
	8008,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (8010,
	8008,
	'value',
	322,
	0,
	'',
	8009,
	'');
INSERT INTO O_TFR
	VALUES (8011,
	7262,
	'pasteEnumerator',
	'',
	19,
	1,
	'select any enumerator from instances of S_ENUM
                                           where (selected.Enum_ID == param.id);
if(not_empty enumerator)
  select one existingEDT related by enumerator->S_EDT[R27];
  if(not_empty existingEDT)
    unrelate enumerator from existingEDT across R27;
  end if;
  relate enumerator to self across R27;
  enumerator.Name = ::getUniqueInitialNameInParent(
                                        instance:enumerator.convertToInstance(),
                         name:enumerator.Name, parent:self.convertToInstance());
  self.addEnumeratorToOrder(id:enumerator.Enum_ID);
end if;',
	1,
	'',
	8008);
INSERT INTO O_TPARM
	VALUES (8012,
	8011,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8013,
	7262,
	'addEnumeratorToOrder',
	'',
	19,
	1,
	'select any enumerator from instances of S_ENUM
                                           where (selected.Enum_ID == param.id);
if(not_empty enumerator)
  ::changeNotificationEnablement(enabled:false);
  select many peers related by self->S_ENUM[R27];
  for each peer in peers
    if (peer != enumerator)
      select one predecessor related by peer->S_ENUM[R56.''precedes''];
      if (empty predecessor)
        relate enumerator to peer across R56.''succeeds'';
      end if;
    end if;
  end for;
  ::changeNotificationEnablement(enabled:true);
end if;',
	1,
	'',
	8011);
INSERT INTO O_TPARM
	VALUES (8014,
	8013,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8015,
	7262,
	'convertToInstance',
	'Translate: native',
	317,
	1,
	'return this;',
	0,
	'',
	8013);
INSERT INTO O_TFR
	VALUES (8016,
	7262,
	'checkIntegrity',
	'',
	19,
	1,
	'// create an integrity issue if there are any other data types under
// the same package with the same name
select one dt related by self->S_DT[R17];
select one package related by dt->PE_PE[R8001]->EP_PKG[R8000];
select one component related by dt->PE_PE[R8001]->C_C[R8003];
if(not empty component)
  pkgId = component.getPackageId();
  select any package from instances of EP_PKG
                                           where (selected.Package_ID == pkgId);
end if;
select one system related by package->S_SYS[R1405];
sys_id = GD::NULL_UNIQUE_ID();
if(not_empty system)
  sys_id = system.Sys_ID;
end if;
select many dts related by dt->PE_PE[R8001]->EP_PKG[R8000]
                                                    ->PE_PE[R8000]->S_DT[R8001];
if(empty dts)
  select many dts related by dt->PE_PE[R8001]->C_C[R8003]
                                                    ->PE_PE[R8003]->S_DT[R8001];
end if;
for each otherDt in dts
  if(otherDt != dt and otherDt.Name == dt.Name)
    MI_IM::createIssue(sys_id:sys_id, description:
           "Found another data type under the same package with a " +
                                                          "matching name.",
                                       severity:Severity::Error, name:dt.Name,
                       path:dt.getPath(path:"", includeSelf:true),
                              id:dt.DT_ID, element:self.convertToInstance());
  end if;
end for;',
	1,
	'',
	8015);
INSERT INTO O_TFR
	VALUES (8017,
	7262,
	'getDescription',
	'',
	322,
	1,
	'select one dt related by self->S_DT[R17];
return dt.Descrip;',
	1,
	'',
	8016);
INSERT INTO O_REF
	VALUES (7262,
	32,
	0,
	156,
	7256,
	7263,
	7257,
	7304,
	8018,
	0,
	0,
	'',
	'Data Type',
	'DT_ID',
	'R17');
INSERT INTO O_RATTR
	VALUES (7304,
	7262,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (7304,
	7262,
	0,
	'DT_ID',
	'',
	'',
	'Element_ID',
	2,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	7262);
INSERT INTO O_OIDA
	VALUES (7304,
	7262,
	0,
	'DT_ID');
INSERT INTO O_ID
	VALUES (1,
	7262);
INSERT INTO O_ID
	VALUES (2,
	7262);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (7346,
	'EE Package in Package',
	24,
	'S_EEPIP',
	'EE Package in Package represents External Entity Packages nested within other External Entity Packages.',
	7221);
INSERT INTO O_REF
	VALUES (7346,
	7338,
	0,
	7340,
	7344,
	7347,
	7345,
	7350,
	8019,
	0,
	0,
	'',
	'External Entity Package',
	'EEPack_ID',
	'R34');
INSERT INTO O_RATTR
	VALUES (7350,
	7346,
	7340,
	7338,
	1,
	'EEPack_ID');
INSERT INTO O_ATTR
	VALUES (7350,
	7346,
	0,
	'EEPack_ID',
	'',
	'',
	'EEPack_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	7346);
INSERT INTO O_OIDA
	VALUES (7350,
	7346,
	0,
	'EEPack_ID');
INSERT INTO O_ID
	VALUES (1,
	7346);
INSERT INTO O_ID
	VALUES (2,
	7346);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (699,
	'Domain',
	1,
	'S_DOM',
	'A typical software system generally consists of distinct and independent subject matters. A Shlaer-Mellor analysis partition is based within each of these subject matters and  each subject matter is called a domain (S_DOM). A domain is inhabited by its  own conceptual entities (called classes). A domain may be partitioned into subsystems depending upon its complexity. Each domain is given a mission statement which provides a charter for the construction of the OOA models.',
	7221);
INSERT INTO O_TFR
	VALUES (8020,
	699,
	'newSubsystem',
	'Create a new Subsystem in this Domain.',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
create object instance ss of S_SS;
relate self to ss across R1;
create object instance sid of S_SID;
relate self to ss across R43 using sid;
ss.initialize();',
	1,
	'',
	8021);
INSERT INTO O_TFR
	VALUES (8022,
	699,
	'newExternalEntity',
	'Create a new External Entity in this Domain.',
	19,
	1,
	'create object instance ee of S_EE;
relate self to ee across R8;
ee.initialize();',
	1,
	'',
	8023);
INSERT INTO O_TFR
	VALUES (8024,
	699,
	'dispose',
	'Dispose of this domain.
',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one sys related by self->S_SYS[R28];
unrelate self from sys across R28;
select many sses related by self->S_SS[R43];
for each ss in sses
  ss.dispose();
end for;
select many eepks related by self->S_EEPK[R36];
for each eepk in eepks
  eepk.dispose();
end for;
select many fpks related by self->S_FPK[R29];
for each fpk in fpks
  fpk.dispose();
end for;
select many dpks related by self->S_DPK[R40];
for each dpk in dpks
  // If the domain is disposing, we want the data type package to
  // dispose whether or not it contains core data types.
  dpk.internal_dispose();
end for;
// dispose any sequences related to this domain
select many sequences related by self->SQ_S[R913];
for each sequence in sequences
  sequence.dispose();
end for;
// dispose any communications related to this domain
select many comms related by self->COMM_COMM[R1132];
for each comm in comms
  comm.dispose();
end for;
// dispose any use cases
select many uccs related by self->UC_UCC[R1201];
for each ucc in uccs
  ucc.dispose();
end for;
// dispose any activities related to this domain
select many acts related by self->A_A[R1100];
for each act in acts
  act.dispose();
end for;
select one dac related by self->CN_DC[R4204];
if(not_empty dac)
  select one component related by dac->C_C[R4204];
  unrelate self from component across R4204 using dac;
  delete object instance dac;
end if;

select many diss related by self->S_DIS[R47];
for each dis in diss
  select one dt related by dis->S_DT[R47];
  unrelate self from dt across R47 using dis;
  delete object instance dis;
  dt.dispose();
end for;


delete object instance self;',
	1,
	'',
	8025);
INSERT INTO O_TFR
	VALUES (8023,
	699,
	'newDatatypePackage',
	'Create a new data type package for this domain.',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
create object instance dPkg of S_DPK;
create object instance sp of EP_SPKG;
relate dPkg to sp across R1402;
relate self to dPkg across R40;
dPkg.initialize();
',
	1,
	'',
	8026);
INSERT INTO O_TFR
	VALUES (8027,
	699,
	'newExternalEntityPackage',
	'Create a new External Entity Package for this domain.',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
create object instance ePkg of S_EEPK;
relate self to ePkg across R36;
create object instance ePkgInDomain of PL_EEPID;
relate self to ePkg across R300 using ePkgInDomain;
ePkg.initialize();
',
	1,
	'',
	8022);
INSERT INTO O_TFR
	VALUES (8028,
	699,
	'newFunctionPackage',
	'Create a new Function Package for this domain.',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
create object instance fPkg of S_FPK;
relate self to fPkg across R29;
create object instance fPkgInDomain of PL_FPID;
relate self to fPkg across R301 using fPkgInDomain;
fPkg.initialize();
',
	1,
	'',
	8027);
INSERT INTO O_TFR
	VALUES (8029,
	699,
	'get_ooa_id',
	'The ooa_id of a Domain is it''s Dom_ID.
-----------------------------------------------------------------------------------
Bridge:GD',
	296,
	1,
	'return self.Dom_ID;
',
	1,
	'',
	8024);
INSERT INTO O_TFR
	VALUES (8021,
	699,
	'newSequence',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
create object instance sequence of SQ_S;
create object instance sp of EP_SPKG;
relate sequence to sp across R1402;
relate self to sequence across R913;
sequence.initialize();',
	1,
	'',
	8028);
INSERT INTO O_TFR
	VALUES (8026,
	699,
	'newCommunication',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
create object instance communication of COMM_COMM;
create object instance sp of EP_SPKG;
relate communication to sp across R1402;
relate self to communication across R1132;
communication.initialize();',
	1,
	'',
	8030);
INSERT INTO O_TFR
	VALUES (8031,
	699,
	'newUseCasePackage',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
create object instance ucc of UC_UCC;
create object instance sp of EP_SPKG;
relate ucc to sp across R1402;
relate self to ucc across R1201;
ucc.initialize();',
	1,
	'',
	8020);
INSERT INTO O_TFR
	VALUES (8030,
	699,
	'newActivity',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
create object instance a of A_A;
create object instance sp of EP_SPKG;
relate sp to a across R1402;
relate self to a across R1100;
a.initialize();',
	1,
	'',
	8029);
INSERT INTO O_TFR
	VALUES (8032,
	699,
	'actionFilter',
	'Bridge:UI',
	316,
	1,
	'if (param.name == "can" and param.value == "launchVerifier")
  return not self.IsBeingVerified;
else
  return false;
end if;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (8033,
	8032,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (8034,
	8032,
	'value',
	322,
	0,
	'',
	8033,
	'');
INSERT INTO O_TFR
	VALUES (8035,
	699,
	'setupWirings',
	'This operation looks for any bridge to domain function wirings that need to be
created for each bridge in this domain.  First each bridge is related to a new
instance of the Automatic Wiring class. Then a search is performed across all
other domains in the system for a domain function that matches the bridge. If
one is found then the Function is related to the Automatic Wiring. Subsequent
bridge invocations can use these relationships to determine if a bridge is
wired to a domain function without searching. It is exepected that this search 
for wirings take place during the launch of a verifier session(not during model
verification).',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Domain.setupWirings() 
select one sysmodel related by self->S_SYS[R28];
select many doms related by sysmodel->S_DOM[R28];
select many ees related by self->S_EE[R8];
for each ee in ees
  select many bridges related by ee->S_BRG[R19];
  for each brg in bridges
    //create the wiring, not associated with any function initially
    create object instance wiring of S_AW;
    relate wiring to brg across R3200;    
    select many statements related by brg->ACT_BRB[R697]->ACT_ACT[R698]->ACT_BLK[R666]->ACT_SMT[R602];
    if (empty statements)
      // This bridge doesn''t contain any statements. Attempt to wire it to a 
      // domain function.      
      wiring_found = false;
      for each dom in doms
        if (wiring_found)
          break;
        end if;
        if (dom.IsBeingVerified and dom.Name == ee.Key_Lett)
          // Now look for a function name matching this bridge name 
          select many function_pkgs related by dom->S_FPK[R29];
          for each function_pkg in function_pkgs;
            if (wiring_found)
              break;
            end if;
            select any function related by function_pkg->S_SYNC[R31] where (selected.Name == brg.Name);
            if (not_empty function)
              // At this stage in the search we have found a domain function(in
              // a domain that marked as being verified) with the same name as 
              // the bridge. Time to verify that the paramters match.
              select many bridge_params related by brg->S_BPARM[R21];
              params_match = true;
              for each bridge_param in bridge_params
                // Now we need to find the function parameter with the same name
                select any func_param related by function->S_SPARM[R24] where (selected.Name == bridge_param.Name);
                if (empty func_param)
                  params_match = false;
                  break;
                end if;
                // And finally we need to check that the datatypes are the same
                select one brg_param_dt related by bridge_param->S_DT[R22];
                select one func_param_dt related by func_param->S_DT[R26];
                if (brg_param_dt.getCoreDataTypeName() != func_param_dt.getCoreDataTypeName())
                  params_match = false;
                  break;
                end if;                 
              end for; // for each bridge_param
              // If the parameters do not match then continue searching in the 
              // other function packages
              if (not params_match)
                continue;
              end if;
              // We have found a match. Associate the wiring to the function.
              relate function to wiring across R3201; 
              wiring_found = true;             
            end if; // not empty function
          end for; //each function_pkg          
        end if; //dom.name == ee.Key_Lett      
      end for; // each dom      
    else 
      continue;  // continue with the next bridge since this one has OAL stmts.
    end if; // empty statements    
  end for; // each brg   
end for; // each ee(external entity)',
	1,
	'',
	8036);
INSERT INTO O_TFR
	VALUES (8037,
	699,
	'removeWirings',
	'This operation removes any wirings created by the setupWirings operation. For
each domain, this operation should be executed before attempting to call the 
setupWirings operation.',
	19,
	1,
	'// Domain.removeWirings()
select many wirings from instances of S_AW;
for each wiring in wirings
  wiring.dispose();
end for;',
	1,
	'',
	8038);
INSERT INTO O_TFR
	VALUES (8039,
	699,
	'pasteSubsystem',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any subsystem from instances of S_SS where (selected.SS_ID == param.id);
if(not_empty subsystem)
  select one existingDomain related by subsystem->S_DOM[R1];
  if(not_empty existingDomain)
    unrelate existingDomain from subsystem across R1;
  end if;
  select one existingSID related by subsystem->S_SID[R43];
  if(not_empty existingSID)
    select one existingDomain related by existingSID->S_DOM[R43];
    if(not_empty existingDomain)
      unrelate subsystem from existingDomain across R43 using existingSID;
    end if;
  else
    // if the pasted in subsystem was nested in another
    // subsystem, then convert it to a top level subsystem
    select one sis related by subsystem->S_SIS[R42];
    if(not_empty sis)
      select one parentSS related by sis->S_SS[R41];
      if(not_empty parentSS)
        sis.dispose();
      end if;
    end if;
    create object instance existingSID of S_SID;
  end if;
  // for every nested subsystem of the one being copied
  // fix the association between this domain across R1
  subsystem.associateChildSubsystemsToDomain(dom_id:self.Dom_ID);
  subsystem.Name = ::getUniqueInitialNameInParent(instance:subsystem.convertToInstance(),
  						name:subsystem.Name, parent:self.convertToInstance());
  relate subsystem to self across R1;
  relate subsystem to self across R43 using existingSID;
  subsystem.removeIncompleteNonLocalEvents();
end if;',
	1,
	'',
	8040);
INSERT INTO O_TPARM
	VALUES (8041,
	8039,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8025,
	699,
	'convertToInstance',
	'Translate: native',
	317,
	1,
	'return this;',
	0,
	'',
	8042);
INSERT INTO O_TFR
	VALUES (8043,
	699,
	'pasteExternalEntityPackage',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any eepkg from instances of S_EEPK where (selected.EEPack_ID == param.id);
if(not_empty eepkg)
  select one prevDomain related by eepkg->S_DOM[R36];
  if(not_empty prevDomain)
    unrelate eepkg from prevDomain across R36;
  end if;
  // guarantee a unique name for the pasted package
  eepkg.Name = ::getUniqueInitialNameInParent(instance:eepkg.convertToInstance(),
  						name:eepkg.Name, parent:self.convertToInstance());
  // connect to self
  relate eepkg to self across R36;
  // now setup the links to the domain
  select one eepid related by eepkg->PL_EEPID[R300];
  if(not_empty eepid)
    select one prevDomain related by eepid->S_DOM[R300];
    unrelate eepkg from prevDomain across R300 using eepid;
    relate eepkg to self across R300 using eepid;
  else
    create object instance eepid of PL_EEPID;
    relate eepkg to self across R300 using eepid;
  end if;
  eepkg.associateChildPackagesToDomain(dom_id:self.Dom_ID);
  // finally associate each ee under the copied
  // package with the domain pasted into
  select many childPkgs related by eepkg->S_EEPIP[R34]->S_EEPK[R35];
  for each childPkg in childPkgs
    select many ees related by childPkg->S_EEIP[R33]->S_EE[R33];
    for each ee in ees
      select one prevDom related by ee->S_DOM[R8];
      if(not_empty prevDom)
        unrelate ee from prevDom across R8;
      end if;
      relate ee to self across R8;
    end for;
  end for;
  select many ees related by eepkg->S_EEIP[R33]->S_EE[R33];
  for each ee in ees
    select one prevDom related by ee->S_DOM[R8];
    if(not_empty prevDom)
      unrelate ee from prevDom across R8;
    end if;
    relate ee to self across R8;
  end for;
end if;',
	1,
	'',
	8044);
INSERT INTO O_TPARM
	VALUES (8045,
	8043,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8046,
	699,
	'pasteFunctionPackage',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any fpkg from instances of S_FPK where (selected.FunPack_ID == param.id);
if(not_empty fpkg)
  // guarantee a unique name for the pasted package
  fpkg.Name = ::getUniqueInitialNameInParent(instance:fpkg.convertToInstance(),
  						name:fpkg.Name, parent:self.convertToInstance());

  select one existDomain related by fpkg->S_DOM[R29];
  if(not_empty existDomain)
    unrelate fpkg from existDomain across R29;
  end if;

  // connect to self
  relate fpkg to self across R29;
  // now setup the links to the domain
  select one fpid related by fpkg->PL_FPID[R301];
  if(not_empty fpid)
    select one prevDomain related by fpid->S_DOM[R301];
    unrelate fpkg from prevDomain across R301 using fpid;
    relate fpkg to self across R301 using fpid;
  else
    create object instance fpid of PL_FPID;
    relate fpkg to self across R301 using fpid;
  end if;
  
  // do the same for any child packages
  fpkg.associateChildPackagesToDomain(dom_id:self.Dom_ID);
  
  // setup R23
  select many functions related by fpkg->S_SYNC[R31];
  for each function in functions
    select one prevDomain related by function->S_DOM[R23];
    if(not_empty prevDomain)
      unrelate function from prevDomain across R23;
    end if;
    relate function to self across R23;
  end for;
  fpkg.associateChildPackageFunctionsToDomain(dom_id:self.Dom_ID);
end if;',
	1,
	'',
	8043);
INSERT INTO O_TPARM
	VALUES (8047,
	8046,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8044,
	699,
	'pasteDataTypePackage',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any dtpkg from instances of S_DPK where (selected.Package_ID == param.id);
if(not_empty dtpkg)
  // guarantee a unique name for the pasted dt package
  dtpkg.Name = ::getUniqueInitialNameInParent(instance:dtpkg.convertToInstance(),
  						name:dtpkg.Name, parent:self.convertToInstance());
  // associate the pasted pkg with this domain
  dtpkg.associateWithDomain(domID:self.Dom_ID);
  // convert the dts in the package and children to domain level
  // dts if necessary
  dtpkg.associateDTSWithDomain(dom_id:self.Dom_ID);
  // convert the constant specs in the package and children to domain level
  // constant specs if necessary
  dtpkg.associateCSPsWithDomain(dom_id:self.Dom_ID);
  // before removing any core dts from this package
  // we must resolve any user dts to new core types
  dtpkg.handleUserDataTypeResolution();
end if;
',
	1,
	'',
	8048);
INSERT INTO O_TPARM
	VALUES (8049,
	8044,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8042,
	699,
	'canCopyDataTypePackage',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any dtPackage related by self->S_DPK[R40] where (selected.Package_ID == param.id);
if(not_empty dtPackage)
  if(dtPackage.Name != ::getCoreDatatypesPackageName())
    return true;
  end if;
end if;
return false;',
	1,
	'',
	8050);
INSERT INTO O_TPARM
	VALUES (8051,
	8042,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8050,
	699,
	'associateChildrenWithSystemCoreTypes',
	'',
	19,
	1,
	'select many coreTypes related by self->S_DT[R14]->S_CDT[R17]
	->S_DT[R17];
for each coreType in coreTypes
  select one system related by self->S_SYS[R28];
  select any matchingSystemType related by system->SLD_SDINP[R4402]
  	->S_DT[R4401]->S_CDT[R17]->S_DT[R17] where (selected.Name == coreType.Name);
  if empty matchingSystemType and not_empty system and system.useGlobals
    select any matchingSystemType related by system->G_EIS[R9100]->PE_PE[R9100]
  	->S_DT[R8001]->S_CDT[R17]->S_DT[R17] where (selected.Name == coreType.Name);
  end if;
  select many functions related by coreType->S_SYNC[R25];
  for each function in functions
    unrelate function from coreType across R25;
    relate function to matchingSystemType across R25;
  end for;
  select many functionParams related by coreType->S_SPARM[R26];
  for each functionParam in functionParams
    unrelate functionParam from coreType across R26;
    relate functionParam to matchingSystemType across R26;
  end for;
  select many structureMembers related by coreType->S_MBR[R45];
  for each structureMember in structureMembers
    unrelate structureMember from coreType across R45;
    relate structureMember to matchingSystemType across R45;
  end for;
  select many bridges related by coreType->S_BRG[R20];
  for each brg in bridges
    unrelate brg from coreType across R20;
    relate brg to matchingSystemType across R20;
  end for;
  select many parms related by coreType->S_BPARM[R22];
  for each parm in parms
    unrelate parm from coreType across R22;
    relate parm to matchingSystemType across R22;
  end for;
  select many eedis related by coreType->S_EEDI[R15];
  for each eedi in eedis
    unrelate eedi from coreType across R15;
    relate eedi to matchingSystemType across R15;
  end for;
  select many eeedis related by coreType->S_EEEDI[R16];
  for each eeedi in eeedis
    unrelate eeedi from coreType across R16;
    relate eeedi to matchingSystemType across R16;
  end for;
  select many udts related by coreType->S_UDT[R18];
  for each udt in udts
    if udt.Gen_Type == 0
      select one coreTypeCore related by coreType->S_CDT[R17];
      if(not_empty coreTypeCore)
        unrelate udt from coreType across R18;
        relate udt to matchingSystemType across R18;
      end if;
    end if;
  end for;
  select many evtdis related by coreType->SM_EVTDI[R524];
  for each evtdi in evtdis
    unrelate evtdi from coreType across R524;
    relate evtdi to matchingSystemType across R524;
  end for;
  select many ops related by coreType->O_TFR[R116];
  for each op in ops
    unrelate op from coreType across R116;
    relate op to matchingSystemType across R116;
  end for;
  select many opParms related by coreType->O_TPARM[R118];
  for each opParm in opParms
    unrelate opParm from coreType across R118;
    relate opParm to matchingSystemType across R118;
  end for;
  select many attrs related by coreType->O_ATTR[R114];
  for each attr in attrs
    unrelate attr from coreType across R114;
    relate attr to matchingSystemType across R114;
  end for;
  select many vvars related by coreType->V_VAR[R848];
  for each vvar in vvars
    unrelate vvar from coreType across R848;
    relate vvar to matchingSystemType across R848;
  end for;
  select many constants related by coreType->CNST_SYC[R1500];
  for each constant in constants
    unrelate constant from coreType across R1500;
    relate constant to matchingSystemType across R1500;
  end for;
end for;',
	1,
	'',
	8052);
INSERT INTO O_TFR
	VALUES (8052,
	699,
	'associateChildrenWithSystemBuiltInTypes',
	'',
	19,
	1,
	'select many coreTypes related by self->S_DT[R14]->S_UDT[R17]
	where (selected.Gen_Type != 0);
for each builtInType in coreTypes
  select one coreType related by builtInType->S_DT[R17];
  select one system related by self->S_SYS[R28];
  select many matchingSystemTypes related by system->SLD_SDINP[R4402]->
  	  S_DT[R4401]->S_UDT[R17]->S_DT[R17] where (selected.Name == coreType.Name);
  if empty matchingSystemTypes and not_empty system and system.useGlobals
    select many matchingSystemTypes related by system->G_EIS[R9100]->
                    PE_PE[R9100]->S_DT[R8001]->S_UDT[R17]->S_DT[R17] where
                                               (selected.Name == coreType.Name);
  end if;
  for each matchingSystemType in matchingSystemTypes
    select one udt related by matchingSystemType->S_UDT[R17];
    if(udt.Gen_Type == 0)
      continue;
    end if;
    select many functions related by coreType->S_SYNC[R25];
    for each function in functions
      unrelate function from coreType across R25;
      relate function to matchingSystemType across R25;
    end for;
    select many functionParams related by coreType->S_SPARM[R26];
    for each functionParam in functionParams
      unrelate functionParam from coreType across R26;
      relate functionParam to matchingSystemType across R26;
    end for;
    select many structureMembers related by coreType->S_MBR[R45];
    for each structureMember in structureMembers
      unrelate structureMember from coreType across R45;
      relate structureMember to matchingSystemType across R45;
    end for;
    select many bridges related by coreType->S_BRG[R20];
    for each brg in bridges
      unrelate brg from coreType across R20;
      relate brg to matchingSystemType across R20;
    end for;
    select many parms related by coreType->S_BPARM[R22];
    for each parm in parms
      unrelate parm from coreType across R22;
      relate parm to matchingSystemType across R22;
    end for;
    select many eedis related by coreType->S_EEDI[R15];
    for each eedi in eedis
      unrelate eedi from coreType across R15;
      relate eedi to matchingSystemType across R15;
    end for;
    select many eeedis related by coreType->S_EEEDI[R16];
    for each eeedi in eeedis
      unrelate eeedi from coreType across R16;
      relate eeedi to matchingSystemType across R16;
    end for;
    select many udts related by coreType->S_UDT[R18];
    for each udt in udts
      select one coreTypeCore related by coreType->S_CDT[R17];
      select one systemCoreType related by matchingSystemType->S_CDT[R17];
      unrelate udt from coreType across R18;
      relate udt to matchingSystemType across R18;
    end for;
    select many evtdis related by coreType->SM_EVTDI[R524];
    for each evtdi in evtdis
      unrelate evtdi from coreType across R524;
      relate evtdi to matchingSystemType across R524;
    end for;
    select many ops related by coreType->O_TFR[R116];
    for each op in ops
      unrelate op from coreType across R116;
      relate op to matchingSystemType across R116;
    end for;
    select many opParms related by coreType->O_TPARM[R118];
    for each opParm in opParms
      unrelate opParm from coreType across R118;
      relate opParm to matchingSystemType across R118;
    end for;
    select many attrs related by coreType->O_ATTR[R114];
    for each attr in attrs
      unrelate attr from coreType across R114;
      relate attr to matchingSystemType across R114;
    end for;
    select many vvars related by coreType->V_VAR[R848];
    for each vvar in vvars
      unrelate vvar from coreType across R848;
      relate vvar to matchingSystemType across R848;
    end for;
  end for;
end for;',
	1,
	'',
	8053);
INSERT INTO O_TFR
	VALUES (8053,
	699,
	'associateChildrenWithSuppressedDatatypes',
	'',
	19,
	1,
	'select many suppressedTypes related by self->S_DIS[R47]->S_DT[R47];
for each suppressedType in suppressedTypes
  select any matchingSystemType related by self->S_DT[R14]
                                   where (selected.Name == suppressedType.Name);
  if not_empty matchingSystemType
    select many functions related by matchingSystemType->S_SYNC[R25];
    for each function in functions
      unrelate function from matchingSystemType across R25;
      relate function to suppressedType across R25;
    end for;
    select many functionParams related by matchingSystemType->S_SPARM[R26];
    for each functionParam in functionParams
      unrelate functionParam from matchingSystemType across R26;
      relate functionParam to suppressedType across R26;
    end for;
    select many structureMembers related by matchingSystemType->S_MBR[R45];
    for each structureMember in structureMembers
      unrelate structureMember from matchingSystemType across R45;
      relate structureMember to suppressedType across R45;
    end for;
    select many bridges related by matchingSystemType->S_BRG[R20];
    for each brg in bridges
      unrelate brg from matchingSystemType across R20;
      relate brg to suppressedType across R20;
    end for;
    select many parms related by matchingSystemType->S_BPARM[R22];
    for each parm in parms
      unrelate parm from matchingSystemType across R22;
      relate parm to suppressedType across R22;
    end for;
    select many eedis related by matchingSystemType->S_EEDI[R15];
    for each eedi in eedis
      unrelate eedi from matchingSystemType across R15;
      relate eedi to suppressedType across R15;
    end for;
    select many eeedis related by matchingSystemType->S_EEEDI[R16];
    for each eeedi in eeedis
      unrelate eeedi from matchingSystemType across R16;
      relate eeedi to suppressedType across R16;
    end for;
    select many udts related by matchingSystemType->S_UDT[R18];
    for each udt in udts
      // we don''t want to retarget system level User Defined Types
      select any system related by udt->S_DT[R17]->SLD_SDINP[R4401]->S_SYS[R4402];
      select any global related by udt->S_DT[R17]->PE_PE[R8001]->G_EIS[R9100];
      if empty system and empty global
        select one systemCoreType related by matchingSystemType->S_CDT[R17];
        select one suppressedCoreType related by suppressedType->S_CDT[R17];
        unrelate udt from matchingSystemType across R18;
        relate udt to suppressedType across R18;
      end if;
    end for;
    select many evtdis related by matchingSystemType->SM_EVTDI[R524];
    for each evtdi in evtdis
      unrelate evtdi from matchingSystemType across R524;
      relate evtdi to suppressedType across R524;
    end for;
    select many ops related by matchingSystemType->O_TFR[R116];
    for each op in ops
      unrelate op from matchingSystemType across R116;
      relate op to suppressedType across R116;
    end for;
    select many opParms related by matchingSystemType->O_TPARM[R118];
    for each opParm in opParms
      unrelate opParm from matchingSystemType across R118;
      relate opParm to suppressedType across R118;
    end for;
    select many attrs related by matchingSystemType->O_ATTR[R114];
    for each attr in attrs
      unrelate attr from matchingSystemType across R114;
      relate attr to suppressedType across R114;
    end for;
    select many vvars related by matchingSystemType->V_VAR[R848];
    for each vvar in vvars
      unrelate vvar from matchingSystemType across R848;
      relate vvar to suppressedType across R848;
    end for;
  end if;
end for;',
	1,
	'',
	8032);
INSERT INTO O_TFR
	VALUES (8036,
	699,
	'resolveDataTypeRelativeToSelf',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// first try the domain for the dt
select any resolvedDT related by self->S_DT[R14]
								   where (selected.Name == param.expected_name);
if(empty resolvedDT)
  select one component related by self->CN_DC[R4204]->C_C[R4204];
  // if we did not find a local dt above, see if
  // this domain is the formal content of a component
  select one system related by component->CP_CP[R4608]->S_SYS[R4606];
  if(not_empty component)
    // if so check for a system data type
    resdt_id = GD::NULL_UNIQUE_ID();
    if not_empty system
      resdt_id = system.getCoreTypeId(name:param.expected_name);
    end if;
    select any pe from instances of PE_PE where selected.Element_ID == resdt_id;
    select one resolvedDT related by pe->S_DT[R8001]; 
  end if;
  // if one was still not resolved
  if(empty resolvedDT)
    // default back to integer type, if the domain is not used
    // to formalize a component get the dt from the domain otherwise
    // from the system
    if(empty component)
      select any resolvedDT related by self->S_DT[R14]
								    where (selected.Name == param.default_name);
    else
      resdt_id = GD::NULL_UNIQUE_ID();
      if not_empty system
        resdt_id = system.getCoreTypeId(name:param.default_name);
      end if;
      select any pe from instances of PE_PE where selected.Element_ID == resdt_id;
      select one resolvedDT related by pe->S_DT[R8001]; 
    end if;
  end if;
end if;
if(not_empty resolvedDT)
  return resolvedDT.DT_ID;
end if;

// no dt was found, this is definitely an issue
// log an error and return a null id
USER::logError(msg:"Unable to resolve any data type.",path:"");
return GD::NULL_UNIQUE_ID();',
	1,
	'',
	8037);
INSERT INTO O_TPARM
	VALUES (8054,
	8036,
	'expected_name',
	322,
	0,
	'',
	8055,
	'');
INSERT INTO O_TPARM
	VALUES (8055,
	8036,
	'default_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8056,
	699,
	'participatesInSystem',
	'',
	316,
	1,
	'/*
 *  Returns true if this domain is used to formalize
 *  a component
 */
select one component related by self->CN_DC[R4204]->C_C[R4204];
return not_empty component;',
	1,
	'',
	8031);
INSERT INTO O_TFR
	VALUES (8057,
	699,
	'pasteActivity',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any activity from instances of A_A
                                        where (selected.Package_ID == param.id);
if(not_empty activity)
  // guarantee a unique name for the pasted element
  activity.Name = ::getUniqueInitialNameInParent(instance:activity.convertToInstance(),
                           name:activity.Name, parent:self.convertToInstance());
  activity.associateWithDomain(domID:self.Dom_ID);
end if;',
	1,
	'',
	8056);
INSERT INTO O_TPARM
	VALUES (8058,
	8057,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8048,
	699,
	'pasteCommunication',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any comm from instances of COMM_COMM
                                        where (selected.Package_ID == param.id);
if(not_empty comm)
  // guarantee a unique name for the pasted element
  comm.Name = ::getUniqueInitialNameInParent (instance:comm.convertToInstance(),
           					   name:comm.Name, parent:self.convertToInstance());
  comm.associateWithDomain(domID:self.Dom_ID);
end if;',
	1,
	'',
	8057);
INSERT INTO O_TPARM
	VALUES (8059,
	8048,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8040,
	699,
	'pasteSequence',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any seq from instances of SQ_S where (selected.Package_ID == param.id);
if(not_empty seq)
  // guarantee a unique name for the pasted element
  seq.Name = ::getUniqueInitialNameInParent (instance:seq.convertToInstance(),
           					    name:seq.Name, parent:self.convertToInstance());
  seq.associateWithDomain(domID:self.Dom_ID);
end if;',
	1,
	'',
	8046);
INSERT INTO O_TPARM
	VALUES (8060,
	8040,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8038,
	699,
	'pasteUseCaseDiagram',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any ucd from instances of UC_UCC where (selected.Package_ID == param.id);
if(not_empty ucd)
  // guarantee a unique name for the pasted element
  ucd.Name = ::getUniqueInitialNameInParent (instance:ucd.convertToInstance(),
           					    name:ucd.Name, parent:self.convertToInstance());
  ucd.associateWithDomain(domID:self.Dom_ID);
end if;',
	1,
	'',
	8039);
INSERT INTO O_TPARM
	VALUES (8061,
	8038,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8062,
	699,
	'getContainingComponentId',
	'',
	296,
	1,
	'select one component related by self->CN_DC[R4204]->C_C[R4204];
if(not_empty component)
  return component.Id;
end if;
return GD::NULL_UNIQUE_ID();
',
	1,
	'',
	8035);
INSERT INTO O_TFR
	VALUES (8063,
	699,
	'getPath',
	'',
	322,
	1,
	'path = self.Name;
if(param.path != "")
  path = path + "::" + param.path;
end if;
select one system related by self->S_SYS[R28];
if(not_empty system)
  // if not formalized only return the domain
  // plus any path provided
  return path;
else
  select one component related by self->CN_DC[R4204]->C_C[R4204];
  if(not_empty component)
    return component.getPath(path:param.path, includeSelf:true);
  end if;
end if;
return path;',
	1,
	'',
	8062);
INSERT INTO O_TPARM
	VALUES (8064,
	8063,
	'path',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8065,
	699,
	'getSubsystemCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many subsystems related by self->S_SS[R43];
return cardinality subsystems;',
	1,
	'',
	8063);
INSERT INTO O_TFR
	VALUES (8066,
	699,
	'getSubsystemId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many subsystems related by self->S_SS[R43];
// We''re preincrementing the index
count = -1;
for each subsystem in subsystems
  if (not_empty subsystem)
      count = count+1;
  end if;
  if (count == param.index)
      return subsystem.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	8065);
INSERT INTO O_TPARM
	VALUES (8067,
	8066,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8068,
	699,
	'getExternalEntityPkgCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many externalEntityPckgs related by self->S_EEPK[R36];
return cardinality externalEntityPckgs;',
	1,
	'',
	8066);
INSERT INTO O_TFR
	VALUES (8069,
	699,
	'getExternalEntityPkgId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many externalEntityPckgs related by self->S_EEPK[R36];
// We''re preincrementing the index
count = -1;
for each externalEntityPckg in externalEntityPckgs
  if (not_empty externalEntityPckg)
      count = count+1;
  end if;
  if (count == param.index)
      return externalEntityPckg.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	8068);
INSERT INTO O_TPARM
	VALUES (8070,
	8069,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8071,
	699,
	'getFunctionPckgCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many functionPckgs related by self->S_FPK[R29];
return cardinality functionPckgs;',
	1,
	'',
	8069);
INSERT INTO O_TFR
	VALUES (8072,
	699,
	'getFunctionPckgId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many functionPckgs related by self->S_FPK[R29];
// We''re preincrementing the index
count = -1;
for each functionPckg in functionPckgs
  if (not_empty functionPckg)
      count = count+1;
  end if;
  if (count == param.index)
      return functionPckg.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	8071);
INSERT INTO O_TPARM
	VALUES (8073,
	8072,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8074,
	699,
	'getDatatypePckgCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many datatypePckgs related by self->S_DPK[R40];
return cardinality datatypePckgs;',
	1,
	'',
	8072);
INSERT INTO O_TFR
	VALUES (8075,
	699,
	'getDatatypePckgId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many datatypePckgs related by self->S_DPK[R40];
// We''re preincrementing the index
count = -1;
for each datatypePckg in datatypePckgs
  if (not_empty datatypePckg)
      count = count+1;
  end if;
  if (count == param.index)
      return datatypePckg.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	8074);
INSERT INTO O_TPARM
	VALUES (8076,
	8075,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8077,
	699,
	'getSequenceCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many sequences related by self->SQ_S[R913];
return cardinality sequences;',
	1,
	'',
	8075);
INSERT INTO O_TFR
	VALUES (8078,
	699,
	'getSequenceId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many sequences related by self->SQ_S[R913];
// We''re preincrementing the index
count = -1;
for each sequence in sequences
  if (not_empty sequence)
      count = count+1;
  end if;
  if (count == param.index)
      return sequence.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	8077);
INSERT INTO O_TPARM
	VALUES (8079,
	8078,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8080,
	699,
	'getCommunicationCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many communications related by self->COMM_COMM[R1132];
return cardinality communications;',
	1,
	'',
	8078);
INSERT INTO O_TFR
	VALUES (8081,
	699,
	'getCommunicationId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many communications related by self->COMM_COMM[R1132];
// We''re preincrementing the index
count = -1;
for each communication in communications
  if (not_empty communication)
      count = count+1;
  end if;
  if (count == param.index)
      return communication.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	8080);
INSERT INTO O_TPARM
	VALUES (8082,
	8081,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8083,
	699,
	'getUsecaseCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many usecases related by self->UC_UCC[R1201];
return cardinality usecases;',
	1,
	'',
	8081);
INSERT INTO O_TFR
	VALUES (8084,
	699,
	'getUsecaseId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many usecases related by self->UC_UCC[R1201];
// We''re preincrementing the index
count = -1;
for each usecase in usecases
  if (not_empty usecase)
      count = count+1;
  end if;
  if (count == param.index)
      return usecase.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	8083);
INSERT INTO O_TPARM
	VALUES (8085,
	8084,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8086,
	699,
	'getActivityCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many activities related by self->A_A[R1100];
return cardinality activities;',
	1,
	'',
	8084);
INSERT INTO O_TFR
	VALUES (8087,
	699,
	'getActivityId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many activities related by self->A_A[R1100];
// We''re preincrementing the index
count = -1;
for each activity in activities
  if (not_empty activity)
      count = count+1;
  end if;
  if (count == param.index)
      return activity.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	8086);
INSERT INTO O_TPARM
	VALUES (8088,
	8087,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8089,
	699,
	'getSystemId',
	'',
	296,
	1,
	'// Domain.getSystemId()
select one system related by self->S_SYS[R28];
if not_empty system
  return system.Sys_ID;
else
  select one component related by self->C_C[R4204];
  if not_empty component
    return component.getSystemId();
  end if;
end if;
USER::logError(msg:"Domain.getSystemId()::No parent found.",path:"");
return GD::NULL_UNIQUE_ID();',
	1,
	'',
	8087);
INSERT INTO O_TFR
	VALUES (8090,
	699,
	'removeIncompleteSignalEvents',
	'',
	19,
	1,
	'// for all subsystems under this domain call the same
// named operation
select many subsystems related by self->S_SS[R1];
for each subsystem in subsystems
  subsystem.removeIncompleteSignalEvents();
end for;',
	1,
	'',
	8089);
INSERT INTO O_NBATTR
	VALUES (712,
	699);
INSERT INTO O_BATTR
	VALUES (712,
	699);
INSERT INTO O_ATTR
	VALUES (712,
	699,
	0,
	'Dom_ID',
	'Full Name: Domain Identifier',
	'',
	'Dom_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8091,
	699);
INSERT INTO O_BATTR
	VALUES (8091,
	699);
INSERT INTO O_ATTR
	VALUES (8091,
	699,
	712,
	'Name',
	'Full Name: Domain Name
Description: A name  that represents the subject matter of the domain.',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8092,
	699);
INSERT INTO O_BATTR
	VALUES (8092,
	699);
INSERT INTO O_ATTR
	VALUES (8092,
	699,
	8091,
	'Descrip',
	'Full Name: Domain Description
Description: A brief description of the domain',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8093,
	699);
INSERT INTO O_BATTR
	VALUES (8093,
	699);
INSERT INTO O_ATTR
	VALUES (8093,
	699,
	8092,
	'Full_Der',
	'Full Name: Fully Derived Indicator
Description: A flag indicating whether the Sychronous and Asychronous Communication Diagrams are fully derived from the information contained in the Class Diagram and Action Specifications.
Data Domain: 0 = OCM and OAM are not fully derived, 1 = OCM and OAM are fully derived
enum0: Partially Derived
enum1: Fully Derived
',
	'',
	'Full_Der',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8094,
	699);
INSERT INTO O_BATTR
	VALUES (8094,
	699);
INSERT INTO O_ATTR
	VALUES (8094,
	699,
	8093,
	'Config_ID',
	'Full Name: Configuration Identifier
Description:  The Configuration Identifier of the version management configuration which the domain is part of (refer to Version Management Subsystem). This ID can be used to access the V_CONFIG record corresponding to the Domain/Subsystem Configuration.',
	'',
	'Config_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_REF
	VALUES (699,
	705,
	0,
	754,
	7318,
	7320,
	7319,
	8095,
	8096,
	0,
	0,
	'',
	'System Model',
	'Sys_ID',
	'R28');
INSERT INTO O_RATTR
	VALUES (8095,
	699,
	754,
	705,
	1,
	'Sys_ID');
INSERT INTO O_ATTR
	VALUES (8095,
	699,
	8094,
	'Sys_ID',
	'',
	'',
	'Sys_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (8097,
	699,
	'select one ee related by self->I_EXE[R2948];
self.IsBeingVerified =  not_empty ee;',
	1);
INSERT INTO O_BATTR
	VALUES (8097,
	699);
INSERT INTO O_ATTR
	VALUES (8097,
	699,
	8095,
	'IsBeingVerified',
	'Persistent:false
User_Visible:false',
	'',
	'IsBeingVerified',
	0,
	316,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	699);
INSERT INTO O_OIDA
	VALUES (712,
	699,
	0,
	'Dom_ID');
INSERT INTO O_ID
	VALUES (1,
	699);
INSERT INTO O_ID
	VALUES (2,
	699);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (59,
	'Dimensions',
	36,
	'S_DIM',
	'',
	7221);
INSERT INTO O_NBATTR
	VALUES (8098,
	59);
INSERT INTO O_BATTR
	VALUES (8098,
	59);
INSERT INTO O_ATTR
	VALUES (8098,
	59,
	0,
	'elementCount',
	'This holds the number of elements in this dimension.
User_Visible:false',
	'',
	'elementCount',
	0,
	298,
	'',
	'');
INSERT INTO O_REF
	VALUES (59,
	48,
	0,
	215,
	7407,
	7409,
	7408,
	8099,
	8100,
	0,
	0,
	'',
	'Function Parameter',
	'SParm_ID',
	'R52');
INSERT INTO O_RATTR
	VALUES (8099,
	59,
	215,
	48,
	1,
	'SParm_ID');
INSERT INTO O_ATTR
	VALUES (8099,
	59,
	8101,
	'SParm_ID',
	'',
	'',
	'SParm_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (59,
	46,
	0,
	211,
	7398,
	7400,
	7399,
	8102,
	8103,
	0,
	0,
	'',
	'Bridge Parameter',
	'BParm_ID',
	'R49');
INSERT INTO O_RATTR
	VALUES (8102,
	59,
	211,
	46,
	1,
	'BParm_ID');
INSERT INTO O_ATTR
	VALUES (8102,
	59,
	8099,
	'BParm_ID',
	'',
	'',
	'BParm_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (59,
	6,
	0,
	16,
	7401,
	7403,
	7402,
	8104,
	8105,
	0,
	0,
	'',
	'Bridge',
	'Brg_ID',
	'R50');
INSERT INTO O_RATTR
	VALUES (8104,
	59,
	16,
	6,
	1,
	'Brg_ID');
INSERT INTO O_ATTR
	VALUES (8104,
	59,
	8102,
	'Brg_ID',
	'',
	'',
	'Brg_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (59,
	2992,
	0,
	3083,
	8106,
	8107,
	8108,
	8109,
	8110,
	0,
	0,
	'',
	'Interface Operation',
	'Id',
	'R4018');
INSERT INTO O_RATTR
	VALUES (8109,
	59,
	3136,
	3137,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (8109,
	59,
	8104,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (59,
	37,
	0,
	168,
	1084,
	1086,
	1085,
	8111,
	8112,
	0,
	0,
	'',
	'Attribute',
	'Attr_ID',
	'R120');
INSERT INTO O_RATTR
	VALUES (8111,
	59,
	168,
	37,
	1,
	'Attr_ID');
INSERT INTO O_ATTR
	VALUES (8111,
	59,
	8113,
	'Attr_ID',
	'',
	'',
	'Attr_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (59,
	50,
	0,
	219,
	1087,
	1089,
	1088,
	8114,
	8115,
	0,
	0,
	'',
	'Operation Parameter',
	'TParm_ID',
	'R121');
INSERT INTO O_RATTR
	VALUES (8114,
	59,
	219,
	50,
	1,
	'TParm_ID');
INSERT INTO O_ATTR
	VALUES (8114,
	59,
	8111,
	'TParm_ID',
	'',
	'',
	'TParm_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (59,
	43,
	0,
	201,
	1090,
	1092,
	1091,
	8116,
	8117,
	0,
	0,
	'',
	'Operation',
	'Tfr_ID',
	'R122');
INSERT INTO O_RATTR
	VALUES (8116,
	59,
	201,
	43,
	1,
	'Tfr_ID');
INSERT INTO O_ATTR
	VALUES (8116,
	59,
	8114,
	'Tfr_ID',
	'',
	'',
	'Tfr_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (59,
	55,
	0,
	231,
	7410,
	7412,
	7411,
	8118,
	8119,
	0,
	0,
	'',
	'Structure Member',
	'Member_ID',
	'R53');
INSERT INTO O_RATTR
	VALUES (8118,
	59,
	231,
	55,
	1,
	'Member_ID');
INSERT INTO O_ATTR
	VALUES (8118,
	59,
	8116,
	'Member_ID',
	'',
	'',
	'Member_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (59,
	57,
	0,
	254,
	8120,
	8121,
	8122,
	8123,
	8124,
	0,
	0,
	'',
	'Property Parameter',
	'PP_Id',
	'R4017');
INSERT INTO O_RATTR
	VALUES (8123,
	59,
	254,
	57,
	1,
	'PP_Id');
INSERT INTO O_ATTR
	VALUES (8123,
	59,
	8125,
	'PP_Id',
	'',
	'',
	'PP_Id',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (59,
	52,
	0,
	276,
	1646,
	1648,
	1647,
	8126,
	8127,
	0,
	0,
	'',
	'State Machine Event Data Item',
	'SM_ID',
	'R531');
INSERT INTO O_RATTR
	VALUES (8126,
	59,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (8126,
	59,
	8123,
	'SM_ID',
	'',
	'',
	'SM_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (59,
	52,
	0,
	277,
	1646,
	1648,
	1647,
	8128,
	8129,
	0,
	0,
	'',
	'State Machine Event Data Item',
	'SMedi_ID',
	'R531');
INSERT INTO O_RATTR
	VALUES (8128,
	59,
	277,
	52,
	1,
	'SMedi_ID');
INSERT INTO O_ATTR
	VALUES (8128,
	59,
	8126,
	'SMedi_ID',
	'',
	'',
	'SMedi_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8130,
	59);
INSERT INTO O_BATTR
	VALUES (8130,
	59);
INSERT INTO O_ATTR
	VALUES (8130,
	59,
	8098,
	'dimensionCount',
	'This is a 0-based value that tells us which dimension this instance represents.
User_Visible:false',
	'',
	'dimensionCount',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8131,
	59);
INSERT INTO O_BATTR
	VALUES (8131,
	59);
INSERT INTO O_ATTR
	VALUES (8131,
	59,
	8128,
	'DIM_ID',
	'',
	'',
	'DIM_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_REF
	VALUES (59,
	129,
	0,
	131,
	284,
	285,
	286,
	8132,
	8133,
	0,
	0,
	'',
	'Variable',
	'Var_ID',
	'R849');
INSERT INTO O_REF
	VALUES (59,
	136,
	0,
	258,
	256,
	259,
	257,
	8132,
	8134,
	8133,
	0,
	'',
	'Transient Var',
	'Var_ID',
	'R844');
INSERT INTO O_RATTR
	VALUES (8132,
	59,
	131,
	129,
	1,
	'Var_ID');
INSERT INTO O_ATTR
	VALUES (8132,
	59,
	8131,
	'Var_ID',
	'',
	'',
	'Var_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (59,
	55,
	0,
	232,
	7410,
	7412,
	7411,
	8125,
	8135,
	0,
	0,
	'',
	'Structure Member',
	'Parent_DT_DT_ID',
	'R53');
INSERT INTO O_RATTR
	VALUES (8125,
	59,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (8125,
	59,
	8118,
	'DT_ID',
	'',
	'',
	'Parent_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (59,
	37,
	0,
	169,
	1084,
	1086,
	1085,
	8113,
	8136,
	0,
	0,
	'',
	'Attribute',
	'Obj_ID',
	'R120');
INSERT INTO O_RATTR
	VALUES (8113,
	59,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (8113,
	59,
	8109,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (59,
	8,
	0,
	11,
	7404,
	7406,
	7405,
	8101,
	8137,
	0,
	0,
	'',
	'Function',
	'Sync_ID',
	'R51');
INSERT INTO O_RATTR
	VALUES (8101,
	59,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (8101,
	59,
	8130,
	'Sync_ID',
	'',
	'',
	'Sync_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	59);
INSERT INTO O_OIDA
	VALUES (8131,
	59,
	0,
	'DIM_ID');
INSERT INTO O_ID
	VALUES (1,
	59);
INSERT INTO O_ID
	VALUES (2,
	59);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (7396,
	'Datatype In Suppression',
	35,
	'S_DIS',
	'',
	7221);
INSERT INTO O_REF
	VALUES (7396,
	699,
	0,
	712,
	7393,
	7397,
	7394,
	8138,
	8139,
	0,
	0,
	'',
	'Domain',
	'Dom_ID',
	'R47');
INSERT INTO O_RATTR
	VALUES (8138,
	7396,
	712,
	699,
	1,
	'Dom_ID');
INSERT INTO O_ATTR
	VALUES (8138,
	7396,
	0,
	'Dom_ID',
	'',
	'',
	'Dom_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (7396,
	32,
	0,
	156,
	7393,
	7397,
	7395,
	8140,
	8141,
	0,
	0,
	'',
	'Data Type',
	'DT_ID',
	'R47');
INSERT INTO O_RATTR
	VALUES (8140,
	7396,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (8140,
	7396,
	8138,
	'DT_ID',
	'',
	'',
	'Element_ID',
	2,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	7396);
INSERT INTO O_OIDA
	VALUES (8138,
	7396,
	0,
	'Dom_ID');
INSERT INTO O_OIDA
	VALUES (8140,
	7396,
	0,
	'DT_ID');
INSERT INTO O_ID
	VALUES (1,
	7396);
INSERT INTO O_ID
	VALUES (2,
	7396);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (7357,
	'Data Type Package in Package',
	27,
	'S_DPIP',
	'Data Type Package in Package represents Data Type Packages nested within other Data Type Packages.',
	7221);
INSERT INTO O_REF
	VALUES (7357,
	936,
	0,
	943,
	7355,
	7358,
	7356,
	7362,
	8142,
	0,
	0,
	'',
	'Data Type Package',
	'Package_ID',
	'R37');
INSERT INTO O_RATTR
	VALUES (7362,
	7357,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (7362,
	7357,
	0,
	'Package_ID',
	'',
	'',
	'Package_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	7357);
INSERT INTO O_OIDA
	VALUES (7362,
	7357,
	0,
	'Package_ID');
INSERT INTO O_ID
	VALUES (1,
	7357);
INSERT INTO O_ID
	VALUES (2,
	7357);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (936,
	'Data Type Package',
	25,
	'S_DPK',
	'Data Type Package represents a package of data types.',
	7221);
INSERT INTO O_TFR
	VALUES (8143,
	936,
	'initialize',
	'The initialization operation for this class.',
	19,
	1,
	'self.Name = ::getUniqueInitialName( 
	instance: self.convertToInstance(), 
	candidateName: "Unnamed Data Type Package");',
	1,
	'',
	8144);
INSERT INTO O_TFR
	VALUES (8145,
	936,
	'dispose',
	'The dispose operation for this class.  Also disposes the associated Data Type Package in Package.',
	19,
	1,
	'select many cdts related by self->S_DT[R39]->S_CDT[R17];
if (empty cdts)
  self.internal_dispose();
end if;
',
	1,
	'',
	8146);
INSERT INTO O_TFR
	VALUES (8147,
	936,
	'newDatatypePackage',
	'Create a new Data Type Package in this Data Type Package.
',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one helper related by self->S_DPIP[R37];
if (empty helper)
  create object instance helper of S_DPIP;
  relate self to helper across R37;
end if;
create object instance newDPkg of S_DPK;
create object instance sp of EP_SPKG;
relate newDPkg to sp across R1402;
relate helper to newDPkg across R38;
newDPkg.initialize();',
	1,
	'',
	8148);
INSERT INTO O_TFR
	VALUES (8148,
	936,
	'newDatatype',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Data Type Package::newDatatype()
select any system from instances of S_SYS
                                  where (selected.Sys_ID == self.getSystemId());
create object instance dt of S_DT;
create object instance udt of S_UDT;
relate dt to udt across R17;
isSystemLevel = false;
if(not self.isDomainLevel())
  isSystemLevel = true;
end if;
select any int_dt from instances of S_DT
                                 where (selected.DT_ID == GD::NULL_UNIQUE_ID());
if(not isSystemLevel)
  // if this dt is not being created at the
  // system level, check for the integer at
  // the domain level
  select any dom from instances of S_DOM;
  select any int_dt related by dom->S_DT[R14] where
                                                     selected.Name == "integer";
  if(empty int_dt)
    // if the default dt was not found this is a formal component
    // get the default from the system
    select one dt_sys related by dom->CN_DC[R4204]->C_C[R4204]->CP_CP[R4608]
                                                                 ->S_SYS[R4606];
    intdt_id = GD::NULL_UNIQUE_ID();
    if not_empty dt_sys
      intdt_id = dt_sys.getCoreTypeId(name:"integer");
    end if;
    select any pe from instances of PE_PE where selected.Element_ID == intdt_id;
    select one int_dt related by pe->S_DT[R8001]; 
  end if;
else
  // if this dt is being created at the system level
  // get the default dt from the system
  if(not_empty system)
    intdt_id = system.getCoreTypeId(name:"integer");
    select any pe from instances of PE_PE where selected.Element_ID == intdt_id;
    select one int_dt related by pe->S_DT[R8001]; 
  end if;
end if;
relate udt to int_dt across R18;
create object instance dip of S_DIP;
relate dt to self across R39 using dip;
dt.initialize(newname:"Unnamed Data Type");
// associate the new data type to the system
// or domain
self.associateNewDTWithDomainOrSystem(dt_id:dt.DT_ID);',
	1,
	'',
	8149);
INSERT INTO O_TFR
	VALUES (8150,
	936,
	'newEnumeration',
	'',
	19,
	1,
	'// Data Type Package::newEnumeration()
create object instance dt of S_DT;
create object instance edt of S_EDT;
relate dt to edt across R17;
create object instance dip of S_DIP;
relate dt to self across R39 using dip;
dt.initialize(newname:"Unnamed Enumeration");
// associate the new data type to the system
// or domain
self.associateNewDTWithDomainOrSystem(dt_id:dt.DT_ID);',
	1,
	'',
	8147);
INSERT INTO O_TFR
	VALUES (8151,
	936,
	'internal_dispose',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many csps related by self->CNST_CIP[R1506]->CNST_CSP[R1506];
for each csp in csps
  csp.dispose();
end for;

// we want to dispose void and integer at the end
select many dts related by self->S_DT[R39] where (selected.Name != "integer" and selected.Name != "void");

for each dt in dts
  dt.dispose();
end for;

select any intDt related by self->S_DT[R39] where (selected.Name == "integer");
if ( not_empty intDt )
  intDt.dispose();
end if;
select any voidDt related by self->S_DT[R39] where (selected.Name == "void");
if ( not_empty voidDt )
  voidDt.dispose();
end if;

select one dom related by self->S_DOM[R40];
if not_empty dom
  unrelate dom from self across R40;
end if;
// unrelate from system if system level package
select one sys related by self->SLD_SDP[R4400]->S_SYS[R4400];
if(not_empty sys)
  select one sdp related by self->SLD_SDP[R4400];
  unrelate self from sys across R4400 using sdp;
  delete object instance sdp;
end if;

// dispose all children
select one dpip related by self->S_DPIP[R37];
if (not_empty dpip)
  select many pkgs related by dpip->S_DPK[R38];
  for each pkg in pkgs
    pkg.internal_dispose();
  end for;
  unrelate self from dpip across R37;
  delete object instance dpip;
end if;

// unrelate from parent
select one dpip related by self->S_DPIP[R38];
if (not_empty dpip)
  unrelate self from dpip across R38;
  select many pkgs related by dpip->S_DPK[R38];
  if ( empty pkgs )
    // no children left
    select one parent_dpk related by dpip->S_DPK[R37];
    unrelate dpip from parent_dpk across R37;
    delete object instance dpip;
  end if;
end if;
select one specPkg related by self->EP_SPKG[R1402];
if(not_empty specPkg)
  unrelate self from specPkg across R1402;
  specPkg.dispose();
end if;
// Remove all System Datatype in Package instances
select many sdips related by self->SLD_SDINP[R4401];
for each sdip in sdips
  select one dt related by sdip->S_DT[R4401];
  if not_empty dt
    unrelate dt from self across R4401 using sdip;
  end if;
  select one system related by sdip->S_SYS[R4402];
  unrelate sdip from system across R4402;
  delete object instance sdip;
end for;
//
delete object instance self;',
	1,
	'',
	8143);
INSERT INTO O_TFR
	VALUES (8152,
	936,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Package_ID;',
	1,
	'',
	8153);
INSERT INTO O_TFR
	VALUES (8154,
	936,
	'get_style',
	'',
	784,
	1,
	'return Style::Folder;',
	1,
	'',
	8152);
INSERT INTO O_TFR
	VALUES (8155,
	936,
	'get_compartments',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	8156);
INSERT INTO O_TFR
	VALUES (8156,
	936,
	'get_compartment_text',
	'',
	322,
	1,
	'result = "";
if (param.at == Justification::Center_in_X)
  result = "data type";
elif (param.at == Justification::Center)
  result = self.Name;
end if;
return result;',
	1,
	'',
	8157);
INSERT INTO O_TPARM
	VALUES (8158,
	8156,
	'comp_num',
	298,
	0,
	'',
	8159,
	'');
INSERT INTO O_TPARM
	VALUES (8160,
	8156,
	'ent_num',
	298,
	0,
	'',
	8158,
	'');
INSERT INTO O_TPARM
	VALUES (8159,
	8156,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8161,
	936,
	'get_text_style',
	'',
	784,
	1,
	'return Style::None;',
	1,
	'',
	8154);
INSERT INTO O_TPARM
	VALUES (8162,
	8161,
	'comp_num',
	298,
	0,
	'',
	8163,
	'');
INSERT INTO O_TPARM
	VALUES (8164,
	8161,
	'ent_num',
	298,
	0,
	'',
	8162,
	'');
INSERT INTO O_TPARM
	VALUES (8163,
	8161,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8153,
	936,
	'get_entries',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	8155);
INSERT INTO O_TPARM
	VALUES (8165,
	8153,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8166,
	936,
	'canDelete',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many dps related by self->S_DPIP[R37]->S_DPK[R38];
if (not_empty dps)
  for each dp in dps
    if (not dp.canDelete())
      return false;
    end if;
  end for;
else
  //checking for core data types
  select any coredt related by self->S_DT[R39]->S_CDT[R17];
  if (not_empty coredt)
    return false;
  end if;
  //checking for pre-defined user data types	
  select many userdts related by self->S_DT[R39]->S_UDT[R17];
  if (not_empty userdts)
    for each udt in userdts
      if (not udt.canDelete())
        return false;
      end if;
    end for;
  end if;	
end if;
return true;',
	1,
	'',
	8167);
INSERT INTO O_TFR
	VALUES (8168,
	936,
	'canRename',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
if (self.Name == ::getCoreDatatypesPackageName())
  select many otherdps related by self->S_DOM[R40]->S_DPK[R40];
  if (cardinality otherdps > 1)
    //If there are more then one Datatype packages with name "Datatypes"
    //we need make only that one read-only that which can not be deleted.
    return self.canDelete();
  end if;
  select one dpip related by self->S_DPIP[R38];
  if (empty dpip)
    return false;
  end if;
end if;
return true;',
	1,
	'',
	8166);
INSERT INTO O_TFR
	VALUES (8169,
	936,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'// just return this instance as an Object
return this;',
	0,
	'',
	8168);
INSERT INTO O_TFR
	VALUES (8170,
	936,
	'associateDTSWithSystem',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
/**
 *  This operation will associate all child dt''s with the given system.
 *
 */
select any system from instances of S_SYS where (selected.Sys_ID == param.sys_id);
if(not_empty system)
  // first convert all child dt packages
  select many childPKGs related by self->S_DPIP[R37]->S_DPK[R38];
  for each childPKG in childPKGs
    childPKG.associateDTSWithSystem(sys_id:param.sys_id);
  end for;
  // now convert each datatype to a system level one
  select many dts related by self->S_DIP[R39]->S_DT[R39];
  for each dt in dts
    dt.associateDTWithSystem(sys_id:param.sys_id);
  end for;
end if;',
	1,
	'',
	8171);
INSERT INTO O_TPARM
	VALUES (8172,
	8170,
	'sys_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8171,
	936,
	'associateDTSWithDomain',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
/**
 *  This operation will associate all child dt''s with the given domain.
 *
 */
select any domain from instances of S_DOM where (selected.Dom_ID == param.dom_id);
if(not_empty domain)
  select many childPKGs related by self->S_DPIP[R37]->S_DPK[R38];
  for each childPKG in childPKGs
    childPKG.associateDTSWithDomain(dom_id:param.dom_id);
  end for;
  // convert each dt to a domain defined one
  select many dts related by self->S_DIP[R39]->S_DT[R39];
  for each dt in dts
    dt.associateDTWithDomain(dom_id:param.dom_id);
  end for;
end if;',
	1,
	'',
	8173);
INSERT INTO O_TPARM
	VALUES (8174,
	8171,
	'dom_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8175,
	936,
	'pasteDataTypePackage',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any pkg from instances of S_DPK where (selected.Package_ID == param.id);
if(not_empty pkg)
  // guarantee a unique name for the pasted dt package
  pkg.Name = ::getUniqueInitialNameInParent(instance:pkg.convertToInstance(),
  						name:pkg.Name, parent:self.convertToInstance());
  thisPackageIsDomainLevel = self.isDomainLevel();
  thisPackageIsSystemLevel = not thisPackageIsDomainLevel;
  pkg.associateWithDataTypePackage(pkgID:self.Package_ID);
  // setup the dts appropriately for the
  // the type of dt package this is
  if(thisPackageIsDomainLevel)
    pkg.associateDTSWithDomain(dom_id:self.getDomainId());
    pkg.associateCSPsWithDomain(dom_id:self.getDomainId());
  elif(thisPackageIsSystemLevel)
    pkg.associateDTSWithSystem(sys_id:self.getSystemId());
    pkg.associateCSPsWithSystem(sys_id:self.getSystemId());
  end if;
  // before removing any core dts from this package
  // we must resolve any user dts to new core types
  pkg.handleUserDataTypeResolution();
end if;',
	1,
	'',
	8176);
INSERT INTO O_TPARM
	VALUES (8177,
	8175,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8178,
	936,
	'isDomainLevel',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
domId = self.getDomainId();
select any domain from instances of S_DOM where (selected.Dom_ID == domId);
return not_empty domain;',
	1,
	'',
	8151);
INSERT INTO O_TFR
	VALUES (8157,
	936,
	'getSystemId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one domain related by self->S_DOM[R40];
if(not_empty domain)
  // this dt package is at the domain level
  // return a null id
  return GD::NULL_UNIQUE_ID();
end if;
select one system related by self->SLD_SDP[R4400]->S_SYS[R4400];
select one package related by self->EP_SPKG[R1402]->EP_PKG[R1400];
if(not_empty package)
  select one system related by package->S_SYS[R1405];
end if;
if(empty system)
  select one parent related by self->S_DPIP[R38]->S_DPK[R37];
  select one topParent related by self->S_DPIP[R38]->S_DPK[R37];
  while(empty parent)
    topParent = parent;
    select one parent related by parent->S_DPIP[R38]->S_DPK[R37];
  end while;
  select one system related by topParent->SLD_SDP[R4400]->S_SYS[R4400];
  if(empty system)
    // if the root package was not defined directly under the
    // system, then it is within a package
    select one package related by topParent->EP_SPKG[R1402]->EP_PKG[R1400];
    if(not_empty package)
      select one system related by package->S_SYS[R1405];
    end if;
  end if;
end if;
if(not_empty system)
  return system.Sys_ID;
else
  return GD::NULL_UNIQUE_ID();
end if;',
	1,
	'',
	8179);
INSERT INTO O_TFR
	VALUES (8180,
	936,
	'getDomainId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one domain related by self->S_DOM[R40];
if(empty domain)
  select one parent related by self->S_DPIP[R38]->S_DPK[R37];
  select one topParent related by self->S_DPIP[R38]->S_DPK[R37];
  while(not_empty parent)
    topParent = parent;
    select one parent related by parent->S_DPIP[R38]->S_DPK[R37];
  end while;
  select one domain related by topParent->S_DOM[R40];
end if;
if(not_empty domain)
  return domain.Dom_ID;
else
  return GD::NULL_UNIQUE_ID();
end if;',
	1,
	'',
	8145);
INSERT INTO O_TFR
	VALUES (8144,
	936,
	'handleUserDataTypeResolution',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many udts related by self->S_DIP[R39]->S_DT[R39]->S_UDT[R17];
for each udt in udts
  if(udt.Gen_Type == 0)
    udt.resolveDatatype();
  end if;
end for;
// resolve all child package''s dts
select many childPkgs related by self->S_DPIP[R37]->S_DPK[R38];
for each childPkg in childPkgs
  childPkg.handleUserDataTypeResolution();
end for;',
	1,
	'',
	8161);
INSERT INTO O_TFR
	VALUES (8181,
	936,
	'pasteUserDataType',
	'',
	19,
	1,
	'select any udt from instances of S_UDT where (selected.DT_ID == param.id);
if(not_empty udt)
  // select the previous dt
  select one dt related by udt->S_DT[R17];
  // guarantee a unique name for the pasted dt
  dt.Name = ::getUniqueInitialNameInParent(instance:dt.convertToInstance(),
  						name:dt.Name, parent:self.convertToInstance());
  create object instance dtip of S_DIP;
  relate dt to self across R39 using dtip;
  
  // associate the dt with either a system or domain
  self.associatePastedDTWithDomainOrSystem(id:dt.DT_ID);
end if;',
	1,
	'',
	8182);
INSERT INTO O_TPARM
	VALUES (8183,
	8181,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8184,
	936,
	'pasteEnumerationDataType',
	'',
	19,
	1,
	'select any edt from instances of S_EDT where (selected.DT_ID == param.id);
if(not_empty edt)
  select one dt related by edt->S_DT[R17];
  // guarantee a unique name for the pasted dt
  dt.Name = ::getUniqueInitialNameInParent(instance:dt.convertToInstance(),
  						name:dt.Name, parent:self.convertToInstance());
  create object instance dtip of S_DIP;
  relate dt to self across R39 using dtip;

  // associate the dt with either a system or domain
  self.associatePastedDTWithDomainOrSystem(id:dt.DT_ID);

end if;',
	1,
	'',
	8175);
INSERT INTO O_TPARM
	VALUES (8185,
	8184,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8167,
	936,
	'canCopyUserDataType',
	'',
	316,
	1,
	'select any udt from instances of S_UDT where (selected.DT_ID == param.id);
if(not_empty udt)
  if(udt.Gen_Type == 0)
    return true;
  end if;
end if;
return false;',
	1,
	'',
	8186);
INSERT INTO O_TPARM
	VALUES (8187,
	8167,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8188,
	936,
	'newStructuredDatatype',
	'',
	19,
	1,
	'// Data Type Package::newStructuredDatatype()
create object instance dt of S_DT;
create object instance sdt of S_SDT;
relate dt to sdt across R17;
create object instance dip of S_DIP;
relate dt to self across R39 using dip;
dt.initialize(newname:"Unnamed Structured Data Type");
// associate the new data type to the system
// or domain
self.associateNewDTWithDomainOrSystem(dt_id:dt.DT_ID);',
	1,
	'',
	8150);
INSERT INTO O_TFR
	VALUES (8182,
	936,
	'pasteStructuredDataType',
	'',
	19,
	1,
	'select any sdt from instances of S_SDT where (selected.DT_ID == param.id);
if(not_empty sdt)
  select one dt related by sdt->S_DT[R17];
  // guarantee a unique name for the pasted dt
  dt.Name = ::getUniqueInitialNameInParent(instance:dt.convertToInstance(),
  						name:dt.Name, parent:self.convertToInstance());
  create object instance dtip of S_DIP;
  relate dt to self across R39 using dtip;
  // associate the dt with either a system or domain
  self.associatePastedDTWithDomainOrSystem(id:dt.DT_ID);
end if;',
	1,
	'',
	8184);
INSERT INTO O_TPARM
	VALUES (8189,
	8182,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8190,
	936,
	'associatePastedDTWithDomainOrSystem',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any dt related by self->S_DIP[R39]->S_DT[R39] where (selected.DT_ID == param.id);
domId = self.getDomainId();
select any domain from instances of S_DOM where (selected.Dom_ID == domId);
if(not_empty domain)
  // this is a domain level dt package
  // associate the datatype with the domain
  relate dt to domain across R14;
else
  // this is a system level dt package
  // associate the datatype with the system
  sysId = self.getSystemId();
  select any system from instances of S_SYS where (selected.Sys_ID == sysId);
  if(not_empty system)
    create object instance sdip of SLD_SDINP;
    relate sdip to system across R4402;
    relate dt to self across R4401 using sdip;
  end if;
end if;',
	1,
	'',
	8191);
INSERT INTO O_TPARM
	VALUES (8192,
	8190,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8193,
	936,
	'associateNewDTWithDomainOrSystem',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any dt related by self->S_DIP[R39]->S_DT[R39]
										  where (selected.DT_ID == param.dt_id);
if(not_empty dt)
  select any system from instances of S_SYS where (selected.Sys_ID == self.getSystemId());
  if (not_empty system)
    create object instance systemDT of SLD_SDINP;
    relate systemDT to system across R4402;
    relate dt to self across R4401 using systemDT;
  else
    select any domain from instances of S_DOM
                                  where (selected.Dom_ID == self.getDomainId());
    relate dt to domain across R14;
  end if;
end if;',
	1,
	'',
	8194);
INSERT INTO O_TPARM
	VALUES (8195,
	8193,
	'dt_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8196,
	936,
	'associateWithPackage',
	'',
	19,
	1,
	'// unhook from current parent
self.deassociateFromParent();
// hook up with package
select any package from instances of EP_PKG
                                     where (selected.Package_ID == param.pkgID);
select one specPkg related by self->EP_SPKG[R1402];
relate specPkg to package across R1400;',
	1,
	'',
	8197);
INSERT INTO O_TPARM
	VALUES (8198,
	8196,
	'pkgID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8146,
	936,
	'deassociateFromParent',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one prevDomain related by self->S_DOM[R40];
if(not_empty prevDomain)
  unrelate self from prevDomain across R40;
end if;
// unrelate from system if any
select one sdp related by self->SLD_SDP[R4400];
if(not_empty sdp)
  select one system related by sdp->S_SYS[R4400];
  unrelate self from system across R4400 using sdp;
  delete object instance sdp;
end if;
select one prevDPIP related by self->S_DPIP[R38];
if(not_empty prevDPIP)
  unrelate self from prevDPIP across R38;
  select many pkgs related by prevDPIP->S_DPK[R38];
  if(empty pkgs)
    delete object instance prevDPIP;
  end if;
end if;
select one specPkg related by self->EP_SPKG[R1402];
select one package related by specPkg->EP_PKG[R1400];
if(not_empty package)
  unrelate specPkg from package across R1400;
end if;',
	1,
	'',
	8169);
INSERT INTO O_TFR
	VALUES (8199,
	936,
	'associateWithSystem',
	'',
	19,
	1,
	'self.deassociateFromParent();
select any system from instances of S_SYS
                                         where (selected.Sys_ID == param.sysID);
create object instance sdp of SLD_SDP;
relate self to system across R4400 using sdp;',
	1,
	'',
	8196);
INSERT INTO O_TPARM
	VALUES (8200,
	8199,
	'sysID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8197,
	936,
	'associateWithDomain',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// unhook from current parent
self.deassociateFromParent();
// hook up with domain
select any domain from instances of S_DOM
                                         where (selected.Dom_ID == param.domID);
relate domain to self across R40;',
	1,
	'',
	8201);
INSERT INTO O_TPARM
	VALUES (8202,
	8197,
	'domID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8201,
	936,
	'associateWithDataTypePackage',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// unhook from current parent
self.deassociateFromParent();
// hook up with domain
select any dtpkg from instances of S_DPK
                                     where (selected.Package_ID == param.pkgID);

// setup the necessary nesting elements
select one dpip related by dtpkg->S_DPIP[R37];
if(empty dpip)
  create object instance dpip of S_DPIP;
  relate dtpkg to dpip across R37;
end if;
relate self to dpip across R38;',
	1,
	'',
	8190);
INSERT INTO O_TPARM
	VALUES (8203,
	8201,
	'pkgID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8179,
	936,
	'getPath',
	'',
	322,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
path = self.Name;
if(param.path != "")
  path = path + "::" + param.path;
end if;
select one pip related by self->S_DPIP[R38]->S_DPK[R37];
if(not_empty pip)
  return pip.getPath(path:path);
else
  select one package related by self->EP_SPKG[R1402]->EP_PKG[R1400];
  if(not_empty package)
    return package.getPath(path:path);
  else
    select one domain related by self->S_DOM[R40];
    if(not_empty domain)
      return domain.getPath(path:path);
    else
      select one system related by self->SLD_SDP[R4400]->S_SYS[R4400];
      if(not_empty system)
        return system.Name + "::" + path;
      end if;
    end if;
  end if;
end if;
return "";',
	1,
	'',
	8180);
INSERT INTO O_TPARM
	VALUES (8204,
	8179,
	'path',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8149,
	936,
	'newConstantSpecification',
	'',
	19,
	1,
	'// Data Type Package::newConstantSpecification()
create object instance csp of CNST_CSP;
create object instance cip of CNST_CIP;
relate csp to self across R1506 using cip;

// associate the new Constant Specification to the system or domain
self.associateNewCSPWithDomainOrSystem(csp_id:csp.Constant_Spec_ID);',
	1,
	'',
	8178);
INSERT INTO O_TFR
	VALUES (8194,
	936,
	'associateNewCSPWithDomainOrSystem',
	'',
	19,
	1,
	'// Data Type Package::associateNewCSPWithDomainOrSystem
select any csp related by self->CNST_CIP[R1506]->CNST_CSP[R1506]
                              where (selected.Constant_Spec_ID == param.csp_id);
if(not_empty csp)
  select any system from instances of S_SYS where (selected.Sys_ID == self.getSystemId());
  if (not_empty system)
    create object instance systemCSP of SLD_SCINP;
    relate systemCSP to system across R4404;
    relate csp to self across R4403 using systemCSP;
  else
    // There is no direct association with a domain.  That is handled by the
    // containing datatype package if necessary.
  end if;
end if;',
	1,
	'',
	8170);
INSERT INTO O_TPARM
	VALUES (8205,
	8194,
	'csp_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8191,
	936,
	'associatePastedCSPWithDomainOrSystem',
	'',
	19,
	1,
	'// Data Type Package::associatePastedCSPWithDomainOrSystem()
//
//  Nothing to do here for the domain case as the domain association is handled
//  by the containing data type package.
select any csp related by self->CNST_CIP[R1506]->CNST_CSP[R1506]
                              where (selected.Constant_Spec_ID == param.csp_id);
sysId = self.getSystemId();
select any system from instances of S_SYS where (selected.Sys_ID == sysId);
if(not_empty system)
  create object instance scip of SLD_SCINP;
  relate scip to system across R4404;
  relate csp to self across R4403 using scip;
end if;',
	1,
	'',
	8193);
INSERT INTO O_TPARM
	VALUES (8206,
	8191,
	'csp_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8176,
	936,
	'pasteConstantSpecification',
	'Called when the user want to paste a cut or copied constant specification.',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Data Type Package::pasteConstantSpecification()
select any csp from instances of CNST_CSP where (selected.Constant_Spec_ID == param.id);
if(not_empty csp)
  //unrelate from existing datatype package
  select one prevCIP related by csp->CNST_CIP[R1506];
  if (not_empty prevCIP)
    select one prevDTP related by prevCIP->S_DPK[R1506];
    unrelate csp from prevDTP across R1506 using prevCIP;
    delete object instance prevCIP;
  end if;

  // relate to this package
  create object instance cip of CNST_CIP;
  relate csp to self across R1506 using cip;

  // associate the csp with either a system or domain
  self.associatePastedCSPWithDomainOrSystem(csp_id:csp.Constant_Spec_ID);

end if;',
	1,
	'',
	8188);
INSERT INTO O_TPARM
	VALUES (8207,
	8176,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8208,
	936,
	'associateCSPsWithDomain',
	'This operation will associate all child constant specifications''s with the
given domain.',
	19,
	1,
	'// Data Type Package::associateCSPsWithDomain()
//
//  Nothing to do here as the domain association is handled by the containing
//  data type package.  This function is just provided for completeness.',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (8209,
	8208,
	'dom_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8173,
	936,
	'associateCSPsWithSystem',
	'This operation will associate all child constant specifications with the
given system.',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Data Type Package::associateCSPsWithSystem()
select any system from instances of S_SYS where (selected.Sys_ID == param.sys_id);
if(not_empty system)
  // First recurse through all child dt packages
  select many childPKGs related by self->S_DPIP[R37]->S_DPK[R38];
  for each childPKG in childPKGs
    childPKG.associateCSPsWithSystem(sys_id:param.sys_id);
  end for;

  // Now convert each constant specification to a system level one
  select many csps related by self->CNST_CIP[R1506]->CNST_CSP[R1506];
  for each csp in csps
    csp.associateWithSystem(sys_id:param.sys_id);
  end for;
end if;',
	1,
	'',
	8208);
INSERT INTO O_TPARM
	VALUES (8210,
	8173,
	'sys_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8211,
	936,
	'getUserDatatypeCount',
	'',
	298,
	1,
	'select many userDatatypePckgs related by self->S_DT[R39]->S_UDT[R17];
return cardinality userDatatypePckgs;',
	1,
	'',
	8181);
INSERT INTO O_TFR
	VALUES (8212,
	936,
	'getUserDatatypeId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many userDatatypePckgs related by self->S_DT[R39]->S_UDT[R17];
// We''re preincrementing the index
count = -1;
for each userDatatypePckg in userDatatypePckgs
  if (not_empty userDatatypePckg)
      count = count+1;
  end if;
  if (count == param.index)
      return userDatatypePckg.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	8211);
INSERT INTO O_TPARM
	VALUES (8213,
	8212,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8214,
	936,
	'getStructuredDatatypeCount',
	'',
	298,
	1,
	'select many structuredDatatypePckgs related by self->S_DT[R39]->S_SDT[R17];
return cardinality structuredDatatypePckgs;',
	1,
	'',
	8212);
INSERT INTO O_TFR
	VALUES (8215,
	936,
	'getStructuredDatatypeId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many structuredDatatypePckgs related by self->S_DT[R39]->S_SDT[R17];
// We''re preincrementing the index
count = -1;
for each structuredDatatypePckg in structuredDatatypePckgs
  if (not_empty structuredDatatypePckg)
      count = count+1;
  end if;
  if (count == param.index)
      return structuredDatatypePckg.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	8214);
INSERT INTO O_TPARM
	VALUES (8216,
	8215,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8217,
	936,
	'getEnumDatatypeCount',
	'',
	298,
	1,
	'select many enumDatatypePckgs related by self->S_DT[R39]->S_EDT[R17];
return cardinality enumDatatypePckgs;',
	1,
	'',
	8215);
INSERT INTO O_TFR
	VALUES (8218,
	936,
	'getEnumDatatypeId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many enumDatatypePckgs related by self->S_DT[R39]->S_EDT[R17];
// We''re preincrementing the index
count = -1;
for each enumDatatypePckg in enumDatatypePckgs
  if (not_empty enumDatatypePckg)
      count = count+1;
  end if;
  if (count == param.index)
      return enumDatatypePckg.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	8217);
INSERT INTO O_TPARM
	VALUES (8219,
	8218,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8220,
	936,
	'getConstantSpecCount',
	'',
	298,
	1,
	'select many constantSpecs related by self->CNST_CSP[R1506];
return cardinality constantSpecs;',
	1,
	'',
	8218);
INSERT INTO O_TFR
	VALUES (8221,
	936,
	'getConstantSpecId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many constantSpecs related by self->CNST_CSP[R1506];
// We''re preincrementing the index
count = -1;
for each constantSpec in constantSpecs
  if (not_empty constantSpec)
      count = count+1;
  end if;
  if (count == param.index)
      return constantSpec.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	8220);
INSERT INTO O_TPARM
	VALUES (8222,
	8221,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8223,
	936,
	'getDtPckgCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many dataTypePckgs related by self->S_DPIP[R37]->S_DPK[R38];
return cardinality dataTypePckgs;',
	1,
	'',
	8221);
INSERT INTO O_TFR
	VALUES (8224,
	936,
	'getDtPckgId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many dataTypePckgs related by self->S_DPIP[R37]->S_DPK[R38];
// We''re preincrementing the index
count = -1;
for each dataTypePckg in dataTypePckgs
  if (not_empty dataTypePckg)
      count = count+1;
  end if;
  if (count == param.index)
      return dataTypePckg.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	8223);
INSERT INTO O_TPARM
	VALUES (8225,
	8224,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8186,
	936,
	'canCopyCoreDataType',
	'',
	316,
	1,
	'return false;',
	1,
	'',
	8199);
INSERT INTO O_TPARM
	VALUES (8226,
	8186,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_NBATTR
	VALUES (8227,
	936);
INSERT INTO O_BATTR
	VALUES (8227,
	936);
INSERT INTO O_ATTR
	VALUES (8227,
	936,
	943,
	'Name',
	'Full Name: Data Type Package Name
Description: A name for a package of data types.',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (936,
	699,
	0,
	712,
	7368,
	7370,
	7369,
	8228,
	8229,
	0,
	0,
	'',
	'Domain',
	'Dom_ID',
	'R40');
INSERT INTO O_RATTR
	VALUES (8228,
	936,
	712,
	699,
	1,
	'Dom_ID');
INSERT INTO O_ATTR
	VALUES (8228,
	936,
	8227,
	'Dom_ID',
	'',
	'',
	'Dom_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (936,
	773,
	0,
	772,
	854,
	6809,
	856,
	943,
	8230,
	0,
	0,
	'',
	'Specification Package',
	'Package_ID',
	'R1402');
INSERT INTO O_RATTR
	VALUES (943,
	936,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (943,
	936,
	0,
	'Package_ID',
	'',
	'',
	'SpecificationPackage_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (936,
	7357,
	0,
	7362,
	7359,
	7360,
	7361,
	8231,
	8232,
	0,
	0,
	'',
	'Data Type Package in Package',
	'Package_ID',
	'R38');
INSERT INTO O_RATTR
	VALUES (8231,
	936,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (8231,
	936,
	8228,
	'Parent_Package_ID',
	'',
	'Parent_',
	'Package_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	936);
INSERT INTO O_OIDA
	VALUES (943,
	936,
	0,
	'Package_ID');
INSERT INTO O_ID
	VALUES (1,
	936);
INSERT INTO O_ID
	VALUES (2,
	936);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (7366,
	'Data Type in Package',
	26,
	'S_DIP',
	' Data Type in Package represents the data types contained within a particular package.',
	7221);
INSERT INTO O_REF
	VALUES (7366,
	936,
	0,
	943,
	7363,
	7367,
	7364,
	8233,
	8234,
	0,
	0,
	'',
	'Data Type Package',
	'Package_ID',
	'R39');
INSERT INTO O_RATTR
	VALUES (8233,
	7366,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (8233,
	7366,
	0,
	'Package_ID',
	'',
	'',
	'Package_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (7366,
	32,
	0,
	156,
	7363,
	7367,
	7365,
	8235,
	8236,
	0,
	0,
	'',
	'Data Type',
	'DT_ID',
	'R39');
INSERT INTO O_RATTR
	VALUES (8235,
	7366,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (8235,
	7366,
	8233,
	'DT_ID',
	'',
	'',
	'Element_ID',
	2,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	7366);
INSERT INTO O_OIDA
	VALUES (8233,
	7366,
	0,
	'Package_ID');
INSERT INTO O_OIDA
	VALUES (8235,
	7366,
	0,
	'DT_ID');
INSERT INTO O_ID
	VALUES (1,
	7366);
INSERT INTO O_ID
	VALUES (2,
	7366);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (32,
	'Data Type',
	9,
	'S_DT',
	'An analyst can assign a data type to the various data items in the models, i.e., class attribute, state machine event data item, operation and bridge parameters and return values.  This data type does not capture the representation of the data items, but rather, the characteristics of the data items including:  1) Value Definition, i.e., whole numbers, 2) Value Range, i.e., values between 0 and 10, 3) Operations, i.e., +, -, *, /',
	7221);
INSERT INTO O_TFR
	VALUES (8237,
	32,
	'dispose',
	'The dispose operation for this class.  Return values get set to a default of void.  Parameters to integer.',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Get some default core data types
select one pe related by self->PE_PE[R8001];
select one PKG related by pe->EP_PKG[R8000]; 
select one systemModel related by PKG->S_SYS[R1405];

select any dom from instances of S_DOM;
select any intdt related by dom->S_DT[R14] where selected.Name == "integer";
select any voidDt related by dom->S_DT[R14] where selected.Name == "void";

select one rootPkg related by self->S_DIP[R39]->S_DPK[R39];
actualRootPkg = rootPkg;
select one sys related by rootPkg->SLD_SDP[R4400]->S_SYS[R4400];
if(empty sys)
  while(not_empty rootPkg)
    select one sys related by rootPkg->SLD_SDP[R4400]->S_SYS[R4400];
    select one rootPkg related by rootPkg->S_DPIP[R38]->S_DPK[R37];
    if(not_empty rootPkg)
      actualRootPkg = rootPkg;
    end if;
  end while;
end if;
if(empty sys)
  select one sys related by actualRootPkg->EP_SPKG[R1402]->
                                                  EP_PKG[R1400]->S_SYS[R1405];
  if empty sys
    select one sys related by dom->S_SYS[R28];
  end if;
end if;
if((empty intdt) and (not_empty sys))
  intdt_id = sys.getCoreTypeId(name:"integer");
  select any pe from instances of PE_PE where selected.Element_ID == intdt_id;
  select one intdt related by pe->S_DT[R8001]; 
end if;
if(empty voidDt and not_empty sys)
  voiddt_id = sys.getCoreTypeId(name:"void");
  select any pe from instances of PE_PE where selected.Element_ID == voiddt_id;
  select one voidDt related by pe->S_DT[R8001]; 
end if;

if(empty intdt and empty voidDt)
  // if the void and int data types are still
  // empty then this domain may be the formal
  // content of a component
  select one compSys related by self->S_DOM[R14]->CN_DC[R4204]->C_C[R4204]
                                                   ->CP_CP[R4608]->S_SYS[R4606];
  if not_empty compSys
    intdt_id = compSys.getCoreTypeId(name:"integer");
    select any pe from instances of PE_PE where selected.Element_ID == intdt_id;
    select one intdt related by pe->S_DT[R8001]; 
    voiddt_id = compSys.getCoreTypeId(name:"void");
    select any pe from instances of PE_PE where selected.Element_ID == voiddt_id;
    select one voidDt related by pe->S_DT[R8001];
  end if;
end if;
if(empty intdt and empty voidDt)
  // if the void and int data types are still empty
  if (not_empty systemModel) 
    // look for them from the system associated with the owning package
    intdt_id = systemModel.getCoreTypeId(name:"integer");
    select any pe from instances of PE_PE where selected.Element_ID == intdt_id;
    select one intdt related by pe->S_DT[R8001]; 
    voiddt_id = systemModel.getCoreTypeId(name:"void");
    select any pe from instances of PE_PE where selected.Element_ID == voiddt_id;
    select one voidDt related by pe->S_DT[R8001]; 
  end if;                                               
end if;
//
// Domain Subsystem
select many brgs related by self->S_BRG[R20];
for each brg in brgs
  unrelate self from brg across R20;
  relate brg to voidDt across R20;
  Util::collectModelElementsNames(elementType:"- Bridge : ",elementName:brg.Name);
end for;
select many bparms related by self->S_BPARM[R22];
for each bparm in bparms
  unrelate self from bparm across R22;
  relate bparm to intdt across R22;
  Util::collectModelElementsNames(elementType:"- Bridge Parameter : ",elementName:bparm.Name);
end for;
select many eedis related by self->S_EEDI[R15];
for each eedi in eedis
  unrelate self from eedi across R15;
  relate eedi to intdt across R15;
  Util::collectModelElementsNames(elementType:"- External Entity : ",elementName:eedi.Name);
end for;
select many eeedis related by self->S_EEEDI[R16];
for each eeedi in eeedis
  unrelate self from eeedi across R16;
  relate eeedi to intdt across R16;
  Util::collectModelElementsNames(elementType:"- External Entity Event DataItem : ",elementName:eeedi.Name);
end for;
select many sparms related by self->S_SPARM[R26];
for each sparm in sparms
  unrelate self from sparm across R26;
  relate sparm to intdt across R26;
  Util::collectModelElementsNames(elementType:"- Function Parameter : ",elementName:sparm.Name);
end for;
select many fns related by self->S_SYNC[R25];
for each fn in fns
  unrelate self from fn across R25;
  relate fn to voidDt across R25;
  Util::collectModelElementsNames(elementType:"- Function : ",elementName:fn.Name);
end for;
select many evtdis related by self->SM_EVTDI[R524];
for each evtdi in evtdis
  unrelate self from evtdi across R524;
  relate evtdi to intdt across R524;
 Util::collectModelElementsNames(elementType:"- State Machine Event DataItem : ",elementName:evtdi.Name);
end for;
select many opers related by self->O_TFR[R116];
for each oper in opers
  unrelate self from oper across R116;
  relate oper to voidDt across R116;
  Util::collectModelElementsNames(elementType:"- Operation : ",elementName:oper.Name);
end for;
select many oparms related by self->O_TPARM[R118];
for each oparm in oparms
  unrelate self from oparm across R118;
  relate oparm to intdt across R118;
  Util::collectModelElementsNames(elementType:"- Operation Parameter : ",elementName:oparm.Name);
end for;
select many attrs related by self->O_ATTR[R114];
for each attr in attrs
  unrelate self from attr across R114;
  relate attr to intdt across R114;
   Util::collectModelElementsNames(elementType:"- Attribute : ",elementName:attr.Name);
end for;
select many members related by self->S_MBR[R45];
for each member in members
  unrelate self from member across R45;
  relate member to intdt across R45;
  Util::collectModelElementsNames(elementType:"- Structure Member : ",elementName:member.Name);
end for;
select one udt related by self->S_UDT[R17];
select one edt related by self->S_EDT[R17];
select one cdt related by self->S_CDT[R17];
assign isCoreType = not_empty cdt;
select one sdt related by self->S_SDT[R17];
select one irdt related by self->S_IRDT[R17];
if not_empty udt
  udt.dispose();
elif (not_empty edt)
  edt.dispose();
elif (not_empty cdt)
  cdt.dispose();
elif (not_empty sdt)
  sdt.dispose();
elif (not_empty irdt)
  irdt.dispose();
end if;
select many sycs related by self->CNST_SYC[R1500];
for each syc in sycs
  syc.setToDefaultDatatype();
  Util::collectModelElementsNames(elementType:"- Symbolic Constant : ",elementName:syc.Name);
end for;
//
// Value Subsystem
select many vals related by self->V_VAL[R820];
for each val in vals
  unrelate self from val across R820;
  relate val to intdt across R820;
end for;
select many tvars related by self->V_TRN[R821];
for each tvar in tvars
  unrelate self from tvar across R821;
  relate tvar to intdt across R821;
end for;
select many vvars related by self->V_VAR[R848];
for each vvar in vvars
  unrelate self from vvar across R848;
  relate vvar to intdt across R848;
  Util::collectModelElementsNames(elementType:"- Variable : ",elementName:vvar.Name);
end for;
//
// Finally, unrelate self from DIP and DPK, delete the DIP, and thendelete self
select one dip related by self->S_DIP[R39];
if (not_empty dip)
  select one dpk related by self->S_DPK[R39];
  unrelate self from dpk across R39 using dip;
  delete object instance dip;
end if;
// unrelate from all domains if a system level datatype
select many sdips related by self->SLD_SDINP[R4401];
for each sdip in sdips
  select one dtp related by sdip->S_DPK[R4401];
  unrelate self from dtp across R4401 using sdip;
  select one system related by sdip->S_SYS[R4402];
  unrelate sdip from system across R4402;
  delete object instance sdip;
end for;
//
select one dom related by self->S_DOM[R14];
if(not_empty dom)
  unrelate self from dom across R14;
end if;

select many diss related by self->S_DIS[R47];
for each dis in diss
  select one domain related by dis->S_DOM[R47];
  unrelate self from domain across R47 using dis;
  delete object instance dis;
end for;

select many ios related by self->C_IO[R4008];
for each io in ios
  unrelate self from io across R4008;
  relate io to voidDt across R4008;
    Util::collectModelElementsNames(elementType:"- Interface Operation : ",elementName:io.Name);
end for;

select many pps related by self->C_PP[R4007];
for each pp in pps
  unrelate self from pp across R4007;
  relate pp to intdt across R4007;
  Util::collectModelElementsNames(elementType:"- Property Parameter : ",elementName:pp.Name);
end for;

select many udts related by self->S_UDT[R18];
for each udt in udts
  unrelate self from udt across R18;
  udt.changeCoreType(typeName:"integer");
  select one udtDt related by udt->S_DT[R17];
  if(not isCoreType and not_empty udtDt)
    Util::collectModelElementsNames(elementType:"- User Data Type : ",
                                                        elementName:udtDt.Name);
  end if;
end for;

select one packageableElement related by self->PE_PE[R8001];
if not_empty packageableElement
  unrelate self from packageableElement across R8001;
  packageableElement.dispose();
end if;
delete object instance self;',
	1,
	'',
	8238);
INSERT INTO O_TFR
	VALUES (8239,
	32,
	'initialize',
	'The initialization operation for this class.',
	19,
	1,
	'name = ::getUniqueInitialName( 
    instance: self.convertToInstance(), 
    candidateName: param.newname);
    
success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:true);    
if ( success!="") 
 self.Name=success;
else 
 self.dispose();
end if;     ',
	1,
	'',
	8240);
INSERT INTO O_TPARM
	VALUES (8241,
	8239,
	'newname',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8242,
	32,
	'rename',
	'Rename this data type.',
	316,
	1,
	'select one cdt related by self->S_CDT[R17];
if (not_empty cdt)
  // Don''t rename core data types
  return FALSE;
end if;
self.Name = param.new_name;
return TRUE;
',
	1,
	'',
	8243);
INSERT INTO O_TPARM
	VALUES (8244,
	8242,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8243,
	32,
	'isCommonAllowedType',
	'',
	316,
	1,
	'//data Type::isCommonAllowedType()
select one udt related by self -> S_UDT[R17];
if not_empty udt
  return true;
else
  select one edt related by self -> S_EDT[R17];
  if not_empty edt
    return true;
  else
    select one sdt related by self -> S_SDT[R17];
    if not_empty sdt
      return true;
    else
      select one irdt related by self -> S_IRDT[R17];
      if not_empty irdt
        return true;
      else
        if ( self.Name == "boolean" or
          self.Name == "component_ref" or
          self.Name == "integer" or
          self.Name == "string" or
          self.Name == "real" or
          self.Name == "unique_id" or
          self.Name == "inst<Event>" )
          return true;
        end if;
      end if;
    end if;
  end if;
end if;
return false;',
	1,
	'',
	8245);
INSERT INTO O_TFR
	VALUES (8245,
	32,
	'isAllowedReturnType',
	'',
	316,
	0,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// this operation assumes that the caller is
// within a domain context
select any dom from instances of S_DOM where (selected.Dom_ID == param.dom_id);
select any dt related by dom->S_DT[R14] where
                                                selected.Name == param.typeName;
if (empty dt)
  select any dt from instances of S_DT where (selected.Name == param.typeName);
end if;                                                
if not_empty dt 
  if ( dt.isCommonAllowedType() )
    return true;
  elif ( param.typeName == "void"  )
    return true;
  end if;
end if;
  
return false;',
	1,
	'',
	8246);
INSERT INTO O_TPARM
	VALUES (8247,
	8245,
	'typeName',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (8248,
	8245,
	'dom_id',
	296,
	0,
	'',
	8247,
	'');
INSERT INTO O_TFR
	VALUES (8246,
	32,
	'isAllowedParameterType',
	'',
	316,
	0,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// this operation assumes that the caller is
// within a domain context
select any dom from instances of S_DOM where (selected.Dom_ID == param.dom_id);
if(not_empty dom)
  select any dt related by dom->S_DT[R14] where
                                                selected.Name == param.typeName;
  if not_empty dt 
    return dt.isCommonAllowedType();
  end if;
else
  select any dt from instances of S_DT where (selected.Name == param.typeName);  
  if not_empty dt 
    return dt.isCommonAllowedType();
  end if;
end if;
return false;',
	1,
	'',
	8239);
INSERT INTO O_TPARM
	VALUES (8249,
	8246,
	'typeName',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (8250,
	8246,
	'dom_id',
	296,
	0,
	'',
	8249,
	'');
INSERT INTO O_TFR
	VALUES (8238,
	32,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'// just return this instance as an Object
return this;',
	0,
	'',
	8251);
INSERT INTO O_TFR
	VALUES (8240,
	32,
	'getDefaultValue',
	'',
	317,
	1,
	'// Data Type.getDefaultValue()
dtName = self.getCoreDataTypeName();
result = GD::NULL_INSTANCE();
default = self.DefaultValue;  // UI assures that default is valid.
if (dtName == "boolean")
  if default != ""
    result = GD::boolean_to_instance(value:GD::string_to_boolean(value:default));
  else
    result = GD::boolean_to_instance(value:false);
  end if;
elif (dtName == "integer")
  if default != ""
    result = GD::int_to_instance(value:GD::string_to_int(value:default));
  else
    result = GD::int_to_instance(value:0);
  end if;
elif (dtName == "real")
  if default != ""
    result = GD::real_to_instance(value:GD::string_to_real(value:default));
  else
    result = GD::real_to_instance(value:0);
  end if;
elif (dtName == "string")
  result = GD::string_to_instance(value:default);
elif (dtName == "unique_id")
  result = GD::unique_id_to_instance(value:GD::NULL_UNIQUE_ID());
elif (dtName == "void" or dtName == "current_state" or
                     dtName == "same_as_base" or dtName == "inst_ref<Object>" or
                         dtName == "inst<Event>" or dtName == "inst<Mapping>" or
                                                  dtName == "inst_ref<Mapping>")
  USER::logError(msg:"Error: Attempted to get default value for data type, " +
                                                                        dtName,path:"NoPathProvided");
  result = GD::NULL_INSTANCE();
else
  // It''s an enumeration . . . 
  if default != ""
    result = GD::string_to_instance(value:default);
  else
    result = GD::string_to_instance(value:dtName + "::Unknown");  
  end if;
end if;
return result;',
	1,
	'',
	8252);
INSERT INTO O_TFR
	VALUES (8253,
	32,
	'getCoreDataTypeName',
	'',
	322,
	1,
	'select one cdt related by self->S_CDT[R17];
select one udt related by self->S_UDT[R17];
select one edt related by self->S_EDT[R17];
select one irdt related by self->S_IRDT[R17];
if (not_empty cdt)
  if (cdt.Core_Typ == 0) //void
    return "void";
  elif (cdt.Core_Typ == 1) //boolean
    return "boolean";
  elif (cdt.Core_Typ == 2) //integer
    return "integer";
  elif (cdt.Core_Typ == 3) //real
    return "real";
  elif (cdt.Core_Typ == 4) //string
    return "string";
  elif (cdt.Core_Typ == 5) //unique_id
    return "unique_id";
  elif (cdt.Core_Typ == 6) //current_state
    return "current_state";
  elif (cdt.Core_Typ == 7) //same_as_base
    return "same_as_base";
  elif (cdt.Core_Typ == 8) //inst_ref<Object>
    return "inst_ref<Object>";
  elif (cdt.Core_Typ == 9) //inst_ref_set<Object>
    return "inst_ref_set<Object>";
  elif (cdt.Core_Typ == 10) //inst<Event>
    return "inst<Event>";
  elif (cdt.Core_Typ == 11) //inst<Mapping>
    return "inst<Mapping>";        
  elif (cdt.Core_Typ == 12) //inst_ref<Mapping>
    return "inst_ref<Mapping>";
  elif (cdt.Core_Typ == 13) //component_ref
    return "component_ref";
  else
    USER::logError(msg:"Data Type.getCoreDataType error: unknown data type",path:"");
    return "";
  end if;
elif (not_empty edt)
  //If the data type is an enumeration data type, return the name of the enumeration
  return edt.get_name();
elif (not_empty irdt)
  //If the data type is an instance reference data type,
  // return the name of the reference type
  return irdt.get_name();
elif (not_empty udt)
  // if a user data type ask the related core type
  select one core related by udt->S_DT[R18];
  return core.getCoreDataTypeName();
else
  USER::logError(msg:"Data Type.getCoreDataType error: unable to get core data type, return the name of the data type",path:"");
  return self.Name;
end if;',
	1,
	'',
	8237);
INSERT INTO O_TFR
	VALUES (8254,
	32,
	'associateDTWithDomain',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any domain from instances of S_DOM where (selected.Dom_ID == param.dom_id);
select any systemDt related by self->SLD_SDINP[R4401];
if(not_empty systemDt and not_empty domain)
  // this dt is a system level dt
  // unrelate from system
  select one system related by systemDt->S_SYS[R4402];
  unrelate systemDt from system across R4402;
  select one pkg related by systemDt->S_DPK[R4401];
  unrelate self from pkg across R4401 using systemDt;
  delete object instance systemDt;
  // associate to domain
  relate domain to self across R14;
elif(not_empty domain and empty systemDt)
  // this dt was previously a domain level dt
  // just update to point at the new
  // domain
  select one prevDomain related by self->S_DOM[R14];
  if(not_empty prevDomain)
    unrelate self from prevDomain across R14;
    relate self to domain across R14;
  end if;
end if;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (8255,
	8254,
	'dom_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8251,
	32,
	'associateDTWithSystem',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any system from instances of S_SYS
                                        where (selected.Sys_ID == param.sys_id);
select one prevDomain related by self->S_DOM[R14];
if(not_empty prevDomain and not_empty system)
  // this instance was previously a domain level dt
  // first unrelate from domain
  unrelate self from prevDomain across R14;
  // now associate the datatype with the system
  create object instance sdinp of SLD_SDINP;
  relate sdinp to system across R4402;
  select one pkg related by self->S_DIP[R39]->S_DPK[R39];
  relate pkg to self across R4401 using sdinp;
elif(empty prevDomain and not_empty system)
  // this instance was previously a system level dt
  // associate it with the new system
  select any sdip related by self->SLD_SDINP[R4401];
  if(not_empty sdip)
    select one prevSystem related by sdip->S_SYS[R4402];
    unrelate sdip from prevSystem across R4402;
    relate sdip to system across R4402;
    select one prevPkg related by sdip->S_DPK[R4401];
    unrelate self from prevPkg across R4401 using sdip;
    select one pkg related by self->S_DIP[R39]->S_DPK[R39];
    relate pkg to self across R4401 using sdip;
  end if;
end if;',
	1,
	'',
	8254);
INSERT INTO O_TPARM
	VALUES (8256,
	8251,
	'sys_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8257,
	32,
	'resolveDomain',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one packageableElem related by self->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;
select one irdt related by self->S_IRDT[R17];
if ((not isInGenericPackage) and (not_empty irdt))
  select one target_dom related by irdt->O_OBJ[R123]->S_SS[R2]->S_DOM[R1];
  select one existing_dom related by self->S_DOM[R14];
  if (target_dom != existing_dom)
    unrelate self from existing_dom across R14;
    relate self to target_dom across R14;
  end if;
end if;',
	1,
	'',
	8242);
INSERT INTO O_TFR
	VALUES (8252,
	32,
	'getDefaultDataTypeName',
	'',
	322,
	0,
	'if(param.elementType == "InterfaceOperation")
  return "void";
elif(param.elementType == "PropertyParameter")
  return "integer";
elif(param.elementType == "Bridge")
  return "void";
elif(param.elementType == "BridgeParameter")
  return "integer";
elif(param.elementType == "OperationParameter")
  return "integer";
elif(param.elementType == "Operation")
  return "void";
elif(param.elementType == "Function")
  return "void";
elif(param.elementType == "FunctionParameter")
  return "integer";
elif(param.elementType == "StateMachineEventDataItem")
  return "integer";
elif(param.elementType == "Attribute")
  return "integer";
elif(param.elementType == "StructureMember")
  return "integer";
elif(param.elementType == "Value")
  return "integer";
elif(param.elementType == "TransientVar")
  return "integer";
elif(param.elementType == "Variable")
  return "integer";
elif(param.elementType == "UserDataType")
  return "integer";
elif(param.elementType == "SymbolicConstant")
  return "integer";
end if;
return "";',
	1,
	'',
	8253);
INSERT INTO O_TPARM
	VALUES (8258,
	8252,
	'elementType',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8259,
	32,
	'getPath',
	'',
	322,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Data Type::getPath()
path = "";
if(param.includeSelf)
  path = self.Name;
end if;
if(param.path != "")
  path = path + "::" + param.path;
end if;
select one dtPackage related by self->S_DIP[R39]->S_DPK[R39];
select one package related by self->PE_PE[R8001]->EP_PKG[R8000];
select one component related by self->PE_PE[R8001]->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;
if isInGenericPackage
  if not_empty package
    if(path != "")
      path = package.getQualifiedName() + "::" + path;
    else
      path = package.getQualifiedName();
    end if;
  else
    if(path != "")
      path = component.getQualifiedName() + "::" + path;
    else
      path = component.getQualifiedName();
    end if;
  end if;
else
  // It has to be in here or else we have a corrupted model
  if not_empty dtPackage
    path = dtPackage.getPath(path:path);
  end if;
end if;
return path;',
	1,
	'',
	8257);
INSERT INTO O_TPARM
	VALUES (8260,
	8259,
	'path',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (8261,
	8259,
	'includeSelf',
	316,
	0,
	'',
	8260,
	'');
INSERT INTO O_NBATTR
	VALUES (8262,
	32);
INSERT INTO O_BATTR
	VALUES (8262,
	32);
INSERT INTO O_ATTR
	VALUES (8262,
	32,
	8263,
	'Name',
	'Full Name: Data Type Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8264,
	32);
INSERT INTO O_BATTR
	VALUES (8264,
	32);
INSERT INTO O_ATTR
	VALUES (8264,
	32,
	8262,
	'Descrip',
	'Full Name: Data Type Description',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (32,
	699,
	0,
	712,
	7247,
	7249,
	7248,
	8263,
	8265,
	0,
	0,
	'',
	'Domain',
	'Dom_ID',
	'R14.''defines types available within''');
INSERT INTO O_RATTR
	VALUES (8263,
	32,
	712,
	699,
	1,
	'Dom_ID');
INSERT INTO O_ATTR
	VALUES (8263,
	32,
	156,
	'Dom_ID',
	'',
	'',
	'Dom_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8266,
	32);
INSERT INTO O_BATTR
	VALUES (8266,
	32);
INSERT INTO O_ATTR
	VALUES (8266,
	32,
	8264,
	'DefaultValue',
	'Full Name: Default Value
Description: This attribute holds text representing the initialization value for elements of this type upon creation in execution environments such as Verifier and generated code.
',
	'',
	'DefaultValue',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (32,
	26,
	0,
	25,
	868,
	2827,
	870,
	156,
	8267,
	0,
	0,
	'',
	'Packageable Element',
	'Element_ID',
	'R8001');
INSERT INTO O_RATTR
	VALUES (156,
	32,
	25,
	26,
	0,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (156,
	32,
	0,
	'DT_ID',
	'',
	'',
	'DT_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	32);
INSERT INTO O_OIDA
	VALUES (156,
	32,
	0,
	'DT_ID');
INSERT INTO O_ID
	VALUES (1,
	32);
INSERT INTO O_OIDA
	VALUES (156,
	32,
	1,
	'DT_ID');
INSERT INTO O_ID
	VALUES (2,
	32);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (7258,
	'Core Data Type',
	10,
	'S_CDT',
	'Core Data Types are those data types which are fundamental, or core, to all data types.  The core data types are built-in to the tool and cannot be changed.',
	7221);
INSERT INTO O_TFR
	VALUES (8268,
	7258,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.DT_ID;',
	1,
	'',
	8269);
INSERT INTO O_TFR
	VALUES (8270,
	7258,
	'get_compartment_text',
	'',
	322,
	1,
	'result = "";
if (param.at == Justification::Center_in_X)
  result = "primitive";
elif (param.at == Justification::Center)
  select one selfDt related by self->S_DT[R17];
  if ( not_empty selfDt )
    result = selfDt.Name;
    select one pe related by selfDt->PE_PE[R8001];
    if not_empty pe
      result = pe.getVisibilityAdornment() + result;
    end if;
  else
    result = ::getOrphanedElementName();
  end if;
end if;
return result;',
	1,
	'',
	8271);
INSERT INTO O_TPARM
	VALUES (8272,
	8270,
	'comp_num',
	298,
	0,
	'',
	8273,
	'');
INSERT INTO O_TPARM
	VALUES (8274,
	8270,
	'ent_num',
	298,
	0,
	'',
	8272,
	'');
INSERT INTO O_TPARM
	VALUES (8273,
	8270,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8275,
	7258,
	'get_compartments',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	8270);
INSERT INTO O_TFR
	VALUES (8276,
	7258,
	'get_entries',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	8275);
INSERT INTO O_TPARM
	VALUES (8277,
	8276,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8278,
	7258,
	'get_text_style',
	'',
	784,
	1,
	'return Style::None;',
	1,
	'',
	8279);
INSERT INTO O_TPARM
	VALUES (8280,
	8278,
	'comp_num',
	298,
	0,
	'',
	8281,
	'');
INSERT INTO O_TPARM
	VALUES (8282,
	8278,
	'ent_num',
	298,
	0,
	'',
	8280,
	'');
INSERT INTO O_TPARM
	VALUES (8281,
	8278,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8279,
	7258,
	'get_style',
	'',
	784,
	1,
	'return Style::Box;',
	1,
	'',
	8268);
INSERT INTO O_TFR
	VALUES (8269,
	7258,
	'get_name',
	'',
	322,
	1,
	'select one dt related by self->S_DT[R17];
if ( empty dt )
  return "";
else
  return dt.Name;
end if;
',
	1,
	'',
	8276);
INSERT INTO O_TFR
	VALUES (8271,
	7258,
	'dispose',
	'',
	19,
	1,
	'select one dt related by self->S_DT[R17];
unrelate self from dt across R17;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (8283,
	7258,
	'convertToInstance',
	'Translate:native',
	317,
	1,
	'return this;',
	0,
	'',
	8278);
INSERT INTO O_NBATTR
	VALUES (8284,
	7258);
INSERT INTO O_BATTR
	VALUES (8284,
	7258);
INSERT INTO O_ATTR
	VALUES (8284,
	7258,
	8285,
	'Core_Typ',
	'Full Name: Core Type
Description: The core BridgePoint type for the data type
Data Domain: 0 = void, 1 = boolean, 2 = integer, 3 = real, 4 = string, 5 = unique_id, 6 = current_state, 7 = same_as_base, 8 = inst_ref\<Object\>, 9 = inst_ref_set\<Object\>, 10 = inst\<Event\>, 11 = inst\<Mapping\>, 12 = inst_ref\<Mapping\>, 13 = component_ref

enum0: void
enum1: boolean
enum2: integer
enum3: real
enum4: string
enum5: unique_id
enum6: state<State_Model>
enum7:  same_as<Base_Attribute>
enum8: inst_ref<Object>
enum9: inst_ref_set<Object>
enum10: inst<Event>
enum11: inst<Mapping>
enum12: inst_ref<Mapping>
enum13: component_ref
impl_detail: true
readonly: true',
	'',
	'Core_Typ',
	0,
	298,
	'',
	'');
INSERT INTO O_REF
	VALUES (7258,
	32,
	0,
	156,
	7256,
	7259,
	7257,
	8285,
	8286,
	0,
	0,
	'',
	'Data Type',
	'DT_ID',
	'R17');
INSERT INTO O_RATTR
	VALUES (8285,
	7258,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (8285,
	7258,
	0,
	'DT_ID',
	'',
	'',
	'Element_ID',
	2,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	7258);
INSERT INTO O_OIDA
	VALUES (8285,
	7258,
	0,
	'DT_ID');
INSERT INTO O_ID
	VALUES (1,
	7258);
INSERT INTO O_ID
	VALUES (2,
	7258);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (46,
	'Bridge Parameter',
	13,
	'S_BPARM',
	'A parameter to a bridge (S_BRG) is called a bridge parameter.  Bridge parameters are either passed in by value, or by reference.  Bridge parameters can be accessed by using the param keyword from within a bridge action specification.',
	7221);
INSERT INTO O_TFR
	VALUES (8287,
	46,
	'dispose',
	'The dispose operation for this class.',
	19,
	1,
	'// Bridge Parameter.dispose()
// Value Subsystem
select many pvs related by self->V_PVL[R831];
for each pv in pvs
  unrelate self from pv across R831;
end for;
//
//
select one brg related by self->S_BRG[R21];
unrelate self from brg across R21;
select one successor related by self->S_BPARM[R55.''precedes''];
select one predecessor related by self->S_BPARM[R55.''succeeds''];
if (not empty successor)
  unrelate self from successor across R55.''precedes'';
end if;
if (not empty predecessor)
  unrelate self from predecessor across R55.''succeeds'';
end if;
if (not_empty successor and not_empty predecessor)
  relate successor to predecessor across R55.''succeeds'';
end if;
select one dt related by self->S_DT[R22];
unrelate self from dt across R22;
// dispose each message argument
// associated with this parm
select many args related by self->MSG_BA[R1014];
for each arg in args
  arg.dispose();
end for;

select many dims related by self->S_DIM[R49];
for each dim in dims
  unrelate self from dim across R49;
  delete object instance dim;
end for;

delete object instance self;',
	1,
	'',
	8288);
INSERT INTO O_TFR
	VALUES (8289,
	46,
	'initialize',
	'The initialization operation for this class.  Set the name and data type to default values.',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one brg related by self->S_BRG[R21];
brg.addBridgeParameterToOrder(id:self.BParm_ID);
select one packageableElem related by self->S_BRG[R21]->S_EE[R19]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;

if (isInGenericPackage)
   if (not_empty package)
    select one system related by package->S_SYS[R1405];
    def_dt_id = GD::NULL_UNIQUE_ID();
    if not_empty system
      def_dt_id = system.getCoreTypeId(name:"integer");
    end if;
    select any pe from instances of PE_PE where selected.Element_ID == def_dt_id;
    select one def_dt related by pe->S_DT[R8001]; 
     if (not_empty def_dt)
        relate self to def_dt across R22;
     end if;
   else
     rootCompIdInPkg = component.getRootComponentId();
     select any rootComponent from instances of C_C where (selected.Id == rootCompIdInPkg);
     select one system related by rootComponent->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405];
     def_dt_id = GD::NULL_UNIQUE_ID();
     if not_empty system
       def_dt_id = system.getCoreTypeId(name:"integer");
     end if;
     select any pe from instances of PE_PE where selected.Element_ID == def_dt_id;
     select one def_dt related by pe->S_DT[R8001]; 
     if (not_empty def_dt)
        relate self to def_dt across R22;
     end if;
   end if;
else
  select any dom from instances of S_DOM;
  select one component related by dom->CN_DC[R4204]->C_C[R4204];
  if(not_empty component)
    select one system related by component->CP_CP[R4608]->S_SYS[R4606];
    def_dt_id = GD::NULL_UNIQUE_ID();
    if not_empty system
      def_dt_id = system.getCoreTypeId(name:"integer");
    end if;
    select any pe from instances of PE_PE where selected.Element_ID == def_dt_id;
    select one def_dt related by pe->S_DT[R8001]; 
    if (not_empty def_dt)
      relate self to def_dt across R22;
    end if;
  else
    select any def_dt related by dom->S_DT[R14] where selected.Name == "integer";
    if (not_empty def_dt)
      relate self to def_dt across R22;
    end if;
  end if;
end if;
name = ::getUniqueInitialName( 
	instance: self.convertToInstance(), 
    candidateName: "Unnamed Bridge Parameter");
success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:true);    
if ( success!="") 
 self.Name=success;
else 
 self.dispose();
end if;    ',
	1,
	'',
	8290);
INSERT INTO O_TFR
	VALUES (8291,
	46,
	'isAllowedType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// if this element is at the system level check the
// system level data types, otherwise check the 
// domain
// Bridge Parameter.isAllowedType()
select one packageableElem related by self->S_BRG[R21]->S_EE[R19]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;
if isInGenericPackage
  return packageableElem.isAllowedType(isReturnType:false,
                                                       typeName:param.typeName);
else
  select one domain related by self->S_BRG[R21]->S_EE[R19]->S_DOM[R8];
  if(not_empty domain)
    select one system related by domain->S_SYS[R28];
    if(not_empty system)
      return S_DT::isAllowedParameterType( typeName: param.typeName,
                                   			dom_id: domain.get_ooa_id() );
    else
      // first check the domain level
      result = S_DT::isAllowedParameterType( typeName: param.typeName,
                                   				dom_id: domain.get_ooa_id() );
      if(not result)
        // if nothing valid check the system level
        select one system related by domain->CN_DC[R4204]->C_C[R4204]
      											   ->CP_CP[R4608]->S_SYS[R4606];
        return Util::isAllowedParameterType(system:system.convertToInstance(),
                                                       typeName:param.typeName);
      else
        return result;
      end if;
    end if;
  end if;
  return false;
end if;',
	1,
	'',
	8289);
INSERT INTO O_TPARM
	VALUES (8292,
	8291,
	'typeName',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8288,
	46,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'// just return this instance as an Object
return this;',
	0,
	'',
	8293);
INSERT INTO O_TFR
	VALUES (8290,
	46,
	'getValue',
	'',
	317,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return GD::NULL_INSTANCE(); ',
	1,
	'',
	8294);
INSERT INTO O_TPARM
	VALUES (8295,
	8290,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8296,
	46,
	'setValue',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	8297);
INSERT INTO O_TPARM
	VALUES (8298,
	8296,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (8299,
	8296,
	'value',
	317,
	0,
	'',
	8298,
	'');
INSERT INTO O_TPARM
	VALUES (8300,
	8296,
	'member_id',
	296,
	0,
	'',
	8299,
	'');
INSERT INTO O_TFR
	VALUES (8297,
	46,
	'resolveDatatype',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one dtProxy related by self->S_DT[R22];
if(not_empty dtProxy and not Util::isProxy(element:self.convertToInstance()))
  name = dtProxy.Name;
  unrelate dtProxy from self across R22;
  
  select one packageableElem related by self->S_BRG[R21]->S_EE[R19]->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = not_empty package or not_empty component;
  if isInGenericPackage
    id = packageableElem.resolveDataTypeRelativeToSelf(default_name:"integer",
                                                            expected_name:name);                                                          
    select any resolvedDt related by package->PE_VIS[R8002]->
                         PE_PE[R8002]->S_DT[R8001] where selected.DT_ID == id;
    if (empty resolvedDt)
      select any resolvedDt related by component->PE_CVS[R8004]->
                       PE_PE[R8004]->S_DT[R8001] where selected.DT_ID == id;
    end if;	
    if not_empty resolvedDt
      relate resolvedDt to self across R22;
    end if;
  else
    select one domain related by self->S_BRG[R21]->S_EE[R19]->S_EEIP[R33]
  									 ->S_EEPK[R33]->PL_EEPID[R300]->S_DOM[R300];
    id = domain.resolveDataTypeRelativeToSelf(default_name:"integer",
  													        expected_name:name);
    // until we have instance reference passing, we search for
    // the data type related to the domain first then to the
    // system
    select any resolvedDT related by domain->S_DT[R14]
  												   where (selected.DT_ID == id);
    if(empty resolvedDT)
      select one domSys related by domain->CN_DC[R4204]->C_C[R4204]
                                                   ->CP_CP[R4608]->S_SYS[R4606];
      select any resolvedDT related by domSys->SLD_SDINP[R4402]->S_DT[R4401]
    				 						       where (selected.DT_ID == id);
      if empty resolvedDT and not_empty domSys and domSys.useGlobals
        select any pe related by domSys->G_EIS[R9100]->PE_PE[R9100]
                                                where selected.Element_ID == id;
        select one resolvedDT related by pe->S_DT[R8001]; 
      end if;
    end if;
    if(not_empty resolvedDT)
      relate resolvedDT to self across R22;
    end if;
  end if;
end if;',
	1,
	'',
	8301);
INSERT INTO O_TFR
	VALUES (8294,
	46,
	'getDimensionsCnt',
	'',
	298,
	1,
	'select many dims related by self->S_DIM[R49];
dimensions = cardinality dims;
return dimensions;
',
	1,
	'',
	8287);
INSERT INTO O_TFR
	VALUES (8301,
	46,
	'resizeDimensions',
	'',
	19,
	1,
	'// If the number of dimensions has increased then add dimensions
while (param.numDimensions > self.getDimensionsCnt())
  create object instance dim of S_DIM;
  dim.dimensionCount = self.getDimensionsCnt();
  relate dim to self across R49;
end while;

// If the number of dimensions has decreased then remove dimensions
while (param.numDimensions < self.getDimensionsCnt())
  select any dim related by self->S_DIM[R49] where (selected.dimensionCount == (self.getDimensionsCnt()-1));
  unrelate dim from self across R49;
  delete object instance dim;
end while;

// Update the specific dimension that was passed-in if its elementCount has 
// changed.
if (param.numDimensions > 0) 
  select any dim related by self->S_DIM[R49] where (selected.dimensionCount == param.dimension);
  if (dim.elementCount != param.elementCount)
    dim.elementCount = param.elementCount;
  end if;
end if;
',
	1,
	'',
	8302);
INSERT INTO O_TPARM
	VALUES (8303,
	8301,
	'numDimensions',
	298,
	0,
	'',
	8304,
	'');
INSERT INTO O_TPARM
	VALUES (8305,
	8301,
	'dimension',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (8304,
	8301,
	'elementCount',
	298,
	0,
	'',
	8305,
	'');
INSERT INTO O_TFR
	VALUES (8302,
	46,
	'moveUp',
	'',
	19,
	1,
	'::changeNotificationEnablement(enabled:false);
select one prev_attr related by self->S_BPARM[R55.''succeeds''];
select one prev_prev_attr related by prev_attr->S_BPARM[R55.''succeeds''];
select one next_attr related by self->S_BPARM[R55.''precedes''];

if ( not_empty prev_prev_attr )
  unrelate prev_attr from prev_prev_attr across R55.''succeeds'';
end if;
if ( not_empty next_attr )
  unrelate next_attr from self across R55.''succeeds'';
end if;
unrelate self from prev_attr across R55.''succeeds'';

if ( not_empty prev_prev_attr )
  relate self to prev_prev_attr across R55.''succeeds'';
end if;
// want to enable listeners at the last possible moment
if ( empty next_attr )
  ::changeNotificationEnablement(enabled:true);
end if;
relate prev_attr to self across R55.''succeeds'';
if ( not_empty next_attr )
  ::changeNotificationEnablement(enabled:true);
  relate next_attr to prev_attr across R55.''succeeds'';
end if;
',
	1,
	'',
	8306);
INSERT INTO O_TFR
	VALUES (8306,
	46,
	'moveDown',
	'',
	19,
	1,
	'::changeNotificationEnablement(enabled:false);
select one next_attr related by self->S_BPARM[R55.''precedes''];
select one prev_attr related by self->S_BPARM[R55.''succeeds''];
select one next_next_attr related by next_attr->S_BPARM[R55.''precedes''];

if ( not_empty next_next_attr )
  unrelate next_next_attr from next_attr across R55.''succeeds'';
end if;
if ( not_empty prev_attr )
  unrelate self from prev_attr across R55.''succeeds'';
end if;
unrelate next_attr from self across R55.''succeeds'';

if ( not_empty prev_attr )
  relate next_attr to prev_attr across R55.''succeeds'';
end if;
   
// want to enable listeners at the last possible moment
if ( empty next_next_attr )
  ::changeNotificationEnablement(enabled:true);
end if;
relate self to next_attr across R55.''succeeds'';
if ( not_empty next_next_attr )
  ::changeNotificationEnablement(enabled:true);
  relate next_next_attr to self across R55.''succeeds'';
end if;
',
	1,
	'',
	8307);
INSERT INTO O_TFR
	VALUES (8308,
	46,
	'actionFilter',
	'',
	316,
	1,
	'if (param.name == "can" )
  if ( param.value == "move up" )
    select one prev_attr related by self->S_BPARM[R55.''succeeds''];
    return not_empty prev_attr;
  elif ( param.value == "move down" )
    select one next_attr related by self->S_BPARM[R55.''precedes''];
    return not_empty next_attr;
  end if;
end if;
return false;
',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (8309,
	8308,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (8310,
	8308,
	'value',
	322,
	0,
	'',
	8309,
	'');
INSERT INTO O_TFR
	VALUES (8311,
	46,
	'canReferToDataType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// select the dt
select one dt related by self->S_DT[R22];
if(not_empty dt)
  select one packageableElem related by self->S_BRG[R21]->S_EE[R19]->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = not_empty package or not_empty component;

  if (isInGenericPackage)
    return packageableElem.canReferToDataType(dtID:dt.DT_ID, dtName: dt.Name);
  else
    // if the data type package is at the system
    // level we can use the data type as long as
    // this element belongs to a formal component
    select one domain related by self->S_BRG[R21]->S_EE[R19]->S_DOM[R8];
    select one dtPkg related by dt->S_DIP[R39]->S_DPK[R39];
    if(not dtPkg.isDomainLevel())
      if(domain.participatesInSystem())
        return true;
      else
        return false;
      end if;
    else
      // otherwise the DT must be in the same domain
      select one dtDomain related by dt->S_DOM[R14];
      if(dtDomain == domain)
        return true;
      end if;
    end if;
  end if;
end if;
return false;
',
	1,
	'',
	8308);
INSERT INTO O_TFR
	VALUES (8307,
	46,
	'isReferringToDefaultDataType',
	'',
	316,
	1,
	'select one dt related by self->S_DT[R22];
elementType = Util::getSimpleClassName(element:self.convertToInstance());
if(dt.Name == S_DT::getDefaultDataTypeName(elementType:elementType))
  return true;
end if;
return false;
',
	1,
	'',
	8291);
INSERT INTO O_TFR
	VALUES (8293,
	46,
	'canUseDataType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Bridge Parameter.canUseDataType()
select one packageableElem related by self->S_BRG[R21]->S_EE[R19]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;
if isInGenericPackage
  // Find the previously created visibility list
  select any resultSet related by package->PE_SRS[R8005] where
        selected.Name == "" and selected.Type == ElementTypeConstants::DATATYPE;
  select any dt related by resultSet->PE_VIS[R8006]->
                     PE_PE[R8002]->S_DT[R8001] where selected.DT_ID == param.id;
  if not_empty component
    // Find the previously created visibility list
    select any compResultSet related by component->PE_CRS[R8007] where
        selected.Name == "" and selected.Type == ElementTypeConstants::DATATYPE;
    select any dt related by compResultSet->PE_CVS[R8008]->
                     PE_PE[R8004]->S_DT[R8001] where selected.DT_ID == param.id;
  end if;
  if(not_empty dt)
    if(self.isAllowedType(typeName:dt.Name))
      return true;
    end if;
  end if;
  return false;
else
  select one domain related by self->S_BRG[R21]->S_EE[R19]->S_DOM[R8];
  if(domain.participatesInSystem())
    // system level check both the system
    // and the domain for the dt
    select one system related by domain->CN_DC[R4204]->C_C[R4204]->CP_CP[R4608]
                                                                 ->S_SYS[R4606];
    select any dt related by system->SLD_SDINP[R4402]->S_DT[R4401]
                                             where (selected.DT_ID == param.id);
    if empty dt and not_empty system and system.useGlobals
      select any pe related by system->G_EIS[R9100]->PE_PE[R9100]
                                          where selected.Element_ID == param.id;
      select one dt related by pe->S_DT[R8001]; 
    end if;
    if(empty dt)
      select any dt related by domain->S_DT[R14]
                                             where (selected.DT_ID == param.id);
    end if;
    if(not_empty dt)
      if(self.isAllowedType(typeName:dt.Name))
        return true;
      end if;
    end if;
  else
    // only check the domain for the dt
    select any dt related by domain->S_DT[R14] where (selected.DT_ID == param.id);
    if(not_empty dt)
      if(self.isAllowedType(typeName:dt.Name))
        return true;
      end if;
    end if;
  end if;
  return false;
end if;',
	1,
	'',
	8311);
INSERT INTO O_TPARM
	VALUES (8312,
	8293,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8313,
	46,
	'getPath',
	'',
	322,
	1,
	'select one brdg related by self-> S_BRG[R21];
select one ee related by brdg->S_EE[R19];
return self.Name+"::"+ee.getPath();
',
	1,
	'',
	8296);
INSERT INTO O_TFR
	VALUES (8314,
	46,
	'checkIntegrity',
	'',
	19,
	1,
	'/**
 *  Create an integrity issue if there are any other parameters in the same
 *  bridge with a matching name
 */
select one brg related by self->S_BRG[R21];
select one package related by brg->S_EE[R19]->PE_PE[R8001]->EP_PKG[R8000];
select one system related by package->S_SYS[R1405];
sys_id = GD::NULL_UNIQUE_ID();
if(not_empty system)
  sys_id = system.Sys_ID;
end if;
select many parameters related by brg->S_BPARM[R21];
for each parameter in parameters
  if(parameter != self and parameter.Name == self.Name)
    MI_IM::createIssue(sys_id:sys_id, description:
         "Found another parameter under the same bridge with a " +
                                                          "matching name.",
                                      severity:Severity::Error, name:self.Name,
                                         path:self.getPath(),
                    id:self.BParm_ID, element:self.convertToInstance());
  end if;
end for;',
	1,
	'',
	8313);
INSERT INTO O_NBATTR
	VALUES (211,
	46);
INSERT INTO O_BATTR
	VALUES (211,
	46);
INSERT INTO O_ATTR
	VALUES (211,
	46,
	0,
	'BParm_ID',
	'Full Name: Bridge Parameter Identifier',
	'',
	'BParm_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_REF
	VALUES (46,
	6,
	0,
	16,
	7270,
	7272,
	7271,
	8315,
	8316,
	0,
	0,
	'',
	'Bridge',
	'Brg_ID',
	'R21.''contains''');
INSERT INTO O_RATTR
	VALUES (8315,
	46,
	16,
	6,
	1,
	'Brg_ID');
INSERT INTO O_ATTR
	VALUES (8315,
	46,
	211,
	'Brg_ID',
	'',
	'',
	'Brg_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8317,
	46);
INSERT INTO O_BATTR
	VALUES (8317,
	46);
INSERT INTO O_ATTR
	VALUES (8317,
	46,
	8315,
	'Name',
	'Full Name: Bridge Parameter Name
Description: The name of a parameter used to identify a supplemental data item being provided in a Bridge statement.',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8318,
	46);
INSERT INTO O_BATTR
	VALUES (8318,
	46);
INSERT INTO O_ATTR
	VALUES (8318,
	46,
	8319,
	'By_Ref',
	'Full Name: By Reference Indicator
Description: Indicates whether or not this parameter is passed by reference
Data Domain: 0 = passed by value, 1 = passed by reference
enum0: By Value
enum1: By Reference',
	'',
	'By_Ref',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8320,
	46);
INSERT INTO O_BATTR
	VALUES (8320,
	46);
INSERT INTO O_ATTR
	VALUES (8320,
	46,
	8318,
	'Dimensions',
	'Full Name: Array Dimensions',
	'',
	'Dimensions',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (46,
	46,
	0,
	211,
	7416,
	7418,
	7417,
	8321,
	8322,
	0,
	0,
	'',
	'Bridge Parameter',
	'BParm_ID',
	'R55.''succeeds''');
INSERT INTO O_RATTR
	VALUES (8321,
	46,
	211,
	46,
	1,
	'BParm_ID');
INSERT INTO O_ATTR
	VALUES (8321,
	46,
	8320,
	'Previous_BParm_ID',
	'',
	'Previous_',
	'BParm_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8323,
	46);
INSERT INTO O_BATTR
	VALUES (8323,
	46);
INSERT INTO O_ATTR
	VALUES (8323,
	46,
	8321,
	'Descrip',
	'Full Name: Description
Description:  A textual description of the bridge parameter.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (46,
	32,
	0,
	156,
	7280,
	7282,
	7281,
	8319,
	8324,
	0,
	0,
	'',
	'Data Type',
	'DT_ID',
	'R22.''is defined by''');
INSERT INTO O_RATTR
	VALUES (8319,
	46,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (8319,
	46,
	8317,
	'DT_ID',
	'',
	'',
	'Element_ID',
	2,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	46);
INSERT INTO O_OIDA
	VALUES (211,
	46,
	0,
	'BParm_ID');
INSERT INTO O_ID
	VALUES (1,
	46);
INSERT INTO O_ID
	VALUES (2,
	46);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (6,
	'Bridge',
	12,
	'S_BRG',
	'A bridge (S_BRG) is a method associated with an external entity (S_EE).  Bridges can be synchronously called from action specifications.  Each bridge as a return type and zero or more parameters (S_BPARM).',
	7221);
INSERT INTO O_TFR
	VALUES (8325,
	6,
	'dispose',
	'The dispose operation for this class.',
	19,
	1,
	'// Domain Subsystem
select one ee related by self->S_EE[R19];
unrelate self from ee across R19;
select many bparms related by self->S_BPARM[R21];
for each bparm in bparms
  bparm.dispose();
end for;
select one dt related by self->S_DT[R20];
unrelate self from dt across R20;
//
// Body Subsystem
select one body related by self->ACT_BRB[R697]->ACT_ACT[R698];
if (not_empty body)
  body.dispose();
end if;
//
// Invocation Subsystem
select many invs related by self->ACT_BRG[R674];
for each inv in invs
  unrelate self from inv across R674;
end for;
//
// Value Subsystem
select many brgVals related by self->V_BRV[R828];
for each brgVal in brgVals
  unrelate self from brgVal across R828;
end for;
// for each message that this bridge
// is associated with
select many bms related by self->MSG_B[R1012];
for each bm in bms
  select one message related by bm->MSG_SM[R1020]->MSG_M[R1018];
  message.unformalize();
end for;
//
// Wiring Subsystem
select one wiring related by self->S_AW[R3200];
if (not_empty wiring)
  unrelate wiring from self across R3200;
  wiring.dispose();
end if;

select many dims related by self->S_DIM[R50];
for each dim in dims
  unrelate self from dim across R50;
  delete object instance dim;
end for;

//
// Finally, delete self
delete object instance self;',
	1,
	'',
	8326);
INSERT INTO O_TFR
	VALUES (8327,
	6,
	'initialize',
	'the initialization operation for this class.  Set the name and return value to defaults.',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one packageableElem related by self->S_EE[R19]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;

if (isInGenericPackage)
   if (not_empty package)
     select one system related by package->S_SYS[R1405];
     def_dt_id = GD::NULL_UNIQUE_ID();
     if not_empty system
       def_dt_id = system.getCoreTypeId(name:"void");
     end if;
     select any pe from instances of PE_PE where selected.Element_ID == def_dt_id;
     select one def_dt related by pe->S_DT[R8001]; 
     if (not_empty def_dt)
       relate self to def_dt across R20;
     end if;
   else
     rootCompIdInPkg = component.getRootComponentId();
     select any rootComponent from instances of C_C where (selected.Id == rootCompIdInPkg);
     select one system related by rootComponent->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405];     
     def_dt_id = GD::NULL_UNIQUE_ID();
     if not_empty system
       def_dt_id = system.getCoreTypeId(name:"void");
     end if;
     select any pe from instances of PE_PE where selected.Element_ID == def_dt_id;
     select one def_dt related by pe->S_DT[R8001]; 
     if (not_empty def_dt)
        relate self to def_dt across R20;
     end if;
   end if;
else
   select any dom from instances of S_DOM;
  select one component related by dom->CN_DC[R4204]->C_C[R4204];
  if(not_empty component)
    // this bridge is part of a formal component
    // get the default data type from the system
    select one compSys related by component->CP_CP[R4608]->S_SYS[R4606];
    def_dt_id = GD::NULL_UNIQUE_ID();
    if not_empty compSys
      def_dt_id = compSys.getCoreTypeId(name:"void");
    end if;
    select any pe from instances of PE_PE where selected.Element_ID == def_dt_id;
    select one def_dt related by pe->S_DT[R8001];
    if(not_empty def_dt)
      relate self to def_dt across R20;
    end if;
  else
    // this bridge is part of a stand alone domain
    // get the default data type from the domain
    select any def_dt related by dom->S_DT[R14] where selected.Name == "void";
    if(not_empty def_dt)
      relate self to def_dt across R20;
    end if;
  end if;
end if;
name = ::getUniqueInitialName( 
    instance: self.convertToInstance(), 
    candidateName: "Unnamed Bridge Operation");
success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:true);    
if ( success!="") 
 self.Name=success;
else 
 self.dispose();
end if;        
self.Suc_Pars = ParseStatus::parseInitial;
',
	1,
	'',
	8328);
INSERT INTO O_TFR
	VALUES (8329,
	6,
	'newParameter',
	'',
	19,
	1,
	'create object instance bparm of S_BPARM;
relate self to bparm across R21;
bparm.initialize();
self.createMessageArgumentsForParameter(id:bparm.BParm_ID);
',
	1,
	'',
	8330);
INSERT INTO O_TFR
	VALUES (8331,
	6,
	'isAllowedReturnType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Bridge.isAllowedReturnType()
select one packageableElem related by self->S_EE[R19]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;
if isInGenericPackage
  if self.getReturnDimensionsCnt() != 0 and param.typeName == "void"
    return false;
  else
    return packageableElem.isAllowedType(isReturnType:true,
                                                       typeName:param.typeName);
  end if;
else
  if self.getReturnDimensionsCnt() != 0 and param.typeName == "void"
    return false;
  else
    // if this element is at the system level check the
    // system level data types, otherwise check the 
    // domain
    select one domain related by self->S_EE[R19]->S_DOM[R8];
    if(not_empty domain)
      select one system related by domain->S_SYS[R28];
      if(not_empty system)
        return S_DT::isAllowedReturnType( typeName: param.typeName,
                                   			dom_id: domain.get_ooa_id() );
      else
        // first check the domain level
        result = S_DT::isAllowedReturnType( typeName: param.typeName,
                                   				dom_id: domain.get_ooa_id() );
        if(not result)
          // if nothing valid check the system level
          select one system related by domain->CN_DC[R4204]->C_C[R4204]
      											   ->CP_CP[R4608]->S_SYS[R4606];
          return Util::isAllowedReturnType(system:system.convertToInstance(),
                                                       typeName:param.typeName);
        else
          return result;
        end if;
      end if;
    end if;
  end if;
  return false;
end if;',
	1,
	'',
	8332);
INSERT INTO O_TPARM
	VALUES (8333,
	8331,
	'typeName',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8326,
	6,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'// just return this instance as an Object
return this;',
	0,
	'',
	8334);
INSERT INTO O_TFR
	VALUES (8328,
	6,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Brg_ID;',
	1,
	'',
	8335);
INSERT INTO O_TFR
	VALUES (8336,
	6,
	'resolveDatatype',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one dtProxy related by self->S_DT[R20];
if(not_empty dtProxy and not Util::isProxy(element:self.convertToInstance()))
  name = dtProxy.Name;
  unrelate dtProxy from self across R20;
  
  select one packageableElem related by self->S_EE[R19]->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = not_empty package or not_empty component;
  if isInGenericPackage
    id = packageableElem.resolveDataTypeRelativeToSelf(default_name:"void",
                                                            expected_name:name);                                                          
    select any resolvedDt related by package->PE_VIS[R8002]->
                         PE_PE[R8002]->S_DT[R8001] where selected.DT_ID == id;
    if (empty resolvedDt)
      select any resolvedDt related by component->PE_CVS[R8004]->
                       PE_PE[R8004]->S_DT[R8001] where selected.DT_ID == id;
    end if;	
    if not_empty resolvedDt
      relate resolvedDt to self across R20;
    end if;
  else
    select one domain related by self->S_EE[R19]->S_EEIP[R33]->S_EEPK[R33]
  										          ->PL_EEPID[R300]->S_DOM[R300];
    id = domain.resolveDataTypeRelativeToSelf(default_name:"void",
  													        expected_name:name);
    // until we have instance reference passing, we search for
    // the data type related to the domain first then to the
    // system
    select any resolvedDT related by domain->S_DT[R14]
  												   where (selected.DT_ID == id);
    if(empty resolvedDT)
      select one domSys related by domain->CN_DC[R4204]->C_C[R4204]
                                                   ->CP_CP[R4608]->S_SYS[R4606];
      select any resolvedDT related by domSys->SLD_SDINP[R4402]->S_DT[R4401]
    				 						       where (selected.DT_ID == id);
      if empty resolvedDT and not_empty domSys and domSys.useGlobals
        select any pe related by domSys->G_EIS[R9100]->PE_PE[R9100]
                                                where selected.Element_ID == id;
        select one resolvedDT related by pe->S_DT[R8001]; 
      end if;
    end if;
    if(not_empty resolvedDT)
      relate resolvedDT to self across R20;
    end if;
  end if;
end if;',
	1,
	'',
	8337);
INSERT INTO O_TFR
	VALUES (8330,
	6,
	'isVoid',
	'',
	316,
	1,
	'select one dt related by self->S_DT[R20];
return dt.Name == "void";',
	1,
	'',
	8338);
INSERT INTO O_TFR
	VALUES (8335,
	6,
	'getReturnDimensionsCnt',
	'',
	298,
	1,
	'select many dims related by self->S_DIM[R50];
dimensions = cardinality dims;
return dimensions;
',
	1,
	'',
	8325);
INSERT INTO O_TFR
	VALUES (8337,
	6,
	'resizeReturn_Dimensions',
	'',
	19,
	1,
	'// If the number of dimensions has increased then add dimensions
while (param.numDimensions > self.getReturnDimensionsCnt())
  create object instance dim of S_DIM;
  dim.dimensionCount = self.getReturnDimensionsCnt();
  relate dim to self across R50;
end while;

// If the number of dimensions has decreased then remove dimensions
while (param.numDimensions < self.getReturnDimensionsCnt())
  select any dim related by self->S_DIM[R50] where (selected.dimensionCount == (self.getReturnDimensionsCnt()-1));
  unrelate dim from self across R50;
  delete object instance dim;
end while;

// Update the specific dimension that was passed-in if its elementCount has 
// changed.
if (param.numDimensions > 0) 
  select any dim related by self->S_DIM[R50] where (selected.dimensionCount == param.dimension);
  if (dim.elementCount != param.elementCount)
    dim.elementCount = param.elementCount;
  end if;
end if; ',
	1,
	'',
	8329);
INSERT INTO O_TPARM
	VALUES (8339,
	8337,
	'numDimensions',
	298,
	0,
	'',
	8340,
	'');
INSERT INTO O_TPARM
	VALUES (8340,
	8337,
	'elementCount',
	298,
	0,
	'',
	8341,
	'');
INSERT INTO O_TPARM
	VALUES (8341,
	8337,
	'dimension',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8332,
	6,
	'initializeOrder',
	'',
	19,
	1,
	'// Alpha-sort the S_BPARM elements if they have not yet been ordered
select many peers related by self->S_BPARM[R21];
if (cardinality peers > 1)
    initialOrderingCheckPerformed = false;
	select any head related by self->S_BPARM[R21] where (selected.Brg_ID == GD::NULL_UNIQUE_ID());
	endOfList = head;
	loopCnt = 0;
	for each peer in peers
	  if ( not initialOrderingCheckPerformed)
	    select one predecessor related by peer->S_BPARM[R55.''precedes''];
	    select one successor related by peer->S_BPARM[R55.''succeeds''];
	    initialOrderingCheckPerformed = true;
	    if (not_empty  predecessor or not_empty  successor)
	      // Already ordered
	      break;
	    end if;
	    head = peer;
	    endOfList = peer;
	  end if;
	  
      if (loopCnt == 1)
        if (peer.Name < head.Name)
          relate peer to head across R55.''precedes'';
          endOfList = peer;
        else
          relate head to peer across R55.''precedes'';
          head = peer;
        end if;
      elif (loopCnt > 1)
        insertPoint = head;
        select one next related by head->S_BPARM[R55.''succeeds''];
        while (not_empty next)
          if (next.Name < peer.Name)
            break;
          else
            insertPoint = next;          
            select one next related by next->S_BPARM[R55.''succeeds''];
          end if;
        end while;
        
        if (empty next)
          // New end of list
          relate peer to endOfList across R55.''precedes'';   
          endOfList = peer;       
        else
          if ((insertPoint == head) and (peer.Name > head.Name))
            // New head
            relate head to peer across R55.''precedes'';
            head = peer;
          else
            unrelate next from insertPoint across R55.''precedes'';
            relate peer to insertPoint across R55.''precedes'';
            relate next to peer across R55.''precedes'';
          end if;          
        end if;
      end if;
      
      loopCnt = loopCnt + 1;
	end for;
end if;',
	1,
	'',
	8327);
INSERT INTO O_TFR
	VALUES (8334,
	6,
	'canReferToDataType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// select the dt
select one dt related by self->S_DT[R20];
if(not_empty dt)
  select one packageableElem related by self->S_EE[R19]->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = not_empty package or not_empty component;

  if (isInGenericPackage)
    return packageableElem.canReferToDataType(dtID:dt.DT_ID, dtName: dt.Name);
  else
    // if the data type package is at the system
    // level we can use the data type as long as
    // this element belongs to a formal component
    select one domain related by self->S_EE[R19]->S_DOM[R8];
    select one dtPkg related by dt->S_DIP[R39]->S_DPK[R39];
    if(not dtPkg.isDomainLevel())
      if(domain.participatesInSystem())
        return true;
      else
        return false;
      end if;
    else
      // otherwise the DT must be in the same domain
      select one dtDomain related by dt->S_DOM[R14];
      if(dtDomain == domain)
        return true;
      end if;
    end if;
  end if;
end if;
return false;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (8338,
	6,
	'isReferringToDefaultDataType',
	'',
	316,
	1,
	'select one dt related by self->S_DT[R20];
elementType = Util::getSimpleClassName(element:self.convertToInstance());
if(dt.Name == S_DT::getDefaultDataTypeName(elementType:elementType))
  return true;
end if;
return false;
',
	1,
	'',
	8331);
INSERT INTO O_TFR
	VALUES (8342,
	6,
	'getContainingComponentId',
	'',
	296,
	1,
	'select one ee related by self->S_EE[R19];
return ee.getContainingComponentId();
',
	1,
	'',
	8336);
INSERT INTO O_TFR
	VALUES (8343,
	6,
	'canUseDataType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Bridge.canUseDataType()
select one packageableElem related by self->S_EE[R19]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;
if isInGenericPackage
  // Find the previously created visibility list
  select any resultSet related by package->PE_SRS[R8005] where
        selected.Name == "" and selected.Type == ElementTypeConstants::DATATYPE;
  select any dt related by resultSet->PE_VIS[R8006]->
                     PE_PE[R8002]->S_DT[R8001] where selected.DT_ID == param.id;
  if not_empty component
    // Find the previously created visibility list
    select any compResultSet related by component->PE_CRS[R8007] where
        selected.Name == "" and selected.Type == ElementTypeConstants::DATATYPE;
    select any dt related by compResultSet->PE_CVS[R8008]->
                     PE_PE[R8004]->S_DT[R8001] where selected.DT_ID == param.id;
  end if;
  if(not_empty dt)
    if(self.isAllowedReturnType(typeName:dt.Name))
      return true;
    end if;
  end if;
  return false;
else
  select one domain related by self->S_EE[R19]->S_DOM[R8];
  if(domain.participatesInSystem())
    // system level check both the system
    // and the domain for the dt
    select one system related by domain->CN_DC[R4204]->C_C[R4204]->CP_CP[R4608]
                                                                 ->S_SYS[R4606];
    select any dt related by system->SLD_SDINP[R4402]->S_DT[R4401]
                                             where (selected.DT_ID == param.id);
    if empty dt and not_empty system and system.useGlobals
      select any pe related by system->G_EIS[R9100]->PE_PE[R9100]
                                          where selected.Element_ID == param.id;
      select one dt related by pe->S_DT[R8001]; 
    end if;
    if(empty dt)
      select any dt related by domain->S_DT[R14]
                                             where (selected.DT_ID == param.id);
    end if;
    if(not_empty dt)
      if(self.isAllowedReturnType(typeName:dt.Name))
        return true;
      end if;
    end if;
  else
    // only check the domain for the dt
    select any dt related by domain->S_DT[R14] where (selected.DT_ID == param.id);
    if(not_empty dt)
      if(self.isAllowedReturnType(typeName:dt.Name))
        return true;
      end if;
    end if;
  end if;
  return false;
end if;
',
	1,
	'',
	8342);
INSERT INTO O_TPARM
	VALUES (8344,
	8343,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8345,
	6,
	'getContainerId',
	'',
	296,
	1,
	'// Bridge.getContainerId()
select one ee related by self->S_EE[R19];
return ee.getContainerId();',
	1,
	'',
	8343);
INSERT INTO O_TFR
	VALUES (8346,
	6,
	'pasteBridgeParameter',
	'',
	19,
	1,
	'select any parameter from instances of S_BPARM
                                          where (selected.BParm_ID == param.id);
if(not_empty parameter)
  select one existingBrg related by parameter->S_BRG[R21];
  if(not_empty existingBrg)
    unrelate parameter from existingBrg across R21;
  end if;
  relate parameter to self across R21;
  parameter.Name = ::getUniqueInitialNameInParent(
                   instance: parameter.convertToInstance(), name:parameter.Name,
                                               parent:self.convertToInstance());
  self.createMessageArgumentsForParameter(id:parameter.BParm_ID);
  self.addBridgeParameterToOrder(id:parameter.BParm_ID);
end if;',
	1,
	'',
	8345);
INSERT INTO O_TPARM
	VALUES (8347,
	8346,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8348,
	6,
	'createMessageArgumentsForParameter',
	'',
	19,
	1,
	'select any parameter from instances of S_BPARM
                                          where (selected.BParm_ID == param.id);
if(not_empty parameter)
  // for each message associated with this bridge
  // create a message argument
  select many messages related by self->MSG_B[R1012]->MSG_SM[R1020]->MSG_M[R1018];
  for each message in messages
    create object instance arg of MSG_A;
    create object instance ba of MSG_BA;
    relate ba to parameter across R1014;
    relate ba to arg across R1013;
    relate message to arg across R1001;
  end for;
end if;',
	1,
	'',
	8346);
INSERT INTO O_TPARM
	VALUES (8349,
	8348,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8350,
	6,
	'addBridgeParameterToOrder',
	'',
	19,
	1,
	'select any parameter from instances of S_BPARM
                                          where (selected.BParm_ID == param.id);
if(not_empty parameter)
  ::changeNotificationEnablement(enabled:false);
  select many peers related by self->S_BPARM[R21];
  for each peer in peers
    if (peer != parameter)
      select one predecessor related by peer->S_BPARM[R55.''precedes''];
      if (empty predecessor)
        relate parameter to peer across R55.''succeeds'';
      end if;
    end if;
  end for;  
  ::changeNotificationEnablement(enabled:true);
end if;
',
	1,
	'',
	8348);
INSERT INTO O_TPARM
	VALUES (8351,
	8350,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8352,
	6,
	'checkIntegrity',
	'',
	19,
	1,
	'/**
 *  Create integrity issues if there are any other bridge operations with a
 *  matching signature
 */
select one ee related by self->S_EE[R19];
select one system related by ee->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405];
sys_id = GD::NULL_UNIQUE_ID();
if(not_empty system)
  sys_id = system.Sys_ID;
end if;
select many bridges related by ee->S_BRG[R19];
for each brg in bridges
  if(brg != self and brg.getSignature() == self.getSignature())
    MI_IM::createIssue(sys_id:sys_id, description:
                 "Found another bridge under the same external entity with a " +
                          "matching signature." + GD::newline() + GD::newline()
                                          + "Signature: " + self.getSignature(),
                                       severity:Severity::Error, name:self.Name,
                           path:ee.getPath() + "::" + self.Name,
                              id:self.Brg_ID, element:self.convertToInstance());
  end if;
end for;',
	1,
	'',
	8350);
INSERT INTO O_TFR
	VALUES (8353,
	6,
	'getSignature',
	'',
	322,
	1,
	'/**
 *  Return a string representation of this operations signature
 */
signature = self.Name;
count = 0;
select many parameters related by self->S_BPARM[R21];
paramLength = cardinality parameters;
if(paramLength > 0)
  signature = signature + "(";
end if;
for each parameter in parameters
  select one type related by parameter->S_DT[R22];
  if(count > 0 and count != paramLength - 1)
    signature = signature + ", ";
  end if;
  signature = signature + type.Name;
  count = count + 1;
end for;
if(paramLength > 0)
  signature = signature + ")";
end if;
return signature;',
	1,
	'',
	8352);
INSERT INTO O_NBATTR
	VALUES (16,
	6);
INSERT INTO O_BATTR
	VALUES (16,
	6);
INSERT INTO O_ATTR
	VALUES (16,
	6,
	0,
	'Brg_ID',
	'Full Name: Bridge Identifier',
	'',
	'Brg_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8354,
	6);
INSERT INTO O_BATTR
	VALUES (8354,
	6);
INSERT INTO O_ATTR
	VALUES (8354,
	6,
	8355,
	'Name',
	'Full Name: Bridge Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8356,
	6);
INSERT INTO O_BATTR
	VALUES (8356,
	6);
INSERT INTO O_ATTR
	VALUES (8356,
	6,
	8354,
	'Descrip',
	'Full Name: Bridge Description',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8357,
	6);
INSERT INTO O_BATTR
	VALUES (8357,
	6);
INSERT INTO O_ATTR
	VALUES (8357,
	6,
	8356,
	'Brg_Typ',
	'Full Name: Bridge Type
Data Domain: 0 = user defined, 1 = built-in
enum0: User-Defined
enum1: Built-in
impl_detail: true
readonly: true


',
	'',
	'Brg_Typ',
	0,
	298,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (8358,
	6,
	'self.Action_Semantics = ::convertRelocatableTags(in:self.Action_Semantics_internal);
',
	1);
INSERT INTO O_BATTR
	VALUES (8358,
	6);
INSERT INTO O_ATTR
	VALUES (8358,
	6,
	8359,
	'Action_Semantics',
	'Full Name: Action Semantics Field
Description: Action Semantics for the bridge action
Persistent:false',
	'',
	'Action_Semantics',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8360,
	6);
INSERT INTO O_BATTR
	VALUES (8360,
	6);
INSERT INTO O_ATTR
	VALUES (8360,
	6,
	8361,
	'Suc_Pars',
	'Full Name: Successful Parse Indicator
Description: Indicates the status of the parse for the bridge action specification in the attribute Action_Semantics
Data Domain: 0=not parsed, 1 = parse successful, 2 = parse unsuccessful, 3 = parse on apply set but never been parsed
',
	'',
	'Suc_Pars',
	0,
	1224,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8361,
	6);
INSERT INTO O_BATTR
	VALUES (8361,
	6);
INSERT INTO O_ATTR
	VALUES (8361,
	6,
	8358,
	'Action_Semantics_internal',
	'User_Visible:false',
	'',
	'Action_Semantics_internal',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8362,
	6);
INSERT INTO O_BATTR
	VALUES (8362,
	6);
INSERT INTO O_ATTR
	VALUES (8362,
	6,
	8360,
	'Return_Dimensions',
	'Full Name: Return Array Dimensions
DynamicReadOnly:isVoid',
	'',
	'Return_Dimensions',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (6,
	32,
	0,
	156,
	7267,
	7269,
	7268,
	8359,
	8363,
	0,
	0,
	'',
	'Data Type',
	'DT_ID',
	'R20');
INSERT INTO O_RATTR
	VALUES (8359,
	6,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (8359,
	6,
	8357,
	'DT_ID',
	'',
	'',
	'Element_ID',
	2,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (6,
	2820,
	0,
	3570,
	7273,
	7274,
	7275,
	8355,
	8364,
	0,
	0,
	'',
	'External Entity',
	'EE_ID',
	'R19');
INSERT INTO O_RATTR
	VALUES (8355,
	6,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (8355,
	6,
	16,
	'EE_ID',
	'',
	'',
	'EE_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	6);
INSERT INTO O_OIDA
	VALUES (16,
	6,
	0,
	'Brg_ID');
INSERT INTO O_ID
	VALUES (1,
	6);
INSERT INTO O_ID
	VALUES (2,
	6);
-- BP 7.1.6 content: DataTypePackage syschar: 3 persistence-version: 7.1.6

INSERT INTO S_DPK
	VALUES (8365,
	'Datatypes',
	1,
	0);
INSERT INTO S_DIP
	VALUES (8365,
	19);
INSERT INTO S_DT
	VALUES (19,
	1,
	'void',
	'',
	'');
INSERT INTO S_CDT
	VALUES (19,
	0);
INSERT INTO PE_PE
	VALUES (19,
	1,
	0,
	0,
	3);
INSERT INTO S_DIP
	VALUES (8365,
	316);
INSERT INTO S_DT
	VALUES (316,
	1,
	'boolean',
	'',
	'');
INSERT INTO S_CDT
	VALUES (316,
	1);
INSERT INTO PE_PE
	VALUES (316,
	1,
	0,
	0,
	3);
INSERT INTO S_DIP
	VALUES (8365,
	298);
INSERT INTO S_DT
	VALUES (298,
	1,
	'integer',
	'',
	'');
INSERT INTO S_CDT
	VALUES (298,
	2);
INSERT INTO PE_PE
	VALUES (298,
	1,
	0,
	0,
	3);
INSERT INTO S_DIP
	VALUES (8365,
	374);
INSERT INTO S_DT
	VALUES (374,
	1,
	'real',
	'',
	'');
INSERT INTO S_CDT
	VALUES (374,
	3);
INSERT INTO PE_PE
	VALUES (374,
	1,
	0,
	0,
	3);
INSERT INTO S_DIP
	VALUES (8365,
	322);
INSERT INTO S_DT
	VALUES (322,
	1,
	'string',
	'',
	'');
INSERT INTO S_CDT
	VALUES (322,
	4);
INSERT INTO PE_PE
	VALUES (322,
	1,
	0,
	0,
	3);
INSERT INTO S_DIP
	VALUES (8365,
	296);
INSERT INTO S_DT
	VALUES (296,
	1,
	'unique_id',
	'',
	'');
INSERT INTO S_CDT
	VALUES (296,
	5);
INSERT INTO PE_PE
	VALUES (296,
	1,
	0,
	0,
	3);
INSERT INTO S_DIP
	VALUES (8365,
	8366);
INSERT INTO S_DT
	VALUES (8366,
	1,
	'state<State_Model>',
	'',
	'');
INSERT INTO S_CDT
	VALUES (8366,
	6);
INSERT INTO PE_PE
	VALUES (8366,
	1,
	0,
	0,
	3);
INSERT INTO S_DIP
	VALUES (8365,
	22);
INSERT INTO S_DT
	VALUES (22,
	1,
	'same_as<Base_Attribute>',
	'',
	'');
INSERT INTO S_CDT
	VALUES (22,
	7);
INSERT INTO PE_PE
	VALUES (22,
	1,
	0,
	0,
	3);
INSERT INTO S_DIP
	VALUES (8365,
	8367);
INSERT INTO S_DT
	VALUES (8367,
	1,
	'inst_ref<Object>',
	'',
	'');
INSERT INTO S_CDT
	VALUES (8367,
	8);
INSERT INTO PE_PE
	VALUES (8367,
	1,
	0,
	0,
	3);
INSERT INTO S_DIP
	VALUES (8365,
	8368);
INSERT INTO S_DT
	VALUES (8368,
	1,
	'inst_ref_set<Object>',
	'',
	'');
INSERT INTO S_CDT
	VALUES (8368,
	9);
INSERT INTO PE_PE
	VALUES (8368,
	1,
	0,
	0,
	3);
INSERT INTO S_DIP
	VALUES (8365,
	8369);
INSERT INTO S_DT
	VALUES (8369,
	1,
	'inst<Event>',
	'',
	'');
INSERT INTO S_CDT
	VALUES (8369,
	10);
INSERT INTO PE_PE
	VALUES (8369,
	1,
	0,
	0,
	3);
INSERT INTO S_DIP
	VALUES (8365,
	8370);
INSERT INTO S_DT
	VALUES (8370,
	1,
	'inst<Mapping>',
	'',
	'');
INSERT INTO S_CDT
	VALUES (8370,
	11);
INSERT INTO PE_PE
	VALUES (8370,
	1,
	0,
	0,
	3);
INSERT INTO S_DIP
	VALUES (8365,
	8371);
INSERT INTO S_DT
	VALUES (8371,
	1,
	'inst_ref<Mapping>',
	'',
	'');
INSERT INTO S_CDT
	VALUES (8371,
	12);
INSERT INTO PE_PE
	VALUES (8371,
	1,
	0,
	0,
	3);
INSERT INTO S_DIP
	VALUES (8365,
	8372);
INSERT INTO S_DT
	VALUES (8372,
	1,
	'date',
	'',
	'');
INSERT INTO S_UDT
	VALUES (8372,
	8370,
	1);
INSERT INTO PE_PE
	VALUES (8372,
	1,
	0,
	0,
	3);
INSERT INTO S_DIP
	VALUES (8365,
	8373);
INSERT INTO S_DT
	VALUES (8373,
	1,
	'timestamp',
	'',
	'');
INSERT INTO S_UDT
	VALUES (8373,
	8370,
	2);
INSERT INTO PE_PE
	VALUES (8373,
	1,
	0,
	0,
	3);
INSERT INTO S_DIP
	VALUES (8365,
	8374);
INSERT INTO S_DT
	VALUES (8374,
	1,
	'inst_ref<Timer>',
	'',
	'');
INSERT INTO S_UDT
	VALUES (8374,
	8371,
	3);
INSERT INTO PE_PE
	VALUES (8374,
	1,
	0,
	0,
	3);
INSERT INTO S_DIP
	VALUES (8365,
	2434);
INSERT INTO S_DT
	VALUES (2434,
	1,
	'Multiplicity',
	'The Multiplicity data type allows specification of the range of allowable cardinality values.
--------------------------------------------------------------
Bridge:GD, ALS',
	'');
INSERT INTO S_EDT
	VALUES (2434);
INSERT INTO S_ENUM
	VALUES (8375,
	'Unknown',
	'Bridge:GD, ALS',
	2434,
	8376);
INSERT INTO S_ENUM
	VALUES (8376,
	'One',
	'Bridge:GD, ALS',
	2434,
	8377);
INSERT INTO S_ENUM
	VALUES (8377,
	'Many',
	'Bridge:GD, ALS',
	2434,
	0);
INSERT INTO PE_PE
	VALUES (2434,
	1,
	0,
	0,
	3);
INSERT INTO S_DIP
	VALUES (8365,
	779);
INSERT INTO S_DT
	VALUES (779,
	1,
	'Justification',
	'The Justification data type is used to specify text at a given location in a compartment.
------------------------------------------------------------------------------
Bridge:GD',
	'');
INSERT INTO S_EDT
	VALUES (779);
INSERT INTO S_ENUM
	VALUES (8378,
	'Center_in_X',
	'Bridge:GD',
	779,
	8379);
INSERT INTO S_ENUM
	VALUES (8380,
	'Left',
	'Bridge:GD',
	779,
	8381);
INSERT INTO S_ENUM
	VALUES (8382,
	'Right',
	'Bridge:GD',
	779,
	8380);
INSERT INTO S_ENUM
	VALUES (8383,
	'Bottom',
	'Bridge:GD',
	779,
	0);
INSERT INTO S_ENUM
	VALUES (8379,
	'Center',
	'Bridge:GD',
	779,
	8383);
INSERT INTO S_ENUM
	VALUES (8381,
	'Floating',
	'Bridge:GD',
	779,
	8378);
INSERT INTO PE_PE
	VALUES (779,
	1,
	0,
	0,
	3);
INSERT INTO S_DIP
	VALUES (8365,
	784);
INSERT INTO S_DT
	VALUES (784,
	1,
	'Style',
	'The Style data type specifies the precise form a graphical element will take when drawn.
--------------------------------------------------------------------------
Bridge:GD',
	'');
INSERT INTO S_EDT
	VALUES (784);
INSERT INTO S_ENUM
	VALUES (8384,
	'Box',
	'Bridge:GD',
	784,
	0);
INSERT INTO S_ENUM
	VALUES (8385,
	'RoundBox',
	'Bridge:GD',
	784,
	8386);
INSERT INTO S_ENUM
	VALUES (8387,
	'Folder',
	'Bridge:GD',
	784,
	8388);
INSERT INTO S_ENUM
	VALUES (8389,
	'Broken',
	'Bridge:GD',
	784,
	8384);
INSERT INTO S_ENUM
	VALUES (8390,
	'Solid',
	'Bridge:GD',
	784,
	8391);
INSERT INTO S_ENUM
	VALUES (8392,
	'Triangle',
	'Bridge:GD',
	784,
	8393);
INSERT INTO S_ENUM
	VALUES (8386,
	'OpenArrow',
	'Bridge:GD',
	784,
	8394);
INSERT INTO S_ENUM
	VALUES (8395,
	'FilledCircle',
	'Bridge:GD',
	784,
	8396);
INSERT INTO S_ENUM
	VALUES (8397,
	'BullsEye',
	'Bridge:GD',
	784,
	8389);
INSERT INTO S_ENUM
	VALUES (8394,
	'None',
	'Bridge:GD',
	784,
	8398);
INSERT INTO S_ENUM
	VALUES (8399,
	'Underlined',
	'Bridge:GD',
	784,
	8392);
INSERT INTO S_ENUM
	VALUES (8400,
	'DashDouble',
	'Bridge:GD',
	784,
	8401);
INSERT INTO S_ENUM
	VALUES (8396,
	'FilledArrow',
	'Bridge:GD',
	784,
	8402);
INSERT INTO S_ENUM
	VALUES (8401,
	'Dash',
	'Bridge:GD',
	784,
	8403);
INSERT INTO S_ENUM
	VALUES (8403,
	'Cross',
	'Bridge:GD',
	784,
	8404);
INSERT INTO S_ENUM
	VALUES (8393,
	'StickFigure',
	'Bridge:GD',
	784,
	8390);
INSERT INTO S_ENUM
	VALUES (8402,
	'Ellipse',
	'Bridge:GD',
	784,
	8405);
INSERT INTO S_ENUM
	VALUES (8406,
	'CircleCross',
	'Bridge:GD',
	784,
	8407);
INSERT INTO S_ENUM
	VALUES (8405,
	'Diamond',
	'Bridge:GD',
	784,
	8400);
INSERT INTO S_ENUM
	VALUES (8408,
	'ConcavePentagon',
	'Bridge:GD',
	784,
	8409);
INSERT INTO S_ENUM
	VALUES (8404,
	'ConvexPentagon',
	'Bridge:GD',
	784,
	8408);
INSERT INTO S_ENUM
	VALUES (8398,
	'Hourglass',
	'Bridge:GD',
	784,
	8387);
INSERT INTO S_ENUM
	VALUES (8410,
	'Component',
	'Bridge:GD',
	784,
	8406);
INSERT INTO S_ENUM
	VALUES (8391,
	'SemiCircle',
	'Bridge:GD',
	784,
	8385);
INSERT INTO S_ENUM
	VALUES (8407,
	'Circle',
	'',
	784,
	8397);
INSERT INTO S_ENUM
	VALUES (8409,
	'ComponentContainer',
	'',
	784,
	8410);
INSERT INTO S_ENUM
	VALUES (8388,
	'FilledSquare',
	'Bridge:GD',
	784,
	8395);
INSERT INTO S_ENUM
	VALUES (8411,
	'BoxArrowIn',
	'Bridge:GD',
	784,
	8399);
INSERT INTO S_ENUM
	VALUES (8412,
	'BoxArrowOut',
	'Bridge:GD',
	784,
	8411);
INSERT INTO S_ENUM
	VALUES (8413,
	'BoxArrowInOut',
	'Bridge:GD',
	784,
	8412);
INSERT INTO PE_PE
	VALUES (784,
	1,
	0,
	0,
	3);
INSERT INTO S_DIP
	VALUES (8365,
	880);
INSERT INTO S_DT
	VALUES (880,
	1,
	'End',
	'Text is positioned at a user adjustable offset from the Start, Middle and End of a connector. Start_Fixed and End_Fixed specify fixed position text found at the start and end of some connectors.
-------------------------------------------------------------
Bridge:GD',
	'');
INSERT INTO S_EDT
	VALUES (880);
INSERT INTO S_ENUM
	VALUES (8414,
	'Start',
	'Bridge:GD',
	880,
	8415);
INSERT INTO S_ENUM
	VALUES (8416,
	'End',
	'Bridge:GD',
	880,
	0);
INSERT INTO S_ENUM
	VALUES (8417,
	'Middle',
	'Bridge:GD',
	880,
	8418);
INSERT INTO S_ENUM
	VALUES (8419,
	'End_Fixed',
	'Bridge:GD',
	880,
	8416);
INSERT INTO S_ENUM
	VALUES (8420,
	'Start_Fixed',
	'Bridge:GD',
	880,
	8414);
INSERT INTO S_ENUM
	VALUES (8415,
	'None',
	'',
	880,
	8417);
INSERT INTO S_ENUM
	VALUES (8418,
	'Floating',
	'Bridge:GD',
	880,
	8419);
INSERT INTO PE_PE
	VALUES (880,
	1,
	0,
	0,
	3);
INSERT INTO S_DIP
	VALUES (8365,
	1224);
INSERT INTO S_DT
	VALUES (1224,
	1,
	'ParseStatus',
	'Indicates the status of the parse for an action specification in the attribute Action_Semantics',
	'');
INSERT INTO S_EDT
	VALUES (1224);
INSERT INTO S_ENUM
	VALUES (8421,
	'doNotParse',
	'Value: 0
Full Name: Do not parse',
	1224,
	0);
INSERT INTO S_ENUM
	VALUES (8422,
	'parseSuccessful',
	'Value: 1
Full Name: Parse successful',
	1224,
	8423);
INSERT INTO S_ENUM
	VALUES (8424,
	'parseUnsuccessful',
	'Value: 2
Full Name: Parse unsuccessful',
	1224,
	8422);
INSERT INTO S_ENUM
	VALUES (8423,
	'parseInitial',
	'Value: 3
Full Name: Do parse',
	1224,
	8421);
INSERT INTO PE_PE
	VALUES (1224,
	1,
	0,
	0,
	3);
INSERT INTO S_DIP
	VALUES (8365,
	1220);
INSERT INTO S_DT
	VALUES (1220,
	1,
	'Scope',
	'',
	'');
INSERT INTO S_EDT
	VALUES (1220);
INSERT INTO S_ENUM
	VALUES (8425,
	'Class',
	'Value: 0
Full Name: Class Based',
	1220,
	0);
INSERT INTO S_ENUM
	VALUES (8426,
	'Instance',
	'Value: 1
Full Name: Instance Based',
	1220,
	8425);
INSERT INTO PE_PE
	VALUES (1220,
	1,
	0,
	0,
	3);
INSERT INTO S_DIP
	VALUES (8365,
	4399);
INSERT INTO S_DT
	VALUES (4399,
	1,
	'ModelEventNotification',
	'This enumeration defines all possible changes that can occur to a model.  
The ALL_EVENTS enumerator is the sum of all values. 
It also defines the delta kinds in case of a MODEL_ELEMENT_CHANGED event type. ',
	'');
INSERT INTO S_EDT
	VALUES (4399);
INSERT INTO S_ENUM
	VALUES (8427,
	'MASK_NO_EVENTS',
	'Value: 0',
	4399,
	8428);
INSERT INTO S_ENUM
	VALUES (8429,
	'MASK_ALL_EVENTS',
	'Value: 127',
	4399,
	8430);
INSERT INTO S_ENUM
	VALUES (8431,
	'UNKNOWN',
	'Value: 1',
	4399,
	8432);
INSERT INTO S_ENUM
	VALUES (8433,
	'MODEL_ELEMENT_UNLOADED',
	'Value: 2',
	4399,
	8434);
INSERT INTO S_ENUM
	VALUES (8435,
	'MODEL_ELEMENT_PRE_DELETE',
	'Value: 4',
	4399,
	8436);
INSERT INTO S_ENUM
	VALUES (8436,
	'MODEL_ELEMENT_LOADED',
	'Value: 8',
	4399,
	8437);
INSERT INTO S_ENUM
	VALUES (8438,
	'MODEL_ELEMENT_PRE_RELOAD',
	'Value: 16',
	4399,
	8435);
INSERT INTO S_ENUM
	VALUES (8434,
	'MODEL_ELEMENT_RELOAD',
	'Value: 32',
	4399,
	8438);
INSERT INTO S_ENUM
	VALUES (8437,
	'MODEL_ELEMENT_CHANGED',
	'Value: 64',
	4399,
	8427);
INSERT INTO S_ENUM
	VALUES (8428,
	'MASK_NO_DELTAS',
	'Value: 255

The binary value is 00000011111111',
	4399,
	8429);
INSERT INTO S_ENUM
	VALUES (8430,
	'MASK_ALL_DELTAS',
	'Value: 7936

The binary value is 11111000000000',
	4399,
	8439);
INSERT INTO S_ENUM
	VALUES (8439,
	'DELTA_NEW',
	'Value: 4096

The binary value is 01000000000000',
	4399,
	8440);
INSERT INTO S_ENUM
	VALUES (8441,
	'DELTA_DELETE',
	'Value: 2048

The binary value is 00100000000000',
	4399,
	8442);
INSERT INTO S_ENUM
	VALUES (8442,
	'DELTA_ATTRIBUTE_CHANGE',
	'Value: 1024

The binary value is 00010000000000',
	4399,
	0);
INSERT INTO S_ENUM
	VALUES (8443,
	'DELTA_ELEMENT_RELATED',
	'Value: 512

The binary value is 00001000000000',
	4399,
	8441);
INSERT INTO S_ENUM
	VALUES (8440,
	'DELTA_ELEMENT_UNRELATED',
	'Value: 256

The binary value is 00000100000000',
	4399,
	8443);
INSERT INTO S_ENUM
	VALUES (8432,
	'MODEL_EXECUTION_STOPPED',
	'Value:128',
	4399,
	8433);
INSERT INTO PE_PE
	VALUES (4399,
	1,
	0,
	0,
	3);
INSERT INTO S_DIP
	VALUES (8365,
	2901);
INSERT INTO S_DT
	VALUES (2901,
	1,
	'Visibility',
	'',
	'');
INSERT INTO S_EDT
	VALUES (2901);
INSERT INTO S_ENUM
	VALUES (8444,
	'Private',
	'Value: 0
Full Name: Private',
	2901,
	0);
INSERT INTO S_ENUM
	VALUES (8445,
	'Public',
	'Value: 1
Full Name: Public
',
	2901,
	8444);
INSERT INTO S_ENUM
	VALUES (8446,
	'Protected',
	'Value: 2
Full Name: Protected',
	2901,
	8445);
INSERT INTO PE_PE
	VALUES (2901,
	1,
	0,
	0,
	3);
INSERT INTO S_DIP
	VALUES (8365,
	317);
INSERT INTO S_DT
	VALUES (317,
	1,
	'instance',
	'',
	'');
INSERT INTO S_UDT
	VALUES (317,
	8371,
	0);
INSERT INTO PE_PE
	VALUES (317,
	1,
	0,
	0,
	3);
INSERT INTO S_DIP
	VALUES (8365,
	4438);
INSERT INTO S_DT
	VALUES (4438,
	1,
	'Token',
	'Each node in the syntax tree has a token associated with it.
We define the type here so that we can pass this data to the 
verification functions, which then pass it on to error reporting 
function, if the verification fails.
Bridge:ALS',
	'');
INSERT INTO S_UDT
	VALUES (4438,
	8371,
	0);
INSERT INTO PE_PE
	VALUES (4438,
	1,
	0,
	0,
	3);
INSERT INTO S_DIP
	VALUES (8365,
	4670);
INSERT INTO S_DT
	VALUES (4670,
	1,
	'OalConstants',
	'Bridge:ALS',
	'');
INSERT INTO S_EDT
	VALUES (4670);
INSERT INTO S_ENUM
	VALUES (8447,
	'FUNCTION_TYPE',
	'',
	4670,
	8448);
INSERT INTO S_ENUM
	VALUES (8448,
	'BRIDGE_TYPE',
	'',
	4670,
	0);
INSERT INTO S_ENUM
	VALUES (8449,
	'OPERATION_TYPE',
	'',
	4670,
	8450);
INSERT INTO S_ENUM
	VALUES (8451,
	'STATE_TYPE',
	'',
	4670,
	8452);
INSERT INTO S_ENUM
	VALUES (8450,
	'MDA_TYPE',
	'',
	4670,
	8453);
INSERT INTO S_ENUM
	VALUES (8453,
	'IB_OPERATION_TYPE',
	'',
	4670,
	8447);
INSERT INTO S_ENUM
	VALUES (8454,
	'REQ_OPERATION_TYPE',
	'',
	4670,
	8455);
INSERT INTO S_ENUM
	VALUES (8456,
	'PROV_OPERATION_TYPE',
	'',
	4670,
	8449);
INSERT INTO S_ENUM
	VALUES (8452,
	'REQ_SIGNAL_TYPE',
	'',
	4670,
	8454);
INSERT INTO S_ENUM
	VALUES (8455,
	'PROV_SIGNAL_TYPE',
	'',
	4670,
	8456);
INSERT INTO S_ENUM
	VALUES (8457,
	'TRANSITION_TYPE',
	'',
	4670,
	8451);
INSERT INTO PE_PE
	VALUES (4670,
	1,
	0,
	0,
	3);
INSERT INTO S_DIP
	VALUES (8365,
	8458);
INSERT INTO S_DT
	VALUES (8458,
	1,
	'RunStateType',
	'',
	'');
INSERT INTO S_EDT
	VALUES (8458);
INSERT INTO S_ENUM
	VALUES (8459,
	'Running',
	'',
	8458,
	0);
INSERT INTO S_ENUM
	VALUES (8460,
	'Suspended',
	'',
	8458,
	8461);
INSERT INTO S_ENUM
	VALUES (8462,
	'Terminated',
	'',
	8458,
	8460);
INSERT INTO S_ENUM
	VALUES (8461,
	'Stepping',
	'',
	8458,
	8459);
INSERT INTO PE_PE
	VALUES (8458,
	1,
	0,
	0,
	3);
INSERT INTO S_DIP
	VALUES (8365,
	8463);
INSERT INTO S_DT
	VALUES (8463,
	1,
	'Breakpoint_Type',
	'',
	'');
INSERT INTO S_EDT
	VALUES (8463);
INSERT INTO S_ENUM
	VALUES (8464,
	'Association',
	'',
	8463,
	0);
INSERT INTO S_ENUM
	VALUES (8465,
	'Event_BP',
	'',
	8463,
	8466);
INSERT INTO S_ENUM
	VALUES (8467,
	'State',
	'',
	8463,
	8468);
INSERT INTO S_ENUM
	VALUES (8466,
	'Attribute',
	'',
	8463,
	8464);
INSERT INTO S_ENUM
	VALUES (8468,
	'OAL',
	'',
	8463,
	8469);
INSERT INTO S_ENUM
	VALUES (8469,
	'Instance',
	'',
	8463,
	8465);
INSERT INTO PE_PE
	VALUES (8463,
	1,
	0,
	0,
	3);
INSERT INTO S_DIP
	VALUES (8365,
	1744);
INSERT INTO S_DT
	VALUES (1744,
	1,
	'StateChangeType',
	'',
	'');
INSERT INTO S_EDT
	VALUES (1744);
INSERT INTO S_ENUM
	VALUES (8470,
	'Entry',
	'',
	1744,
	0);
INSERT INTO S_ENUM
	VALUES (8471,
	'Exit',
	'',
	1744,
	8470);
INSERT INTO PE_PE
	VALUES (1744,
	1,
	0,
	0,
	3);
INSERT INTO S_DIP
	VALUES (8365,
	1823);
INSERT INTO S_DT
	VALUES (1823,
	1,
	'EventProcessType',
	'',
	'');
INSERT INTO S_EDT
	VALUES (1823);
INSERT INTO S_ENUM
	VALUES (8472,
	'Enqueued',
	'',
	1823,
	8473);
INSERT INTO S_ENUM
	VALUES (8473,
	'Dequeued',
	'',
	1823,
	8474);
INSERT INTO S_ENUM
	VALUES (8474,
	'CantHappen',
	'',
	1823,
	0);
INSERT INTO S_ENUM
	VALUES (8475,
	'Ignored',
	'',
	1823,
	8472);
INSERT INTO PE_PE
	VALUES (1823,
	1,
	0,
	0,
	3);
INSERT INTO S_DIP
	VALUES (8365,
	4654);
INSERT INTO S_DT
	VALUES (4654,
	1,
	'IFDirectionType',
	'BridgePoint allows the user to specify communication direction of individual 
elements in an interface as opposed to on the interface as a whole (which is 
what UML does).  For example, in UML when an interface is specified as being 
provided, all that interface''s operations are one way (from server to 
client).  Likewise, when a interface is specified as being required, all the 
operations are one way (from client to server).  In reality, interfaces are 
not often like this. There is a mixture of client to server and server to 
client in one interface.     This enum is used at the operation/signal level 
to determine if it is to be used for client to server or server to client 
communication.',
	'');
INSERT INTO S_EDT
	VALUES (4654);
INSERT INTO S_ENUM
	VALUES (8476,
	'ClientServer',
	'Value: 0
Full Name: To Provider',
	4654,
	0);
INSERT INTO S_ENUM
	VALUES (8477,
	'ServerClient',
	'Value: 1
Full Name: From Provider',
	4654,
	8476);
INSERT INTO PE_PE
	VALUES (4654,
	1,
	0,
	0,
	3);
INSERT INTO S_DIP
	VALUES (8365,
	8478);
INSERT INTO S_DT
	VALUES (8478,
	1,
	'StateEnum',
	'',
	'');
INSERT INTO S_EDT
	VALUES (8478);
INSERT INTO S_ENUM
	VALUES (8479,
	'Enabled',
	'',
	8478,
	8480);
INSERT INTO S_ENUM
	VALUES (8480,
	'Disabled',
	'',
	8478,
	0);
INSERT INTO PE_PE
	VALUES (8478,
	1,
	0,
	0,
	3);
INSERT INTO S_DIP
	VALUES (8365,
	4355);
INSERT INTO S_DT
	VALUES (4355,
	1,
	'ReentrantLock',
	'',
	'');
INSERT INTO S_UDT
	VALUES (4355,
	8371,
	0);
INSERT INTO PE_PE
	VALUES (4355,
	1,
	0,
	0,
	3);
INSERT INTO S_DIP
	VALUES (8365,
	2878);
INSERT INTO S_DT
	VALUES (2878,
	1,
	'ElementTypeConstants',
	'',
	'');
INSERT INTO S_EDT
	VALUES (2878);
INSERT INTO S_ENUM
	VALUES (8481,
	'FUNCTION',
	'',
	2878,
	0);
INSERT INTO S_ENUM
	VALUES (8482,
	'COMPONENT',
	'',
	2878,
	8483);
INSERT INTO S_ENUM
	VALUES (8483,
	'DATATYPE',
	'',
	2878,
	8484);
INSERT INTO S_ENUM
	VALUES (8484,
	'CLASS',
	'',
	2878,
	8481);
INSERT INTO S_ENUM
	VALUES (8485,
	'EE',
	'',
	2878,
	8482);
INSERT INTO S_ENUM
	VALUES (8486,
	'INTERFACE',
	'',
	2878,
	8485);
INSERT INTO S_ENUM
	VALUES (8487,
	'PACKAGE',
	'',
	2878,
	8486);
INSERT INTO S_ENUM
	VALUES (8488,
	'PORT',
	'',
	2878,
	8487);
INSERT INTO S_ENUM
	VALUES (8489,
	'ASSOCIATION',
	'',
	2878,
	8488);
INSERT INTO S_ENUM
	VALUES (8490,
	'CONSTANT',
	'',
	2878,
	8489);
INSERT INTO S_ENUM
	VALUES (8491,
	'ACTIVITY_PARTITION',
	'',
	2878,
	8490);
INSERT INTO S_ENUM
	VALUES (8492,
	'ACTIVITY_EDGE',
	'This enumeration may need to be replaced with several more specific ones.',
	2878,
	8491);
INSERT INTO S_ENUM
	VALUES (8493,
	'TIMING_MARK',
	'',
	2878,
	8492);
INSERT INTO S_ENUM
	VALUES (8494,
	'INTERACTION_PARTICIPANT',
	'This enumeration may need to be replaced with several more specific ones.',
	2878,
	8493);
INSERT INTO S_ENUM
	VALUES (8495,
	'TIME_SPAN',
	'',
	2878,
	8494);
INSERT INTO S_ENUM
	VALUES (8496,
	'USE_CASE_ASSOCIATION',
	'',
	2878,
	8495);
INSERT INTO S_ENUM
	VALUES (8497,
	'MESSAGE',
	'This enumeration may need to be replaced with several more specific ones.',
	2878,
	8496);
INSERT INTO S_ENUM
	VALUES (8498,
	'ACTIVITY_NODE',
	'This enumeration may need to be replaced with several more specific ones.',
	2878,
	8497);
INSERT INTO S_ENUM
	VALUES (8499,
	'IMPORTED_CLASS',
	'',
	2878,
	8498);
INSERT INTO S_ENUM
	VALUES (8500,
	'INTERFACE_REFERENCE',
	'',
	2878,
	8499);
INSERT INTO S_ENUM
	VALUES (8501,
	'COMPONENT_REFERENCE',
	'',
	2878,
	8500);
INSERT INTO S_ENUM
	VALUES (8502,
	'SATISFACTION',
	'',
	2878,
	8501);
INSERT INTO S_ENUM
	VALUES (8503,
	'DELEGATION',
	'',
	2878,
	8502);
INSERT INTO PE_PE
	VALUES (2878,
	1,
	0,
	0,
	3);
INSERT INTO S_DIP
	VALUES (8365,
	2978);
INSERT INTO S_DT
	VALUES (2978,
	1,
	'long',
	'',
	'');
INSERT INTO S_UDT
	VALUES (2978,
	8370,
	0);
INSERT INTO PE_PE
	VALUES (2978,
	1,
	0,
	0,
	3);
INSERT INTO S_DIP
	VALUES (8365,
	2512);
INSERT INTO S_DT
	VALUES (2512,
	1,
	'SearchScope',
	'',
	'');
INSERT INTO S_EDT
	VALUES (2512);
INSERT INTO S_ENUM
	VALUES (8504,
	'EnclosingSystem',
	'',
	2512,
	0);
INSERT INTO S_ENUM
	VALUES (8505,
	'Universe',
	'',
	2512,
	8504);
INSERT INTO S_ENUM
	VALUES (8506,
	'Selection',
	'',
	2512,
	8505);
INSERT INTO PE_PE
	VALUES (2512,
	1,
	0,
	0,
	3);
INSERT INTO S_DIP
	VALUES (8365,
	3500);
INSERT INTO S_DT
	VALUES (3500,
	1,
	'SynchronizationType',
	'',
	'');
INSERT INTO S_EDT
	VALUES (3500);
INSERT INTO S_ENUM
	VALUES (8507,
	'Pull',
	'',
	3500,
	0);
INSERT INTO S_ENUM
	VALUES (8508,
	'Push',
	'',
	3500,
	8507);
INSERT INTO PE_PE
	VALUES (3500,
	1,
	0,
	0,
	3);
INSERT INTO S_DIP
	VALUES (8365,
	2958);
INSERT INTO S_DT
	VALUES (2958,
	1,
	'Severity',
	'',
	'');
INSERT INTO S_EDT
	VALUES (2958);
INSERT INTO S_ENUM
	VALUES (8509,
	'Warning',
	'',
	2958,
	0);
INSERT INTO S_ENUM
	VALUES (8510,
	'Error',
	'',
	2958,
	8509);
INSERT INTO S_ENUM
	VALUES (8511,
	'Information',
	'',
	2958,
	8510);
INSERT INTO EP_SPKG
	VALUES (8365,
	0);
-- BP 7.1 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (8512,
	'Constants',
	'This subsystem contains the metamodel support for constants.  Individual
constants are contained inside a constant specification on the datatypes
diagram.',
	'CNST',
	1500,
	1,
	0);
INSERT INTO S_SID
	VALUES (1,
	8512);
INSERT INTO O_IOBJ
	VALUES (8513,
	936,
	0,
	8512,
	'Data Type Package',
	'S_DPK');
INSERT INTO O_IOBJ
	VALUES (8514,
	32,
	0,
	8512,
	'Data Type',
	'S_DT');
INSERT INTO R_SIMP
	VALUES (8515);
INSERT INTO R_REL
	VALUES (8515,
	1500,
	'CrossComponent:true',
	8512);
INSERT INTO R_FORM
	VALUES (66,
	8515,
	8516,
	1,
	1,
	'defines the type of');
INSERT INTO R_RGO
	VALUES (66,
	8515,
	8516);
INSERT INTO R_OIR
	VALUES (66,
	8515,
	8516,
	0);
INSERT INTO R_PART
	VALUES (32,
	8515,
	8517,
	0,
	0,
	'is defined by');
INSERT INTO O_RTIDA
	VALUES (156,
	32,
	0,
	8515,
	8517);
INSERT INTO R_RTO
	VALUES (32,
	8515,
	8517,
	0);
INSERT INTO R_OIR
	VALUES (32,
	8515,
	8517,
	8514);
INSERT INTO R_SUBSUP
	VALUES (8518);
INSERT INTO R_REL
	VALUES (8518,
	1502,
	'',
	8512);
INSERT INTO R_SUPER
	VALUES (66,
	8518,
	8519);
INSERT INTO O_RTIDA
	VALUES (290,
	66,
	0,
	8518,
	8519);
INSERT INTO O_RTIDA
	VALUES (291,
	66,
	0,
	8518,
	8519);
INSERT INTO R_RTO
	VALUES (66,
	8518,
	8519,
	0);
INSERT INTO R_OIR
	VALUES (66,
	8518,
	8519,
	0);
INSERT INTO R_SUB
	VALUES (8520,
	8518,
	8521);
INSERT INTO R_RGO
	VALUES (8520,
	8518,
	8521);
INSERT INTO R_OIR
	VALUES (8520,
	8518,
	8521,
	0);
INSERT INTO R_SUBSUP
	VALUES (8522);
INSERT INTO R_REL
	VALUES (8522,
	1503,
	'',
	8512);
INSERT INTO R_SUPER
	VALUES (8520,
	8522,
	8523);
INSERT INTO O_RTIDA
	VALUES (8524,
	8520,
	0,
	8522,
	8523);
INSERT INTO O_RTIDA
	VALUES (8525,
	8520,
	0,
	8522,
	8523);
INSERT INTO R_RTO
	VALUES (8520,
	8522,
	8523,
	0);
INSERT INTO R_OIR
	VALUES (8520,
	8522,
	8523,
	0);
INSERT INTO R_SUB
	VALUES (8526,
	8522,
	8527);
INSERT INTO R_RGO
	VALUES (8526,
	8522,
	8527);
INSERT INTO R_OIR
	VALUES (8526,
	8522,
	8527,
	0);
INSERT INTO R_SIMP
	VALUES (8528);
INSERT INTO R_REL
	VALUES (8528,
	1504,
	'',
	8512);
INSERT INTO R_PART
	VALUES (939,
	8528,
	8529,
	0,
	0,
	'is contained by');
INSERT INTO O_RTIDA
	VALUES (961,
	939,
	0,
	8528,
	8529);
INSERT INTO R_RTO
	VALUES (939,
	8528,
	8529,
	0);
INSERT INTO R_OIR
	VALUES (939,
	8528,
	8529,
	0);
INSERT INTO R_FORM
	VALUES (66,
	8528,
	8530,
	1,
	1,
	'contains');
INSERT INTO R_RGO
	VALUES (66,
	8528,
	8530);
INSERT INTO R_OIR
	VALUES (66,
	8528,
	8530,
	0);
INSERT INTO R_SIMP
	VALUES (8531);
INSERT INTO R_REL
	VALUES (8531,
	1505,
	'',
	8512);
INSERT INTO R_PART
	VALUES (66,
	8531,
	8532,
	0,
	1,
	'succeeds');
INSERT INTO O_RTIDA
	VALUES (290,
	66,
	0,
	8531,
	8532);
INSERT INTO O_RTIDA
	VALUES (291,
	66,
	0,
	8531,
	8532);
INSERT INTO R_RTO
	VALUES (66,
	8531,
	8532,
	0);
INSERT INTO R_OIR
	VALUES (66,
	8531,
	8532,
	0);
INSERT INTO R_FORM
	VALUES (66,
	8531,
	8533,
	0,
	1,
	'precedes');
INSERT INTO R_RGO
	VALUES (66,
	8531,
	8533);
INSERT INTO R_OIR
	VALUES (66,
	8531,
	8533,
	0);
INSERT INTO R_ASSOC
	VALUES (8534);
INSERT INTO R_REL
	VALUES (8534,
	1506,
	'',
	8512);
INSERT INTO R_AONE
	VALUES (939,
	8534,
	8535,
	1,
	1,
	'contains');
INSERT INTO O_RTIDA
	VALUES (961,
	939,
	0,
	8534,
	8535);
INSERT INTO R_RTO
	VALUES (939,
	8534,
	8535,
	0);
INSERT INTO R_OIR
	VALUES (939,
	8534,
	8535,
	0);
INSERT INTO R_AOTH
	VALUES (936,
	8534,
	8536,
	0,
	0,
	'is contained in');
INSERT INTO O_RTIDA
	VALUES (943,
	936,
	0,
	8534,
	8536);
INSERT INTO R_RTO
	VALUES (936,
	8534,
	8536,
	0);
INSERT INTO R_OIR
	VALUES (936,
	8534,
	8536,
	8513);
INSERT INTO R_ASSR
	VALUES (8537,
	8534,
	8538,
	0);
INSERT INTO R_RGO
	VALUES (8537,
	8534,
	8538);
INSERT INTO R_OIR
	VALUES (8537,
	8534,
	8538,
	0);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (66,
	'Symbolic Constant',
	1501,
	'CNST_SYC',
	'A constant with a name as opposed to a literal constant that has a value only.',
	8512);
INSERT INTO O_TFR
	VALUES (8539,
	66,
	'actionFilter',
	'Returns whether or not a given context menu entry item should be available.',
	316,
	1,
	'if (param.name == "can" )
  if ( param.value == "move up" )
    select one prev_attr related by self->CNST_SYC[R1505.''succeeds''];
    return not_empty prev_attr;
  elif ( param.value == "move down" )
    select one next_attr related by self->CNST_SYC[R1505.''precedes''];
    return not_empty next_attr;
  end if;
end if;
return false;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (8540,
	8539,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (8541,
	8539,
	'value',
	322,
	0,
	'',
	8540,
	'');
INSERT INTO O_TFR
	VALUES (8542,
	66,
	'convertToInstance',
	'A utility operation to get an instance of this class.

Translate: native',
	317,
	1,
	'// just return this instance as an Object
return this;',
	0,
	'',
	8539);
INSERT INTO O_TFR
	VALUES (8543,
	66,
	'dispose',
	'',
	19,
	1,
	'// Symbolic Constant (CNST_SYC) dispose operation

// Remove the associated subtype chain
select one lfsc related by self->CNST_LFSC[R1502];
if not_empty lfsc
  lfsc.dispose();
end if;





// Remove self from the list of chained symbolic constants by making the
// preceding element point to the succeeding element
select one owningSpec related by self->CNST_CSP[R1504];
select one nextConst related by self->CNST_SYC[R1505.''precedes''];
::changeNotificationEnablement(enabled:false);
if(not_empty nextConst)
  if (self.Previous_Const_ID == GD::NULL_UNIQUE_ID())
    // this attribute is at the top of the list
    unrelate self from nextConst across R1505.''precedes'';
  else
    // otherwise this attribute is somewhere in the middle
    // or at the end
    select many consts related by owningSpec->CNST_SYC[R1504];
    for each const in consts
      select one thisconst related by const->CNST_SYC[R1505.''precedes''];
      if (self == thisconst)
        // now tell the next const that this is not
        // the const that it succeeds anymore
        unrelate self from nextConst across R1505.''precedes'';
        // and tell this const that it no longer succeeds
        // any const. 
        // *NOTE* this is not really required for deletion but
        // more for restoration
        unrelate self from const across R1505.''succeeds'';
        // finally connect the two const that this
        // const was between
        relate nextConst to const across R1505.''succeeds'';
        break;
      end if;
    end for;
  end if;
else
  // we are at the end of the list
  select one priorCost related by self->CNST_SYC[R1505.''succeeds''];
  if ( not_empty priorCost )
    unrelate self from priorCost across R1505.''succeeds'';
  end if;
end if;
::changeNotificationEnablement(enabled:true);

// Unrelate from the associated datatype
select one dt related by self->S_DT[R1500];
unrelate self from dt across R1500;

// Unrelate from constant specification
select one csp related by self->CNST_CSP[R1504];
unrelate self from csp across R1504;

// Clean up Value Subsystem ties
select many scvs related by self->V_SCV[R850];
for each scv in scvs
  unrelate self from scv across R850;
end for;

delete object instance self;',
	1,
	'',
	8542);
INSERT INTO O_TFR
	VALUES (8544,
	66,
	'initialize',
	'The initialization operation for this class.',
	19,
	1,
	'// Symbolic Constant (CNST_SYC) initialize operation
select many peers related by self->CNST_CSP[R1504]->CNST_SYC[R1504];
for each peer in peers
  select one nextConst related by peer->CNST_SYC[R1505.''precedes''];
  if (empty nextConst)
    break;
  end if;
end for;
if (not_empty peer)
  //
  // If there was a previous last attribute link this one to the end . . .
  // We need to disable the listeners because the ordering change
  // causes a NPE 
  ::changeNotificationEnablement(enabled:false);
  relate peer to self across R1505.''precedes'';
  ::changeNotificationEnablement(enabled:true);
end if;
::changeNotificationEnablement(enabled:true);
name = ::getUniqueInitialName(
    instance: self.convertToInstance(),
    candidateName: "Unnamed Constant");    
success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:true);    
if ( success!="") 
 self.Name=success;
else 
 self.dispose();
end if;        

 ',
	1,
	'',
	8543);
INSERT INTO O_TFR
	VALUES (8545,
	66,
	'moveDown',
	'Move this Symbolic Constant down in the list of CNST_SYCs in this Constant
Specification Package.',
	19,
	1,
	'::changeNotificationEnablement(enabled:false);
select one next_attr related by self->CNST_SYC[R1505.''precedes''];
select one prev_attr related by self->CNST_SYC[R1505.''succeeds''];
select one next_next_attr related by next_attr->CNST_SYC[R1505.''precedes''];

if ( not_empty next_next_attr )
  unrelate next_next_attr from next_attr across R1505.''succeeds'';
end if;
if ( not_empty prev_attr )
  unrelate self from prev_attr across R1505.''succeeds'';
end if;
unrelate next_attr from self across R1505.''succeeds'';

if ( not_empty prev_attr )
  relate next_attr to prev_attr across R1505.''succeeds'';
end if;

// want to enable listeners at the last possible moment
if ( empty next_next_attr )
  ::changeNotificationEnablement(enabled:true);
end if;
relate self to next_attr across R1505.''succeeds'';
if ( not_empty next_next_attr )
  ::changeNotificationEnablement(enabled:true);
  relate next_next_attr to self across R1505.''succeeds'';
end if;',
	1,
	'',
	8544);
INSERT INTO O_TFR
	VALUES (8546,
	66,
	'moveUp',
	'Move this Symbolic Constant up in the list of CNST_SYCs in this Constant
Specification Package.',
	19,
	1,
	'::changeNotificationEnablement(enabled:false);
select one prev_attr related by self->CNST_SYC[R1505.''succeeds''];
select one prev_prev_attr related by prev_attr->CNST_SYC[R1505.''succeeds''];
select one next_attr related by self->CNST_SYC[R1505.''precedes''];

if ( not_empty prev_prev_attr )
  unrelate prev_attr from prev_prev_attr across R1505.''succeeds'';
end if;
if ( not_empty next_attr )
  unrelate next_attr from self across R1505.''succeeds'';
end if;
unrelate self from prev_attr across R1505.''succeeds'';

if ( not_empty prev_prev_attr )
  relate self to prev_prev_attr across R1505.''succeeds'';
end if;
// want to enable listeners at the last possible moment
if ( empty next_attr )
  ::changeNotificationEnablement(enabled:true);
end if;
relate prev_attr to self across R1505.''succeeds'';
if ( not_empty next_attr )
  ::changeNotificationEnablement(enabled:true);
  relate next_attr to prev_attr across R1505.''succeeds'';
end if;',
	1,
	'',
	8545);
INSERT INTO O_TFR
	VALUES (8547,
	66,
	'setToDefaultDatatype',
	'This function is called when the datatype associated with this constant needs to
be set to the default "integer".  This is needed during initialization and when
the previously associated datatype is disposed.',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Symbolic Constant (CNST_SYC) setToDefaultDatatype operation

// Get the integer core data type
select any dom from instances of S_DOM;
select any intdt related by dom->S_DT[R14] where selected.Name == "integer";

select one rootPkg related by self->CNST_CSP[R1504]->CNST_CIP[R1506]->S_DPK[R1506];
actualRootPkg = rootPkg;
select one sys related by rootPkg->SLD_SDP[R4400]->S_SYS[R4400];
if(empty sys)
  while(not_empty rootPkg)
    select one sys related by rootPkg->SLD_SDP[R4400]->S_SYS[R4400];
    select one rootPkg related by rootPkg->S_DPIP[R38]->S_DPK[R37];
    if(not_empty rootPkg)
      actualRootPkg = rootPkg;
    end if;
  end while;
end if;
if(empty sys)
  select one sys related by actualRootPkg->EP_SPKG[R1402]->EP_PKG[R1400]
                                                                 ->S_SYS[R1405];
end if;

if (empty sys)
  // if empty we may be in a generic package
  select one sys related by self->CNST_CSP[R1504]->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405];
  int_dt_id = GD::NULL_UNIQUE_ID();
  if not_empty sys
    int_dt_id = sys.getCoreTypeId(name:"integer");
  end if;
  select any pe from instances of PE_PE where selected.Element_ID == int_dt_id;
  select one int_dt related by pe->S_DT[R8001];
  if (empty int_dt)
    // TBD Why is this here?
    select any int_dt related by sys->EP_PKG[R1405]->PE_PE[R8000]->S_DT[R8001] where (selected.Name == "integer");
  end if;
end if;
// TBD What is the difference between int_dt and intdt? Why do we need both?
if((empty intdt) and (not_empty sys))
  intdt_id = GD::NULL_UNIQUE_ID();
  if not_empty sys
    intdt_id = sys.getCoreTypeId(name:"integer");
  end if;
  select any pe from instances of PE_PE where selected.Element_ID == intdt_id;
  select one intdt related by pe->S_DT[R8001]; 
end if;

if(empty intdt)
  // if the integer data type is still empty then this domain is the formal
  // content of a component
  select one dtPkg related by self->CNST_CSP[R1504]->CNST_CIP[R1506]->S_DPK[R1506];
  select any domain from instances of S_DOM where (selected.Dom_ID == dtPkg.getDomainId());

  select one compSys related by domain->CN_DC[R4204]->C_C[R4204]->CP_CP[R4608]->S_SYS[R4606];
  intdt_id = GD::NULL_UNIQUE_ID();
  if not_empty compSys
    intdt_id = compSys.getCoreTypeId(name:"integer");
  end if;
  select any pe from instances of PE_PE where selected.Element_ID == intdt_id;
  select one intdt related by pe->S_DT[R8001]; 
end if;


// Now that we have the integer datatype, clean up the CNST_SYC->S_DT
// association and reset them to the integer. Set the value of the constant to 0.
select one dt related by self->S_DT[R1500];
unrelate self from dt across R1500;
relate self to intdt across R1500;
select one lsc related by self->CNST_LFSC[R1502]->CNST_LSC[R1503];
if (not_empty lsc)
  lsc.Value = "0";
end if;',
	1,
	'',
	8548);
INSERT INTO O_TFR
	VALUES (8548,
	66,
	'resolveDatatype',
	'This operation is called automatically by the paste infrastructure to fix up
datatype relationships for pasted elements.',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
//
// Symbolic Constant.resolveDatatype()
//
select one dtProxy related by self->S_DT[R1500];
if(not_empty dtProxy and not Util::isProxy(element:self.convertToInstance()))
  name = dtProxy.Name;
  unrelate dtProxy from self across R1500;
  
  select one packageableElem related by self->CNST_CSP[R1504]->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = not_empty package or not_empty component;
  if isInGenericPackage
    id = packageableElem.resolveDataTypeRelativeToSelf(default_name:"integer",
                                                            expected_name:name);                                                          
    select any resolvedDt related by package->PE_VIS[R8002]->
                         PE_PE[R8002]->S_DT[R8001] where selected.DT_ID == id;
    if (empty resolvedDt)
      select any resolvedDt related by component->PE_CVS[R8004]->
                       PE_PE[R8004]->S_DT[R8001] where selected.DT_ID == id;
    end if;	
    if not_empty resolvedDt
      relate resolvedDt to self across R1500;
    end if;
  else

    select one system related by self->CNST_CSP[R1504]->CNST_CIP[R1506]->S_DPK[R1506]
                                                 ->SLD_SDP[R4400]->S_SYS[R4400];
    if(not empty system)
      // this is a system data type only allow resolving dts
      // from the system level
      r_dt_id = system.getCoreTypeId(name:name);
      select any pe from instances of PE_PE where selected.Element_ID == r_dt_id;
      select one resolvedDT related by pe->S_DT[R8001]; 
      if(empty resolvedDT)
        r_dt_id = system.getCoreTypeId(name:"integer");
        select any pe from instances of PE_PE where
                                                 selected.Element_ID == r_dt_id;
        select one resolvedDT related by pe->S_DT[R8001]; 
      end if;
      if(not_empty resolvedDT)
        relate resolvedDT to self across R1500;
      end if;
    else
      select one dtPkg related by self->CNST_CSP[R1504]->CNST_CIP[R1506]->S_DPK[R1506];
      select any domain from instances of S_DOM where (selected.Dom_ID == dtPkg.getDomainId());
      id = domain.resolveDataTypeRelativeToSelf(default_name:"integer",
                                                              expected_name:name);
      select any resolvedDT related by domain->S_DT[R14]
                                                   where (selected.DT_ID == id);
      if(empty resolvedDT)
        // if the data type was not found local to the domain
        // check for a system level data type
        select one domSys related by domain->CN_DC[R4204]->C_C[R4204]
                                                   ->CP_CP[R4608]->S_SYS[R4606];
        select any resolvedDT related by domSys->SLD_SDINP[R4402]->S_DT[R4401]
                                                   where (selected.DT_ID == id);
        if empty resolvedDT and not_empty domSys and domSys.useGlobals
          select any pe related by domSys->G_EIS[R9100]->PE_PE[R9100]
                                                where selected.Element_ID == id;
          select one resolvedDT related by pe->S_DT[R8001]; 
        end if;
      end if;
      if(not_empty resolvedDT)
        relate resolvedDT to self across R1500;
      end if;
    end if;
  end if;
end if;',
	1,
	'',
	8546);
INSERT INTO O_TFR
	VALUES (8549,
	66,
	'checkIntegrity',
	'',
	19,
	1,
	'/**
 *  Create an integrity issue if there are any other constants in the same
 *  specification with a matching name
 */
select one spec related by self->CNST_CSP[R1504];
select one package related by spec->PE_PE[R8001]->EP_PKG[R8000];
select one system related by package->S_SYS[R1405];
sys_id = GD::NULL_UNIQUE_ID();
if(not_empty system)
  sys_id = system.Sys_ID;
end if;
select many constants related by package->PE_PE[R8000]->CNST_CSP[R8001]
                                                              ->CNST_SYC[R1504];
for each constant in constants
  if(constant != self and constant.Name == self.Name)
    MI_IM::createIssue(sys_id:sys_id, description:
         "Found another constant under the same specification with a " +
                                                          "matching name.",
                                      severity:Severity::Error, name:self.Name,
                                         path:package.getPath(path:"") + "::" +
                                      spec.InformalGroupName + "::" + self.Name,
                    id:self.Const_ID, element:self.convertToInstance());
  end if;
end for;',
	1,
	'',
	8547);
INSERT INTO O_NBATTR
	VALUES (290,
	66);
INSERT INTO O_BATTR
	VALUES (290,
	66);
INSERT INTO O_ATTR
	VALUES (290,
	66,
	0,
	'Const_ID',
	'',
	'',
	'Const_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8550,
	66);
INSERT INTO O_BATTR
	VALUES (8550,
	66);
INSERT INTO O_ATTR
	VALUES (8550,
	66,
	290,
	'Name',
	'Full Name: Name
Description: The name of this constant',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8551,
	66);
INSERT INTO O_BATTR
	VALUES (8551,
	66);
INSERT INTO O_ATTR
	VALUES (8551,
	66,
	8550,
	'Descrip',
	'Full Name: Description
Description:  A textual description of the symbolic constant as specified in the application analysis domain.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (66,
	66,
	0,
	290,
	8531,
	8533,
	8532,
	8552,
	8553,
	0,
	0,
	'',
	'Symbolic Constant',
	'Const_ID',
	'R1505');
INSERT INTO O_RATTR
	VALUES (8552,
	66,
	290,
	66,
	1,
	'Const_ID');
INSERT INTO O_ATTR
	VALUES (8552,
	66,
	8554,
	'Previous_Const_ID',
	'',
	'Previous_',
	'Const_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (66,
	32,
	0,
	156,
	8515,
	8516,
	8517,
	291,
	8555,
	0,
	0,
	'',
	'Data Type',
	'DT_ID',
	'R1500');
INSERT INTO O_RATTR
	VALUES (291,
	66,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (291,
	66,
	8551,
	'DT_ID',
	'',
	'',
	'Element_ID',
	2,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (66,
	66,
	0,
	291,
	8531,
	8533,
	8532,
	8556,
	8557,
	0,
	0,
	'',
	'Symbolic Constant',
	'DT_ID',
	'R1505');
INSERT INTO O_RATTR
	VALUES (8556,
	66,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (8556,
	66,
	8552,
	'Previous_DT_DT_ID',
	'',
	'Previous_DT_',
	'DT_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (66,
	939,
	0,
	961,
	8528,
	8530,
	8529,
	8554,
	8558,
	0,
	0,
	'',
	'Constant Specification',
	'Constant_Spec_ID',
	'R1504');
INSERT INTO O_RATTR
	VALUES (8554,
	66,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (8554,
	66,
	291,
	'Constant_Spec_ID',
	'',
	'',
	'Constant_Spec_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	66);
INSERT INTO O_OIDA
	VALUES (290,
	66,
	0,
	'Const_ID');
INSERT INTO O_OIDA
	VALUES (291,
	66,
	0,
	'DT_ID');
INSERT INTO O_ID
	VALUES (1,
	66);
INSERT INTO O_ID
	VALUES (2,
	66);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (8526,
	'Literal Symbolic Constant',
	1503,
	'CNST_LSC',
	'A symbolic constant containing a single value. Unlike a simple literal constant,
this represents a tuple; name _and_ value. A simple literal constant represents
only a value and is not captured in this subsystem (see the Value subsystem,
Literal * classes for these).',
	8512);
INSERT INTO O_TFR
	VALUES (8559,
	8526,
	'dispose',
	'',
	19,
	1,
	'// Literal Symbolic Constant (CNST_LSC) dispose operation
select one lfsc related by self->CNST_LFSC[R1503];
unrelate self from lfsc across R1503;

delete object instance self;',
	1,
	'',
	8560);
INSERT INTO O_TFR
	VALUES (8561,
	8526,
	'canUseDataType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Literal Symbolic Constant.canUseDataType()
select one packageableElem related by self->CNST_LFSC[R1503]->
                                 CNST_SYC[R1502]->CNST_CSP[R1504]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;
if isInGenericPackage
  // Find the previously created visibility list
  select any resultSet related by package->PE_SRS[R8005] where
        selected.Name == "" and selected.Type == ElementTypeConstants::DATATYPE;
  select any dt related by resultSet->PE_VIS[R8006]->
                     PE_PE[R8002]->S_DT[R8001] where selected.DT_ID == param.id;
  if not_empty component
    // Find the previously created visibility list
    select any compResultSet related by component->PE_CRS[R8007] where
        selected.Name == "" and selected.Type == ElementTypeConstants::DATATYPE;
    select any dt related by compResultSet->PE_CVS[R8008]->
                     PE_PE[R8004]->S_DT[R8001] where selected.DT_ID == param.id;
  end if;
  if(not_empty dt)
    if(self.isAllowedType(typeName:dt.Name))
      return true;
    end if;
  end if;
  return false;
else
  select one symConst related by self->CNST_LFSC[R1503]->CNST_SYC[R1502];

  // Check the system for the datatype
  select any system related by symConst->CNST_CSP[R1504]->CNST_CIP[R1506]
                                 ->S_DPK[R1506]->SLD_SCINP[R4403]->S_SYS[R4404];
  select any dt related by system->SLD_SDINP[R4402]->S_DT[R4401]
                                             where (selected.DT_ID == param.id);

  if empty dt and not_empty system and system.useGlobals
    select any pe related by system->G_EIS[R9100]->PE_PE[R9100]
                                          where selected.Element_ID == param.id;
    select one dt related by pe->S_DT[R8001]; 
  end if;
  if (empty dt)
    // check the domain for the dt
    select one dtPkg related by symConst->CNST_CSP[R1504]->CNST_CIP[R1506]->S_DPK[R1506];
    select any domain from instances of S_DOM where (selected.Dom_ID == dtPkg.getDomainId());
    select any dt related by domain->S_DT[R14] where (selected.DT_ID == param.id);
  end if;

  if(not_empty dt)
    if(self.isAllowedType(typeName:dt.Name))
      return true;
    end if;
  end if;

  return false;
end if;',
	1,
	'',
	8562);
INSERT INTO O_TPARM
	VALUES (8563,
	8561,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8562,
	8526,
	'canReferToDataType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Literal Symbolic Constant.canReferToDataType()
select one symConst related by self->CNST_LFSC[R1503]->CNST_SYC[R1502];
select one dt related by symConst->S_DT[R1500];
if(not_empty dt)
  select one packageableElem related by symConst->CNST_CSP[R1504]->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = not_empty package or not_empty component;

  if (isInGenericPackage)
    return packageableElem.canReferToDataType(dtID:dt.DT_ID, dtName: dt.Name);
  else
    // if the data type package is at the system
    // level we can use the data type as long as
    // this element belongs to a formal component
    select one myDtPkg related by symConst->CNST_CSP[R1504]->CNST_CIP[R1506]->S_DPK[R1506];
    select any myDomain from instances of S_DOM where (selected.Dom_ID == myDtPkg.getDomainId());
    select one dtPkg related by dt->S_DIP[R39]->S_DPK[R39];
    if(not dtPkg.isDomainLevel())
      if(myDomain.participatesInSystem())
        return true;
      else
        return false;
      end if;
    else
      // otherwise the DT must be in the same domain
      select one dtDomain related by dt->S_DOM[R14];
      if(dtDomain == myDomain)
        return true;
      end if;
    end if;
  end if;
end if;
return false;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (8564,
	8526,
	'isAllowedType',
	'',
	316,
	1,
	'if ( param.typeName == "boolean" or
     param.typeName == "integer" or
     param.typeName == "string" or
     param.typeName == "real" )
  return true;
end if;

return false;',
	1,
	'',
	8565);
INSERT INTO O_TPARM
	VALUES (8566,
	8564,
	'typeName',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8567,
	8526,
	'initialize',
	'',
	19,
	1,
	'//
// Literal Symbolic Constant.initialize(csp_id)
//
select any csp from instances of CNST_CSP where
                                    (selected.Constant_Spec_ID == param.csp_id);
select many peers related by csp->CNST_SYC[R1504];
select one my_syc related by self->CNST_LFSC[R1503]->CNST_SYC[R1502];

// This function sets the default datatype of the SYC and LSC to integer and
// initializes the LSC''s value to 0
my_syc.setToDefaultDatatype();

csp.addLiteralSymbolicConstantToOrdering(id:my_syc.Const_ID);
name = ::getUniqueInitialName(
    instance: self.convertToInstance(),
    candidateName: "Unnamed Constant");
success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:true);    
if ( success!="") 
 my_syc.Name=success;
else 
 self.dispose();
end if;         ',
	1,
	'',
	8564);
INSERT INTO O_TPARM
	VALUES (8568,
	8567,
	'csp_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8560,
	8526,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the instance datatype.

Translate: native',
	317,
	1,
	'// just return this instance as an Object
return this;',
	0,
	'',
	8569);
INSERT INTO O_TFR
	VALUES (8569,
	8526,
	'changeType',
	'',
	19,
	1,
	'// Literal Symbolic Constant::changeType
select any selectedDT from instances of S_DT where selected.Name == param.newTypeName;
if(not_empty selectedDT)
  select one syc related by self->CNST_LFSC[R1503]->CNST_SYC[R1502];
  select one originalDT related by syc->S_DT[R1500];
  unrelate syc from originalDT across R1500;

  relate syc to selectedDT across R1500;

  // Set the value to the default for this type
  self.updateValueToDefault(typeName:selectedDT.Name);
end if;
',
	1,
	'',
	8561);
INSERT INTO O_TPARM
	VALUES (8570,
	8569,
	'newTypeName',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8571,
	8526,
	'getBoolean',
	'',
	316,
	1,
	'if GD::toLower(value:self.Value) == "true"
  return true;
else
  return false;
end if;',
	1,
	'',
	8559);
INSERT INTO O_TFR
	VALUES (8572,
	8526,
	'getInteger',
	'',
	298,
	1,
	'return GD::string_to_int(value:self.Value);',
	1,
	'',
	8571);
INSERT INTO O_TFR
	VALUES (8573,
	8526,
	'getReal',
	'',
	374,
	1,
	'return GD::string_to_real(value:self.Value);',
	1,
	'',
	8572);
INSERT INTO O_TFR
	VALUES (8565,
	8526,
	'getString',
	'',
	322,
	1,
	'return self.Value;',
	1,
	'',
	8573);
INSERT INTO O_TFR
	VALUES (8574,
	8526,
	'updateValueToDefault',
	'',
	19,
	1,
	'// Set the value to the default for this type
if (param.typeName == "integer")
  self.Value = "0";
elif (param.typeName == "real")
  self.Value = "0.0";
elif (param.typeName == "boolean")
  self.Value = "false";
else
  self.Value = "";
end if;
',
	1,
	'',
	8567);
INSERT INTO O_TPARM
	VALUES (8575,
	8574,
	'typeName',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8576,
	8526,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Const_ID;',
	1,
	'',
	8574);
INSERT INTO O_NBATTR
	VALUES (8577,
	8526);
INSERT INTO O_BATTR
	VALUES (8577,
	8526);
INSERT INTO O_ATTR
	VALUES (8577,
	8526,
	8578,
	'Value',
	'Full Name: Value
Description: The value of this constant',
	'',
	'Value',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (8526,
	8520,
	0,
	8524,
	8522,
	8527,
	8523,
	8579,
	8580,
	0,
	0,
	'',
	'Leaf Symbolic Constant',
	'Const_ID',
	'R1503');
INSERT INTO O_RATTR
	VALUES (8579,
	8526,
	290,
	66,
	1,
	'Const_ID');
INSERT INTO O_ATTR
	VALUES (8579,
	8526,
	0,
	'Const_ID',
	'',
	'',
	'Const_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (8526,
	8520,
	0,
	8525,
	8522,
	8527,
	8523,
	8578,
	8581,
	0,
	0,
	'',
	'Leaf Symbolic Constant',
	'DT_ID',
	'R1503');
INSERT INTO O_RATTR
	VALUES (8578,
	8526,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (8578,
	8526,
	8579,
	'DT_ID',
	'',
	'',
	'ID',
	2,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	8526);
INSERT INTO O_OIDA
	VALUES (8579,
	8526,
	0,
	'Const_ID');
INSERT INTO O_OIDA
	VALUES (8578,
	8526,
	0,
	'DT_ID');
INSERT INTO O_ID
	VALUES (1,
	8526);
INSERT INTO O_ID
	VALUES (2,
	8526);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (8520,
	'Leaf Symbolic Constant',
	1502,
	'CNST_LFSC',
	'A constant that requires no further definition by the analyst. This is a
supertype for other constant classes that represent various types of fully
defined constants (e.g. Literal Symbolic, Enum, Predefined).',
	8512);
INSERT INTO O_TFR
	VALUES (8582,
	8520,
	'dispose',
	'',
	19,
	1,
	'// Leaf Symbolic Constant (CNST_LFSC) dispose operation
select one lsc related by self->CNST_LSC[R1503];
if not_empty lsc
  lsc.dispose();
end if;

select one syc related by self->CNST_SYC[R1502];
unrelate self from syc across R1502;

delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (8520,
	66,
	0,
	290,
	8518,
	8521,
	8519,
	8524,
	8583,
	0,
	0,
	'',
	'Symbolic Constant',
	'Const_ID',
	'R1502');
INSERT INTO O_RATTR
	VALUES (8524,
	8520,
	290,
	66,
	1,
	'Const_ID');
INSERT INTO O_ATTR
	VALUES (8524,
	8520,
	0,
	'Const_ID',
	'',
	'',
	'Const_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (8520,
	66,
	0,
	291,
	8518,
	8521,
	8519,
	8525,
	8584,
	0,
	0,
	'',
	'Symbolic Constant',
	'DT_ID',
	'R1502');
INSERT INTO O_RATTR
	VALUES (8525,
	8520,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (8525,
	8520,
	8524,
	'DT_ID',
	'',
	'',
	'DT_ID',
	2,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	8520);
INSERT INTO O_OIDA
	VALUES (8524,
	8520,
	0,
	'Const_ID');
INSERT INTO O_OIDA
	VALUES (8525,
	8520,
	0,
	'DT_ID');
INSERT INTO O_ID
	VALUES (1,
	8520);
INSERT INTO O_ID
	VALUES (2,
	8520);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (939,
	'Constant Specification',
	1500,
	'CNST_CSP',
	'A grouping of constants. The name is informal and does not imply any scoping.
It is used by the parser to locate the constant.',
	8512);
INSERT INTO O_TFR
	VALUES (8585,
	939,
	'associateWithSystem',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Constant Specification::associateWithSystem()
select any system from instances of S_SYS
                                        where (selected.Sys_ID == param.sys_id);
if(not_empty system)
  select any scip related by self->SLD_SCINP[R4403];
  if(not_empty scip)
    // This instance was previously a system level csp.  Associate it with the
    // new system.
    select one prevSystem related by scip->S_SYS[R4404];
    unrelate scip from prevSystem across R4404;
    select one prevPkg related by scip->S_DPK[R4403];
    unrelate self from prevPkg across R4403 using scip;
  else
    // create the symbolic constant in package
    create object instance scip of SLD_SCINP;
  end if;
  relate scip to system across R4404;
  select one pkg related by self->CNST_CIP[R1506]->S_DPK[R1506];
  relate pkg to self across R4403 using scip;
end if;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (8586,
	8585,
	'sys_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8587,
	939,
	'dispose',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Constant Specification (CNST_CSP) dispose operation

select one pe related by self->PE_PE[R8001];
if(not_empty pe)
  // PE_PE.dispose() will call back into this function at which time the
  // rest of the activity will execute.
  pe.dispose();
  return;
end if;

// Clean up the relationship to the containing Data Type Package
select one cip related by self->CNST_CIP[R1506];
if (not_empty cip)
  select one dpk related by self->S_DPK[R1506];
  unrelate self from dpk across R1506 using cip;
  delete object instance cip;
end if;

// Iterate over all of the contained Symbolic Constants, disposing each in turn
select many sycs related by self->CNST_SYC[R1504];
for each syc in sycs
  syc.dispose();
end for;

// Clean up system constant ties
select many scips related by self->SLD_SCINP[R4403];
for each scip in scips
  select one dtp related by scip->S_DPK[R4403];
  if (not_empty dtp)
  unrelate self from dtp across R4403 using scip;
  end if;
  select one system related by scip->S_SYS[R4404];
  unrelate scip from system across R4404;
  delete object instance scip;
end for;

delete object instance self;',
	1,
	'',
	8585);
INSERT INTO O_TFR
	VALUES (8588,
	939,
	'get_compartment_text',
	'Return the textual contents of the given compartment.  Compartment one is the
header info, compartment two is the list of contained constants.',
	322,
	1,
	'result = "";
if (param.comp_num == 1)
  if (param.at == Justification::Center_in_X)
    result = "constant";
    result = result + GD::newline();
    select one pe related by self->PE_PE[R8001];
    if not_empty pe
      result = result + pe.getVisibilityAdornment();
    end if;
    result = result + self.InformalGroupName;
  end if;
else
  if (param.at == Justification::Left)
    select any symConst related by self->CNST_SYC[R1504] where (selected.Previous_Const_ID == GD::NULL_UNIQUE_ID());
    cursor = param.ent_num;
    while (not_empty symConst AND cursor > 1)
      select one symConst related by symConst->CNST_SYC[R1505.''precedes''];
      cursor = cursor - 1;
    end while;
    if (empty symConst)
      result = "";
    else
      // <name>:<type> = <value>
      select one dt related by symConst->S_DT[R1500];
      select one lsc related by symConst->CNST_LFSC[R1502]->CNST_LSC[R1503];
      dtname = "";
      lscvalue = "";
      if (not_empty dt)
        dtname = dt.Name;
      end if;
      if (not_empty lsc)
        lscvalue = lsc.Value;
      end if;
      result = symConst.Name + ":" + dtname + " = " + lscvalue;
    end if;
  end if;
end if;
return result;',
	1,
	'',
	8587);
INSERT INTO O_TPARM
	VALUES (8589,
	8588,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (8590,
	8588,
	'comp_num',
	298,
	0,
	'',
	8589,
	'');
INSERT INTO O_TPARM
	VALUES (8591,
	8588,
	'ent_num',
	298,
	0,
	'',
	8590,
	'');
INSERT INTO O_TFR
	VALUES (8592,
	939,
	'get_compartments',
	'Return the number of compartments in the graphical element.  There are 2, the
header, and the body (which contains all the defined constants).',
	298,
	1,
	'return 2;',
	1,
	'',
	8588);
INSERT INTO O_TFR
	VALUES (8593,
	939,
	'get_entries',
	'Returns the number of elements in the given compartment.  One for the top, and
the number of contained constants for the bottom compartment.',
	298,
	1,
	'if (param.comp_num == 1)
  return 1;
else
  select many symConsts related by self->CNST_SYC[R1504];
  return cardinality symConsts;
end if;',
	1,
	'',
	8592);
INSERT INTO O_TPARM
	VALUES (8594,
	8593,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8595,
	939,
	'get_name',
	'Returns the name of this constant specification.',
	322,
	1,
	'return self.InformalGroupName;',
	1,
	'',
	8593);
INSERT INTO O_TFR
	VALUES (8596,
	939,
	'get_ooa_id',
	'Returns the unique key for this class.',
	296,
	1,
	'return self.Constant_Spec_ID;',
	1,
	'',
	8595);
INSERT INTO O_TFR
	VALUES (8597,
	939,
	'get_style',
	'Returns the graphical style of this element, which is a box.',
	784,
	1,
	'return Style::Box;',
	1,
	'',
	8596);
INSERT INTO O_TFR
	VALUES (8598,
	939,
	'get_text_style',
	'Returns special text style info, in this case none.',
	784,
	1,
	'return Style::None;',
	1,
	'',
	8597);
INSERT INTO O_TPARM
	VALUES (8599,
	8598,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (8600,
	8598,
	'comp_num',
	298,
	0,
	'',
	8599,
	'');
INSERT INTO O_TPARM
	VALUES (8601,
	8598,
	'ent_num',
	298,
	0,
	'',
	8600,
	'');
INSERT INTO O_TFR
	VALUES (8602,
	939,
	'newLiteralSymbolicConstant',
	'',
	19,
	1,
	'//
// Constant Specification.newLiteralSymbolicConstant()
//
create object instance lsc of CNST_LSC;
create object instance lfsc of CNST_LFSC;
create object instance syc of CNST_SYC;
relate lsc to lfsc across R1503;
relate lfsc to syc across R1502;
relate self to syc across R1504;
lsc.initialize(csp_id: self.Constant_Spec_ID);',
	1,
	'',
	8598);
INSERT INTO O_TFR
	VALUES (8603,
	939,
	'actionFilter',
	'',
	316,
	1,
	'if(param.name == "can")
  if param.value == "make public"
    select one pe related by self->PE_PE[R8001];
    select one pkg related by pe->EP_PKG[R8000];
    if not_empty pkg
      if not_empty pe 
        return pe.Visibility != Visibility::Public;
      end if;
    end if;
  elif param.value == "make protected"
    select one pe related by self->PE_PE[R8001];
    select one pkg related by pe->EP_PKG[R8000];
    if not_empty pkg
      if not_empty pe 
        return pe.Visibility != Visibility::Protected;
      end if;
    end if;
  elif param.value == "make private"
    select one pe related by self->PE_PE[R8001];
    select one pkg related by pe->EP_PKG[R8000];
    if not_empty pkg
      if not_empty pe 
        return pe.Visibility != Visibility::Private;
      end if;
    end if;
  end if;
end if;
return false;',
	1,
	'',
	8602);
INSERT INTO O_TPARM
	VALUES (8604,
	8603,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (8605,
	8603,
	'value',
	322,
	0,
	'',
	8604,
	'');
INSERT INTO O_TFR
	VALUES (8606,
	939,
	'pasteLiteralSymbolicConstant',
	'',
	19,
	1,
	'select any lsc from instances of CNST_LSC where (selected.Const_ID == param.id);
if(not_empty lsc)
  select one syc related by lsc->CNST_LFSC[R1503]->CNST_SYC[R1502];
  if(not_empty syc)
    relate syc to self across R1504;
  end if;
  syc.Name = ::getUniqueInitialNameInParent(
    instance: syc.convertToInstance(),
    name: syc.Name, parent:self.convertToInstance());
  self.addLiteralSymbolicConstantToOrdering(id:syc.Const_ID);
end if;',
	1,
	'',
	8603);
INSERT INTO O_TPARM
	VALUES (8607,
	8606,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8608,
	939,
	'addLiteralSymbolicConstantToOrdering',
	'',
	19,
	1,
	'select any syc from instances of CNST_SYC where (selected.Const_ID == param.id);
if(not_empty syc)
  select many peers related by self->CNST_SYC[R1504];
  ::changeNotificationEnablement(enabled:false);
  for each peer in peers
    if (peer != syc)
      select one predecessor related by peer->CNST_SYC[R1505.''precedes''];
      if (empty predecessor)
        relate syc to peer across R1505.''succeeds'';
      end if;
    end if;
  end for;
  ::changeNotificationEnablement(enabled:true);
end if;',
	1,
	'',
	8606);
INSERT INTO O_TPARM
	VALUES (8609,
	8608,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8610,
	939,
	'convertToInstance',
	'Translate: native',
	317,
	1,
	'return this;',
	0,
	'',
	8608);
INSERT INTO O_TFR
	VALUES (8611,
	939,
	'initialize',
	'',
	19,
	1,
	'name = ::getUniqueInitialName(
    instance: self.convertToInstance(),
    candidateName: "Unnamed Constant Specification");
success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:false);    
if ( success!="")
 self.InformalGroupName =success; 
else 
 self.dispose();
end if;         ',
	1,
	'',
	8610);
INSERT INTO O_NBATTR
	VALUES (8612,
	939);
INSERT INTO O_BATTR
	VALUES (8612,
	939);
INSERT INTO O_ATTR
	VALUES (8612,
	939,
	961,
	'InformalGroupName',
	'Full Name: Constant Specification Informal Name
Description: Contains the name of this constant specification.  It is informal in that it has no semantic meaning.',
	'',
	'InformalGroupName',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8613,
	939);
INSERT INTO O_BATTR
	VALUES (8613,
	939);
INSERT INTO O_ATTR
	VALUES (8613,
	939,
	8612,
	'Descrip',
	'Full Name: Description
Description:  A textual description of this constant specification.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (939,
	26,
	0,
	25,
	868,
	2834,
	870,
	961,
	8614,
	0,
	0,
	'',
	'Packageable Element',
	'Element_ID',
	'R8001');
INSERT INTO O_RATTR
	VALUES (961,
	939,
	25,
	26,
	0,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (961,
	939,
	0,
	'Constant_Spec_ID',
	'',
	'',
	'Constant_Spec_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	939);
INSERT INTO O_OIDA
	VALUES (961,
	939,
	0,
	'Constant_Spec_ID');
INSERT INTO O_ID
	VALUES (1,
	939);
INSERT INTO O_ID
	VALUES (2,
	939);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (8537,
	'Constant in Package',
	1504,
	'CNST_CIP',
	'Constant in Package represents the constants contained within a particular package.',
	8512);
INSERT INTO O_REF
	VALUES (8537,
	936,
	0,
	943,
	8534,
	8538,
	8536,
	8615,
	8616,
	0,
	0,
	'',
	'Data Type Package',
	'Package_ID',
	'R1506');
INSERT INTO O_RATTR
	VALUES (8615,
	8537,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (8615,
	8537,
	8617,
	'Package_ID',
	'',
	'',
	'Package_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (8537,
	939,
	0,
	961,
	8534,
	8538,
	8535,
	8617,
	8618,
	0,
	0,
	'',
	'Constant Specification',
	'Constant_Spec_ID',
	'R1506');
INSERT INTO O_RATTR
	VALUES (8617,
	8537,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (8617,
	8537,
	0,
	'Constant_Spec_ID',
	'',
	'',
	'Constant_Spec_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	8537);
INSERT INTO O_OIDA
	VALUES (8615,
	8537,
	0,
	'Package_ID');
INSERT INTO O_OIDA
	VALUES (8617,
	8537,
	0,
	'Constant_Spec_ID');
INSERT INTO O_ID
	VALUES (1,
	8537);
INSERT INTO O_ID
	VALUES (2,
	8537);
-- BP 7.1 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (8619,
	'Component',
	'// This is used by schema_gen to ignore this subsystem (for publication)
TRANSLATE_FOR_EXTERNAL_USE:FALSE

The component subsystem contains the classes necessary to capture the data
required for modeling components.',
	'C',
	4000,
	1,
	0);
INSERT INTO S_SID
	VALUES (1,
	8619);
INSERT INTO O_IOBJ
	VALUES (8620,
	32,
	0,
	8619,
	'Data Type',
	'S_DT');
INSERT INTO O_IOBJ
	VALUES (8621,
	59,
	0,
	8619,
	'Dimensions',
	'S_DIM');
INSERT INTO R_ASSOC
	VALUES (8622);
INSERT INTO R_REL
	VALUES (8622,
	4002,
	'CrossComponent:true',
	8619);
INSERT INTO R_AONE
	VALUES (8623,
	8622,
	8624,
	1,
	1,
	'defines required satisfication');
INSERT INTO O_RTIDA
	VALUES (8625,
	8623,
	0,
	8622,
	8624);
INSERT INTO R_RTO
	VALUES (8623,
	8622,
	8624,
	0);
INSERT INTO R_OIR
	VALUES (8623,
	8622,
	8624,
	0);
INSERT INTO R_AOTH
	VALUES (8626,
	8622,
	8627,
	1,
	1,
	'satisfies');
INSERT INTO O_RTIDA
	VALUES (8628,
	8626,
	0,
	8622,
	8627);
INSERT INTO R_RTO
	VALUES (8626,
	8622,
	8627,
	0);
INSERT INTO R_OIR
	VALUES (8626,
	8622,
	8627,
	0);
INSERT INTO R_ASSR
	VALUES (2765,
	8622,
	8629,
	0);
INSERT INTO R_RGO
	VALUES (2765,
	8622,
	8629);
INSERT INTO R_OIR
	VALUES (2765,
	8622,
	8629,
	0);
INSERT INTO R_SIMP
	VALUES (8630);
INSERT INTO R_REL
	VALUES (8630,
	4003,
	'',
	8619);
INSERT INTO R_PART
	VALUES (2809,
	8630,
	8631,
	0,
	0,
	'provides signature of');
INSERT INTO O_RTIDA
	VALUES (8632,
	2809,
	0,
	8630,
	8631);
INSERT INTO R_RTO
	VALUES (2809,
	8630,
	8631,
	0);
INSERT INTO R_OIR
	VALUES (2809,
	8630,
	8631,
	0);
INSERT INTO R_FORM
	VALUES (3137,
	8630,
	8633,
	1,
	1,
	'is defined by');
INSERT INTO R_RGO
	VALUES (3137,
	8630,
	8633);
INSERT INTO R_OIR
	VALUES (3137,
	8630,
	8633,
	0);
INSERT INTO R_SUBSUP
	VALUES (8634);
INSERT INTO R_REL
	VALUES (8634,
	4004,
	'',
	8619);
INSERT INTO R_SUPER
	VALUES (3137,
	8634,
	8635);
INSERT INTO O_RTIDA
	VALUES (3136,
	3137,
	0,
	8634,
	8635);
INSERT INTO R_RTO
	VALUES (3137,
	8634,
	8635,
	0);
INSERT INTO R_OIR
	VALUES (3137,
	8634,
	8635,
	0);
INSERT INTO R_SUB
	VALUES (2992,
	8634,
	8636);
INSERT INTO R_RGO
	VALUES (2992,
	8634,
	8636);
INSERT INTO R_OIR
	VALUES (2992,
	8634,
	8636,
	0);
INSERT INTO R_SUB
	VALUES (2990,
	8634,
	8637);
INSERT INTO R_RGO
	VALUES (2990,
	8634,
	8637);
INSERT INTO R_OIR
	VALUES (2990,
	8634,
	8637,
	0);
INSERT INTO R_SIMP
	VALUES (8638);
INSERT INTO R_REL
	VALUES (8638,
	4006,
	'',
	8619);
INSERT INTO R_PART
	VALUES (3137,
	8638,
	8639,
	0,
	0,
	'parameterizes');
INSERT INTO O_RTIDA
	VALUES (3136,
	3137,
	0,
	8638,
	8639);
INSERT INTO R_RTO
	VALUES (3137,
	8638,
	8639,
	0);
INSERT INTO R_OIR
	VALUES (3137,
	8638,
	8639,
	0);
INSERT INTO R_FORM
	VALUES (57,
	8638,
	8640,
	1,
	1,
	'is parameter to');
INSERT INTO R_RGO
	VALUES (57,
	8638,
	8640);
INSERT INTO R_OIR
	VALUES (57,
	8638,
	8640,
	0);
INSERT INTO R_SIMP
	VALUES (8641);
INSERT INTO R_REL
	VALUES (8641,
	4007,
	'CrossComponent:true',
	8619);
INSERT INTO R_FORM
	VALUES (57,
	8641,
	8642,
	1,
	1,
	'Defines the type');
INSERT INTO R_RGO
	VALUES (57,
	8641,
	8642);
INSERT INTO R_OIR
	VALUES (57,
	8641,
	8642,
	0);
INSERT INTO R_PART
	VALUES (32,
	8641,
	8643,
	0,
	0,
	'is typed by');
INSERT INTO O_RTIDA
	VALUES (156,
	32,
	0,
	8641,
	8643);
INSERT INTO R_RTO
	VALUES (32,
	8641,
	8643,
	0);
INSERT INTO R_OIR
	VALUES (32,
	8641,
	8643,
	8620);
INSERT INTO R_SIMP
	VALUES (8644);
INSERT INTO R_REL
	VALUES (8644,
	4008,
	'CrossComponent:true',
	8619);
INSERT INTO R_FORM
	VALUES (2992,
	8644,
	8645,
	1,
	1,
	'defines return type');
INSERT INTO R_RGO
	VALUES (2992,
	8644,
	8645);
INSERT INTO R_OIR
	VALUES (2992,
	8644,
	8645,
	0);
INSERT INTO R_PART
	VALUES (32,
	8644,
	8646,
	0,
	0,
	'has return defined by');
INSERT INTO O_RTIDA
	VALUES (156,
	32,
	0,
	8644,
	8646);
INSERT INTO R_RTO
	VALUES (32,
	8644,
	8646,
	0);
INSERT INTO R_OIR
	VALUES (32,
	8644,
	8646,
	8620);
INSERT INTO R_SUBSUP
	VALUES (8647);
INSERT INTO R_REL
	VALUES (8647,
	4009,
	'',
	8619);
INSERT INTO R_SUPER
	VALUES (8648,
	8647,
	8649);
INSERT INTO O_RTIDA
	VALUES (8650,
	8648,
	0,
	8647,
	8649);
INSERT INTO R_RTO
	VALUES (8648,
	8647,
	8649,
	0);
INSERT INTO R_OIR
	VALUES (8648,
	8647,
	8649,
	0);
INSERT INTO R_SUB
	VALUES (8623,
	8647,
	8651);
INSERT INTO R_RGO
	VALUES (8623,
	8647,
	8651);
INSERT INTO R_OIR
	VALUES (8623,
	8647,
	8651,
	0);
INSERT INTO R_SUB
	VALUES (8626,
	8647,
	8652);
INSERT INTO R_RGO
	VALUES (8626,
	8647,
	8652);
INSERT INTO R_OIR
	VALUES (8626,
	8647,
	8652,
	0);
INSERT INTO R_SIMP
	VALUES (8653);
INSERT INTO R_REL
	VALUES (8653,
	4012,
	'CrossComponent:true',
	8619);
INSERT INTO R_FORM
	VALUES (8648,
	8653,
	8654,
	1,
	1,
	'is formal definition');
INSERT INTO R_RGO
	VALUES (8648,
	8653,
	8654);
INSERT INTO R_OIR
	VALUES (8648,
	8653,
	8654,
	0);
INSERT INTO R_PART
	VALUES (2809,
	8653,
	8655,
	0,
	1,
	'may be defined by');
INSERT INTO O_RTIDA
	VALUES (8632,
	2809,
	0,
	8653,
	8655);
INSERT INTO R_RTO
	VALUES (2809,
	8653,
	8655,
	0);
INSERT INTO R_OIR
	VALUES (2809,
	8653,
	8655,
	0);
INSERT INTO R_ASSOC
	VALUES (8656);
INSERT INTO R_REL
	VALUES (8656,
	4013,
	'',
	8619);
INSERT INTO R_AOTH
	VALUES (2762,
	8656,
	8657,
	1,
	1,
	'may delegate through');
INSERT INTO O_RTIDA
	VALUES (2771,
	2762,
	0,
	8656,
	8657);
INSERT INTO R_RTO
	VALUES (2762,
	8656,
	8657,
	0);
INSERT INTO R_OIR
	VALUES (2762,
	8656,
	8657,
	0);
INSERT INTO R_AONE
	VALUES (8648,
	8656,
	8658,
	1,
	1,
	'handles delegation for');
INSERT INTO O_RTIDA
	VALUES (8650,
	8648,
	0,
	8656,
	8658);
INSERT INTO R_RTO
	VALUES (8648,
	8656,
	8658,
	0);
INSERT INTO R_OIR
	VALUES (8648,
	8656,
	8658,
	0);
INSERT INTO R_ASSR
	VALUES (8659,
	8656,
	8660,
	0);
INSERT INTO R_RGO
	VALUES (8659,
	8656,
	8660);
INSERT INTO R_OIR
	VALUES (8659,
	8656,
	8660,
	0);
INSERT INTO R_SIMP
	VALUES (8661);
INSERT INTO R_REL
	VALUES (8661,
	4014,
	'CrossComponent:true',
	8619);
INSERT INTO R_PART
	VALUES (2762,
	8661,
	8662,
	0,
	1,
	'receives delegation via');
INSERT INTO O_RTIDA
	VALUES (2771,
	2762,
	0,
	8661,
	8662);
INSERT INTO R_RTO
	VALUES (2762,
	8661,
	8662,
	0);
INSERT INTO R_OIR
	VALUES (2762,
	8661,
	8662,
	0);
INSERT INTO R_FORM
	VALUES (8648,
	8661,
	8663,
	1,
	1,
	'provides delegation to');
INSERT INTO R_RGO
	VALUES (8648,
	8661,
	8663);
INSERT INTO R_OIR
	VALUES (8648,
	8661,
	8663,
	0);
INSERT INTO R_SIMP
	VALUES (8664);
INSERT INTO R_REL
	VALUES (8664,
	4010,
	'',
	8619);
INSERT INTO R_PART
	VALUES (709,
	8664,
	8665,
	0,
	0,
	'appears in');
INSERT INTO O_RTIDA
	VALUES (762,
	709,
	0,
	8664,
	8665);
INSERT INTO R_RTO
	VALUES (709,
	8664,
	8665,
	0);
INSERT INTO R_OIR
	VALUES (709,
	8664,
	8665,
	0);
INSERT INTO R_FORM
	VALUES (8666,
	8664,
	8667,
	1,
	1,
	'communicates through');
INSERT INTO R_RGO
	VALUES (8666,
	8664,
	8667);
INSERT INTO R_OIR
	VALUES (8666,
	8664,
	8667,
	0);
INSERT INTO R_SIMP
	VALUES (8668);
INSERT INTO R_REL
	VALUES (8668,
	4016,
	'',
	8619);
INSERT INTO R_PART
	VALUES (8666,
	8668,
	8669,
	0,
	0,
	'originates from');
INSERT INTO O_RTIDA
	VALUES (8670,
	8666,
	0,
	8668,
	8669);
INSERT INTO R_RTO
	VALUES (8666,
	8668,
	8669,
	0);
INSERT INTO R_OIR
	VALUES (8666,
	8668,
	8669,
	0);
INSERT INTO R_FORM
	VALUES (8648,
	8668,
	8671,
	1,
	1,
	'exposes');
INSERT INTO R_RGO
	VALUES (8648,
	8668,
	8671);
INSERT INTO R_OIR
	VALUES (8648,
	8668,
	8671,
	0);
INSERT INTO R_SIMP
	VALUES (8120);
INSERT INTO R_REL
	VALUES (8120,
	4017,
	'',
	8619);
INSERT INTO R_PART
	VALUES (57,
	8120,
	8122,
	0,
	1,
	'specifies occurrences of');
INSERT INTO O_RTIDA
	VALUES (254,
	57,
	0,
	8120,
	8122);
INSERT INTO R_RTO
	VALUES (57,
	8120,
	8122,
	0);
INSERT INTO R_OIR
	VALUES (57,
	8120,
	8122,
	0);
INSERT INTO R_FORM
	VALUES (59,
	8120,
	8121,
	1,
	1,
	'may have');
INSERT INTO R_RGO
	VALUES (59,
	8120,
	8121);
INSERT INTO R_OIR
	VALUES (59,
	8120,
	8121,
	8621);
INSERT INTO R_SIMP
	VALUES (8106);
INSERT INTO R_REL
	VALUES (8106,
	4018,
	'',
	8619);
INSERT INTO R_PART
	VALUES (2992,
	8106,
	8108,
	0,
	1,
	'defines return value dimensions for ');
INSERT INTO O_RTIDA
	VALUES (3083,
	2992,
	0,
	8106,
	8108);
INSERT INTO R_RTO
	VALUES (2992,
	8106,
	8108,
	0);
INSERT INTO R_OIR
	VALUES (2992,
	8106,
	8108,
	0);
INSERT INTO R_FORM
	VALUES (59,
	8106,
	8107,
	1,
	1,
	'return value may have');
INSERT INTO R_RGO
	VALUES (59,
	8106,
	8107);
INSERT INTO R_OIR
	VALUES (59,
	8106,
	8107,
	8621);
INSERT INTO R_SIMP
	VALUES (8672);
INSERT INTO R_REL
	VALUES (8672,
	4019,
	'',
	8619);
INSERT INTO R_PART
	VALUES (2992,
	8672,
	8673,
	0,
	1,
	'succeeds');
INSERT INTO O_RTIDA
	VALUES (3083,
	2992,
	0,
	8672,
	8673);
INSERT INTO R_RTO
	VALUES (2992,
	8672,
	8673,
	0);
INSERT INTO R_OIR
	VALUES (2992,
	8672,
	8673,
	0);
INSERT INTO R_FORM
	VALUES (2992,
	8672,
	8674,
	0,
	1,
	'precedes');
INSERT INTO R_RGO
	VALUES (2992,
	8672,
	8674);
INSERT INTO R_OIR
	VALUES (2992,
	8672,
	8674,
	0);
INSERT INTO R_SIMP
	VALUES (8675);
INSERT INTO R_REL
	VALUES (8675,
	4020,
	'',
	8619);
INSERT INTO R_PART
	VALUES (2990,
	8675,
	8676,
	0,
	1,
	'succeeds');
INSERT INTO O_RTIDA
	VALUES (3079,
	2990,
	0,
	8675,
	8676);
INSERT INTO R_RTO
	VALUES (2990,
	8675,
	8676,
	0);
INSERT INTO R_OIR
	VALUES (2990,
	8675,
	8676,
	0);
INSERT INTO R_FORM
	VALUES (2990,
	8675,
	8677,
	0,
	1,
	'precedes');
INSERT INTO R_RGO
	VALUES (2990,
	8675,
	8677);
INSERT INTO R_OIR
	VALUES (2990,
	8675,
	8677,
	0);
INSERT INTO R_SIMP
	VALUES (8678);
INSERT INTO R_REL
	VALUES (8678,
	4021,
	'',
	8619);
INSERT INTO R_PART
	VALUES (57,
	8678,
	8679,
	0,
	1,
	'succeeds');
INSERT INTO O_RTIDA
	VALUES (254,
	57,
	0,
	8678,
	8679);
INSERT INTO R_RTO
	VALUES (57,
	8678,
	8679,
	0);
INSERT INTO R_OIR
	VALUES (57,
	8678,
	8679,
	0);
INSERT INTO R_FORM
	VALUES (57,
	8678,
	8680,
	0,
	1,
	'precedes');
INSERT INTO R_RGO
	VALUES (57,
	8678,
	8680);
INSERT INTO R_OIR
	VALUES (57,
	8678,
	8680,
	0);
-- BP 7.1 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (8681,
	'Signal Provisions and Requirements',
	'// This is used by schema_gen to ignore this subsystem (for publication)
TRANSLATE_FOR_EXTERNAL_USE:FALSE

The Signal Provisions and Requirements subsystem captures data which will be
used to define the implementation of provided and required interfaces.',
	'SPR',
	4500,
	1,
	0);
INSERT INTO O_IOBJ
	VALUES (8682,
	3137,
	0,
	8681,
	'Executable Property',
	'C_EP');
INSERT INTO O_IOBJ
	VALUES (8683,
	8623,
	0,
	8681,
	'Requirement',
	'C_R');
INSERT INTO O_IOBJ
	VALUES (8684,
	8626,
	0,
	8681,
	'Provision',
	'C_P');
INSERT INTO R_ASSOC
	VALUES (8685);
INSERT INTO R_REL
	VALUES (8685,
	4500,
	'CrossComponent:true',
	8681);
INSERT INTO R_AONE
	VALUES (3137,
	8685,
	8686,
	1,
	1,
	'implements');
INSERT INTO O_RTIDA
	VALUES (3136,
	3137,
	0,
	8685,
	8686);
INSERT INTO R_RTO
	VALUES (3137,
	8685,
	8686,
	0);
INSERT INTO R_OIR
	VALUES (3137,
	8685,
	8686,
	8682);
INSERT INTO R_AOTH
	VALUES (8623,
	8685,
	8687,
	1,
	1,
	'is implemented by');
INSERT INTO O_RTIDA
	VALUES (8625,
	8623,
	0,
	8685,
	8687);
INSERT INTO R_RTO
	VALUES (8623,
	8685,
	8687,
	0);
INSERT INTO R_OIR
	VALUES (8623,
	8685,
	8687,
	8683);
INSERT INTO R_ASSR
	VALUES (63,
	8685,
	8688,
	0);
INSERT INTO R_RGO
	VALUES (63,
	8685,
	8688);
INSERT INTO R_OIR
	VALUES (63,
	8685,
	8688,
	0);
INSERT INTO R_ASSOC
	VALUES (8689);
INSERT INTO R_REL
	VALUES (8689,
	4501,
	'CrossComponent:true',
	8681);
INSERT INTO R_AONE
	VALUES (3137,
	8689,
	8690,
	1,
	1,
	'implements');
INSERT INTO O_RTIDA
	VALUES (3136,
	3137,
	0,
	8689,
	8690);
INSERT INTO R_RTO
	VALUES (3137,
	8689,
	8690,
	0);
INSERT INTO R_OIR
	VALUES (3137,
	8689,
	8690,
	8682);
INSERT INTO R_AOTH
	VALUES (8626,
	8689,
	8691,
	1,
	1,
	'is implemented by');
INSERT INTO O_RTIDA
	VALUES (8628,
	8626,
	0,
	8689,
	8691);
INSERT INTO R_RTO
	VALUES (8626,
	8689,
	8691,
	0);
INSERT INTO R_OIR
	VALUES (8626,
	8689,
	8691,
	8684);
INSERT INTO R_ASSR
	VALUES (61,
	8689,
	8692,
	0);
INSERT INTO R_RGO
	VALUES (61,
	8689,
	8692);
INSERT INTO R_OIR
	VALUES (61,
	8689,
	8692,
	0);
INSERT INTO R_SUBSUP
	VALUES (8693);
INSERT INTO R_REL
	VALUES (8693,
	4502,
	'',
	8681);
INSERT INTO R_SUPER
	VALUES (63,
	8693,
	8694);
INSERT INTO O_RTIDA
	VALUES (267,
	63,
	0,
	8693,
	8694);
INSERT INTO R_RTO
	VALUES (63,
	8693,
	8694,
	0);
INSERT INTO R_OIR
	VALUES (63,
	8693,
	8694,
	0);
INSERT INTO R_SUB
	VALUES (1485,
	8693,
	8695);
INSERT INTO R_RGO
	VALUES (1485,
	8693,
	8695);
INSERT INTO R_OIR
	VALUES (1485,
	8693,
	8695,
	0);
INSERT INTO R_SUB
	VALUES (3308,
	8693,
	8696);
INSERT INTO R_RGO
	VALUES (3308,
	8693,
	8696);
INSERT INTO R_OIR
	VALUES (3308,
	8693,
	8696,
	0);
INSERT INTO R_SUBSUP
	VALUES (8697);
INSERT INTO R_REL
	VALUES (8697,
	4503,
	'',
	8681);
INSERT INTO R_SUPER
	VALUES (61,
	8697,
	8698);
INSERT INTO O_RTIDA
	VALUES (263,
	61,
	0,
	8697,
	8698);
INSERT INTO R_RTO
	VALUES (61,
	8697,
	8698,
	0);
INSERT INTO R_OIR
	VALUES (61,
	8697,
	8698,
	0);
INSERT INTO R_SUB
	VALUES (3306,
	8697,
	8699);
INSERT INTO R_RGO
	VALUES (3306,
	8697,
	8699);
INSERT INTO R_OIR
	VALUES (3306,
	8697,
	8699,
	0);
INSERT INTO R_SUB
	VALUES (1483,
	8697,
	8700);
INSERT INTO R_RGO
	VALUES (1483,
	8697,
	8700);
INSERT INTO R_OIR
	VALUES (1483,
	8697,
	8700,
	0);
INSERT INTO S_SIS
	VALUES (8619,
	8681);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (1485,
	'Required Signal',
	4503,
	'SPR_RS',
	'',
	8681);
INSERT INTO O_TFR
	VALUES (8701,
	1485,
	'initialize',
	'',
	19,
	1,
	'self.Suc_Pars = ParseStatus::parseInitial;',
	1,
	'',
	8702);
INSERT INTO O_TFR
	VALUES (8703,
	1485,
	'dispose',
	'',
	19,
	1,
	'select one rep related by self->SPR_REP[R4502];
if(not_empty rep)
  unrelate self from rep across R4502;
  rep.dispose();
end if;
select one req_body related by self->ACT_RSB[R684];
if(not_empty req_body)
  unrelate self from req_body across R684;
  req_body.dispose();
end if;
select one evt related by self->SM_SGEVT[R529]->SM_SEVT[R526]->SM_EVT[R525];
if not_empty evt
  evt.dispose();
end if;
select many invocations related by self->ACT_SGN[R660];
for each sgn in invocations
  unrelate self from sgn across R660;
end for;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (8704,
	1485,
	'isAvailableForAllocationTo',
	'',
	316,
	1,
	'// Required Signal::isAvailableForAllocationTo()
// Returns false if the signal has been allocated to a state machine 
// other than the one owining the transition whose id is passed.
select one ifSig related by self->SPR_REP[R4502]->C_EP[R4500]->C_AS[R4004];
if ( (not_empty ifSig) and (ifSig.Direction == IFDirectionType::ServerClient) )
  select one sm related by self->SM_SGEVT[R529]->SM_SEVT[R526]->
                                                      SM_EVT[R525]->SM_SM[R502];
  if not_empty sm
    select any transition from instances of SM_TXN where
                                       selected.Trans_ID == param.transition_id;
    if not_empty transition
      select one ne_txn related by transition->SM_NETXN[R507];
      select one originatingState related by ne_txn->SM_STATE[R508];
      if empty ne_txn
        select one originatingState related by transition->SM_NSTXN[R507]->
                                                  SM_SEME[R504]->SM_STATE[R503];
      end if;
      // Disallow this signal if it is already allocated on
      // another outgoing transition from the same originating state
      select many semes related by originatingState->SM_SEME[R503];
      for each seme in semes
        // Don''t consider can''t happen entries
        select one ch related by seme->SM_CH[R504];
        if empty ch
          select one outGoingSig related by seme->
                                    SM_SEVT[R503]->SM_SGEVT[R526]->SPR_RS[R529];
          if not_empty outGoingSig and outGoingSig == self
            return false;
          end if;
        end if;
      end for;
      // Its not already allocated to an outgoing transition on the current
      // state, if this signal is assigned to another transition in this state
      // model and not to some other state model, then its available.
      return sm.SM_ID == transition.SM_ID;
    end if;
  else
    // It is not allocated at all, so its available.
    return true;
  end if;
end if;
return false;',
	1,
	'',
	8701);
INSERT INTO O_TPARM
	VALUES (8705,
	8704,
	'transition_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8702,
	1485,
	'getComponentId',
	'',
	296,
	1,
	'select one rep related by self->SPR_REP[R4502];
return rep.getComponentId();',
	1,
	'',
	8703);
INSERT INTO O_TFR
	VALUES (8706,
	1485,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native
',
	317,
	1,
	'// just return this instance as an Object
return this;
',
	0,
	'',
	8704);
INSERT INTO O_TFR
	VALUES (8707,
	1485,
	'getMessageDirection',
	'',
	298,
	1,
	'select one signal related by self->SPR_REP[R4502]->C_EP[R4500]->C_AS[R4004];
if(not_empty signal)
 if(signal.Direction==IFDirectionType::ClientServer)
  return 0;
 elif (signal.Direction==IFDirectionType::ServerClient)
  return 1;
 else // direction=IFDirectionType::Bidirectional
  return 2;  
 end if;
else
  return -1;  
end if;',
	1,
	'',
	8706);
INSERT INTO O_TFR
	VALUES (8708,
	1485,
	'isSynchronized',
	'',
	316,
	1,
	'// ask the supertype if we are synchronized, this operation exist to support
// ui capabilities
select one rep related by self->SPR_REP[R4502];
if(not_empty rep)
  return rep.isSynchronized();
end if;
return true;',
	1,
	'',
	8707);
INSERT INTO O_TFR
	VALUES (8709,
	1485,
	'collectChanges',
	'',
	19,
	1,
	'/*
 *  Collect removal changes
 */
if(not self.isSynchronized())
  Util::createElementChange(changeList:param.changeList,
                        elementChanged:self.convertToInstance(), isRemoval:true,
                                                         changeLabel:"removed");
end if;',
	1,
	'',
	8708);
INSERT INTO O_TPARM
	VALUES (8710,
	8709,
	'changeList',
	317,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8711,
	1485,
	'synchronize',
	'',
	19,
	1,
	'/**
 *  Allow owning element to synchronize, but only if we are not synchronized
 */
if(not self.isSynchronized())
  select one requirement related by self->SPR_REP[R4502]->C_R[R4500];
  if(not_empty requirement)
    requirement.synchronize();
  end if;
end if;',
	1,
	'',
	8709);
INSERT INTO O_TFR
	VALUES (8712,
	1485,
	'getCachedName',
	'Translate:native',
	322,
	1,
	'	return m_name;',
	0,
	'',
	8711);
INSERT INTO O_TFR
	VALUES (8713,
	1485,
	'setCachedName',
	'Translate:native',
	19,
	1,
	'	m_name = p_Name;',
	0,
	'',
	8712);
INSERT INTO O_TPARM
	VALUES (8714,
	8713,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8715,
	1485,
	'initializeUnparsed',
	'',
	19,
	1,
	'// Required Signal.initializeUnparsed()
select one rsb related by self->ACT_RSB[R684];
if empty rsb
  create object instance rsb of ACT_RSB;
  relate self to rsb across R684;
end if;
select one bdy related by rsb->ACT_ACT[R698];
if empty rsb
  create object instance bdy of ACT_ACT;
  relate bdy to rsb across R698;
end if;
select one blk related by bdy->ACT_BLK[R650];
if empty blk
  create object instance blk of ACT_BLK;
  // Associate across the parsed associations, these
  // will be transferred to the committed state as necessary
  relate bdy to blk across R650;
  relate bdy to blk across R612;
end if;',
	1,
	'',
	8713);
INSERT INTO O_TFR
	VALUES (8716,
	1485,
	'getCachedDescrip',
	'Translate:native',
	322,
	1,
	'	return m_descrip;',
	0,
	'',
	8715);
INSERT INTO O_TFR
	VALUES (8717,
	1485,
	'setCachedDescrip',
	'Translate:native',
	19,
	1,
	'	m_descrip = p_Descrip;',
	0,
	'',
	8716);
INSERT INTO O_TPARM
	VALUES (8718,
	8717,
	'descrip',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (1485,
	63,
	0,
	267,
	8693,
	8695,
	8694,
	1641,
	8719,
	0,
	0,
	'',
	'Required Executable Property',
	'Id',
	'R4502');
INSERT INTO O_RATTR
	VALUES (1641,
	1485,
	267,
	63,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (1641,
	1485,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (8720,
	1485,
	'select one ep related by self->SPR_REP[R4502]->C_EP[R4500];
select one signal related by ep->C_AS[R4004];
if(not_empty signal)
  self.setCachedName(name:ep.Name);
  self.Name = ep.Name;
else
  if(not_empty ep)
    self.Name = ep.getCachedName();
  else
    self.Name = self.getCachedName();
  end if;
end if;',
	1);
INSERT INTO O_BATTR
	VALUES (8720,
	1485);
INSERT INTO O_ATTR
	VALUES (8720,
	1485,
	1641,
	'Name',
	'Full Name: Required Signal Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (8721,
	1485,
	'select one ep related by self->SPR_REP[R4502]->C_EP[R4500];
select one signal related by ep->C_AS[R4004];
if(not_empty signal)
  self.setCachedDescrip(descrip:ep.Descrip);
  self.Descrip = signal.Descrip;
else
  if(not_empty ep)
    self.Descrip = ep.getCachedDescrip();
  else
    self.Descrip = self.getCachedDescrip();
  end if;
end if;',
	1);
INSERT INTO O_BATTR
	VALUES (8721,
	1485);
INSERT INTO O_ATTR
	VALUES (8721,
	1485,
	8720,
	'Descrip',
	'Full Name: Required Signal Description
Description: A textual description of this required signal.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (8722,
	1485,
	'self.Action_Semantics = ::convertRelocatableTags(in:self.Action_Semantics_internal);',
	1);
INSERT INTO O_BATTR
	VALUES (8722,
	1485);
INSERT INTO O_ATTR
	VALUES (8722,
	1485,
	8721,
	'Action_Semantics',
	'Full Name: Action Semantics Field
Description: Action Semantics for the operation action
Persistent:false
',
	'',
	'Action_Semantics',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8723,
	1485);
INSERT INTO O_BATTR
	VALUES (8723,
	1485);
INSERT INTO O_ATTR
	VALUES (8723,
	1485,
	8722,
	'Action_Semantics_internal',
	'User_Visible:false',
	'',
	'Action_Semantics_internal',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8724,
	1485);
INSERT INTO O_BATTR
	VALUES (8724,
	1485);
INSERT INTO O_ATTR
	VALUES (8724,
	1485,
	8723,
	'Suc_Pars',
	'Full Name: Successful Parse Indicator
Description: Indicates the status of the parse for the action specification in the attribute Action_Semantics
Data Domain: 0=not parsed, 1 = parse successful, 2 = parse unsuccessful, 3 = parse on apply set but never been parsed
',
	'',
	'Suc_Pars',
	0,
	1224,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	1485);
INSERT INTO O_OIDA
	VALUES (1641,
	1485,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	1485);
INSERT INTO O_ID
	VALUES (2,
	1485);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3308,
	'Required Operation',
	4502,
	'SPR_RO',
	'',
	8681);
INSERT INTO O_TFR
	VALUES (8725,
	3308,
	'initialize',
	'',
	19,
	1,
	'self.Suc_Pars = ParseStatus::parseInitial;',
	1,
	'',
	8726);
INSERT INTO O_TFR
	VALUES (8727,
	3308,
	'dispose',
	'',
	19,
	1,
	'select one rep related by self->SPR_REP[R4502];
if(not_empty rep)
  unrelate self from rep across R4502;
  rep.dispose();
end if;
select one req_body related by self->ACT_ROB[R685];
if(not_empty req_body)
  unrelate self from req_body across R685;
  req_body.dispose();
end if;
select many invocations related by self->ACT_IOP[R657];
for each iop in invocations
  unrelate self from iop across R657;
end for;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (8726,
	3308,
	'getComponentId',
	'',
	296,
	1,
	'select one rep related by self->SPR_REP[R4502];
return rep.getComponentId();',
	1,
	'',
	8727);
INSERT INTO O_TFR
	VALUES (8728,
	3308,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native
',
	317,
	1,
	'// just return this instance as an Object
return this;
',
	0,
	'',
	8725);
INSERT INTO O_TFR
	VALUES (8729,
	3308,
	'getMessageDirection',
	'',
	298,
	1,
	'select one operation related by self->SPR_REP[R4502]->C_EP[R4500]->C_IO[R4004];
if(not_empty operation)
 if(operation.Direction==IFDirectionType::ClientServer)
  return 0;
 elif (operation.Direction==IFDirectionType::ServerClient)
  return 1;
 else // direction=IFDirectionType::Bidirectional
  return 2;  
 end if;
else
  return -1;  
end if;',
	1,
	'',
	8728);
INSERT INTO O_TFR
	VALUES (8730,
	3308,
	'isSynchronized',
	'',
	316,
	1,
	'// ask the supertype if we are synchronized, this operation exist to support
// ui capabilities
select one rep related by self->SPR_REP[R4502];
if(not_empty rep)
  return rep.isSynchronized();
end if;
return true;',
	1,
	'',
	8729);
INSERT INTO O_TFR
	VALUES (8731,
	3308,
	'collectChanges',
	'',
	19,
	1,
	'/*
 *  Collect removal changes
 */
if(not self.isSynchronized())
  Util::createElementChange(changeList:param.changeList,
                        elementChanged:self.convertToInstance(), isRemoval:true,
                                                         changeLabel:"removed");
end if;',
	1,
	'',
	8730);
INSERT INTO O_TPARM
	VALUES (8732,
	8731,
	'changeList',
	317,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8733,
	3308,
	'synchronize',
	'',
	19,
	1,
	'/**
 *  Allow owning element to synchronize, but only if we are not synchronized
 */
if(not self.isSynchronized())
  select one requirement related by self->SPR_REP[R4502]->C_R[R4500];
  if(not_empty requirement)
    requirement.synchronize();
  end if;
end if;',
	1,
	'',
	8731);
INSERT INTO O_TFR
	VALUES (8734,
	3308,
	'getCachedName',
	'Translate:native',
	322,
	1,
	'	return m_name;',
	0,
	'',
	8733);
INSERT INTO O_TFR
	VALUES (8735,
	3308,
	'setCachedName',
	'Translate:native',
	19,
	1,
	'	m_name = p_Name;',
	0,
	'',
	8734);
INSERT INTO O_TPARM
	VALUES (8736,
	8735,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8737,
	3308,
	'initializeUnparsed',
	'',
	19,
	1,
	'// Required Operation.initializeUnparsed()
select one rob related by self->ACT_ROB[R685];
if empty rob
  create object instance rob of ACT_ROB;
  relate self to rob across R685;
end if;
select one bdy related by rob->ACT_ACT[R698];
if empty bdy
  create object instance bdy of ACT_ACT;
  relate bdy to rob across R698;
end if;
select one blk related by bdy->ACT_BLK[R650];
if empty blk
  create object instance blk of ACT_BLK;
  // Associate across the parsed associations, these
  // will be transferred to the committed state as necessary
  relate bdy to blk across R650;
  relate bdy to blk across R612;
end if;',
	1,
	'',
	8735);
INSERT INTO O_TFR
	VALUES (8738,
	3308,
	'getCachedDescrip',
	'Translate:native',
	322,
	1,
	'	return m_descrip;',
	0,
	'',
	8737);
INSERT INTO O_TFR
	VALUES (8739,
	3308,
	'setCachedDescrip',
	'Translate:native',
	19,
	1,
	'	m_descrip = p_Descrip;',
	0,
	'',
	8738);
INSERT INTO O_TPARM
	VALUES (8740,
	8739,
	'descrip',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (3308,
	63,
	0,
	267,
	8693,
	8696,
	8694,
	3337,
	8741,
	0,
	0,
	'',
	'Required Executable Property',
	'Id',
	'R4502');
INSERT INTO O_RATTR
	VALUES (3337,
	3308,
	267,
	63,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (3337,
	3308,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (8742,
	3308,
	'select one ep related by self->SPR_REP[R4502]->C_EP[R4500];
select one operation related by ep->C_IO[R4004];
if(not_empty operation)
  self.setCachedName(name:ep.Name);
  self.Name = ep.Name;
else
  if(not_empty ep)
    self.Name = ep.getCachedName();
  else
    self.Name = self.getCachedName();
  end if;
end if;',
	1);
INSERT INTO O_BATTR
	VALUES (8742,
	3308);
INSERT INTO O_ATTR
	VALUES (8742,
	3308,
	3337,
	'Name',
	'Full Name: Required Operation Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (8743,
	3308,
	'select one ep related by self->SPR_REP[R4502]->C_EP[R4500];
select one operation related by ep->C_IO[R4004];
if(not_empty operation)
  self.setCachedDescrip(descrip:ep.Descrip);
  self.Descrip = operation.Descrip;
else
  if(not_empty ep)
    self.Descrip = ep.getCachedDescrip();
  else
    self.Descrip = self.getCachedDescrip();
  end if;
end if;',
	1);
INSERT INTO O_BATTR
	VALUES (8743,
	3308);
INSERT INTO O_ATTR
	VALUES (8743,
	3308,
	8742,
	'Descrip',
	'Full Name: Required Operation Description
Description: A textual description of this required operation.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (8744,
	3308,
	'self.Action_Semantics = ::convertRelocatableTags(in:self.Action_Semantics_internal);',
	1);
INSERT INTO O_BATTR
	VALUES (8744,
	3308);
INSERT INTO O_ATTR
	VALUES (8744,
	3308,
	8743,
	'Action_Semantics',
	'Full Name: Action Semantics Field
Description: Action Semantics for the operation action
Persistent:false
',
	'',
	'Action_Semantics',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8745,
	3308);
INSERT INTO O_BATTR
	VALUES (8745,
	3308);
INSERT INTO O_ATTR
	VALUES (8745,
	3308,
	8744,
	'Action_Semantics_internal',
	'User_Visible:false',
	'',
	'Action_Semantics_internal',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8746,
	3308);
INSERT INTO O_BATTR
	VALUES (8746,
	3308);
INSERT INTO O_ATTR
	VALUES (8746,
	3308,
	8745,
	'Suc_Pars',
	'Full Name: Successful Parse Indicator
Description: Indicates the status of the parse for the action specification in the attribute Action_Semantics
Data Domain: 0=not parsed, 1 = parse successful, 2 = parse unsuccessful, 3 = parse on apply set but never been parsed
',
	'',
	'Suc_Pars',
	0,
	1224,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3308);
INSERT INTO O_OIDA
	VALUES (3337,
	3308,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	3308);
INSERT INTO O_ID
	VALUES (2,
	3308);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (63,
	'Required Executable Property',
	4500,
	'SPR_REP',
	'',
	8681);
INSERT INTO O_TFR
	VALUES (8747,
	63,
	'dispose',
	'',
	19,
	1,
	'select one req_signal related by self->SPR_RS[R4502];
select one req_operation related by self->SPR_RO[R4502];
if(not_empty req_signal)
  unrelate self from req_signal across R4502;
  req_signal.dispose();
end if;
if(not_empty req_operation)
  unrelate self from req_operation across R4502;
  req_operation.dispose();
end if;
select one requirement related by self->C_R[R4500];
select one ep related by self->C_EP[R4500];
if(not_empty requirement and not_empty ep)
  unrelate requirement from ep across R4500 using self;
end if;
select many messageVals related by self->V_MSV[R845];
for each msv in messageVals
  unrelate self from msv across R845;
end for;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (8748,
	63,
	'getComponentId',
	'',
	296,
	1,
	'select one requirement related by self->C_R[R4500];
return requirement.getComponentId();',
	1,
	'',
	8747);
INSERT INTO O_TFR
	VALUES (8749,
	63,
	'isSynchronized',
	'',
	316,
	1,
	'/**
 * A Required Executable Property is synchronized if the associated Executable
 * Property exists and is not a proxy
 */
select one ep related by self->C_EP[R4500];
if(empty ep or Util::isProxy(element:ep.convertToInstance()))
  return false;
end if;
// if the ep is not null or not a proxy, then check for an interface
// if that is null or a proxy the EP has been disposed
select one iface related by ep->C_I[R4003];
if(empty iface or Util::isProxy(element:iface.convertToInstance()))
  return false;
end if;
return true;',
	1,
	'',
	8748);
INSERT INTO O_TFR
	VALUES (8750,
	63,
	'migrateExecutableProperty',
	'',
	19,
	1,
	'// we can migrate an executable property if the name matches and the subtypes
// are the same.
select one epProxy related by self->C_EP[R4500];
if(Util::isProxy(element:epProxy.convertToInstance()))
  select one sig related by self->SPR_RS[R4502];
  isSig = not_empty sig;
  select one requirement related by self->C_R[R4500];
  select one interface related by requirement->C_IR[R4009]->C_I[R4012];
  if(not_empty interface)
    select many eps related by interface->C_EP[R4003]
                               where (selected.Name == epProxy.getCachedName());
    for each ep in eps
      if(isSig)
        select one interfaceSig related by ep->C_AS[R4004];
        if(not_empty interfaceSig)
          unrelate requirement from epProxy across R4500 using self;
          relate requirement to ep across R4500 using self;
          return;
        end if;
      else
        select one interfaceOp related by ep->C_IO[R4004];
        if(not_empty interfaceOp)
          unrelate requirement from epProxy across R4500 using self;
          relate requirement to ep across R4500 using self;
          return;         
        end if;
      end if;
    end for;
  end if;
end if;',
	1,
	'',
	8749);
INSERT INTO O_TFR
	VALUES (8751,
	63,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'return this;',
	0,
	'',
	8750);
INSERT INTO O_TFR
	VALUES (8752,
	63,
	'isReferringToDefaultExecutableProperty',
	'',
	316,
	1,
	'select one ep related by self->C_EP[R4500];
if(empty ep or Util::isProxy(element:ep.convertToInstance()))
  return true;
end if;
return false;',
	1,
	'',
	8751);
INSERT INTO O_TFR
	VALUES (8753,
	63,
	'canReferToExecutableProperty',
	'',
	316,
	1,
	'select one interface related by self->C_EP[R4500]->C_I[R4003];
select one reference related by self->C_R[R4500]->C_IR[R4009];
select one ourInterface related by reference->C_I[R4012];
if(interface == ourInterface)
  return true;
end if;
if(Util::isProxy(element:ourInterface.convertToInstance()))
  // we must associate the EPs interface with our reference
  // then ask if it can be used
  unrelate ourInterface from reference across R4012;
  relate interface to reference across R4012;
  result = false;
  if(reference.canReferToInterface())
    result = true;
  end if;
  unrelate reference from interface across R4012;
  relate reference to ourInterface across R4012;
  return result;
end if;
return false;',
	1,
	'',
	8752);
INSERT INTO O_REF
	VALUES (63,
	3137,
	0,
	3136,
	8685,
	8688,
	8686,
	8754,
	8755,
	0,
	0,
	'',
	'Executable Property',
	'Id',
	'R4500');
INSERT INTO O_RATTR
	VALUES (8754,
	63,
	3136,
	3137,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (8754,
	63,
	267,
	'ExecutableProperty_Id',
	'',
	'ExecutableProperty_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (267,
	63);
INSERT INTO O_BATTR
	VALUES (267,
	63);
INSERT INTO O_ATTR
	VALUES (267,
	63,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	296,
	'',
	'');
INSERT INTO O_REF
	VALUES (63,
	8623,
	0,
	8625,
	8685,
	8688,
	8687,
	8756,
	8757,
	0,
	0,
	'',
	'Requirement',
	'Requirement_Id',
	'R4500');
INSERT INTO O_RATTR
	VALUES (8756,
	63,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (8756,
	63,
	8754,
	'Requirement_Id',
	'',
	'',
	'Requirement_Id',
	2,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	63);
INSERT INTO O_OIDA
	VALUES (267,
	63,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	63);
INSERT INTO O_ID
	VALUES (2,
	63);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (1483,
	'Provided Signal',
	4505,
	'SPR_PS',
	'',
	8681);
INSERT INTO O_TFR
	VALUES (8758,
	1483,
	'initialize',
	'',
	19,
	1,
	'self.Suc_Pars = ParseStatus::parseInitial;',
	1,
	'',
	8759);
INSERT INTO O_TFR
	VALUES (8760,
	1483,
	'dispose',
	'',
	19,
	1,
	'select one pep related by self->SPR_PEP[R4503];
if(not_empty pep)
  unrelate self from pep across R4503;
  pep.dispose();
end if;
select one pro_body related by self->ACT_PSB[R686];
if(not_empty pro_body)
  unrelate self from pro_body across R686;
  pro_body.dispose();
end if;
select one evt related by self->SM_SGEVT[R528]->SM_SEVT[R526]->SM_EVT[R525];
if not_empty evt
  evt.dispose();
end if;
select many invocations related by self->ACT_SGN[R663];
for each sgn in invocations
  unrelate self from sgn across R663;
end for;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (8761,
	1483,
	'isAvailableForAllocationTo',
	'',
	316,
	1,
	'// Provided Signal::isAvailableForAllocationTo()
// Returns false if the signal has been allocated to a state machine 
// other than the one owining the transition whose id is passed.
select one ifSig related by self->SPR_PEP[R4503]->C_EP[R4501]->C_AS[R4004];
if ifSig.Direction == IFDirectionType::ClientServer
  select one sm related by self->SM_SGEVT[R528]->SM_SEVT[R526]->
                                                      SM_EVT[R525]->SM_SM[R502];
  if not_empty sm
    select any transition from instances of SM_TXN where
                                       selected.Trans_ID == param.transition_id;
    if not_empty transition
      select one ne_txn related by transition->SM_NETXN[R507];
      select one originatingState related by ne_txn->SM_STATE[R508];
      if empty ne_txn
        select one originatingState related by transition->SM_NSTXN[R507]->
                                                  SM_SEME[R504]->SM_STATE[R503];
      end if;
      // Disallow this signal if it is already allocated on
      // another outgoing transition from the same originating state
      select many semes related by originatingState->SM_SEME[R503];
      for each seme in semes
        // Don''t consider can''t happen entries
        select one ch related by seme->SM_CH[R504];
        if empty ch
          select one outGoingSig related by seme->
                                    SM_SEVT[R503]->SM_SGEVT[R526]->SPR_PS[R528];
          if not_empty outGoingSig and outGoingSig == self
            return false;
          end if;
        end if;
      end for;
      // Its not already allocated to an outgoing transition on the current
      // state, if this signal is assigned to another transition in this state
      // model and not to some other state model, then its available.
      return sm.SM_ID == transition.SM_ID;
    end if;
  else
    // It is not allocated at all, so its available.
    return true;
  end if;
end if;
return false;',
	1,
	'',
	8758);
INSERT INTO O_TPARM
	VALUES (8762,
	8761,
	'transition_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8759,
	1483,
	'getComponentId',
	'',
	296,
	1,
	'select one pep related by self->SPR_PEP[R4503];
return pep.getComponentId();',
	1,
	'',
	8760);
INSERT INTO O_TFR
	VALUES (8763,
	1483,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native
',
	317,
	1,
	'// just return this instance as an Object
return this;
',
	0,
	'',
	8761);
INSERT INTO O_TFR
	VALUES (8764,
	1483,
	'getMessageDirection',
	'',
	298,
	1,
	'select one signal related by self->SPR_PEP[R4503]->C_EP[R4501]->C_AS[R4004];
if(not_empty signal)
 if(signal.Direction==IFDirectionType::ClientServer)
  return 0;
 elif (signal.Direction==IFDirectionType::ServerClient)
  return 1;
 else // direction=IFDirectionType::Bidirectional
  return 2;  
 end if; 
else
  return -1; 
end if;',
	1,
	'',
	8763);
INSERT INTO O_TFR
	VALUES (8765,
	1483,
	'isSynchronized',
	'',
	316,
	1,
	'// ask the supertype if we are synchronized, this operation exist to support
// ui capabilities
select one pep related by self->SPR_PEP[R4503];
if(not_empty pep)
  return pep.isSynchronized();
end if;
return true;',
	1,
	'',
	8764);
INSERT INTO O_TFR
	VALUES (8766,
	1483,
	'collectChanges',
	'',
	19,
	1,
	'/*
 *  Collect removal changes
 */
if(not self.isSynchronized())
  Util::createElementChange(changeList:param.changeList,
                        elementChanged:self.convertToInstance(), isRemoval:true,
                                                         changeLabel:"removed");
end if;',
	1,
	'',
	8765);
INSERT INTO O_TPARM
	VALUES (8767,
	8766,
	'changeList',
	317,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8768,
	1483,
	'synchronize',
	'',
	19,
	1,
	'/**
 *  Allow owning element to synchronize, but only if we are not synchronized
 */
if(not self.isSynchronized())
  select one provision related by self->SPR_PEP[R4503]->C_P[R4501];
  if(not_empty provision)
    provision.synchronize();
  end if;
end if;',
	1,
	'',
	8766);
INSERT INTO O_TFR
	VALUES (8769,
	1483,
	'getCachedName',
	'Translate:native',
	322,
	1,
	'	return m_name;',
	0,
	'',
	8768);
INSERT INTO O_TFR
	VALUES (8770,
	1483,
	'setCachedName',
	'Translate:native',
	19,
	1,
	'	m_name = p_Name;',
	0,
	'',
	8769);
INSERT INTO O_TPARM
	VALUES (8771,
	8770,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8772,
	1483,
	'initializeUnparsed',
	'',
	19,
	1,
	'// Provided Signal.initializeUnparsed()
select one psb related by self->ACT_PSB[R686];
if empty psb
  create object instance psb of ACT_PSB;
  relate self to psb across R686;
end if;
select one bdy related by psb->ACT_ACT[R698];
if empty bdy
  create object instance bdy of ACT_ACT;
  relate bdy to psb across R698;
end if;
select one blk related by bdy->ACT_BLK[R650];
if empty blk
  create object instance blk of ACT_BLK;
  // Associate across the parsed associations, these
  // will be transferred to the committed state as necessary
  relate bdy to blk across R650;
  relate bdy to blk across R612;
end if;',
	1,
	'',
	8770);
INSERT INTO O_TFR
	VALUES (8773,
	1483,
	'getCachedDescrip',
	'Translate:native',
	322,
	1,
	'	return m_descrip;',
	0,
	'',
	8772);
INSERT INTO O_TFR
	VALUES (8774,
	1483,
	'setCachedDescrip',
	'Translate:native',
	19,
	1,
	'	m_descrip = p_Descrip;',
	0,
	'',
	8773);
INSERT INTO O_TPARM
	VALUES (8775,
	8774,
	'descrip',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (1483,
	61,
	0,
	263,
	8697,
	8700,
	8698,
	1637,
	8776,
	0,
	0,
	'',
	'Provided Executable Property',
	'Id',
	'R4503');
INSERT INTO O_RATTR
	VALUES (1637,
	1483,
	263,
	61,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (1637,
	1483,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (8777,
	1483,
	'select one ep related by self->SPR_PEP[R4503]->C_EP[R4501];
select one signal related by ep->C_AS[R4004];
if(not_empty signal)
  self.setCachedName(name:ep.Name);
  self.Name = ep.Name;
else
  if(not_empty ep)
    self.Name = ep.getCachedName();
  else
    self.Name = self.getCachedName();
  end if;
end if;',
	1);
INSERT INTO O_BATTR
	VALUES (8777,
	1483);
INSERT INTO O_ATTR
	VALUES (8777,
	1483,
	1637,
	'Name',
	'Full Name: Provided Signal Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (8778,
	1483,
	'select one ep related by self->SPR_PEP[R4503]->C_EP[R4501];
select one signal related by ep->C_AS[R4004];
if(not_empty signal)
  self.setCachedDescrip(descrip:ep.Descrip);
  self.Descrip = signal.Descrip;
else
  if(not_empty ep)
    self.Descrip = ep.getCachedDescrip();
  else
    self.Descrip = self.getCachedDescrip();
  end if;
end if;',
	1);
INSERT INTO O_BATTR
	VALUES (8778,
	1483);
INSERT INTO O_ATTR
	VALUES (8778,
	1483,
	8777,
	'Descrip',
	'Full Name: Provided Signal Description
Description: A textual description of this provided signal.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (8779,
	1483,
	'self.Action_Semantics = ::convertRelocatableTags(in:self.Action_Semantics_internal);',
	1);
INSERT INTO O_BATTR
	VALUES (8779,
	1483);
INSERT INTO O_ATTR
	VALUES (8779,
	1483,
	8778,
	'Action_Semantics',
	'Full Name: Action Semantics Field
Description: Action Semantics for the signal action
Persistent:false
',
	'',
	'Action_Semantics',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8780,
	1483);
INSERT INTO O_BATTR
	VALUES (8780,
	1483);
INSERT INTO O_ATTR
	VALUES (8780,
	1483,
	8779,
	'Action_Semantics_internal',
	'User_Visible:false',
	'',
	'Action_Semantics_internal',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8781,
	1483);
INSERT INTO O_BATTR
	VALUES (8781,
	1483);
INSERT INTO O_ATTR
	VALUES (8781,
	1483,
	8780,
	'Suc_Pars',
	'Full Name: Successful Parse Indicator
Description: Indicates the status of the parse for the action specification in the attribute Action_Semantics
Data Domain: 0=not parsed, 1 = parse successful, 2 = parse unsuccessful, 3 = parse on apply set but never been parsed
',
	'',
	'Suc_Pars',
	0,
	1224,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	1483);
INSERT INTO O_OIDA
	VALUES (1637,
	1483,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	1483);
INSERT INTO O_ID
	VALUES (2,
	1483);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3306,
	'Provided Operation',
	4504,
	'SPR_PO',
	'',
	8681);
INSERT INTO O_TFR
	VALUES (8782,
	3306,
	'initialize',
	'',
	19,
	1,
	'self.Suc_Pars = ParseStatus::parseInitial;',
	1,
	'',
	8783);
INSERT INTO O_TFR
	VALUES (8784,
	3306,
	'dispose',
	'',
	19,
	1,
	'select one pep related by self->SPR_PEP[R4503];
if(not_empty pep)
  unrelate self from pep across R4503;
  pep.dispose();
end if;
select one pro_body related by self->ACT_POB[R687];
if(not_empty pro_body)
  unrelate self from pro_body across R687;
  pro_body.dispose();
end if;
select many invocations related by self->ACT_IOP[R680];
for each iop in invocations
  unrelate self from iop across R680;
end for;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (8783,
	3306,
	'getComponentId',
	'',
	296,
	1,
	'select one pep related by self->SPR_PEP[R4503];
return pep.getComponentId();',
	1,
	'',
	8784);
INSERT INTO O_TFR
	VALUES (8785,
	3306,
	'getMessageDirection',
	'',
	298,
	1,
	'select one operation related by self->SPR_PEP[R4503]->C_EP[R4501]->C_IO[R4004];
if(not_empty operation)
 if(operation.Direction==IFDirectionType::ClientServer)
  return 0;
 elif (operation.Direction==IFDirectionType::ServerClient)
  return 1;
 else // direction=IFDirectionType::Bidirectional
  return 2;  
 end if; 
else
  return -1;
end if;',
	1,
	'',
	8782);
INSERT INTO O_TFR
	VALUES (8786,
	3306,
	'isSynchronized',
	'',
	316,
	1,
	'// ask the supertype if we are synchronized, this operation exist to support
// ui capabilities
select one pep related by self->SPR_PEP[R4503];
if(not_empty pep)
  return pep.isSynchronized();
end if;
return true;',
	1,
	'',
	8785);
INSERT INTO O_TFR
	VALUES (8787,
	3306,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'return this;',
	0,
	'',
	8786);
INSERT INTO O_TFR
	VALUES (8788,
	3306,
	'collectChanges',
	'',
	19,
	1,
	'/*
 *  Collect removal changes
 */
if(not self.isSynchronized())
  Util::createElementChange(changeList:param.changeList,
                        elementChanged:self.convertToInstance(), isRemoval:true,
                                                         changeLabel:"removed");
end if;',
	1,
	'',
	8787);
INSERT INTO O_TPARM
	VALUES (8789,
	8788,
	'changeList',
	317,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8790,
	3306,
	'synchronize',
	'',
	19,
	1,
	'/**
 *  Allow owning element to synchronize, but only if we are not synchronized
 */
if(not self.isSynchronized())
  select one provision related by self->SPR_PEP[R4503]->C_P[R4501];
  if(not_empty provision)
    provision.synchronize();
  end if;
end if;',
	1,
	'',
	8788);
INSERT INTO O_TFR
	VALUES (8791,
	3306,
	'getCachedName',
	'Translate:native',
	322,
	1,
	'	return m_name;',
	0,
	'',
	8790);
INSERT INTO O_TFR
	VALUES (8792,
	3306,
	'setCachedName',
	'Translate:native',
	19,
	1,
	'	m_name = p_Name;',
	0,
	'',
	8791);
INSERT INTO O_TPARM
	VALUES (8793,
	8792,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8794,
	3306,
	'initializeUnparsed',
	'',
	19,
	1,
	'// Provided Operation.initializeUnparsed()
select one pob related by self->ACT_POB[R687];
if empty pob
  create object instance pob of ACT_POB;
  relate self to pob across R687;
end if;
select one bdy related by pob->ACT_ACT[R698];
if empty bdy
  create object instance bdy of ACT_ACT;
  relate bdy to pob across R698;
end if;
select one blk related by bdy->ACT_BLK[R650];
if empty blk
  create object instance blk of ACT_BLK;
  // Associate across the parsed associations, these
  // will be transferred to the committed state as necessary
  relate bdy to blk across R650;
  relate bdy to blk across R612;
end if;',
	1,
	'',
	8792);
INSERT INTO O_TFR
	VALUES (8795,
	3306,
	'getCachedDescrip',
	'Translate:native',
	322,
	1,
	'	return m_descrip;',
	0,
	'',
	8794);
INSERT INTO O_TFR
	VALUES (8796,
	3306,
	'setCachedDescrip',
	'Translate:native',
	19,
	1,
	'	m_descrip = p_Descrip;',
	0,
	'',
	8795);
INSERT INTO O_TPARM
	VALUES (8797,
	8796,
	'descrip',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (3306,
	61,
	0,
	263,
	8697,
	8699,
	8698,
	3334,
	8798,
	0,
	0,
	'',
	'Provided Executable Property',
	'Id',
	'R4503');
INSERT INTO O_RATTR
	VALUES (3334,
	3306,
	263,
	61,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (3334,
	3306,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (8799,
	3306,
	'select one ep related by self->SPR_PEP[R4503]->C_EP[R4501];
select one operation related by ep->C_IO[R4004];
if(not_empty operation)
  self.setCachedName(name:ep.Name);
  self.Name = ep.Name;
else
  if(not_empty ep)
    self.Name = ep.getCachedName();
  else
    self.Name = self.getCachedName();
  end if;
end if;',
	1);
INSERT INTO O_BATTR
	VALUES (8799,
	3306);
INSERT INTO O_ATTR
	VALUES (8799,
	3306,
	3334,
	'Name',
	'Full Name: Provided Operation Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (8800,
	3306,
	'select one ep related by self->SPR_PEP[R4503]->C_EP[R4501];
select one operation related by ep->C_IO[R4004];
if(not_empty operation)
  self.setCachedDescrip(descrip:ep.Descrip);
  self.Descrip = operation.Descrip;
else
  if(not_empty ep)
    self.Descrip = ep.getCachedDescrip();
  else
    self.Descrip = self.getCachedDescrip();
  end if;
end if;',
	1);
INSERT INTO O_BATTR
	VALUES (8800,
	3306);
INSERT INTO O_ATTR
	VALUES (8800,
	3306,
	8799,
	'Descrip',
	'Full Name: Provided Operation Description
Description: A textual description of this provided operation.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (8801,
	3306,
	'self.Action_Semantics = ::convertRelocatableTags(in:self.Action_Semantics_internal);',
	1);
INSERT INTO O_BATTR
	VALUES (8801,
	3306);
INSERT INTO O_ATTR
	VALUES (8801,
	3306,
	8800,
	'Action_Semantics',
	'Full Name: Action Semantics Field
Description: Action Semantics for the signal action
Persistent:false
',
	'',
	'Action_Semantics',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8802,
	3306);
INSERT INTO O_BATTR
	VALUES (8802,
	3306);
INSERT INTO O_ATTR
	VALUES (8802,
	3306,
	8801,
	'Action_Semantics_internal',
	'User_Visible:false',
	'',
	'Action_Semantics_internal',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8803,
	3306);
INSERT INTO O_BATTR
	VALUES (8803,
	3306);
INSERT INTO O_ATTR
	VALUES (8803,
	3306,
	8802,
	'Suc_Pars',
	'Full Name: Successful Parse Indicator
Description: Indicates the status of the parse for the action specification in the attribute Action_Semantics
Data Domain: 0=not parsed, 1 = parse successful, 2 = parse unsuccessful, 3 = parse on apply set but never been parsed
',
	'',
	'Suc_Pars',
	0,
	1224,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3306);
INSERT INTO O_OIDA
	VALUES (3334,
	3306,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	3306);
INSERT INTO O_ID
	VALUES (2,
	3306);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (61,
	'Provided Executable Property',
	4501,
	'SPR_PEP',
	'',
	8681);
INSERT INTO O_TFR
	VALUES (8804,
	61,
	'dispose',
	'',
	19,
	1,
	'select one pro_signal related by self->SPR_PS[R4503];
select one pro_operation related by self->SPR_PO[R4503];
if(not_empty pro_signal)
  unrelate self from pro_signal across R4503;
  pro_signal.dispose();
end if;
if(not_empty pro_operation)
  unrelate self from pro_operation across R4503;
  pro_operation.dispose();
end if;
select one provision related by self->C_P[R4501];
select one ep related by self->C_EP[R4501];
if(not_empty provision and not_empty ep)
  unrelate provision from ep across R4501 using self;
end if;
select many messageVals related by self->V_MSV[R841];
for each msv in messageVals
  unrelate self from msv across R841;
end for;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (8805,
	61,
	'getComponentId',
	'',
	296,
	1,
	'select one provision related by self->C_P[R4501];
return provision.getComponentId();',
	1,
	'',
	8804);
INSERT INTO O_TFR
	VALUES (8806,
	61,
	'isSynchronized',
	'',
	316,
	1,
	'/**
 * A Provided Executable Property is synchronized if the associated Executable
 * Property exists and is not a proxy
 */
select one ep related by self->C_EP[R4501];
if(empty ep or Util::isProxy(element:ep.convertToInstance()))
  return false;
end if;
// if the ep is not null or not a proxy, then check for an interface
// if that is null or a proxy the EP has been disposed
select one iface related by ep->C_I[R4003];
if(empty iface or Util::isProxy(element:iface.convertToInstance()))
  return false;
end if;
return true;',
	1,
	'',
	8805);
INSERT INTO O_TFR
	VALUES (8807,
	61,
	'migrateExecutableProperty',
	'',
	19,
	1,
	'// we can migrate an executable property if the name matches and the subtypes
// are the same.
select one epProxy related by self->C_EP[R4501];
if(Util::isProxy(element:epProxy.convertToInstance()))
  select one sig related by self->SPR_PS[R4503];
  isSig = not_empty sig;
  select one provision related by self->C_P[R4501];
  select one interface related by provision->C_IR[R4009]->C_I[R4012];
  if(not_empty interface)
    select many eps related by interface->C_EP[R4003]
                               where (selected.Name == epProxy.getCachedName());
    for each ep in eps
      if(isSig)
        select one interfaceSig related by ep->C_AS[R4004];
        if(not_empty interfaceSig)
          unrelate provision from epProxy across R4501 using self;
          relate provision to ep across R4501 using self;
          return;
        end if;
      else
        select one interfaceOp related by ep->C_IO[R4004];
        if(not_empty interfaceOp)
          unrelate provision from epProxy across R4501 using self;
          relate provision to ep across R4501 using self;
          return;         
        end if;
      end if;
    end for;
  end if;
end if;',
	1,
	'',
	8806);
INSERT INTO O_TFR
	VALUES (8808,
	61,
	'isReferringToDefaultExecutableProperty',
	'',
	316,
	1,
	'select one ep related by self->C_EP[R4501];
if(empty ep or Util::isProxy(element:ep.convertToInstance()))
  return true;
end if;
return false;',
	1,
	'',
	8807);
INSERT INTO O_TFR
	VALUES (8809,
	61,
	'canReferToExecutableProperty',
	'',
	316,
	1,
	'select one interface related by self->C_EP[R4501]->C_I[R4003];
select one reference related by self->C_P[R4501]->C_IR[R4009];
select one ourInterface related by reference->C_I[R4012];
if(interface == ourInterface)
  return true;
end if;
if(Util::isProxy(element:ourInterface.convertToInstance()))
  // we must associate the EPs interface with our reference
  // then ask if it can be used
  unrelate ourInterface from reference across R4012;
  relate interface to reference across R4012;
  result = false;
  if(reference.canReferToInterface())
    result = true;
  end if;
  unrelate reference from interface across R4012;
  relate reference to ourInterface across R4012;
  return result;
end if;
return false;',
	1,
	'',
	8808);
INSERT INTO O_TFR
	VALUES (8810,
	61,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'return this;',
	0,
	'',
	8809);
INSERT INTO O_REF
	VALUES (61,
	3137,
	0,
	3136,
	8689,
	8692,
	8690,
	8811,
	8812,
	0,
	0,
	'',
	'Executable Property',
	'Id',
	'R4501');
INSERT INTO O_RATTR
	VALUES (8811,
	61,
	3136,
	3137,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (8811,
	61,
	263,
	'ExecutableProperty_Id',
	'',
	'ExecutableProperty_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (263,
	61);
INSERT INTO O_BATTR
	VALUES (263,
	61);
INSERT INTO O_ATTR
	VALUES (263,
	61,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	296,
	'',
	'');
INSERT INTO O_REF
	VALUES (61,
	8626,
	0,
	8628,
	8689,
	8692,
	8691,
	8813,
	8814,
	0,
	0,
	'',
	'Provision',
	'Provision_Id',
	'R4501');
INSERT INTO O_RATTR
	VALUES (8813,
	61,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (8813,
	61,
	8811,
	'Provision_Id',
	'',
	'',
	'Provision_Id',
	2,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	61);
INSERT INTO O_OIDA
	VALUES (263,
	61,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	61);
INSERT INTO O_ID
	VALUES (2,
	61);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2765,
	'Satisfaction',
	4007,
	'C_SF',
	'A satisfaction represents the fact that one provided interface satisfies one or
more requirements.  This link class is setup when a provided interface is
connected to one or more required interfaces.',
	8619);
INSERT INTO O_TFR
	VALUES (8815,
	2765,
	'satisfiesWithImportedRef',
	'',
	316,
	1,
	'return self.satisfiesWithImportedPro() or self.satisfiesWithImportedReq();',
	1,
	'',
	8816);
INSERT INTO O_TFR
	VALUES (8817,
	2765,
	'dispose',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Satisfaction.dispose()
select one pe related by self->PE_PE[R8001];
isInGenericPackage = not_empty pe;
if isInGenericPackage
  // PackageableElement.dispose() will call back down into here, so just return
  pe.dispose();
  return;
else
  select one pro related by self->C_P[R4002];
  select one req related by self->C_R[R4002];
  if(not_empty pro) and (not_empty req)
    unrelate req from pro across R4002 using self;
  end if;
  select one importedPro related by self->CL_IPINS[R4705]->CL_IP[R4705];
  if(not_empty importedPro)
    select one ipins related by self->CL_IPINS[R4705];
    unrelate self from importedPro across R4705 using ipins;
    delete object instance ipins;
  end if;
  select one importedReq related by self->CL_IR[R4706];
  if(not_empty importedReq)
    unrelate self from importedReq across R4706;
  end if;
  select one sicp related by self->PA_SICP[R9001];
  select one comppkg related by sicp->CP_CP[R9001];
  if (not_empty sicp)
    unrelate self from comppkg across R9001 using sicp;
    // no need to dispose comppkg, it will get
    // disposed later
    delete object instance sicp;
  end if;

  select one sic related by self->PA_SIC[R9000];
  if (not_empty sic)
    select one comp related by sic->C_C[R9000];
    unrelate self from comp across R9000 using sic;
    // no need to dispose component, it will get
    // disposed later
    delete object instance sic;
  end if;

end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (8818,
	2765,
	'satisfiesWithImportedReq',
	'',
	316,
	1,
	'select one importedReq related by self->CL_IR[R4706];
if(not_empty importedReq)
  return true;
end if;
return false;',
	1,
	'',
	8815);
INSERT INTO O_TFR
	VALUES (8816,
	2765,
	'satisfiesWithImportedPro',
	'',
	316,
	1,
	'select one importedPro related by self->CL_IPINS[R4705];
if(not_empty importedPro)
  return true;
end if;
return false;',
	1,
	'',
	8817);
INSERT INTO O_TFR
	VALUES (8819,
	2765,
	'convertToInstance',
	'Translate:native',
	317,
	1,
	'return this;',
	0,
	'',
	8818);
INSERT INTO O_TFR
	VALUES (8820,
	2765,
	'get_name',
	'',
	322,
	1,
	'return self.Label;',
	1,
	'',
	8819);
INSERT INTO O_NBATTR
	VALUES (8821,
	2765);
INSERT INTO O_BATTR
	VALUES (8821,
	2765);
INSERT INTO O_ATTR
	VALUES (8821,
	2765,
	8822,
	'Descrip',
	'Full Name: Satisfaction Description
Description: A textual description of this satisfaction.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (2765,
	8623,
	0,
	8625,
	8622,
	8629,
	8624,
	8823,
	8824,
	0,
	0,
	'',
	'Requirement',
	'Requirement_Id',
	'R4002.''defines required satisfication''');
INSERT INTO O_RATTR
	VALUES (8823,
	2765,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (8823,
	2765,
	2778,
	'Requirement_Id',
	'',
	'Requirement_',
	'Requirement_Id',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2765,
	8626,
	0,
	8628,
	8622,
	8629,
	8627,
	8822,
	8825,
	0,
	0,
	'',
	'Provision',
	'Provision_Id',
	'R4002.''satisfies''');
INSERT INTO O_RATTR
	VALUES (8822,
	2765,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (8822,
	2765,
	8823,
	'Provision_Id',
	'',
	'Provision_',
	'Provision_Id',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2765,
	26,
	0,
	25,
	868,
	2841,
	870,
	2778,
	8826,
	0,
	0,
	'',
	'Packageable Element',
	'Element_ID',
	'R8001');
INSERT INTO O_RATTR
	VALUES (2778,
	2765,
	25,
	26,
	0,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (2778,
	2765,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (8827,
	2765,
	'select one provision related by self->C_P[R4002];
select one requirement related by self->C_R[R4002];
provision_path = "[undetermined path]";
requirement_path = "[undetermined path]";
if(not_empty provision)
  provision_path = provision.pathFromComponent;
end if;
if(not_empty requirement)
  requirement_path = requirement.reversePathFromComponent;
end if;
self.Label = provision_path + " -o)- " + requirement_path; ',
	1);
INSERT INTO O_BATTR
	VALUES (8827,
	2765);
INSERT INTO O_ATTR
	VALUES (8827,
	2765,
	8821,
	'Label',
	'Full Name: Satisfaction Label
User_Visible:false',
	'',
	'Label',
	0,
	322,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2765);
INSERT INTO O_OIDA
	VALUES (2778,
	2765,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	2765);
INSERT INTO O_OIDA
	VALUES (8823,
	2765,
	1,
	'Requirement_Id');
INSERT INTO O_OIDA
	VALUES (8822,
	2765,
	1,
	'Provision_Id');
INSERT INTO O_ID
	VALUES (2,
	2765);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (8623,
	'Requirement',
	4003,
	'C_R',
	'Requirements are used to represent required interfaces on a Component Diagram.
When they are formal, that is related to a defined interface on an interface
diagram, an association is setup between the component that requires the
interface and one component that provides the same interface.',
	8619);
INSERT INTO O_TFR
	VALUES (8828,
	8623,
	'get_connector_text',
	'',
	322,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
name = "";
if(param.at == End::Middle)
  select one comp related by self->C_IR[R4009]->C_PO[R4016]->C_C[R4010];
  select one parentCP related by comp->CP_CP[R4604];
  if(empty parentCP)
    select one parentComp related by comp->CN_CIC[R4203]->C_C[R4202];
    if(not_empty parentComp)
      while(empty parentCP)
        select one parentCP related by parentComp->CP_CP[R4604];
        select one parentComp related by parentComp->CN_CIC[R4203]->C_C[R4202];
      end while;
    end if;
  end if;
  
  select one packageableElem related by comp->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = ((not_empty package or not_empty component) and (empty parentCP));
  
  if(not_empty parentCP or isInGenericPackage)
    if (isInGenericPackage) 
      select one system related by package->S_SYS[R1405];
      if (empty system)
        rootCompIdInPkg = component.getRootComponentId();
        select any rootComponent from instances of C_C where (selected.Id == rootCompIdInPkg);
        select one system related by rootComponent->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405];
      end if;
      select any parentPackage related by system->EP_PKG[R1405] where (selected.Package_ID == param.parent_ID);
      if(empty parentPackage)
        // this is not a requirement shown in a component package
        // if this requirement is not associated with a component
        // that is nested in the component with the given id
        // then always draw the name
        select one nestingComp related by comp->PE_PE[R8001]->C_C[R8003];
        if(empty nestingComp or nestingComp.Id != param.parent_ID)
          if(param.at == End::Middle)
            return self.Name;
          end if;
        end if;
      end if;
    else
      select one system related by parentCP->S_SYS[R4606];
      select any parentPackage related by system->CP_CP[R4606] where (selected.Package_ID == param.parent_ID);
      if(empty parentPackage)
        // this is not a requirement shown in a component package
        // if this requirement is not associated with a component
        // that is nested in the component with the given id
        // then always draw the name
        select one nestingComp related by comp->CN_CIC[R4203]->C_C[R4202];
        if(empty nestingComp or nestingComp.Id != param.parent_ID)
          if(param.at == End::Middle)
            return self.Name;
          end if;
        end if;
      end if;
    end if;
  end if;
  select many satisfactions related by self->C_SF[R4002];
  // if there is at least one satisfaction made with out
  // an imported ref, don''t show the text for this
  satisfactionWithoutImportedRef = false;
  select any provision from instances of C_P where (selected.Provision_Id 
													   == GD::NULL_UNIQUE_ID());
  for each satisfaction in satisfactions
    select one importedRef related by satisfaction->CL_IR[R4706];
    if(empty importedRef)
      select one provision related by satisfaction->C_P[R4002];
      satisfactionWithoutImportedRef = true;
      break;
    end if;
  end for;
  if(satisfactionWithoutImportedRef)
    if(self.isFormal() and not param.connected_disabled)
      return "";
    else
      if(provision.Name == self.Name and not param.connected_disabled)
        return "";
      else
        return self.Name;
      end if;
    end if;
  else
    return self.Name;
  end if;
elif(param.at == End::Start_Fixed)
  select one port related by self->C_IR[R4009]->C_PO[R4016];
  if(not_empty port)
    if(not port.DoNotShowPortOnCanvas)
      return port.getPortText();
    end if;
  end if;
end if;
return "";',
	1,
	'',
	8829);
INSERT INTO O_TPARM
	VALUES (8830,
	8828,
	'Obj_ID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (8831,
	8828,
	'Obj_TypeIsImported',
	316,
	0,
	'',
	8830,
	'');
INSERT INTO O_TPARM
	VALUES (8832,
	8828,
	'at',
	880,
	0,
	'',
	8831,
	'');
INSERT INTO O_TPARM
	VALUES (8833,
	8828,
	'parent_ID',
	296,
	0,
	'',
	8832,
	'');
INSERT INTO O_TPARM
	VALUES (8834,
	8828,
	'connected_disabled',
	316,
	0,
	'',
	8833,
	'');
INSERT INTO O_TFR
	VALUES (8835,
	8623,
	'get_style',
	'',
	784,
	1,
	'if(param.at == End::End)
  return Style::SemiCircle;
elif(param.at == End::Start)
  // if the port wants to show
  // draw a small square at the
  // start of this provision
  select one port related by self->C_IR[R4009]->C_PO[R4016];
  if(not_empty port)
    if(not port.DoNotShowPortOnCanvas)
      select one interface related by self->C_IR[R4009]->C_I[R4012];
      if(not_empty interface)
        clientServer = interface.hasEPWithDirection(
                                       direction:IFDirectionType::ClientServer);
        serverClient = interface.hasEPWithDirection(
                                       direction:IFDirectionType::ServerClient);
        if(clientServer and serverClient)
          return Style::BoxArrowInOut;
        end if;
        if(clientServer)
          return Style::BoxArrowOut;
        end if;
        if(serverClient)
          return Style::BoxArrowIn;
        end if;
      end if;
      return Style::FilledSquare;
    end if;
  end if;
end if;
return Style::None;',
	1,
	'',
	8836);
INSERT INTO O_TPARM
	VALUES (8837,
	8835,
	'at',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8838,
	8623,
	'dispose',
	'',
	19,
	1,
	'self.dissatisfy();
select one iref related by self->C_IR[R4009];
if(not_empty iref)
  unrelate self from iref across R4009;
  iref.dispose();
end if;
select many reps related by self->SPR_REP[R4500];
for each rep in reps
  select one ep related by rep->C_EP[R4500];
  unrelate self from ep across R4500 using rep;
  rep.dispose();
end for;
delete object instance self;',
	1,
	'',
	8839);
INSERT INTO O_TFR
	VALUES (8840,
	8623,
	'actionFilter',
	'',
	316,
	1,
	'if(param.name == "can")
  satisfiesWithImportedComponent = false;
  // see if this requirement is satisfied with
  // a provision that shares a satisfaction
  // with an imported requirement, or if this
  // requirement is satisfied with an imported
  // provision
  select many satisfactions related by self->C_SF[R4002];
  for each satisfaction in satisfactions
    if(not satisfaction.satisfiesWithImportedReq())
      // this is the satisfaction at the definition
      // first see if the satisfaction is with an imported
      // provision
      if(satisfaction.satisfiesWithImportedPro())
        satisfiesWithImportedComponent = true;
        break;
      else
        // otherwise see if the provision satisfies
        // any imported requirements
        select many proSatisfactions related by satisfaction->C_P[R4002]->C_SF[R4002];
        for each proSat in proSatisfactions
          if(not proSat.satisfiesWithImportedPro())
            // this is a satisfaction which is at the provision
            // definition
            if(proSat.satisfiesWithImportedReq())
              satisfiesWithImportedComponent = true;
              break;
            end if;
          end if;
        end for;
        if(satisfiesWithImportedComponent)
          break;
        end if;
      end if;
      break;
    end if;
  end for;
  select one ir related by self->C_IR[R4009];
  select one packageableElem related by ir->C_PO[R4016]->C_C[R4010]->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = not_empty package or not_empty component;
  
  if((param.value == "formalize spec pkg") or (param.value == "formalize generic pkg"))
    if ((param.value == "formalize spec pkg") and (isInGenericPackage))
      return false;
    end if;
    if ((param.value == "formalize generic pkg") and (not isInGenericPackage))
      return false;
    end if;
    if(satisfiesWithImportedComponent)
      return false;
    end if;
    return ir.canFormalizeAgainstAnyInterface();
  elif(param.value == "unformalize")
    if(satisfiesWithImportedComponent)
      return false;
    end if;
    select one interface related by self->C_IR[R4009]->C_I[R4012];
    if(not_empty interface)
      return true;
    end if;
  elif(param.value == "dissatisfy")
    select any satisfaction related by self->C_SF[R4002];
    if not_empty satisfaction
      return true;
    end if;
  end if;
end if;
return false;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (8841,
	8840,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (8842,
	8840,
	'value',
	322,
	0,
	'',
	8841,
	'');
INSERT INTO O_TFR
	VALUES (8829,
	8623,
	'formalize',
	'',
	19,
	1,
	'select one ir related by self->C_IR[R4009];
ir.formalize(id:param.Id, formalizeOther:param.formalizePro);',
	1,
	'',
	8838);
INSERT INTO O_TPARM
	VALUES (8843,
	8829,
	'Id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (8844,
	8829,
	'formalizePro',
	316,
	0,
	'',
	8843,
	'');
INSERT INTO O_TFR
	VALUES (8845,
	8623,
	'unformalize',
	'',
	19,
	1,
	'select one ir related by self->C_IR[R4009];
ir.unformalize(unformalizeOther:param.unformalizePro);',
	1,
	'',
	8846);
INSERT INTO O_TPARM
	VALUES (8847,
	8845,
	'unformalizePro',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8848,
	8623,
	'isFormal',
	'',
	316,
	1,
	'select one ir related by self->C_IR[R4009];
// the interface reference may be empty during
// a dispose
if(not_empty ir)
  return ir.isFormal();
end if;
return false;',
	1,
	'',
	8849);
INSERT INTO O_TFR
	VALUES (8850,
	8623,
	'canRename',
	'',
	316,
	1,
	'return not self.isFormal();',
	1,
	'',
	8840);
INSERT INTO O_TFR
	VALUES (8849,
	8623,
	'initialize',
	'',
	19,
	1,
	'self.InformalName = "Unnamed Interface";',
	1,
	'',
	8851);
INSERT INTO O_TFR
	VALUES (8836,
	8623,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Requirement_Id;',
	1,
	'',
	8828);
INSERT INTO O_TFR
	VALUES (8839,
	8623,
	'canUseInterfacesInPackage',
	'',
	316,
	1,
	'select one ir related by self->C_IR[R4009];
return ir.canUseInterfacesInPackage(Id:param.Id);',
	1,
	'',
	8850);
INSERT INTO O_TPARM
	VALUES (8852,
	8839,
	'Id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8851,
	8623,
	'hasAvailableSignalsFor',
	'',
	316,
	1,
	'// Requirement::hasAvailableSignalsFor()
select many signals related by self->SPR_REP[R4500]->SPR_RS[R4502];
for each signal in signals
  if signal.isAvailableForAllocationTo(transition_id:param.transition_id)
    return true;
  end if;
end for;
return false;',
	1,
	'',
	8835);
INSERT INTO O_TPARM
	VALUES (8853,
	8851,
	'transition_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8854,
	8623,
	'linkConnector',
	'',
	316,
	1,
	'if(self.canLinkConnector(to:param.to))
  isLinked = false;
  select one component related by self->C_IR[R4009]->C_PO[R4016]->C_C[R4010];
  if (param.to != GD::NULL_UNIQUE_ID())
    select any provision from instances of C_P where(selected.Provision_Id == param.to);
    if (not_empty provision)
      isLinked = component.initializeRequirement(requirement_id:self.Requirement_Id, provision_id:provision.Provision_Id, proceed:true);
    else
      select any importedRef from instances of CL_IIR where (selected.Id == param.to);
      if (not_empty importedRef)
        isLinked = component.initializeRequirement(requirement_id:self.Requirement_Id, provision_id:importedRef.Id, proceed:true);
      end if;
    end if;    
  end if;
  return isLinked;
end if;
return false;
',
	1,
	'',
	8848);
INSERT INTO O_TPARM
	VALUES (8855,
	8854,
	'to',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8856,
	8623,
	'getComponentId',
	'',
	296,
	1,
	'select one interfaceRef related by self->C_IR[R4009];
return interfaceRef.getComponentId();',
	1,
	'',
	8845);
INSERT INTO O_TFR
	VALUES (8846,
	8623,
	'dissatisfy',
	'',
	19,
	1,
	'select many sats related by self->C_SF[R4002];
for each sat in sats
  select one provision related by sat->C_P[R4002];
  unrelate self from provision across R4002 using sat;
  sat.dispose();
end for;',
	1,
	'',
	8854);
INSERT INTO O_TFR
	VALUES (8857,
	8623,
	'getSatisfactionCount',
	'',
	298,
	1,
	'select many satisfactions related by self->C_SF[R4002];
return cardinality satisfactions;',
	1,
	'',
	8856);
INSERT INTO O_TPARM
	VALUES (8858,
	8857,
	'filterDelegations',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8859,
	8623,
	'canLinkConnector',
	'',
	316,
	1,
	'isLinked = false;
select one component related by self->C_IR[R4009]->C_PO[R4016]->C_C[R4010];
if (param.to != GD::NULL_UNIQUE_ID())
  select any provision from instances of C_P where(selected.Provision_Id == param.to);
  if (not_empty provision)
    isLinked = component.initializeRequirement(requirement_id:self.Requirement_Id, provision_id:provision.Provision_Id, proceed:false);
  else
    select any importedRef from instances of CL_IIR where (selected.Id == param.to);
    if (not_empty importedRef)
      isLinked = component.initializeRequirement(requirement_id:self.Requirement_Id, provision_id:importedRef.Id, proceed:false);
    end if;
  end if;    
end if;  
return isLinked;
',
	1,
	'',
	8857);
INSERT INTO O_TPARM
	VALUES (8860,
	8859,
	'to',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8861,
	8623,
	'get_connector_tooltip',
	'',
	322,
	1,
	'/**
 *  For the start of the provision we want to return the associated
 *  port name
 */
if(param.end == End::Start)
  select one port related by self->C_IR[R4009]->C_PO[R4016];
  if(not_empty port)
    return port.Name;
  end if;
end if;
return "";',
	1,
	'',
	8859);
INSERT INTO O_TPARM
	VALUES (8862,
	8861,
	'end',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8863,
	8623,
	'convertToInstance',
	'Translate:native',
	317,
	1,
	'return this;',
	0,
	'',
	8861);
INSERT INTO O_TFR
	VALUES (8864,
	8623,
	'getConfigurationInheritanceElementId',
	'',
	317,
	1,
	'select one interface related by self->C_IR[R4009]->C_I[R4012];
if(not_empty interface)
  return interface.convertToInstance();
end if;
return self.convertToInstance();',
	1,
	'',
	8863);
INSERT INTO O_TFR
	VALUES (8865,
	8623,
	'isSynchronized',
	'',
	316,
	1,
	'select one iface related by self->C_IR[R4009];
if(not_empty iface)
  return iface.isSynchronized();
end if;
return true;',
	1,
	'',
	8864);
INSERT INTO O_TFR
	VALUES (8866,
	8623,
	'collectReferencesForSynchronization',
	'',
	19,
	1,
	'/*
 *  Collect all local operation or signals
 */
select many ros related by self->SPR_REP[R4500]->SPR_RO[R4502];
for each ro in ros
  Util::addElementToList(elementList: param.referenceList,
                                                element:ro.convertToInstance());
end for;
select many rss related by self->SPR_REP[R4500]->SPR_RS[R4502];
for each rs in rss
  Util::addElementToList(elementList: param.referenceList,
                                                element:rs.convertToInstance());
end for;',
	1,
	'',
	8865);
INSERT INTO O_TPARM
	VALUES (8867,
	8866,
	'referenceList',
	317,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (8868,
	8866,
	'syncType',
	3500,
	0,
	'',
	8867,
	'');
INSERT INTO O_TFR
	VALUES (8869,
	8623,
	'synchronize',
	'',
	19,
	1,
	'/**
 *  Synchronize this reference with the associated interface
 */
select one interfaceRef related by self->C_IR[R4009];
if(not_empty interfaceRef)
  interfaceRef.synchronize();
end if;',
	1,
	'',
	8866);
INSERT INTO O_TFR
	VALUES (8870,
	8623,
	'collectChanges',
	'',
	19,
	1,
	'/**
 *  Collect unformlization change and additions in the interface
 */
if(not self.isSynchronized())
  select one interface related by self->C_IR[R4009]->C_I[R4012];
  isTornDown = Util::isProxy(element:interface.convertToInstance());
  if(not isTornDown)
    select one pkg related by interface->IP_IP[R4303];
    select one pe related by interface->PE_PE[R8001];
    if(empty pkg and empty pe)
      isTornDown = true;
    end if;
  end if; 
  if(isTornDown)
    Util::createElementChange(changeList:param.changeList,
                        elementChanged:self.convertToInstance(), isRemoval:true,
                                                   changeLabel:"unformalized");
  else
    select many eps related by interface->C_EP[R4003];
    for each ep in eps
      select any rep related by self->SPR_REP[R4500]
                                where (selected.ExecutableProperty_Id == ep.Id);
      if(empty rep)
        // create a change
        Util::createElementChange(changeList:param.changeList, elementChanged:
                                      self.convertToInstance(), isRemoval:false,
                                                changeLabel:ep.Name + " added");
      end if;
    end for; 
  end if;
end if;',
	1,
	'',
	8869);
INSERT INTO O_TPARM
	VALUES (8871,
	8870,
	'changeList',
	317,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8872,
	8623,
	'getCachedReversePathFromComponent',
	'Translate:native',
	322,
	1,
	'	return m_reversepathfromcomponent;',
	0,
	'',
	8870);
INSERT INTO O_TFR
	VALUES (8873,
	8623,
	'setCachedReversePathFromComponent',
	'Translate:native',
	19,
	1,
	'	m_reversepathfromcomponent = p_Value;',
	0,
	'',
	8872);
INSERT INTO O_TPARM
	VALUES (8874,
	8873,
	'value',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8875,
	8623,
	'getCachedName',
	'Translate:native',
	322,
	1,
	'	return m_name;',
	0,
	'',
	8873);
INSERT INTO O_TFR
	VALUES (8876,
	8623,
	'setCachedName',
	'Translate:native',
	19,
	1,
	'	m_name = p_Value;',
	0,
	'',
	8875);
INSERT INTO O_TPARM
	VALUES (8877,
	8876,
	'value',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_DBATTR
	VALUES (8878,
	8623,
	'result = "";
select one ir related by self->C_IR[R4009];
result = self.InformalName;
if (self.isFormal())
  result = ir.interfaceName();
  self.setCachedName(value:result);
end if;
// if the interface reference is not present
// we are most likely dealing with comparison
// of satisfactions
// in any case return the cached value
if(empty ir)
  result = self.getCachedName();
end if;
self.Name = result;',
	1);
INSERT INTO O_BATTR
	VALUES (8878,
	8623);
INSERT INTO O_ATTR
	VALUES (8878,
	8623,
	8625,
	'Name',
	'User_Visible:false',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8879,
	8623);
INSERT INTO O_BATTR
	VALUES (8879,
	8623);
INSERT INTO O_ATTR
	VALUES (8879,
	8623,
	8878,
	'Descrip',
	'Full Name: Interface Description
Description: A textual description of this required interface.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8880,
	8623);
INSERT INTO O_BATTR
	VALUES (8880,
	8623);
INSERT INTO O_ATTR
	VALUES (8880,
	8623,
	8879,
	'InformalName',
	'Full Name: Informal Interface Name',
	'',
	'InformalName',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (8623,
	8648,
	0,
	8650,
	8647,
	8651,
	8649,
	8625,
	8881,
	0,
	0,
	'',
	'Interface Reference',
	'Id',
	'R4009');
INSERT INTO O_RATTR
	VALUES (8625,
	8623,
	8650,
	8648,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (8625,
	8623,
	0,
	'Requirement_Id',
	'',
	'Requirement_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (8882,
	8623,
	'select one port related by self->C_IR[R4009]->C_PO[R4016];
select one component related by port->C_C[R4010];
if(empty component or empty port)
  result = self.getCachedReversePathFromComponent();
  if(result == "")
    result = self.Name;
  end if;
  self.reversePathFromComponent = result;
else
  select one component related by port->C_C[R4010];
  result = component.Name + "::" + port.Name + "::" + self.Name;
  self.setCachedReversePathFromComponent(value: result);
  self.reversePathFromComponent = result;
end if;',
	1);
INSERT INTO O_BATTR
	VALUES (8882,
	8623);
INSERT INTO O_ATTR
	VALUES (8882,
	8623,
	8880,
	'reversePathFromComponent',
	'User_Visible:false',
	'',
	'reversePathFromComponent',
	0,
	322,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	8623);
INSERT INTO O_OIDA
	VALUES (8625,
	8623,
	0,
	'Requirement_Id');
INSERT INTO O_ID
	VALUES (1,
	8623);
INSERT INTO O_ID
	VALUES (2,
	8623);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (8626,
	'Provision',
	4002,
	'C_P',
	'Provisions are used to represent provided interfaces on a Component Diagram.
When they are formal, that is related to a defined interface on an interface
diagram, an association is setup between the component that provides the
interface and any number of components that require the same interface.',
	8619);
INSERT INTO O_TFR
	VALUES (8883,
	8626,
	'get_connector_text',
	'',
	322,
	1,
	'if(param.at == End::Middle)
  return self.Name;
elif(param.at == End::Start_Fixed)
  select one port related by self->C_IR[R4009]->C_PO[R4016];
  if(not_empty port)
    if(not port.DoNotShowPortOnCanvas)
      return port.getPortText();
    end if;
  end if;
end if;
return "";
',
	1,
	'',
	8884);
INSERT INTO O_TPARM
	VALUES (8885,
	8883,
	'Obj_ID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (8886,
	8883,
	'Obj_TypeIsImported',
	316,
	0,
	'',
	8885,
	'');
INSERT INTO O_TPARM
	VALUES (8887,
	8883,
	'at',
	880,
	0,
	'',
	8886,
	'');
INSERT INTO O_TPARM
	VALUES (8888,
	8883,
	'parent_ID',
	296,
	0,
	'',
	8887,
	'');
INSERT INTO O_TFR
	VALUES (8889,
	8626,
	'get_style',
	'',
	784,
	1,
	'if(param.at == End::End)
  return Style::Circle;
elif(param.at == End::Start)
  // if the port wants to show
  // draw a small square at the
  // start of this provision
  select one port related by self->C_IR[R4009]->C_PO[R4016];
  // this can be null during auto-reconcilation
  if(not_empty port)
    if(not port.DoNotShowPortOnCanvas)
      select one interface related by self->C_IR[R4009]->C_I[R4012];
      if(not_empty interface)
        clientServer = interface.hasEPWithDirection(
                                       direction:IFDirectionType::ClientServer);
        serverClient = interface.hasEPWithDirection(
                                       direction:IFDirectionType::ServerClient);
        if(clientServer and serverClient)
          return Style::BoxArrowInOut;
        end if;
        if(clientServer)
          return Style::BoxArrowIn;
        end if;
        if(serverClient)
          return Style::BoxArrowOut;
        end if;
      end if;
      return Style::FilledSquare;
    end if;
  end if;
end if;
return Style::None;',
	1,
	'',
	8890);
INSERT INTO O_TPARM
	VALUES (8891,
	8889,
	'at',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8892,
	8626,
	'dispose',
	'',
	19,
	1,
	'self.dissatisfy();
select one iref related by self->C_IR[R4009];
if(not_empty iref)
  unrelate self from iref across R4009;
  iref.dispose();
end if;
select many peps related by self->SPR_PEP[R4501];
for each pep in peps
  select one ep related by pep->C_EP[R4501];
  unrelate self from ep across R4501 using pep;
  pep.dispose();
end for;
delete object instance self;',
	1,
	'',
	8893);
INSERT INTO O_TFR
	VALUES (8894,
	8626,
	'actionFilter',
	'',
	316,
	1,
	'if(param.name == "can")
  satisfiesWithImportedComponent = false;
  // see if this provision satisfies
  // an imported requirement
  select many satisfactions related by self->C_SF[R4002];
  for each satisfaction in satisfactions
    if(not satisfaction.satisfiesWithImportedPro())
      // this is a satisfaction at the definition
      if(satisfaction.satisfiesWithImportedReq())
        satisfiesWithImportedComponent = true;
        break;
      end if;
    end if;
  end for;
  select one ir related by self->C_IR[R4009];
  select one packageableElem related by ir->C_PO[R4016]->C_C[R4010]->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = not_empty package or not_empty component;
  
  if(param.value == "formalize spec pkg") or (param.value == "formalize generic pkg")
    if (param.value == "formalize spec pkg") and (isInGenericPackage)
      return false;
    end if;
    if (param.value == "formalize generic pkg") and (not isInGenericPackage)
      return false;
    end if;
    
    if(satisfiesWithImportedComponent)
      return false;
    end if;
    // ask the interface reference if there 
    // are any possible candidates
    return ir.canFormalizeAgainstAnyInterface();
  elif(param.value == "unformalize")
    if(satisfiesWithImportedComponent)
      return false;
    end if;
    select one interface related by self->C_IR[R4009]->C_I[R4012];
    if(not_empty interface)
      return true;
    end if;
  elif(param.value == "dissatisfy")
    select any satisfaction related by self->C_SF[R4002];
    if not_empty satisfaction
      return true;
    end if;
  end if;
end if;
return false;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (8895,
	8894,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (8896,
	8894,
	'value',
	322,
	0,
	'',
	8895,
	'');
INSERT INTO O_TFR
	VALUES (8897,
	8626,
	'formalize',
	'',
	19,
	1,
	'select one ir related by self->C_IR[R4009];
ir.formalize(id:param.Id, formalizeOther:param.formalizeReq);',
	1,
	'',
	8892);
INSERT INTO O_TPARM
	VALUES (8898,
	8897,
	'Id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (8899,
	8897,
	'formalizeReq',
	316,
	0,
	'',
	8898,
	'');
INSERT INTO O_TFR
	VALUES (8900,
	8626,
	'isFormal',
	'',
	316,
	1,
	'select one ir related by self->C_IR[R4009];
// the interface reference may be empty during
// a dispose
if(not_empty ir)
  return ir.isFormal();
end if;
return false;',
	1,
	'',
	8901);
INSERT INTO O_TFR
	VALUES (8902,
	8626,
	'unformalize',
	'',
	19,
	1,
	'select one ir related by self->C_IR[R4009];
ir.unformalize(unformalizeOther:param.unformalizeReq);',
	1,
	'',
	8903);
INSERT INTO O_TPARM
	VALUES (8904,
	8902,
	'unformalizeReq',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8905,
	8626,
	'canRename',
	'',
	316,
	1,
	'return not self.isFormal();',
	1,
	'',
	8894);
INSERT INTO O_TFR
	VALUES (8901,
	8626,
	'initialize',
	'',
	19,
	1,
	'self.InformalName = "Unnamed Interface";',
	1,
	'',
	8906);
INSERT INTO O_TFR
	VALUES (8890,
	8626,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Provision_Id;',
	1,
	'',
	8883);
INSERT INTO O_TFR
	VALUES (8893,
	8626,
	'canUseInterfacesInPackage',
	'',
	316,
	1,
	'select one ir related by self->C_IR[R4009];
return ir.canUseInterfacesInPackage(Id:param.Id);',
	1,
	'',
	8905);
INSERT INTO O_TPARM
	VALUES (8907,
	8893,
	'Id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8906,
	8626,
	'hasAvailableSignalsFor',
	'',
	316,
	1,
	'// Provision::hasAvailableSignalsFor()
select many signals related by self->SPR_PEP[R4501]->SPR_PS[R4503];
for each signal in signals
  if signal.isAvailableForAllocationTo(transition_id:param.transition_id)
    return true;
  end if;
end for;
return false;',
	1,
	'',
	8889);
INSERT INTO O_TPARM
	VALUES (8908,
	8906,
	'transition_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8909,
	8626,
	'linkConnector',
	'',
	316,
	1,
	'if(self.canLinkConnector(to:param.to))
  isLinked = false;
  select one component related by self->C_IR[R4009]->C_PO[R4016]->C_C[R4010];
  if (param.to != GD::NULL_UNIQUE_ID())
    select any requirement from instances of C_R where(selected.Requirement_Id == param.to);
    if (not_empty requirement)
      isLinked = component.initializeProvision(requirement_id:requirement.Requirement_Id, provision_id:self.Provision_Id, proceed:true);
    else
      select any importedRef from instances of CL_IIR where (selected.Id == param.to);
      if (not_empty importedRef)
        isLinked = component.initializeProvision(requirement_id:importedRef.Id, provision_id:self.Provision_Id, proceed:true);
      end if;
    end if;    
  end if;
  return isLinked;
end if;
return false;
',
	1,
	'',
	8900);
INSERT INTO O_TPARM
	VALUES (8910,
	8909,
	'to',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8884,
	8626,
	'getComponentId',
	'',
	296,
	1,
	'select one interfaceRef related by self->C_IR[R4009];
return interfaceRef.getComponentId();',
	1,
	'',
	8897);
INSERT INTO O_TFR
	VALUES (8903,
	8626,
	'dissatisfy',
	'',
	19,
	1,
	'select many sats related by self->C_SF[R4002];
for each sat in sats
  select one requirement related by sat->C_R[R4002];
  unrelate self from requirement across R4002 using sat;
  sat.dispose();
end for;',
	1,
	'',
	8909);
INSERT INTO O_TFR
	VALUES (8911,
	8626,
	'getSatisfactionCount',
	'',
	298,
	1,
	'select many satisfactions related by self->C_SF[R4002];
return cardinality satisfactions;',
	1,
	'',
	8902);
INSERT INTO O_TPARM
	VALUES (8912,
	8911,
	'filterDelegations',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8913,
	8626,
	'canLinkConnector',
	'',
	316,
	1,
	'isLinked = false;
select one component related by self->C_IR[R4009]->C_PO[R4016]->C_C[R4010];
if (param.to != GD::NULL_UNIQUE_ID())
  select any requirement from instances of C_R where(selected.Requirement_Id == param.to);
  if (not_empty requirement)
    isLinked = component.initializeProvision(requirement_id:requirement.Requirement_Id, provision_id:self.Provision_Id, proceed:false);
  else
    select any importedRef from instances of CL_IIR where (selected.Id == param.to);
    if (not_empty importedRef)
      isLinked = component.initializeProvision(requirement_id:importedRef.Id, provision_id:self.Provision_Id, proceed:false);
    end if;
  end if;    
end if;
return isLinked;
',
	1,
	'',
	8911);
INSERT INTO O_TPARM
	VALUES (8914,
	8913,
	'to',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8915,
	8626,
	'get_connector_tooltip',
	'',
	322,
	1,
	'/**
 *  For the start of the provision we want to return the associated
 *  port name
 */
if(param.end == End::Start)
  select one port related by self->C_IR[R4009]->C_PO[R4016];
  if(not_empty port)
    return port.Name;
  end if;
end if;
return "";',
	1,
	'',
	8913);
INSERT INTO O_TPARM
	VALUES (8916,
	8915,
	'end',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8917,
	8626,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'return this;',
	0,
	'',
	8915);
INSERT INTO O_TFR
	VALUES (8918,
	8626,
	'getConfigurationInheritanceElementId',
	'',
	317,
	1,
	'select one interface related by self->C_IR[R4009]->C_I[R4012];
if(not_empty interface)
  return interface.convertToInstance();
end if;
return self.convertToInstance();',
	1,
	'',
	8917);
INSERT INTO O_TFR
	VALUES (8919,
	8626,
	'isSynchronized',
	'',
	316,
	1,
	'select one iface related by self->C_IR[R4009];
if(not_empty iface)
  return iface.isSynchronized();
end if;
return true;',
	1,
	'',
	8918);
INSERT INTO O_TFR
	VALUES (8920,
	8626,
	'collectReferencesForSynchronization',
	'',
	19,
	1,
	'/*
 *  Collect all local operation or signals
 */
select many pos related by self->SPR_PEP[R4501]->SPR_PO[R4503];
for each po in pos
  Util::addElementToList(elementList: param.referenceList,
                                                element:po.convertToInstance());
end for;
select many pss related by self->SPR_PEP[R4501]->SPR_PS[R4503];
for each ps in pss
  Util::addElementToList(elementList: param.referenceList,
                                                element:ps.convertToInstance());
end for;',
	1,
	'',
	8919);
INSERT INTO O_TPARM
	VALUES (8921,
	8920,
	'referenceList',
	317,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (8922,
	8920,
	'syncType',
	3500,
	0,
	'',
	8921,
	'');
INSERT INTO O_TFR
	VALUES (8923,
	8626,
	'synchronize',
	'',
	19,
	1,
	'/**
 *  Synchronize this reference with the associated interface
 */
select one interfaceRef related by self->C_IR[R4009];
if(not_empty interfaceRef)
  interfaceRef.synchronize();
end if;',
	1,
	'',
	8920);
INSERT INTO O_TFR
	VALUES (8924,
	8626,
	'collectChanges',
	'',
	19,
	1,
	'/**
 *  Collect unformlization change and additions in the interface
 */
if(not self.isSynchronized())
  select one interface related by self->C_IR[R4009]->C_I[R4012];
  isTornDown = Util::isProxy(element:interface.convertToInstance());
  if(not isTornDown)
    select one pkg related by interface->IP_IP[R4303];
    select one pe related by interface->PE_PE[R8001];
    if(empty pkg and empty pe)
      isTornDown = true;
    end if;
  end if; 
  if(isTornDown)
    Util::createElementChange(changeList:param.changeList,
                        elementChanged:self.convertToInstance(), isRemoval:true,
                                                   changeLabel:"unformalized");
  else
    select many eps related by interface->C_EP[R4003];
    for each ep in eps
      select any pep related by self->SPR_PEP[R4501]
                                where (selected.ExecutableProperty_Id == ep.Id);
      if(empty pep)
        // create a change
        Util::createElementChange(changeList:param.changeList, elementChanged:
                                      self.convertToInstance(), isRemoval:false,
                                                changeLabel:ep.Name + " added");
      end if;
    end for; 
  end if;
end if;',
	1,
	'',
	8923);
INSERT INTO O_TPARM
	VALUES (8925,
	8924,
	'changeList',
	317,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8926,
	8626,
	'getCachedPathFromComponent',
	'Translate:native',
	322,
	1,
	'	return m_pathfromcomponent;',
	0,
	'',
	8924);
INSERT INTO O_TFR
	VALUES (8927,
	8626,
	'setCachedPathFromComponent',
	'Translate:native',
	19,
	1,
	'	m_pathfromcomponent = p_Value;',
	0,
	'',
	8926);
INSERT INTO O_TPARM
	VALUES (8928,
	8927,
	'value',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8929,
	8626,
	'getCachedName',
	'Translate:native',
	322,
	1,
	'	return m_name;',
	0,
	'',
	8927);
INSERT INTO O_TFR
	VALUES (8930,
	8626,
	'setCachedName',
	'Translate:native',
	19,
	1,
	'	m_name = p_Value;',
	0,
	'',
	8929);
INSERT INTO O_TPARM
	VALUES (8931,
	8930,
	'value',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_DBATTR
	VALUES (8932,
	8626,
	'result = "";
select one ir related by self->C_IR[R4009];
result = self.InformalName;
if (self.isFormal())
  result = ir.interfaceName();
  self.setCachedName(value:result);
end if;
// if the interface reference is not present
// we are most likely dealing with comparison
// of satisfactions
// in any case return the cached value
if(empty ir)
  result = self.getCachedName();
end if;
self.Name = result;',
	1);
INSERT INTO O_BATTR
	VALUES (8932,
	8626);
INSERT INTO O_ATTR
	VALUES (8932,
	8626,
	8628,
	'Name',
	'User_Visible:false',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8933,
	8626);
INSERT INTO O_BATTR
	VALUES (8933,
	8626);
INSERT INTO O_ATTR
	VALUES (8933,
	8626,
	8934,
	'Descrip',
	'Full Name: Interface Description
Description: A textual description of this provided interface.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8934,
	8626);
INSERT INTO O_BATTR
	VALUES (8934,
	8626);
INSERT INTO O_ATTR
	VALUES (8934,
	8626,
	8932,
	'InformalName',
	'Full Name: Informal Interface Name',
	'',
	'InformalName',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (8626,
	8648,
	0,
	8650,
	8647,
	8652,
	8649,
	8628,
	8935,
	0,
	0,
	'',
	'Interface Reference',
	'Id',
	'R4009');
INSERT INTO O_RATTR
	VALUES (8628,
	8626,
	8650,
	8648,
	0,
	'Id');
INSERT INTO O_ATTR
	VALUES (8628,
	8626,
	0,
	'Provision_Id',
	'',
	'Provision_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (8936,
	8626,
	'select one port related by self->C_IR[R4009]->C_PO[R4016];
select one component related by port->C_C[R4010];
if(empty component or empty port)
  result = self.getCachedPathFromComponent();
  if(result == "")
    result = self.Name;
  end if;
  self.pathFromComponent = result;
else
  result = component.Name + "::" + port.Name + "::" + self.Name;
  self.setCachedPathFromComponent(value: result);
  self.pathFromComponent = result;
end if;',
	1);
INSERT INTO O_BATTR
	VALUES (8936,
	8626);
INSERT INTO O_ATTR
	VALUES (8936,
	8626,
	8933,
	'pathFromComponent',
	'User_Visible:false',
	'',
	'pathFromComponent',
	0,
	322,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	8626);
INSERT INTO O_OIDA
	VALUES (8628,
	8626,
	0,
	'Provision_Id');
INSERT INTO O_ID
	VALUES (1,
	8626);
INSERT INTO O_ID
	VALUES (2,
	8626);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (57,
	'Property Parameter',
	4009,
	'C_PP',
	'',
	8619);
INSERT INTO O_TFR
	VALUES (8937,
	57,
	'initialize',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one system related by self->C_EP[R4006]->C_I[R4003]->IP_IP[R4303]->S_SYS[R4304];

select one packageableElem related by self->C_EP[R4006]->C_I[R4003]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;

select one ep related by self->C_EP[R4006];
ep.addPropertyParameterToOrder(id:self.PP_Id);
if (isInGenericPackage)
  if (empty package)
    rootCompIdInPkg = component.getRootComponentId();
    select any rootComponent from instances of C_C where (selected.Id == rootCompIdInPkg);
    select one system related by rootComponent->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405];
  else
    select one system related by package->S_SYS[R1405];  
  end if;
end if;
def_dt_id = GD::NULL_UNIQUE_ID();
if not_empty system
  def_dt_id = system.getCoreTypeId(name:"integer");
end if;
select any pe from instances of PE_PE where selected.Element_ID == def_dt_id;
select one def_dt related by pe->S_DT[R8001]; 
relate self to def_dt across R4007;
name = ::getUniqueInitialName( 
    instance: self.convertToInstance(),
    candidateName: "Unnamed Parameter");
success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:true);    
if ( success!="") 
 self.Name=success;
else 
 self.dispose();
end if;       ',
	1,
	'',
	8938);
INSERT INTO O_TFR
	VALUES (8939,
	57,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'return this;',
	0,
	'',
	8940);
INSERT INTO O_TFR
	VALUES (8941,
	57,
	'dispose',
	'',
	19,
	1,
	'select one dt related by self->S_DT[R4007];
unrelate self from dt across R4007;
select one ep related by self->C_EP[R4006];
if(not_empty ep)
  unrelate self from ep across R4006;
end if;
select one successor related by self->C_PP[R4021.''precedes''];
select one predecessor related by self->C_PP[R4021.''succeeds''];
if (not empty successor)
  unrelate self from successor across R4021.''precedes'';
end if;
if (not empty predecessor)
  unrelate self from predecessor across R4021.''succeeds'';
end if;
if (not_empty successor and not_empty predecessor)
  relate successor to predecessor across R4021.''succeeds'';
end if;
select many parmVals related by self->V_PVL[R843];
for each pvl in parmVals
  unrelate self from pvl across R843;
end for;
select many evtParmRefs related by self->V_EPR[R847];
for each evtParmRef in evtParmRefs
  evtParmRef.dispose();
end for;
select many dims related by self->S_DIM[R4017];
for each dim in dims
  unrelate self from dim across R4017;
  delete object instance dim;
end for;
select many evtDis related by self->I_DIV[R2956];
for each evtDi in evtDis
  evtDi.dispose();
end for;
select many participationArgs related by self->MSG_EPA[R1023];
for each pa in participationArgs
  unrelate self from pa across R1023;
  pa.dispose();
end for;
delete object instance self;',
	1,
	'',
	8939);
INSERT INTO O_TFR
	VALUES (8942,
	57,
	'isAllowedType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Property Parameter.isAllowedType()
select one packageableElem related by self->
                                          C_EP[R4006]->C_I[R4003]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;
if isInGenericPackage
  return packageableElem.isAllowedType(isReturnType:false,
                                                       typeName:param.typeName);
else
  select one system related by self->C_EP[R4006]->C_I[R4003]->IP_IP[R4303]->S_SYS[R4304];
  return Util::isAllowedParameterType( typeName: param.typeName, system:system.convertToInstance() );
end if;',
	1,
	'',
	8937);
INSERT INTO O_TPARM
	VALUES (8943,
	8942,
	'typeName',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8944,
	57,
	'resolveDatatype',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one dtProxy related by self->S_DT[R4007];
if(not_empty dtProxy and not Util::isProxy(element:self.convertToInstance()))
  name = dtProxy.Name;
  unrelate dtProxy from self across R4007;
  select one packageableElem related by self->C_EP[R4006]->C_I[R4003]
                                                                 ->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = not_empty package or not_empty component;
  if isInGenericPackage
    id = packageableElem.resolveDataTypeRelativeToSelf(default_name:"integer",
                                                            expected_name:name);
    select any resolvedDt related by package->PE_VIS[R8002]->
                           PE_PE[R8002]->S_DT[R8001] where selected.DT_ID == id;
    if (empty resolvedDt)
      select any resolvedDt related by component->PE_CVS[R8004]->
                           PE_PE[R8004]->S_DT[R8001] where selected.DT_ID == id;
    end if;	
    if not_empty resolvedDt
      relate resolvedDt to self across R4007;
    end if;
  else
    select one system related by self->C_EP[R4006]->C_I[R4003]->IP_IP[R4303]
                                                                 ->S_SYS[R4304];       
    r_dt_id = GD::NULL_UNIQUE_ID();
    if not_empty system
      r_dt_id = system.getCoreTypeId(name:name);
    end if;
    select any pe from instances of PE_PE where selected.Element_ID == r_dt_id;
    select one resolvedDT related by pe->S_DT[R8001];
    // if one was not resolved
    if(empty resolvedDT)
      // default back to integer type
      r_dt_id = GD::NULL_UNIQUE_ID();
      if not_empty system
        r_dt_id = system.getCoreTypeId(name:"integer");
      end if;
      select any pe from instances of PE_PE where selected.Element_ID == r_dt_id;
      select one resolvedDT related by pe->S_DT[R8001];
    end if;
    if(not_empty resolvedDT)
      relate resolvedDT to self across R4007;
    end if;
  end if;
end if;',
	1,
	'',
	8945);
INSERT INTO O_TFR
	VALUES (8946,
	57,
	'getDimensionsCnt',
	'',
	298,
	1,
	'select many dims related by self->S_DIM[R4017];
dimensions = cardinality dims;
return dimensions;
',
	1,
	'',
	8941);
INSERT INTO O_TFR
	VALUES (8945,
	57,
	'resizeDimensions',
	'',
	19,
	1,
	'// If the number of dimensions has increased then add dimensions
while (param.numDimensions > self.getDimensionsCnt())
  create object instance dim of S_DIM;
  dim.dimensionCount = self.getDimensionsCnt();
  relate dim to self across R4017;
end while;

// If the number of dimensions has decreased then remove dimensions
while (param.numDimensions < self.getDimensionsCnt())
  select any dim related by self->S_DIM[R4017] where (selected.dimensionCount == (self.getDimensionsCnt()-1));
  unrelate dim from self across R4017;
  delete object instance dim;
end while;

// Update the specific dimension that was passed-in if its elementCount has 
// changed.
if (param.numDimensions > 0) 
  select any dim related by self->S_DIM[R4017] where (selected.dimensionCount == param.dimension);
  if (dim.elementCount != param.elementCount)
    dim.elementCount = param.elementCount;
  end if;
end if;
',
	1,
	'',
	8947);
INSERT INTO O_TPARM
	VALUES (8948,
	8945,
	'dimension',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (8949,
	8945,
	'numDimensions',
	298,
	0,
	'',
	8950,
	'');
INSERT INTO O_TPARM
	VALUES (8950,
	8945,
	'elementCount',
	298,
	0,
	'',
	8948,
	'');
INSERT INTO O_TFR
	VALUES (8938,
	57,
	'getValue',
	'',
	317,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return GD::NULL_INSTANCE(); ',
	1,
	'',
	8946);
INSERT INTO O_TPARM
	VALUES (8951,
	8938,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8952,
	57,
	'setValue',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	8944);
INSERT INTO O_TPARM
	VALUES (8953,
	8952,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (8954,
	8952,
	'value',
	317,
	0,
	'',
	8953,
	'');
INSERT INTO O_TPARM
	VALUES (8955,
	8952,
	'member_id',
	296,
	0,
	'',
	8954,
	'');
INSERT INTO O_TFR
	VALUES (8947,
	57,
	'moveUp',
	'',
	19,
	1,
	'::changeNotificationEnablement(enabled:false);
select one prev_attr related by self->C_PP[R4021.''succeeds''];
select one prev_prev_attr related by prev_attr->C_PP[R4021.''succeeds''];
select one next_attr related by self->C_PP[R4021.''precedes''];

if ( not_empty prev_prev_attr )
  unrelate prev_attr from prev_prev_attr across R4021.''succeeds'';
end if;
if ( not_empty next_attr )
  unrelate next_attr from self across R4021.''succeeds'';
end if;
unrelate self from prev_attr across R4021.''succeeds'';

if ( not_empty prev_prev_attr )
  relate self to prev_prev_attr across R4021.''succeeds'';
end if;
// want to enable listeners at the last possible moment
if ( empty next_attr )
  ::changeNotificationEnablement(enabled:true);
end if;
relate prev_attr to self across R4021.''succeeds'';
if ( not_empty next_attr )
  ::changeNotificationEnablement(enabled:true);
  relate next_attr to prev_attr across R4021.''succeeds'';
end if;
',
	1,
	'',
	8956);
INSERT INTO O_TFR
	VALUES (8956,
	57,
	'moveDown',
	'',
	19,
	1,
	'::changeNotificationEnablement(enabled:false);
select one next_attr related by self->C_PP[R4021.''precedes''];
select one prev_attr related by self->C_PP[R4021.''succeeds''];
select one next_next_attr related by next_attr->C_PP[R4021.''precedes''];

if ( not_empty next_next_attr )
  unrelate next_next_attr from next_attr across R4021.''succeeds'';
end if;
if ( not_empty prev_attr )
  unrelate self from prev_attr across R4021.''succeeds'';
end if;
unrelate next_attr from self across R4021.''succeeds'';

if ( not_empty prev_attr )
  relate next_attr to prev_attr across R4021.''succeeds'';
end if;
   
// want to enable listeners at the last possible moment
if ( empty next_next_attr )
  ::changeNotificationEnablement(enabled:true);
end if;
relate self to next_attr across R4021.''succeeds'';
if ( not_empty next_next_attr )
  ::changeNotificationEnablement(enabled:true);
  relate next_next_attr to self across R4021.''succeeds'';
end if;
',
	1,
	'',
	8957);
INSERT INTO O_TFR
	VALUES (8958,
	57,
	'actionFilter',
	'',
	316,
	1,
	'if (param.name == "can" )
  if ( param.value == "move up" )
    select one prev_attr related by self->C_PP[R4021.''succeeds''];
    return not_empty prev_attr;
  elif ( param.value == "move down" )
    select one next_attr related by self->C_PP[R4021.''precedes''];
    return not_empty next_attr;
  end if;
end if;
return false;
',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (8959,
	8958,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (8960,
	8958,
	'value',
	322,
	0,
	'',
	8959,
	'');
INSERT INTO O_TFR
	VALUES (8961,
	57,
	'canReferToDataType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// select the dt
select one dt related by self->S_DT[R4007];
if(not_empty dt)
  select one packageableElem related by self->C_EP[R4006]->C_I[R4003]->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = not_empty package or not_empty component;

  if (isInGenericPackage)
    return packageableElem.canReferToDataType(dtID:dt.DT_ID, dtName: dt.Name);
  else
    // as long as the data type package
    // is not defined within a domain
    // then the dt is allowed
    select one dtPkg related by dt->S_DIP[R39]->S_DPK[R39];
    if(dtPkg.isDomainLevel())
      return false;
    end if;
    return true;
  end if;
end if;
return false;
',
	1,
	'',
	8958);
INSERT INTO O_TFR
	VALUES (8957,
	57,
	'isReferringToDefaultDataType',
	'',
	316,
	1,
	'select one dt related by self->S_DT[R4007];
elementType = Util::getSimpleClassName(element:self.convertToInstance());
if(dt.Name == S_DT::getDefaultDataTypeName(elementType:elementType))
  return true;
end if;
return false;
',
	1,
	'',
	8942);
INSERT INTO O_TFR
	VALUES (8940,
	57,
	'canUseDataType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Property Parameter.canUseDataType()
select one packageableElem related by self->
                                          C_EP[R4006]->C_I[R4003]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;
if isInGenericPackage
  // Find the previously created visibility list
  select any resultSet related by package->PE_SRS[R8005] where
        selected.Name == "" and selected.Type == ElementTypeConstants::DATATYPE;
  select any dt related by resultSet->PE_VIS[R8006]->
                     PE_PE[R8002]->S_DT[R8001] where selected.DT_ID == param.id;
  if not_empty component
    // Find the previously created visibility list
    select any compResultSet related by component->PE_CRS[R8007] where
        selected.Name == "" and selected.Type == ElementTypeConstants::DATATYPE;
    select any dt related by compResultSet->PE_CVS[R8008]->
                     PE_PE[R8004]->S_DT[R8001] where selected.DT_ID == param.id;
  end if;
  if(not_empty dt)
    if(self.isAllowedType(typeName:dt.Name))
      return true;
    end if;
  end if;
  return false;
else
  select one interface related by self->C_EP[R4006]->C_I[R4003];
  select one system related by interface->IP_IP[R4303]->S_SYS[R4304];
  select any dt related by system->SLD_SDINP[R4402]->S_DT[R4401]
                                             where (selected.DT_ID == param.id);
  if empty dt and not_empty system and system.useGlobals
    select any pe related by system->G_EIS[R9100]->PE_PE[R9100]
                                          where selected.Element_ID == param.id;
    select one dt related by pe->S_DT[R8001]; 
  end if;
  if(not_empty dt)
    // if the dt is at the system level and
    // is an allowed type it is usable 
    if(self.isAllowedType(typeName:dt.Name))
      return true;
    end if;
  end if;
  return false;
end if;',
	1,
	'',
	8961);
INSERT INTO O_TPARM
	VALUES (8962,
	8940,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (8963,
	57,
	'getPath',
	'',
	322,
	1,
	'select one exProperty related by self-> C_EP[R4006];
select one iface related by exProperty->C_I[R4003]; 
return iface.getPath(path:self.Name, includeSelf:true);


',
	1,
	'',
	8952);
INSERT INTO O_TFR
	VALUES (8964,
	57,
	'checkIntegrity',
	'',
	19,
	1,
	'/**
 *  Create an integrity issue if there are any other ports on this compoenent
 *  with a matching name
 */
select one executableProperty related by self->C_EP[R4006];
select one interface related by executableProperty->C_I[R4003];
select one package related by interface->PE_PE[R8001]->EP_PKG[R8000];
if(empty package)
  select one component related by interface->PE_PE[R8001]->C_C[R8003];
  if(not_empty component)
    pkgId = component.getPackageId();
    select any package from instances of EP_PKG
                                           where (selected.Package_ID == pkgId);
  end if;
end if;
select one system related by package->S_SYS[R1405];
sys_id = GD::NULL_UNIQUE_ID();
if(not_empty system)
  sys_id = system.Sys_ID;
end if;
select many parameters related by executableProperty->C_PP[R4006];
for each parameter in parameters
  if(parameter != self and parameter.Name == self.Name)
    MI_IM::createIssue(sys_id:sys_id, description:
           "Found another parameter under the same executable property with a" +
                                                          " matching name.",
                                       severity:Severity::Error, name:self.Name,
                       path:self.getPath(),
                              id:self.PP_Id, element:self.convertToInstance());
  end if;
end for;',
	1,
	'',
	8963);
INSERT INTO O_NBATTR
	VALUES (254,
	57);
INSERT INTO O_BATTR
	VALUES (254,
	57);
INSERT INTO O_ATTR
	VALUES (254,
	57,
	0,
	'PP_Id',
	'',
	'',
	'PP_Id',
	0,
	296,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8965,
	57);
INSERT INTO O_BATTR
	VALUES (8965,
	57);
INSERT INTO O_ATTR
	VALUES (8965,
	57,
	8966,
	'Name',
	'Full Name: Parameter Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8967,
	57);
INSERT INTO O_BATTR
	VALUES (8967,
	57);
INSERT INTO O_ATTR
	VALUES (8967,
	57,
	8965,
	'Descrip',
	'Full Name: Parameter Description
Description: A textual description of this parameter.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (57,
	3137,
	0,
	3136,
	8638,
	8640,
	8639,
	8968,
	8969,
	0,
	0,
	'',
	'Executable Property',
	'Id',
	'R4006.''parameterizes''');
INSERT INTO O_RATTR
	VALUES (8968,
	57,
	3136,
	3137,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (8968,
	57,
	254,
	'Signal_Id',
	'',
	'Signal_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8970,
	57);
INSERT INTO O_BATTR
	VALUES (8970,
	57);
INSERT INTO O_ATTR
	VALUES (8970,
	57,
	8967,
	'By_Ref',
	'Full Name: By Reference Indicator
Description: Indicates whether or not this parameter is passed by reference
Data Domain: 0 = passed by value, 1 = passed by reference
enum0: By Value
enum1: By Reference',
	'',
	'By_Ref',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8971,
	57);
INSERT INTO O_BATTR
	VALUES (8971,
	57);
INSERT INTO O_ATTR
	VALUES (8971,
	57,
	8970,
	'Dimensions',
	'Full Name: Array Dimensions',
	'',
	'Dimensions',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (57,
	57,
	0,
	254,
	8678,
	8680,
	8679,
	8972,
	8973,
	0,
	0,
	'',
	'Property Parameter',
	'PP_Id',
	'R4021.''succeeds''');
INSERT INTO O_RATTR
	VALUES (8972,
	57,
	254,
	57,
	1,
	'PP_Id');
INSERT INTO O_ATTR
	VALUES (8972,
	57,
	8971,
	'Previous_PP_Id',
	'',
	'Previous_',
	'PP_Id',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (57,
	32,
	0,
	156,
	8641,
	8642,
	8643,
	8966,
	8974,
	0,
	0,
	'',
	'Data Type',
	'DT_ID',
	'R4007.''is typed by''');
INSERT INTO O_RATTR
	VALUES (8966,
	57,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (8966,
	57,
	8968,
	'DT_ID',
	'',
	'',
	'Element_ID',
	2,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	57);
INSERT INTO O_OIDA
	VALUES (254,
	57,
	0,
	'PP_Id');
INSERT INTO O_ID
	VALUES (1,
	57);
INSERT INTO O_ID
	VALUES (2,
	57);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (8666,
	'Port',
	4013,
	'C_PO',
	'',
	8619);
INSERT INTO O_TFR
	VALUES (8975,
	8666,
	'dispose',
	'',
	19,
	1,
	'select many irs related by self->C_IR[R4016];
for each ir in irs
  unrelate self from ir across R4016;
  ir.dispose();
end for;
select one component related by self->C_C[R4010];
if(not_empty component)
  unrelate self from component across R4010;
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (8976,
	8666,
	'initialize',
	'',
	19,
	1,
	'self.DoNotShowPortOnCanvas = false;
select many ports related by self->C_C[R4010]->C_PO[R4010];
count = 1;
for each port in ports
  potentialName = "Port" + GD::int_to_string(value:count);
  select any otherPort related by self->C_C[R4010]->C_PO[R4010]
  			where (selected.Name == potentialName);
  if(empty otherPort)
    break;
  end if;
  count = count + 1;
end for;
self.Name = "Port" + GD::int_to_string(value:count);',
	1,
	'',
	8977);
INSERT INTO O_TFR
	VALUES (8977,
	8666,
	'getPortText',
	'',
	322,
	1,
	'// Always return an empty string for this bridge operation.  When the port
// name is displayed on the canvas, it makes looked cluttered.  However, we
// need the port name in ME.  Returning an empty string here instead of the 
// port name keeps the name off the canvas.
portName = "";
return portName;',
	1,
	'',
	8978);
INSERT INTO O_TFR
	VALUES (8979,
	8666,
	'manyMultAllowed',
	'',
	316,
	1,
	'return true;',
	1,
	'',
	8976);
INSERT INTO O_TFR
	VALUES (8978,
	8666,
	'getComponentId',
	'',
	296,
	1,
	'select one component related by self->C_C[R4010];
return component.Id;',
	1,
	'',
	8975);
INSERT INTO O_TFR
	VALUES (8980,
	8666,
	'collectReferencesForSynchronization',
	'',
	19,
	1,
	'/**
 *  Collect all children required for synchronization, this will be interface
 *  references
 */
if(param.syncType == SynchronizationType::Pull)
  // recursively call for all children
  select many interfaceReferences related by self->C_IR[R4016];
  for each interfaceReference in interfaceReferences
    interfaceReference.collectReferencesForSynchronization(
                   referenceList:param.referenceList, syncType: param.syncType);
  end for;
end if;',
	1,
	'',
	8979);
INSERT INTO O_TPARM
	VALUES (8981,
	8980,
	'referenceList',
	317,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (8982,
	8980,
	'syncType',
	3500,
	0,
	'',
	8981,
	'');
INSERT INTO O_TFR
	VALUES (8983,
	8666,
	'checkIntegrity',
	'',
	19,
	1,
	'/**
 *  Create an integrity issue if there are any other ports on this compoenent
 *  with a matching name
 */
select one component related by self->C_C[R4010];
pkgId = component.getPackageId();
select any package from instances of EP_PKG
                                           where (selected.Package_ID == pkgId);
select one system related by package->S_SYS[R1405];
sys_id = GD::NULL_UNIQUE_ID();
if(not_empty system)
  sys_id = system.Sys_ID;
end if;
select many ports related by component->C_PO[R4010];
for each port in ports
  if(port != self and port.Name == self.Name)
    MI_IM::createIssue(sys_id:sys_id, description:
                    "Found another port under the same component with a " +
                                                          "matching name.",
                                       severity:Severity::Error, name:self.Name,
                       path:component.getPath(path:self.Name, includeSelf:true),
                              id:self.Id, element:self.convertToInstance());
  end if;
end for;',
	1,
	'',
	8980);
INSERT INTO O_TFR
	VALUES (8984,
	8666,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.
Translate: native
',
	317,
	1,
	'// just return this instance as an Object
return this;
',
	0,
	'',
	8983);
INSERT INTO O_NBATTR
	VALUES (8985,
	8666);
INSERT INTO O_BATTR
	VALUES (8985,
	8666);
INSERT INTO O_ATTR
	VALUES (8985,
	8666,
	8986,
	'Name',
	'Full Name: Port Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8987,
	8666);
INSERT INTO O_BATTR
	VALUES (8987,
	8666);
INSERT INTO O_ATTR
	VALUES (8987,
	8666,
	8988,
	'DoNotShowPortOnCanvas',
	'This value is used to determine if port will be displayed or not.
Full Name: Hide Port Graphic',
	'',
	'DoNotShowPortOnCanvas',
	0,
	316,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8988,
	8666);
INSERT INTO O_BATTR
	VALUES (8988,
	8666);
INSERT INTO O_ATTR
	VALUES (8988,
	8666,
	8985,
	'Mult',
	'Full Name: Multiplicity
Description: Multiplicity of the port.  Indicates how many instances of the port may exist.
Data Domain: 0 = one, 1 = many
enum0: One
enum1: Many',
	'',
	'Mult',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8670,
	8666);
INSERT INTO O_BATTR
	VALUES (8670,
	8666);
INSERT INTO O_ATTR
	VALUES (8670,
	8666,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	296,
	'',
	'');
INSERT INTO O_REF
	VALUES (8666,
	709,
	0,
	762,
	8664,
	8667,
	8665,
	8986,
	8989,
	0,
	0,
	'',
	'Component',
	'Id',
	'R4010');
INSERT INTO O_RATTR
	VALUES (8986,
	8666,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (8986,
	8666,
	8670,
	'Component_Id',
	'',
	'Component_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	8666);
INSERT INTO O_OIDA
	VALUES (8670,
	8666,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	8666);
INSERT INTO O_ID
	VALUES (2,
	8666);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2990,
	'Interface Signal',
	4005,
	'C_AS',
	'',
	8619);
INSERT INTO O_TFR
	VALUES (8990,
	2990,
	'initialize',
	'',
	19,
	1,
	'select one iface related by self->C_EP[R4004]->C_I[R4003];
iface.addInterfaceSignalToOrder(id:self.Id);
name = "Unnamed Signal";
success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:true);    
if ( success!="") 
 self.Name=success;
else 
 self.dispose();
end if;       
direction=PREF::getString(name:"bridgepoint_prefs_message_direction");
if (direction == "from provider")
  self.Direction = IFDirectionType::ServerClient;
else  // if(direction == "to provider")
  self.Direction = IFDirectionType::ClientServer;
end if; 
//else
 // self.Direction=IFDirectionType::Bidirectional ;',
	1,
	'',
	8991);
INSERT INTO O_TFR
	VALUES (8992,
	2990,
	'newParameter',
	'',
	19,
	1,
	'create object instance parameter of C_PP;
select one ep related by self->C_EP[R4004];
relate ep to parameter across R4006;
parameter.initialize();
ep.createMessageArgumentsForParameter(id:parameter.PP_Id);
',
	1,
	'',
	8993);
INSERT INTO O_TFR
	VALUES (8991,
	2990,
	'dispose',
	'',
	19,
	1,
	'select one ep related by self->C_EP[R4004];
if(not_empty ep)
  ep.dispose();
end if;
select one successor related by self->C_AS[R4020.''precedes''];
select one predecessor related by self->C_AS[R4020.''succeeds''];
if (not empty successor)
  unrelate self from successor across R4020.''precedes'';
end if;
if (not empty predecessor)
  unrelate self from predecessor across R4020.''succeeds'';
end if;
if (not_empty successor and not_empty predecessor)
  relate successor to predecessor across R4020.''succeeds'';
end if;
select many msgs related by self->MSG_SIG[R1021]->MSG_AM[R1019]->MSG_M[R1018];
for each msg in msgs
  msg.dispose();
end for;
delete object instance self;',
	1,
	'',
	8994);
INSERT INTO O_TFR
	VALUES (8993,
	2990,
	'moveUp',
	'',
	19,
	1,
	'::changeNotificationEnablement(enabled:false);
select one prev_attr related by self->C_AS[R4020.''succeeds''];
select one prev_prev_attr related by prev_attr->C_AS[R4020.''succeeds''];
select one next_attr related by self->C_AS[R4020.''precedes''];

if ( not_empty prev_prev_attr )
  unrelate prev_attr from prev_prev_attr across R4020.''succeeds'';
end if;
if ( not_empty next_attr )
  unrelate next_attr from self across R4020.''succeeds'';
end if;
unrelate self from prev_attr across R4020.''succeeds'';

if ( not_empty prev_prev_attr )
  relate self to prev_prev_attr across R4020.''succeeds'';
end if;
// want to enable listeners at the last possible moment
if ( empty next_attr )
  ::changeNotificationEnablement(enabled:true);
end if;
relate prev_attr to self across R4020.''succeeds'';
if ( not_empty next_attr )
  ::changeNotificationEnablement(enabled:true);
  relate next_attr to prev_attr across R4020.''succeeds'';
end if;
',
	1,
	'',
	8995);
INSERT INTO O_TFR
	VALUES (8995,
	2990,
	'moveDown',
	'',
	19,
	1,
	'::changeNotificationEnablement(enabled:false);
select one next_attr related by self->C_AS[R4020.''precedes''];
select one prev_attr related by self->C_AS[R4020.''succeeds''];
select one next_next_attr related by next_attr->C_AS[R4020.''precedes''];

if ( not_empty next_next_attr )
  unrelate next_next_attr from next_attr across R4020.''succeeds'';
end if;
if ( not_empty prev_attr )
  unrelate self from prev_attr across R4020.''succeeds'';
end if;
unrelate next_attr from self across R4020.''succeeds'';

if ( not_empty prev_attr )
  relate next_attr to prev_attr across R4020.''succeeds'';
end if;
   
// want to enable listeners at the last possible moment
if ( empty next_next_attr )
  ::changeNotificationEnablement(enabled:true);
end if;
relate self to next_attr across R4020.''succeeds'';
if ( not_empty next_next_attr )
  ::changeNotificationEnablement(enabled:true);
  relate next_next_attr to self across R4020.''succeeds'';
end if;
',
	1,
	'',
	8990);
INSERT INTO O_TFR
	VALUES (8994,
	2990,
	'actionFilter',
	'',
	316,
	1,
	'if (param.name == "can" )
  if ( param.value == "move up" )
    select one prev_attr related by self->C_AS[R4020.''succeeds''];
    return not_empty prev_attr;
  elif ( param.value == "move down" )
    select one next_attr related by self->C_AS[R4020.''precedes''];
    return not_empty next_attr;
  elif ( param.value == "setToProvider" )
    return self.Direction == IFDirectionType::ServerClient;
  elif ( param.value == "setFromProvider" )
    return self.Direction == IFDirectionType::ClientServer;
  end if;
end if;
return false;
',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (8996,
	8994,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (8997,
	8994,
	'value',
	322,
	0,
	'',
	8996,
	'');
INSERT INTO O_TFR
	VALUES (8998,
	2990,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Id;',
	1,
	'',
	8992);
INSERT INTO O_TFR
	VALUES (8999,
	2990,
	'convertToInstance',
	'Translate: native',
	317,
	1,
	'return this;',
	0,
	'',
	8998);
INSERT INTO O_TFR
	VALUES (9000,
	2990,
	'pastePropertyParameter',
	'',
	19,
	1,
	'select one ep related by self->C_EP[R4004];
ep.pastePropertyParameter(id:param.id);',
	1,
	'',
	8999);
INSERT INTO O_TPARM
	VALUES (9001,
	9000,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9002,
	2990,
	'checkIntegrity',
	'',
	19,
	1,
	'/**
 *  Create integrity issues if there are any other signals with a
 *  matching signature
 */
select one iface related by self->C_EP[R4004]->C_I[R4003];
select many signals related by iface->C_EP[R4003]->C_AS[R4004];
select one system related by iface->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405];
if(empty system)
  select one component related by iface->PE_PE[R8001]->C_C[R8003];
  pkgId = component.getPackageId();
  select any package from instances of EP_PKG 
                                           where (selected.Package_ID == pkgId);
  select one system related by package->S_SYS[R1405];
end if;
sys_id = GD::NULL_UNIQUE_ID();
if(not_empty system)
  sys_id = system.Sys_ID;
end if;
for each signal in signals
  if(signal != self and signal.getSignature() == self.getSignature())
    MI_IM::createIssue(sys_id:sys_id, description:
                    "Found another signal under the same interface with a " +
                        "matching signature." + GD::newline() + GD::newline() +
                        "Signature: " + self.getSignature(),
                                       severity:Severity::Error, name:self.Name,
                           path:iface.getPath(path:self.Name, includeSelf:true),
                              id:self.Id, element:self.convertToInstance());
  end if;
end for;',
	1,
	'',
	9000);
INSERT INTO O_TFR
	VALUES (9003,
	2990,
	'getSignature',
	'',
	322,
	1,
	'/**
 *  Return a string representation of this signals signature
 */
signature = self.Name;
count = 0;
select many parameters related by self->C_EP[R4004]->C_PP[R4006];
paramLength = cardinality parameters;
if(paramLength > 0)
  signature = signature + "(";
end if;
for each parameter in parameters
  select one type related by parameter->S_DT[R4007];
  if(count > 0 and count != paramLength - 1)
    signature = signature + ", ";
  end if;
  signature = signature + type.Name;
  count = count + 1;
end for;
if(paramLength > 0)
  signature = signature + ")";
end if;
return signature;',
	1,
	'',
	9002);
INSERT INTO O_REF
	VALUES (2990,
	3137,
	0,
	3136,
	8634,
	8637,
	8635,
	3079,
	9004,
	0,
	0,
	'',
	'Executable Property',
	'Id',
	'R4004');
INSERT INTO O_RATTR
	VALUES (3079,
	2990,
	3136,
	3137,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (3079,
	2990,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (9005,
	2990);
INSERT INTO O_BATTR
	VALUES (9005,
	2990);
INSERT INTO O_ATTR
	VALUES (9005,
	2990,
	3079,
	'Name',
	'Full Name: Signal Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (9006,
	2990);
INSERT INTO O_BATTR
	VALUES (9006,
	2990);
INSERT INTO O_ATTR
	VALUES (9006,
	2990,
	9005,
	'Descrip',
	'Full Name: Signal Description
Description: A textual description of this signal.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (9007,
	2990);
INSERT INTO O_BATTR
	VALUES (9007,
	2990);
INSERT INTO O_ATTR
	VALUES (9007,
	2990,
	9006,
	'Direction',
	'Full Name: Message Direction

Description: Indicates the direction this interface element is intended to be passed.

Data Domain: 0 = client to server, 1 = server to client',
	'',
	'Direction',
	0,
	4654,
	'',
	'');
INSERT INTO O_REF
	VALUES (2990,
	2990,
	0,
	3079,
	8675,
	8677,
	8676,
	9008,
	9009,
	0,
	0,
	'',
	'Interface Signal',
	'Id',
	'R4020');
INSERT INTO O_RATTR
	VALUES (9008,
	2990,
	3136,
	3137,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (9008,
	2990,
	9007,
	'Previous_Id',
	'',
	'Previous_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2990);
INSERT INTO O_OIDA
	VALUES (3079,
	2990,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	2990);
INSERT INTO O_ID
	VALUES (2,
	2990);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (8659,
	'Interface Reference In Delegation',
	4014,
	'C_RID',
	'',
	8619);
INSERT INTO O_REF
	VALUES (8659,
	8648,
	0,
	8650,
	8656,
	8660,
	8658,
	9010,
	9011,
	0,
	0,
	'',
	'Interface Reference',
	'Id',
	'R4013');
INSERT INTO O_RATTR
	VALUES (9010,
	8659,
	8650,
	8648,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (9010,
	8659,
	0,
	'Reference_Id',
	'',
	'Reference_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (8659,
	2762,
	0,
	2771,
	8656,
	8660,
	8657,
	9012,
	9013,
	0,
	0,
	'',
	'Delegation',
	'Id',
	'R4013');
INSERT INTO O_RATTR
	VALUES (9012,
	8659,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (9012,
	8659,
	9010,
	'Delegation_Id',
	'',
	'Delegation_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	8659);
INSERT INTO O_OIDA
	VALUES (9010,
	8659,
	0,
	'Reference_Id');
INSERT INTO O_OIDA
	VALUES (9012,
	8659,
	0,
	'Delegation_Id');
INSERT INTO O_ID
	VALUES (1,
	8659);
INSERT INTO O_ID
	VALUES (2,
	8659);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (8648,
	'Interface Reference',
	4011,
	'C_IR',
	'',
	8619);
INSERT INTO O_TFR
	VALUES (9014,
	8648,
	'dispose',
	'',
	19,
	1,
	'select many delegationMediums related by self->C_RID[R4013];
for each dMedium in delegationMediums
  select one delegation related by dMedium->C_DG[R4013];
  unrelate self from delegation across R4013 using dMedium;
  delete object instance dMedium;
  delegation.dispose();
end for;

select one delegation related by self->C_DG[R4014];
if(not_empty delegation)
  unrelate self from delegation across R4014;
  delegation.dispose();
end if;

select one port related by self->C_PO[R4016];
if(not_empty port) 
  select one component related by port->C_C[R4010];
  if (not_empty component)
  	unrelate component from port across R4010;
  end if;
  unrelate port from self across R4016;
  port.dispose();
end if;

self.removeSignalsAndOperations();

select one interface related by self->C_I[R4012];
if (not_empty interface)
  unrelate interface from self across R4012;
end if;

select one provision related by self->C_P[R4009];
select one requirement related by self->C_R[R4009];
if(not_empty provision)
  unrelate self from provision across R4009;
  provision.dispose();
elif(not_empty requirement)
  unrelate self from requirement across R4009;
  requirement.dispose();
end if;

delete object instance self;',
	1,
	'',
	9015);
INSERT INTO O_TFR
	VALUES (9016,
	8648,
	'formalize',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any rootIr from instances of C_IR where (selected.Id == self.getRootIR());
select one interface related by rootIr->C_I[R4012];
formalizedRoot = false;
if not_empty interface
  if(param.id == interface.Id and not Util::isProxy(element:interface.convertToInstance()))
    // already formalized
    formalizedRoot = true;
  else
    // otherwise this reference
    // is formalized to another
    // interface so unformalize
    // now
    self.unformalize(unformalizeOther:false);
  end if;
end if;
if(not (self.Id == self.getRootIR()) and not formalizedRoot)
  // if this is not the root reference
  // there are delegations and the formalization
  // should start with the root ir
  select one rootPro related by rootIr->C_P[R4009];
  if(not_empty rootPro)
    rootPro.formalize(Id:param.id, formalizeReq:param.formalizeOther);
  else
    select one rootReq related by rootIr->C_R[R4009];
    if(not_empty rootReq)
      rootReq.formalize(Id:param.id, formalizePro:param.formalizeOther);
    end if;
  end if;
  return;
end if;
select one provision related by self->C_P[R4009];
select one requirement related by self->C_R[R4009];
select one compPackage related by self->C_PO[R4016]->C_C[R4010]->CP_CP[R4604];
if(empty compPackage)
  // walk the nesting tree of the parent component
  select one parentComponent related by self->C_PO[R4016]->C_C[R4010]->CN_CIC[R4203]->C_C[R4202];
  if(not_empty parentComponent)
    while(empty compPackage)
      select one compPackage related by parentComponent->CP_CP[R4604];
      select one parentComponent related by parentComponent->CN_CIC[R4203]->C_C[R4202];
    end while;
  end if;
end if;
isInGenericPkg = false;
select one system related by self->C_PO[R4016]->C_C[R4010]->PE_PE[R8001]
                                                  ->EP_PKG[R8000]->S_SYS[R1405];
if(empty system)
  select one component related by self->C_PO[R4016]->C_C[R4010];
  rootCompIdInPkg = component.getRootComponentId();
  select any rootComponent from instances of C_C
                                         where (selected.Id == rootCompIdInPkg);
  select one package related by rootComponent->PE_PE[R8001]->EP_PKG[R8000];
  select one system related by package->S_SYS[R1405];
end if;
if (not_empty system)
  isInGenericPkg = true;
end if;
if (not_empty compPackage or isInGenericPkg)
  if (isInGenericPkg)
    select any interfacePe from instances of PE_PE
                                        where (selected.Element_ID == param.id);
    select one interface related by interfacePe->C_I[R8001];
  else
    select one system related by compPackage->S_SYS[R4606];
    select any interface related by system->IP_IP[R4304]->C_I[R4303] where (selected.Id == param.id);
  end if;
  if (not_empty interface)
    doNotFormalize = false;
    if(not (self.Id == self.getRootIR() and formalizedRoot))
      self.createSignalsAndOperations(interface_id:interface.Id);
      relate interface to self across R4012;
      if(not_empty requirement)
        select many provisions related by requirement->C_SF[R4002]->C_P[R4002];
        for each provision in provisions
          if(param.formalizeOther) or (not provision.isFormal())
            provision.formalize(Id:param.id, formalizeReq:false);
          end if;
        end for;
      elif(not_empty provision)
        select many requirements related by provision->C_SF[R4002]->C_R[R4002];
        for each requirement in requirements
          if(param.formalizeOther) or (not requirement.isFormal())
            requirement.formalize(Id:interface.Id, formalizePro:false);
          end if;
        end for;
      end if;
    end if;
    // associate all interface references that
    // exist along the chain of delegations
    // with the interface
    if(self.Id == self.getRootIR())
      self.formalizeDelegatedReferences(id:interface.Id, formalizeOther:param.formalizeOther);
    end if;
  end if;
end if;',
	1,
	'',
	9017);
INSERT INTO O_TPARM
	VALUES (9018,
	9016,
	'id',
	296,
	0,
	'',
	9019,
	'');
INSERT INTO O_TPARM
	VALUES (9019,
	9016,
	'formalizeOther',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9020,
	8648,
	'isFormal',
	'',
	316,
	1,
	'// If the association between self and C_I is set up
// then this reference is formal
select one interface related by self->C_I[R4012];
return not_empty interface;',
	1,
	'',
	9021);
INSERT INTO O_TFR
	VALUES (9021,
	8648,
	'interfaceName',
	'',
	322,
	1,
	'select one interface related by self->C_I[R4012];
if not_empty interface
  return interface.Name;
end if;
result = "";
select one requirement related by self->C_R[R4009];
select one provision related by self->C_P[R4009];
if not_empty requirement
  result = requirement.InformalName;
else
  result = provision.InformalName;
end if;
return result;',
	1,
	'',
	9022);
INSERT INTO O_TFR
	VALUES (9023,
	8648,
	'unformalize',
	'',
	19,
	1,
	'if(not (self.Id == self.getRootIR()))
  // if this is not the root reference
  // there are delegations and the formalization
  // should start with the root ir
  select any rootIr from instances of C_IR where (selected.Id == self.getRootIR());
  if(rootIr.isFormal())
    select one rootPro related by rootIr->C_P[R4009];
    if(not_empty rootPro)
      rootPro.unformalize(unformalizeReq:param.unformalizeOther);
    else
      select one rootReq related by rootIr->C_R[R4009];
      if(not_empty rootReq)
        rootReq.unformalize(unformalizePro:param.unformalizeOther);
      end if;
    end if;
    return;
  end if;
end if;
select one requirement related by self->C_R[R4009];
select one provision related by self->C_P[R4009];
select one interface related by self->C_I[R4012];
if(not_empty requirement)
  select many reps related by requirement->SPR_REP[R4500];
  for each rep in reps
    select one ep related by rep->C_EP[R4500];
    unrelate requirement from ep across R4500 using rep;
    rep.dispose();
  end for;
  if(param.unformalizeOther)
    select many provisions related by requirement->C_SF[R4002]->C_P[R4002];
    for each provision in provisions
      provision.unformalize(unformalizeReq:false);
    end for;
  end if;
elif(not_empty provision)
  select many peps related by provision->SPR_PEP[R4501];
  for each pep in peps
    select one ep related by pep->C_EP[R4501];
    unrelate provision from ep across R4501 using pep;
    pep.dispose();
  end for;
  select many reqs related by provision->C_SF[R4002]->C_R[R4002];
  for each req in reqs
    if(param.unformalizeOther) or (req.isFormal())
      req.unformalize(unformalizePro:false);
    end if;
  end for;
end if;
if (not_empty interface)
  unrelate interface from self across R4012;
end if;
// deassociate all interface references that
// exist along the chain of delegations
// with the interface
if(self.Id == self.getRootIR())
  self.unformalizeDelegatedReferences(unformalizeOther:param.unformalizeOther);
end if;',
	1,
	'',
	9024);
INSERT INTO O_TPARM
	VALUES (9025,
	9023,
	'unformalizeOther',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9026,
	8648,
	'getDelegatedIR',
	'',
	296,
	1,
	'resultID = GD::NULL_UNIQUE_ID();
NULL_ID = GD::NULL_UNIQUE_ID();
select one interface related by self->C_I[R4012];
if (empty interface)
  select many delegatedIRs related by self->C_DG[R4013]->C_IR[R4014];
  for each delegatedIR in delegatedIRs
    select one interface related by delegatedIR->C_I[R4012];
    if (not_empty interface)
      resultID = interface.Id;
    else
      return delegatedIR.getDelegatedIR();
    end if;
    if (resultID != NULL_ID)
      break;
    end if;
  end for;
end if;
return resultID;',
	1,
	'',
	9027);
INSERT INTO O_TFR
	VALUES (9028,
	8648,
	'getRootIR',
	'',
	296,
	1,
	'rootIR = self;
NULL_ID = GD::NULL_UNIQUE_ID();
tempIR = rootIR;
while not_empty tempIR
  rootIR = tempIR;
  select any tempIR related by tempIR->C_DG[R4014]->C_RID[R4013]->C_IR[R4013];
end while;
 
return rootIR.Id;',
	1,
	'',
	9026);
INSERT INTO O_TFR
	VALUES (9029,
	8648,
	'canUseInterfacesInPackage',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
/*
 *  Check that the interface package given exists either at the
 *  system level or along the parent path of the containing
 *  component.
 *
 */
result = false;
select one component related by self->C_PO[R4016]->C_C[R4010];

// check for isInGenericPackage.  If in a generic package the
// interface will never be in an interface package
select one pkg related by component->PE_PE[R8001]->EP_PKG[R8000];

if(not_empty component and empty pkg)
  // This scoping limitation is disabled until we provide package
  // importing, at which time we may or may not use the below call
  //result = component.interfacePackageIsAlongParentPath(id:param.Id);
  // see if the interface package has any interfaces
  select any ipkg related by self->C_PO[R4016]->C_C[R4010]->CP_CP[R4608]
             									    ->S_SYS[R4606]->IP_IP[R4304]
  							            where (selected.Package_ID == param.Id);
  if(not_empty ipkg)
    // Until the package import functionality is available all interfaces
    // are allowed unless they are defined within a component, at which
    // point they are only allowed if defined along the parent path
    select one irParent related by component->CN_CIC[R4203]->C_C[R4202];
    select one interfaceParentComponent related by ipkg->C_C[R4206];
    if(empty interfaceParentComponent)
      select one parentInterfacePackage related by ipkg->IP_IPINIP[R4301]
                                                                 ->IP_IP[R4300];
      while(not_empty parentInterfacePackage)
        select one interfaceParentComponent related by parentInterfacePackage
                                                                   ->C_C[R4206];
        select one parentInterfacePackage related by parentInterfacePackage
                                               ->IP_IPINIP[R4301]->IP_IP[R4300];
      end while;
    end if;
    if(not_empty irParent and not_empty interfaceParentComponent)
      if(not_empty interfaceParentComponent)
        // check that the component which the interface
        // package is defined in, is defined along the
        // parent path
        select one parentParentComponent related by irParent->CN_CIC[R4203]
                                                                   ->C_C[R4202];
        while(not_empty parentParentComponent)
          if(interfaceParentComponent == parentParentComponent)
            result = true;
            break;
          end if;
          select one parentParentComponent related by parentParentComponent
                                                    ->CN_CIC[R4203]->C_C[R4202];
        end while;
        // also check the component the interface package is
        // defined in
        if(not result)
          if(interfaceParentComponent == irParent)
            result = true;
          end if;
        end if;
      end if;
    elif(empty irParent and not_empty interfaceParentComponent)
      // if the interface reference is defined in a component package
      // yet the interace package is within a component it cannot be
      // used
      return false;
    elif(not_empty irParent and empty interfaceParentComponent or
                              empty irParent and empty interfaceParentComponent)
      // allowed if interface package is not within a component
      result = true;
    end if;
    if(result)
      select any interface related by ipkg->C_I[R4303];
      if(not_empty interface)
        result = true;
      else
        result = false;
      end if;
      // if everything is good so far, check that
      // this package does not only contain the
      // interface which this reference is already
      // assigned to
      if(self.isFormal() and result)
        select one existingInterface related by self->C_I[R4012];
        select many interfaces related by ipkg->C_I[R4303];
        for each interface in interfaces
          if(existingInterface != interface)
            return true;
          end if;
        end for;
        // if we get passed the above
        // then the package only contains
        // the interface we are already
        // formalized against
        result = false;
      end if;
    end if;
  end if;
end if;
return result;',
	1,
	'',
	9030);
INSERT INTO O_TPARM
	VALUES (9031,
	9029,
	'Id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9030,
	8648,
	'canFormalizeAgainstAnyInterface',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// locate the component package
isInGenericPkg = false;
select one system related by self->C_PO[R4016]->C_C[R4010]->PE_PE[R8001]
                                                  ->EP_PKG[R8000]->S_SYS[R1405];
if(empty system)
  // check for component as parent
  select one component related by self->C_PO[R4016]->C_C[R4010];
  if(not_empty component)
    rootCompIdInPkg = component.getRootComponentId();
    select any rootComponent from instances of C_C
                                         where (selected.Id == rootCompIdInPkg);
    select one system related by rootComponent->PE_PE[R8001]->EP_PKG[R8000]
                                                                 ->S_SYS[R1405];
  end if;
end if;
if (not_empty system)
  isInGenericPkg = true;
end if;
if (isInGenericPkg)
  // verify that there is at least one interface
  // which we can formalize against
  select one package related by self->C_PO[R4016]->C_C[R4010]->PE_PE[R8001]
                                                                ->EP_PKG[R8000];
  if(not_empty package)
    package.clearScope();
    package.collectVisibleElementsForName(name:"",
                         type:ElementTypeConstants::INTERFACE, descending:false,
                                      originatingContainerID:package.Package_ID,
                    delegatingPkgID:GD::NULL_UNIQUE_ID(), collectGlobally:true);
    select many srs related by package->PE_SRS[R8005]
                       where (selected.Type == ElementTypeConstants::INTERFACE);
    select many interfaces related by srs->PE_VIS[R8006]->PE_PE[R8002] 
                                                                   ->C_I[R8001];
    for each interface in interfaces
      if(interface.Id != self.Formal_Interface_Id)
        return true;
      end if;
    end for;
  end if;
  select one component related by self->C_PO[R4016]->C_C[R4010]->PE_PE[R8001]
                                                                   ->C_C[R8003];
  if(not_empty component)
    component.clearScope();
    component.collectVisibleElementsForName(name:"",
                         type:ElementTypeConstants::INTERFACE,
                                      originatingContainerID:component.Id,
                                    delegatingContainerID:GD::NULL_UNIQUE_ID(),
                                                          collectGlobally:true);
    select many crs related by component->PE_CRS[R8007]
                       where (selected.Type == ElementTypeConstants::INTERFACE);
    select many interfaces related by crs->PE_CVS[R8008]->PE_PE[R8004] 
                                                                   ->C_I[R8001];
    for each interface in interfaces
      if(interface.Id != self.Formal_Interface_Id)
        return true;
      end if;
    end for;
  end if;
else
  select one componentPackage related by self->C_PO[R4016]->C_C[R4010]->CP_CP[R4608];
  select one system related by componentPackage->S_SYS[R4606];
  if (not_empty system)
    // select all interface packages in the system
    select many diagrams related by system->IP_IP[R4304];
    for each diagram in diagrams
      // if this package is within scope this reference
      // can be formalized against an interface
      if(self.canUseInterfacesInPackage(Id:diagram.Package_ID))
        // verify that there is at least one interface
        // which we can formalize against
        select many interfaces related by diagram->C_I[R4303];
        for each interface in interfaces
          if(interface.Id != self.Formal_Interface_Id)
            return true;
          end if;
        end for;
      end if;
    end for;
  end if;
end if;
return false;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (9027,
	8648,
	'formalizeDelegatedReferences',
	'',
	19,
	1,
	'select many nextRefs related by self->C_RID[R4013]->C_DG[R4013]->C_IR[R4014];
for each nextRef in nextRefs
  formalize = false;
  if(nextRef.isFormal())
    select one interface related by nextRef->C_I[R4012];
    if(interface.Id != param.id)
      nextRef.unformalize(unformalizeOther:false);
      formalize = true;
    end if;
  else
    formalize = true;
  end if;
  if(formalize)
    nextRef.formalize(formalizeOther:param.formalizeOther, id:param.id);
  end if;
  nextRef.formalizeDelegatedReferences(id:param.id, formalizeOther:param.formalizeOther);
end for;',
	1,
	'',
	9016);
INSERT INTO O_TPARM
	VALUES (9032,
	9027,
	'id',
	296,
	0,
	'',
	9033,
	'');
INSERT INTO O_TPARM
	VALUES (9033,
	9027,
	'formalizeOther',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9034,
	8648,
	'unformalizeDelegatedReferences',
	'',
	19,
	1,
	'select many nextRefs related by self->C_RID[R4013]->C_DG[R4013]->C_IR[R4014];
for each nextRef in nextRefs
  nextRef.unformalize(unformalizeOther:param.unformalizeOther);
  nextRef.unformalizeDelegatedReferences(unformalizeOther:param.unformalizeOther);
end for;',
	1,
	'',
	9023);
INSERT INTO O_TPARM
	VALUES (9035,
	9034,
	'unformalizeOther',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9022,
	8648,
	'get_name',
	'',
	322,
	1,
	'//Interface Reference::get_name()
result = self.interfaceName();
select one port related by self->C_PO[R4016];
if not_empty port and port.Name != "";
  result = port.Name + " ( " + result + " )";
end if;
return result;',
	1,
	'',
	9028);
INSERT INTO O_TFR
	VALUES (9024,
	8648,
	'resolveInterface',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one proxyInterface related by self->C_I[R4012];
if(not_empty proxyInterface and
                            not Util::isProxy(element:self.convertToInstance()))
  select one genericPkgSys related by self->C_PO[R4016]->C_C[R4010]
                                    ->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405];
  if(empty genericPkgSys)
    // check for component as parent
   select one component related by self->C_PO[R4016]->C_C[R4010];
   if(not_empty component)
      rootCompIdInPkg = component.getRootComponentId();
      select any rootComponent from instances of C_C
                                         where (selected.Id == rootCompIdInPkg);
      select one genericPkgSys related by rootComponent->PE_PE[R8001]
  		    									  ->EP_PKG[R8000]->S_SYS[R1405];
    end if;
  end if;
  if(not_empty genericPkgSys)
    id = self.findMatchingInterface(system_id:genericPkgSys.Sys_ID, pe:GD::NULL_UNIQUE_ID());
	// this interface could be in another system, just get the
	// first one in the ElementVisibility lists
	select one pkg related by self->C_PO[R4016]->C_C[R4010]->PE_PE[R8001]
                                                                ->EP_PKG[R8000];
    select one comp related by self->C_PO[R4016]->C_C[R4010]->PE_PE[R8001]
                                                                   ->C_C[R8003];
	select many resolvedInterfaces related by pkg->PE_VIS[R8002]->PE_PE[R8002]
                                                                   ->C_I[R8001];
    if(empty resolvedInterfaces)
      select many resolvedInterfaces related by comp->PE_CVS[R8004]
                                                     ->PE_PE[R8004]->C_I[R8001];
    end if;
    interfaceLocated = false;
	for each interface in resolvedInterfaces
	  if(interface.Id == id)
	    interfaceLocated = true;
	    unrelate self from proxyInterface across R4012;
	    relate self to interface across R4012;
        // migrate executable properties
        self.migrateExecutableProperties();
        break;
      end if;	  
	end for;
	if(not interfaceLocated)
	  Util::addPastedElementToProblemList(elementName:self.interfaceName(),
                         message:"Interfaces for the following references could"
                                                          + " not be located:");
	end if;
  else
    select one componentPackage related by self->C_PO[R4016]
  									                 ->C_C[R4010]->CP_CP[R4608];
    if(not_empty componentPackage)
      select one system related by componentPackage->S_SYS[R4606];
      if(not_empty system)
        id = self.findMatchingInterface(system_id:system.Sys_ID, pe:GD::NULL_UNIQUE_ID());
        select any interface related by system->IP_IP[R4304]->C_I[R4303]
      											  where (selected.Id == id);
        if(not_empty interface)
          unrelate self from proxyInterface across R4012;
          relate self to interface across R4012;
          self.migrateExecutableProperties();
        else
          Util::addPastedElementToProblemList(elementName:self.interfaceName(),
                         message:"Interfaces for the following references could"
                                                          + " not be located:");
        end if;
      end if;
    end if;
  end if;
end if;',
	1,
	'',
	9036);
INSERT INTO O_TFR
	VALUES (9015,
	8648,
	'createSignalsAndOperations',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any interface related by self->C_PO[R4016]->C_C[R4010]->CP_CP[R4608]
										->S_SYS[R4606]->IP_IP[R4304]->C_I[R4303]
									  where (selected.Id == param.interface_id);
if (empty interface)
  select any interfacePe from instances of PE_PE
                              where (selected.Element_ID == param.interface_id);
  select one interface related by interfacePe->C_I[R8001];
end if;

if(not_empty interface)
  select many operations related by interface->C_EP[R4003]->C_IO[R4004];
  select many signals related by interface->C_EP[R4003]->C_AS[R4004];
  select one requirement related by self->C_R[R4009];
  if(not_empty requirement)
    for each signal in signals
      select one ep related by signal->C_EP[R4004];
      create object instance req_ep of SPR_REP;
      create object instance req_signal of SPR_RS;
      req_signal.initialize();
      relate requirement to ep across R4500 using req_ep;
      relate req_signal to req_ep across R4502;
    end for;
    for each operation in operations
      select one ep related by operation->C_EP[R4004];
      create object instance req_ep of SPR_REP;
      create object instance req_operation of SPR_RO;
      req_operation.initialize();
      relate requirement to ep across R4500 using req_ep;
      relate req_operation to req_ep across R4502;
    end for;
  else
    select one provision related by self->C_P[R4009];
    for each signal in signals
      select one ep related by signal->C_EP[R4004];
      create object instance pro_ep of SPR_PEP;
      create object instance pro_signal of SPR_PS;
      pro_signal.initialize();
      relate provision to ep across R4501 using pro_ep;
      relate pro_signal to pro_ep across R4503;
    end for;
    for each operation in operations
      select one ep related by operation->C_EP[R4004];
      create object instance pro_ep of SPR_PEP;
      create object instance pro_operation of SPR_PO;
      pro_operation.initialize();
      relate provision to ep across R4501 using pro_ep;
      relate pro_operation to pro_ep across R4503;
    end for;
  end if;
end if;',
	1,
	'',
	9037);
INSERT INTO O_TPARM
	VALUES (9038,
	9015,
	'interface_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9036,
	8648,
	'removeSignalsAndOperations',
	'',
	19,
	1,
	'select one requirement related by self->C_R[R4009];
if(not_empty requirement)
  select many reps related by requirement->SPR_REP[R4500];
  for each rep in reps
    select one ep related by rep->C_EP[R4500];
    unrelate requirement from ep across R4500 using rep;
    rep.dispose();
  end for;
else
  select one provision related by self->C_P[R4009];
  select many peps related by provision->SPR_PEP[R4501];
  for each pep in peps
    select one ep related by pep->C_EP[R4501];
    unrelate provision from ep across R4501 using pep;
    pep.dispose();
  end for;
end if;',
	1,
	'',
	9020);
INSERT INTO O_TFR
	VALUES (9037,
	8648,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'return this;',
	0,
	'',
	9029);
INSERT INTO O_TFR
	VALUES (9017,
	8648,
	'findMatchingInterface',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one currentInterface related by self->C_I[R4012];
if(empty currentInterface)
  return GD::NULL_UNIQUE_ID();
end if;
id = GD::NULL_UNIQUE_ID();
if(Util::isProxy(element:currentInterface.convertToInstance()))
  name = currentInterface.Name;
  select any system from instances of S_SYS where (selected.Sys_ID
  															== param.system_id);
  isInGenericPkg = false;
  select one pkg related by self->C_PO[R4016]->C_C[R4010]->PE_PE[R8001]
                                                                ->EP_PKG[R8000];
  select one comp related by self->C_PO[R4016]->C_C[R4010]->PE_PE[R8001]
                                                                   ->C_C[R8003];
  if (not_empty pkg or not_empty comp)
    isInGenericPkg = true;
  else
    if(param.pe != GD::NULL_UNIQUE_ID())
      isInGenericPkg = true;
    end if;
  end if;
  if (isInGenericPkg)
    select one packageableElement related by self->C_PO[R4016]->C_C[R4010]
                                                                 ->PE_PE[R8001];
    if(param.pe != GD::NULL_UNIQUE_ID())
      select any packageableElement from instances of PE_PE where (selected.Element_ID == param.pe);
      select one pkg related by packageableElement->EP_PKG[R8000];
      if(empty pkg)
        select one comp related by packageableElement->C_C[R8003];
      end if;
    end if;
    packageableElement.resolveInterfaceRelativeToSelf(expected_name:name);
    select many resolvedInterfaces related by pkg->PE_VIS[R8002]->PE_PE[R8002]
                                                                   ->C_I[R8001];
    if(empty resolvedInterfaces)
      select many resolvedInterfaces related by comp->PE_CVS[R8004]
                                                     ->PE_PE[R8004]->C_I[R8001];
    end if;
    // the interfaces will be all that can be used and share the
    // same name
    if(cardinality resolvedInterfaces == 1)
	  for each interface in resolvedInterfaces
	    return interface.Id;
	  end for;
	else
	  // otherwise locate a perfect match, if none found
	  // just return the first one in the list
	  for each interface in resolvedInterfaces
	    if(self.interfacePreciselyMatches(id: interface.Id))
	      return interface.Id;
	    end if;
	  end for;
	  for each interface in resolvedInterfaces
	    return interface.Id;
	  end for;	  
    end if;
  else
    select any interface related by system->IP_IP[R4304]->C_I[R4303]
  												  where (selected.Name == name);
    if(not_empty interface)
      return interface.Id;
    end if;
  end if;   
  
else
  id = currentInterface.Id;
end if;
return id;',
	1,
	'',
	9014);
INSERT INTO O_TPARM
	VALUES (9039,
	9017,
	'system_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9040,
	9017,
	'pe',
	296,
	0,
	'',
	9039,
	'');
INSERT INTO O_TFR
	VALUES (9041,
	8648,
	'getComponentId',
	'',
	296,
	1,
	'select one port related by self->C_PO[R4016];
return port.getComponentId();',
	1,
	'',
	9034);
INSERT INTO O_TFR
	VALUES (9042,
	8648,
	'isSynchronized',
	'',
	316,
	1,
	'/**
 *  An interface reference is synchronized if the interface exists and the
 *  signature matches.
 */
// first check the existence
select one interface related by self->C_I[R4012];
if(empty interface)
  return true;
end if;
if(Util::isProxy(element:interface.convertToInstance()))
  return false;
end if;
// also check the parents in the case where the interface
// was not converted to a proxy but is torn down
select one pkg related by interface->IP_IP[R4303];
select one pe related by interface->PE_PE[R8001];
if(empty pkg and empty pe)
  return false;
end if;
// next ask each current op/signal associated
select one provision related by self->C_P[R4009];
select one requirement related by self->C_R[R4009];
// additionally check for any messages that exist in the interface
// but not under the interface reference
select many eps related by interface->C_EP[R4003];
for each ep in eps
  if(not_empty provision)
    select any pep related by provision->SPR_PEP[R4501]
                                where (selected.ExecutableProperty_Id == ep.Id);
    if(empty pep)
      return false;
    end if;
  end if;
  if(not_empty requirement)
    select any rep related by requirement->SPR_REP[R4500]
                                where (selected.ExecutableProperty_Id == ep.Id);
    if(empty rep)
      return false;
    end if;
  end if;
end for;
return true;',
	1,
	'',
	9041);
INSERT INTO O_TFR
	VALUES (9043,
	8648,
	'synchronizeSignalsAndOperations',
	'',
	19,
	1,
	'/**
 * This operation will synchronize the signal and operation set with the current
 * state of the formal interface 
**/
select one interface related by self->C_I[R4012];
select many operations related by interface->C_EP[R4003]->C_IO[R4004];
select many signals related by interface->C_EP[R4003]->C_AS[R4004];
select one provision related by self->C_P[R4009];
if(not_empty provision)
  // compare the operation set with the associated provided operations
  select many providedOperations related by provision->SPR_PEP[R4501]
                                                                ->SPR_PO[R4503];
  // first remove any that point at missing C_EP instances
  for each providedOperation in providedOperations
    select one pep related by providedOperation->SPR_PEP[R4503];
    select one ep related by pep->C_EP[R4501];
    // if the ep is a proxy, it does not exist in the target
    // as it would have been resolved by the selection
    select one iface related by ep->C_I[R4003];
    if(empty ep or Util::isProxy(element:ep.convertToInstance()) or empty iface
                            or Util::isProxy(element:iface.convertToInstance()))
      unrelate provision from ep across R4501 using pep;
      pep.dispose();
    end if;
  end for;
  // then create any that are missing in the local reference
  for each operation in operations
    select any pep related by operation->C_EP[R4004]->SPR_PEP[R4501]
                        where (selected.Provision_Id == provision.Provision_Id);
    if(empty pep)
      // create the necessary provided operation
      select one ep related by operation->C_EP[R4004];
      create object instance pro_ep of SPR_PEP;
      create object instance pro_operation of SPR_PO;
      pro_operation.initialize();
      relate provision to ep across R4501 using pro_ep;
      relate pro_operation to pro_ep across R4503;        
    end if;
  end for;
  // compare the signal set with the associated provided signals
  select many providedSignals related by provision->SPR_PEP[R4501]
                                                                ->SPR_PS[R4503];
  // first remove any that point at missing C_EP instances
  for each providedSignal in providedSignals
    select one pep related by providedSignal->SPR_PEP[R4503];
    select one ep related by pep->C_EP[R4501];
    // if the ep is a proxy, it does not exist in the target
    // as it would have been resolved by the selection
    select one iface related by ep->C_I[R4003];
    if(empty ep or Util::isProxy(element:ep.convertToInstance()) or empty iface
                            or Util::isProxy(element:iface.convertToInstance()))
      unrelate provision from ep across R4501 using pep;
      pep.dispose();
    end if;
  end for;  
  // then create any that are missing in the local reference
  for each signal in signals
    select any pep related by signal->C_EP[R4004]->SPR_PEP[R4501]
                        where (selected.Provision_Id == provision.Provision_Id);
    if(empty pep)
      // create the necessary provided signal
      select one ep related by signal->C_EP[R4004];
      create object instance pro_ep of SPR_PEP;
      create object instance pro_signal of SPR_PS;
      pro_signal.initialize();
      relate provision to ep across R4501 using pro_ep;
      relate pro_signal to pro_ep across R4503;        
    end if;
  end for;
end if;
select one requirement related by self->C_R[R4009];
if(not_empty requirement)
  // compare the operation set with the associated requirements operations
  select many requiredOperations related by requirement->SPR_REP[R4500]
                                                                ->SPR_RO[R4502];
  // first remove any that are pointing at missing C_EP instances
  for each requiredOperation in requiredOperations
    select one rep related by requiredOperation->SPR_REP[R4502];
    select one ep related by rep->C_EP[R4500];
    // if the ep is a proxy, it does not exist in the target
    // as it would have been resolved by the selection
    select one iface related by ep->C_I[R4003];
    if(empty ep or Util::isProxy(element:ep.convertToInstance()) or empty iface
                            or Util::isProxy(element:iface.convertToInstance()))
      unrelate requirement from ep across R4500 using rep;
      rep.dispose();
    end if;
  end for;
  // then create any that are missing in the local reference
  for each operation in operations
    select any rep related by operation->C_EP[R4004]->SPR_REP[R4500]
                  where (selected.Requirement_Id == requirement.Requirement_Id);
    if(empty rep)
      // create the necessary required operation
      select one ep related by operation->C_EP[R4004];
      create object instance req_ep of SPR_REP;
      create object instance req_operation of SPR_RO;
      req_operation.initialize();
      relate requirement to ep across R4500 using req_ep;
      relate req_operation to req_ep across R4502;        
    end if;
  end for;
  // compare the signal set with the associated provided signals
  select many requiredSignals related by requirement->SPR_REP[R4500]
                                                                ->SPR_RS[R4502];
  // first remove any that are pointing at missing C_EP instances
  for each requiredSignal in requiredSignals
    select one rep related by requiredSignal->SPR_REP[R4502];
    select one ep related by rep->C_EP[R4500];
    // if the ep is a proxy, it does not exist in the target
    // as it would have been resolved by the selection
    select one iface related by ep->C_I[R4003];
    if(empty ep or Util::isProxy(element:ep.convertToInstance()) or empty iface
                            or Util::isProxy(element:iface.convertToInstance()))
      unrelate requirement from ep across R4500 using rep;
      rep.dispose();
    end if;
  end for;  
  // then create any that are missing in the local reference
  for each signal in signals
    select any rep related by signal->C_EP[R4004]->SPR_REP[R4500]
                  where (selected.Requirement_Id == requirement.Requirement_Id);
    if(empty rep)
      // create the necessary required signal
      select one ep related by signal->C_EP[R4004];
      create object instance req_ep of SPR_REP;
      create object instance req_signal of SPR_RS;
      req_signal.initialize();
      relate requirement to ep across R4500 using req_ep;
      relate req_signal to req_ep across R4502;        
    end if;
  end for;
end if;',
	1,
	'',
	9042);
INSERT INTO O_TFR
	VALUES (9044,
	8648,
	'migrateExecutableProperties',
	'',
	19,
	1,
	'/**
 *  During paste we want to migrate provided and required executable properties
 *  rather than just leave them is unsynchronized.  This allows the move case to
 *  work without an additional step from the user.
 */
select one provision related by self->C_P[R4009];
select one requirement related by self->C_R[R4009];
if(not_empty provision)
  select many peps related by provision->SPR_PEP[R4501];
  for each pep in peps
    pep.migrateExecutableProperty();
  end for;
end if;
if(not_empty requirement)
  select many reps related by requirement->SPR_REP[R4500];
  for each rep in reps
    rep.migrateExecutableProperty();
  end for;
end if;',
	1,
	'',
	9043);
INSERT INTO O_TFR
	VALUES (9045,
	8648,
	'interfacePreciselyMatches',
	'',
	316,
	1,
	'/**
 *  An interface precisely matches if the required and provided local
 *  messages match the interface messages
 */
select one pkg related by self->C_PO[R4016]->C_C[R4010]->PE_PE[R8001]
                                                                ->EP_PKG[R8000];
select one comp related by self->C_PO[R4016]->C_C[R4010]->PE_PE[R8001]
                                                                   ->C_C[R8003];
select many resolvedInterfaces related by pkg->PE_VIS[R8002]->PE_PE[R8002]
                                                                   ->C_I[R8001];
if(empty resolvedInterfaces)
  select many resolvedInterfaces related by comp->PE_CVS[R8004]
                                                     ->PE_PE[R8004]->C_I[R8001];
end if;
for each interface in resolvedInterfaces
  if(interface.Id == param.id)
    // this is the interface in question, compare local
    // data with remote data
    // do some quick checks first for optimization
    select many eps related by interface->C_EP[R4003];
    select many peps related by self->C_P[R4009]->SPR_PEP[R4501];
    if(not_empty peps)
      if(cardinality peps != cardinality eps)
        return false;
      end if;
      foundMatch = false;
      for each pep in peps
        select one epProxy related by pep->C_EP[R4501];
        for each ep in eps
          if(ep.Name == epProxy.getCachedName())
            select one iop related by ep->C_IO[R4004];
            if(not_empty iop)
              select one providedOp related by pep->SPR_PO[R4503];
              if(not_empty providedOp)
                foundMatch = true;
              else
                foundMatch = false;
              end if;
            else
              select one as related by ep->C_AS[R4004];
              if(not_empty as)
                select one providedSignal related by pep->SPR_PS[R4503];
                if(not_empty providedSignal)
                  foundMatch = true;
                else
                  foundMatch = false;
                end if;
              end if;
            end if;
          end if;
        end for;
        if(not foundMatch)
          return false;
        end if;
      end for;
      // if we get here the interface is a match
      return true;
    end if;
    select many reps related by self->C_R[R4009]->SPR_REP[R4500];
    if(not_empty reps)
      if(cardinality reps != cardinality eps)
        return false;
      end if;
      foundMatch = false;
      for each rep in reps
        select one epProxy related by rep->C_EP[R4500];
        for each ep in eps
          if(ep.Name == epProxy.getCachedName())
            select one iop related by ep->C_IO[R4004];
            if(not_empty iop)
              select one requiredOp related by rep->SPR_RO[R4502];
              if(not_empty requiredOp)
                foundMatch = true;
              else
                foundMatch = false;
              end if;
            else
              select one as related by ep->C_AS[R4004];
              if(not_empty as)
                select one requiredSignal related by rep->SPR_RS[R4502];
                if(not_empty requiredSignal)
                  foundMatch = true;
                else
                  foundMatch = false;
                end if;
              end if;
            end if;
          end if;
        end for;
        if(not foundMatch)
          return false;
        end if;
      end for;
      // if we get here the interface is a match
      return true;
    end if;
  end if;
end for;
return false;',
	1,
	'',
	9044);
INSERT INTO O_TPARM
	VALUES (9046,
	9045,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9047,
	8648,
	'synchronize',
	'',
	19,
	1,
	'/**
 *  Synchronize this reference with the associated interface
 */
select one interface related by self->C_I[R4012];
if(not_empty interface)
  // if the interface is a proxy, then simply unformalize
  isTornDown = Util::isProxy(element:interface.convertToInstance());
  if(not isTornDown)
    // check for parents
    select one pkg related by interface->IP_IP[R4303];
    select one pe related by interface->PE_PE[R8001];
    if(empty pkg and empty pe)
      isTornDown = true;
    end if;
  end if;
  if(isTornDown)
    self.unformalize(unformalizeOther:false);
    return;
  end if;
  self.synchronizeSignalsAndOperations();
end if;',
	1,
	'',
	9045);
INSERT INTO O_TFR
	VALUES (9048,
	8648,
	'collectReferencesForSynchronization',
	'',
	19,
	1,
	'/*
 *  Collect subtype
 */
select one provision related by self->C_P[R4009];
if(not_empty provision)
  Util::addElementToList(elementList:param.referenceList,
                                         element:provision.convertToInstance());
  provision.collectReferencesForSynchronization(
                   referenceList:param.referenceList, syncType: param.syncType);
end if;
select one requirement related by self->C_R[R4009];
if(not_empty requirement)
  Util::addElementToList(elementList:param.referenceList,
                                       element:requirement.convertToInstance());
  requirement.collectReferencesForSynchronization(
                   referenceList:param.referenceList, syncType: param.syncType);
end if;',
	1,
	'',
	9047);
INSERT INTO O_TPARM
	VALUES (9049,
	9048,
	'referenceList',
	317,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9050,
	9048,
	'syncType',
	3500,
	0,
	'',
	9049,
	'');
INSERT INTO O_TFR
	VALUES (9051,
	8648,
	'isReferringToDefaultInterface',
	'',
	316,
	1,
	'select one interface related by self->C_I[R4012];
if(not_empty interface)
  return Util::isProxy(element:interface.convertToInstance());
end if;
return true;',
	1,
	'',
	9048);
INSERT INTO O_TFR
	VALUES (9052,
	8648,
	'canReferToInterface',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// locate the component package
isInGenericPkg = false;
select one system related by self->C_PO[R4016]->C_C[R4010]->PE_PE[R8001]
                                                  ->EP_PKG[R8000]->S_SYS[R1405];
if(empty system)
  // check for component as parent
  select one component related by self->C_PO[R4016]->C_C[R4010];
  if(not_empty component)
    rootCompIdInPkg = component.getRootComponentId();
    select any rootComponent from instances of C_C
                                         where (selected.Id == rootCompIdInPkg);
    select one system related by rootComponent->PE_PE[R8001]->EP_PKG[R8000]
                                                                 ->S_SYS[R1405];
  end if;
end if;
if (not_empty system)
  isInGenericPkg = true;
end if;
if (isInGenericPkg)
  // verify that there is at least one interface
  // which we can formalize against
  select one package related by self->C_PO[R4016]->C_C[R4010]->PE_PE[R8001]
                                                                ->EP_PKG[R8000];
  if(not_empty package)
    package.clearScope();
    package.collectVisibleElementsForName(name:"",
                         type:ElementTypeConstants::INTERFACE, descending:false,
                                      originatingContainerID:package.Package_ID,
                    delegatingPkgID:GD::NULL_UNIQUE_ID(), collectGlobally:true);
    select many srs related by package->PE_SRS[R8005]
                       where (selected.Type == ElementTypeConstants::INTERFACE);
    select many interfaces related by srs->PE_VIS[R8006]->PE_PE[R8002] 
                                                                   ->C_I[R8001];
    for each interface in interfaces
      if(interface.Id == self.Formal_Interface_Id)
        return true;
      end if;
    end for;
  end if;
  select one component related by self->C_PO[R4016]->C_C[R4010]->PE_PE[R8001]
                                                                   ->C_C[R8003];
  if(not_empty component)
    component.clearScope();
    component.collectVisibleElementsForName(name:"",
                         type:ElementTypeConstants::INTERFACE,
                                      originatingContainerID:component.Id,
                                    delegatingContainerID:GD::NULL_UNIQUE_ID(),
                                                          collectGlobally:true);
    select many crs related by component->PE_CRS[R8007]
                       where (selected.Type == ElementTypeConstants::INTERFACE);
    select many interfaces related by crs->PE_CVS[R8008]->PE_PE[R8004] 
                                                                   ->C_I[R8001];
    for each interface in interfaces
      if(interface.Id == self.Formal_Interface_Id)
        return true;
      end if;
    end for;
  end if;
else
  select one componentPackage related by self->C_PO[R4016]->C_C[R4010]->CP_CP[R4608];
  select one system related by componentPackage->S_SYS[R4606];
  if (not_empty system)
    // select all interface packages in the system
    select many diagrams related by system->IP_IP[R4304];
    for each diagram in diagrams
      // if this package is within scope this reference
      // can be formalized against an interface
      if(self.canUseInterfacesInPackage(Id:diagram.Package_ID))
        // verify that there is at least one interface
        // which we can formalize against
        select many interfaces related by diagram->C_I[R4303];
        for each interface in interfaces
          if(interface.Id == self.Formal_Interface_Id)
            return true;
          end if;
        end for;
      end if;
    end for;
  end if;
end if;
return false;',
	1,
	'',
	9051);
INSERT INTO O_REF
	VALUES (8648,
	8666,
	0,
	8670,
	8668,
	8671,
	8669,
	9053,
	9054,
	0,
	0,
	'',
	'Port',
	'Id',
	'R4016');
INSERT INTO O_RATTR
	VALUES (9053,
	8648,
	8670,
	8666,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (9053,
	8648,
	9055,
	'Port_Id',
	'',
	'Port_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (8650,
	8648);
INSERT INTO O_BATTR
	VALUES (8650,
	8648);
INSERT INTO O_ATTR
	VALUES (8650,
	8648,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	296,
	'',
	'');
INSERT INTO O_REF
	VALUES (8648,
	2809,
	0,
	8632,
	8653,
	8654,
	8655,
	9056,
	9057,
	0,
	0,
	'',
	'Interface',
	'Id',
	'R4012');
INSERT INTO O_RATTR
	VALUES (9056,
	8648,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (9056,
	8648,
	8650,
	'Formal_Interface_Id',
	'',
	'Formal_Interface_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (8648,
	2762,
	0,
	2771,
	8661,
	8663,
	8662,
	9055,
	9058,
	0,
	0,
	'',
	'Delegation',
	'Id',
	'R4014');
INSERT INTO O_RATTR
	VALUES (9055,
	8648,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (9055,
	8648,
	9056,
	'Delegation_Id',
	'',
	'Delegation_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	8648);
INSERT INTO O_OIDA
	VALUES (8650,
	8648,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	8648);
INSERT INTO O_ID
	VALUES (2,
	8648);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2992,
	'Interface Operation',
	4006,
	'C_IO',
	'',
	8619);
INSERT INTO O_TFR
	VALUES (9059,
	2992,
	'dispose',
	'',
	19,
	1,
	'select one dt related by self->S_DT[R4008];
if(not_empty dt)
  unrelate self from dt across R4008;
end if;
select one ep related by self->C_EP[R4004];
if(not_empty ep)
  ep.dispose();
end if;
select one successor related by self->C_IO[R4019.''precedes''];
select one predecessor related by self->C_IO[R4019.''succeeds''];
if (not empty successor)
  unrelate self from successor across R4019.''precedes'';
end if;
if (not empty predecessor)
  unrelate self from predecessor across R4019.''succeeds'';
end if;
if (not_empty successor and not_empty predecessor)
  relate successor to predecessor across R4019.''succeeds'';
end if;
select many msgs related by self->MSG_IOP[R1022]->MSG_SM[R1020]->MSG_M[R1018];
for each msg in msgs
  msg.dispose();
end for;
select many dims related by self->S_DIM[R4018];
for each dim in dims
  unrelate self from dim across R4018;
  delete object instance dim;
end for;
delete object instance self;',
	1,
	'',
	9060);
INSERT INTO O_TFR
	VALUES (9061,
	2992,
	'initialize',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one system related by self->C_EP[R4004]->C_I[R4003]->IP_IP[R4303]->S_SYS[R4304];

select one packageableElem related by self->C_EP[R4004]->C_I[R4003]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;
  
if (isInGenericPackage)
  if (empty package)
    rootCompIdInPkg = component.getRootComponentId();
    select any rootComponent from instances of C_C where (selected.Id == rootCompIdInPkg);
    select one system related by rootComponent->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405];
  else
    select one system related by package->S_SYS[R1405];  
  end if;
end if;                                   
select one interface related by self->C_EP[R4004]->C_I[R4003];
interface.addInterfaceOperationToOrder(id:self.Id);
if (isInGenericPackage)
  def_dt_id = GD::NULL_UNIQUE_ID();
  if not_empty system
    def_dt_id = system.getCoreTypeId(name:"void");
  end if;
  select any pe from instances of PE_PE where selected.Element_ID == def_dt_id;
  select one def_dt related by pe->S_DT[R8001]; 
  relate self to def_dt across R4008;
else
  select any def_dt related by system->SLD_SDP[R4400]->S_DPK[R4400]->SLD_SDINP[R4401]->S_DT[R4401] where (selected.Name == "void");
  relate self to def_dt across R4008;
end if;

name = "Unnamed Operation";
success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:true);    
if ( success!="") 
 self.Name=success;
else 
 self.dispose();
end if;       
direction=PREF::getString(name:"bridgepoint_prefs_message_direction");
if (direction == "from provider")
  self.Direction = IFDirectionType::ServerClient;
else  // if(direction == "to provider")
  self.Direction = IFDirectionType::ClientServer;
end if; 
',
	1,
	'',
	9062);
INSERT INTO O_TFR
	VALUES (9063,
	2992,
	'changeReturnType',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
isInGenericPkg = false;
select one system related by self->C_EP[R4004]->C_I[R4003]->IP_IP[R4303]->S_SYS[R4304];
// Get S_SYS when in isInGenericPackage
if (empty system)
  select one system related by self->C_EP[R4004]->C_I[R4003]->PE_PE[R8001]->
                                   EP_PKG[R8000]->S_SYS[R1405];
end if;
type_dt_id = GD::NULL_UNIQUE_ID();
if not_empty system
  type_dt_id = system.getCoreTypeId(name:param.typeName);
end if;
select any pe from instances of PE_PE where selected.Element_ID == type_dt_id;
select one dt related by pe->S_DT[R8001];
if(not_empty dt)
  select one current_dt related by self->S_DT[R4008];
  unrelate self from current_dt across R4008;
  relate dt to self across R4008;
end if;',
	1,
	'',
	9064);
INSERT INTO O_TPARM
	VALUES (9065,
	9063,
	'typeName',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9066,
	2992,
	'isAllowedReturnType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one packageableElem related by self->C_EP[R4004]->
                                                       C_I[R4003]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;
if isInGenericPackage
  if self.getReturnDimensionsCnt() != 0 and param.typeName == "void"
    return false;
  else
    return packageableElem.isAllowedType(isReturnType:true,
                                                       typeName:param.typeName);
  end if;
else
  if self.getReturnDimensionsCnt() != 0 and param.typeName == "void"
    return false;
  else
    select one system related by self->C_EP[R4004]->C_I[R4003]->
                                                     IP_IP[R4303]->S_SYS[R4304];                                                    
    // Get S_SYS when in generic package
    if (empty system)
      select one system related by self->C_EP[R4004]->C_I[R4003]->PE_PE[R8001]->
                                     EP_PKG[R8000]->S_SYS[R1405];
    end if;
    return Util::isAllowedReturnType( typeName: param.typeName,
                                           system: system.convertToInstance() );
  end if;
end if;',
	1,
	'',
	9061);
INSERT INTO O_TPARM
	VALUES (9067,
	9066,
	'typeName',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9068,
	2992,
	'newParameter',
	'',
	19,
	1,
	'create object instance parameter of C_PP;
select one ep related by self->C_EP[R4004];
relate ep to parameter across R4006;
parameter.initialize();
ep.createMessageArgumentsForParameter(id:parameter.PP_Id);',
	1,
	'',
	9069);
INSERT INTO O_TFR
	VALUES (9070,
	2992,
	'isVoid',
	'',
	316,
	1,
	'select one dt related by self->S_DT[R4008];
return dt.Name == "void";',
	1,
	'',
	9071);
INSERT INTO O_TFR
	VALUES (9072,
	2992,
	'resolveDatatype',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one dtProxy related by self->S_DT[R4008];
if(not_empty dtProxy and not Util::isProxy(element:self.convertToInstance()))
  name = dtProxy.Name;
  unrelate dtProxy from self across R4008;

  select one packageableElem related by self->C_EP[R4004]->C_I[R4003]
       ->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = not_empty package or not_empty component;
  if isInGenericPackage
    id = packageableElem.resolveDataTypeRelativeToSelf(default_name:"void",
                                                            expected_name:name);
    select any resolvedDt related by package->PE_VIS[R8002]->
                           PE_PE[R8002]->S_DT[R8001] where selected.DT_ID == id;
    if (empty resolvedDt)
      select any resolvedDt related by component->PE_CVS[R8004]->
                           PE_PE[R8004]->S_DT[R8001] where selected.DT_ID == id;
    end if;	
    if not_empty resolvedDt
      relate resolvedDt to self across R4008;
    end if;
  else
    select one system related by self->C_EP[R4004]->C_I[R4003]->IP_IP[R4303]
                                                                 ->S_SYS[R4304];                     
    select any resolvedDT related by system->SLD_SDINP[R4402]->S_DT[R4401]
                                                  where (selected.Name == name);
    r_dt_id = GD::NULL_UNIQUE_ID();
    if not_empty system
      r_dt_id = system.getCoreTypeId(name:name);
    end if;
    select any pe from instances of PE_PE where selected.Element_ID == r_dt_id;
    select one resolvedDT related by pe->S_DT[R8001]; 
    // if one was not resolved
    if(empty resolvedDT)
      // default back to void type
      r_dt_id = GD::NULL_UNIQUE_ID();
      if not_empty system
        r_dt_id = system.getCoreTypeId(name:"void");
      end if;
      select any pe from instances of PE_PE where
                                                 selected.Element_ID == r_dt_id;
      select one resolvedDT related by pe->S_DT[R8001]; 
    end if;
    if(not_empty resolvedDT)
      relate resolvedDT to self across R4008;
    end if;
  end if;
end if;',
	1,
	'',
	9073);
INSERT INTO O_TFR
	VALUES (9062,
	2992,
	'getReturnDimensionsCnt',
	'',
	298,
	1,
	'select many dims related by self->S_DIM[R4018];
dimensions = cardinality dims;
return dimensions;
',
	1,
	'',
	9059);
INSERT INTO O_TFR
	VALUES (9073,
	2992,
	'resizeReturn_Dimensions',
	'',
	19,
	1,
	'// If the number of dimensions has increased then add dimensions
while (param.numDimensions > self.getReturnDimensionsCnt())
  create object instance dim of S_DIM;
  dim.dimensionCount = self.getReturnDimensionsCnt();
  relate dim to self across R4018;
end while;

// If the number of dimensions has decreased then remove dimensions
while (param.numDimensions < self.getReturnDimensionsCnt())
  select any dim related by self->S_DIM[R4018] where (selected.dimensionCount == (self.getReturnDimensionsCnt()-1));
  unrelate dim from self across R4018;
  delete object instance dim;
end while;

// Update the specific dimension that was passed-in if its elementCount has 
// changed.
if (param.numDimensions > 0) 
  select any dim related by self->S_DIM[R4018] where (selected.dimensionCount == param.dimension);
  if (dim.elementCount != param.elementCount)
    dim.elementCount = param.elementCount;
  end if;
end if;
',
	1,
	'',
	9068);
INSERT INTO O_TPARM
	VALUES (9074,
	9073,
	'dimension',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9075,
	9073,
	'elementCount',
	298,
	0,
	'',
	9074,
	'');
INSERT INTO O_TPARM
	VALUES (9076,
	9073,
	'numDimensions',
	298,
	0,
	'',
	9075,
	'');
INSERT INTO O_TFR
	VALUES (9069,
	2992,
	'moveUp',
	'',
	19,
	1,
	'::changeNotificationEnablement(enabled:false);
select one prev_attr related by self->C_IO[R4019.''succeeds''];
select one prev_prev_attr related by prev_attr->C_IO[R4019.''succeeds''];
select one next_attr related by self->C_IO[R4019.''precedes''];

if ( not_empty prev_prev_attr )
  unrelate prev_attr from prev_prev_attr across R4019.''succeeds'';
end if;
if ( not_empty next_attr )
  unrelate next_attr from self across R4019.''succeeds'';
end if;
unrelate self from prev_attr across R4019.''succeeds'';

if ( not_empty prev_prev_attr )
  relate self to prev_prev_attr across R4019.''succeeds'';
end if;
// want to enable listeners at the last possible moment
if ( empty next_attr )
  ::changeNotificationEnablement(enabled:true);
end if;
relate prev_attr to self across R4019.''succeeds'';
if ( not_empty next_attr )
  ::changeNotificationEnablement(enabled:true);
  relate next_attr to prev_attr across R4019.''succeeds'';
end if;
',
	1,
	'',
	9077);
INSERT INTO O_TFR
	VALUES (9077,
	2992,
	'moveDown',
	'',
	19,
	1,
	'::changeNotificationEnablement(enabled:false);
select one next_attr related by self->C_IO[R4019.''precedes''];
select one prev_attr related by self->C_IO[R4019.''succeeds''];
select one next_next_attr related by next_attr->C_IO[R4019.''precedes''];

if ( not_empty next_next_attr )
  unrelate next_next_attr from next_attr across R4019.''succeeds'';
end if;
if ( not_empty prev_attr )
  unrelate self from prev_attr across R4019.''succeeds'';
end if;
unrelate next_attr from self across R4019.''succeeds'';

if ( not_empty prev_attr )
  relate next_attr to prev_attr across R4019.''succeeds'';
end if;
   
// want to enable listeners at the last possible moment
if ( empty next_next_attr )
  ::changeNotificationEnablement(enabled:true);
end if;
relate self to next_attr across R4019.''succeeds'';
if ( not_empty next_next_attr )
  ::changeNotificationEnablement(enabled:true);
  relate next_next_attr to self across R4019.''succeeds'';
end if;
',
	1,
	'',
	9070);
INSERT INTO O_TFR
	VALUES (9078,
	2992,
	'actionFilter',
	'',
	316,
	1,
	'if (param.name == "can" )
  if ( param.value == "move up" )
    select one prev_attr related by self->C_IO[R4019.''succeeds''];
    return not_empty prev_attr;
  elif ( param.value == "move down" )
    select one next_attr related by self->C_IO[R4019.''precedes''];
    return not_empty next_attr;
  elif ( param.value == "setToProvider" )
    return self.Direction == IFDirectionType::ServerClient;
  elif ( param.value == "setFromProvider" )
    return self.Direction == IFDirectionType::ClientServer;
  end if;
end if;
return false;
',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (9079,
	9078,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9080,
	9078,
	'value',
	322,
	0,
	'',
	9079,
	'');
INSERT INTO O_TFR
	VALUES (9081,
	2992,
	'canReferToDataType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// select the dt
select one dt related by self->S_DT[R4008];
if(not_empty dt)
  select one packageableElem related by self->C_EP[R4004]->C_I[R4003]->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = not_empty package or not_empty component;

  if (isInGenericPackage)
    return packageableElem.canReferToDataType(dtID:dt.DT_ID, dtName: dt.Name);
  else
    // as long as the data type package
    // is not defined within a domain
    // then the dt is allowed
    select one dtPkg related by dt->S_DIP[R39]->S_DPK[R39];
    if((not_empty dtPkg) and (dtPkg.isDomainLevel()))
      return false;
    end if;
    return true;
  end if;
end if;
return false;
',
	1,
	'',
	9078);
INSERT INTO O_TFR
	VALUES (9071,
	2992,
	'isReferringToDefaultDataType',
	'',
	316,
	1,
	'select one dt related by self->S_DT[R4008];
elementType = Util::getSimpleClassName(element:self.convertToInstance());
if(dt.Name == S_DT::getDefaultDataTypeName(elementType:elementType))
  return true;
end if;
return false;
',
	1,
	'',
	9066);
INSERT INTO O_TFR
	VALUES (9060,
	2992,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.
Translate: native
',
	317,
	1,
	'// just return this instance as an Object
return this;
',
	0,
	'',
	9063);
INSERT INTO O_TFR
	VALUES (9064,
	2992,
	'canUseDataType',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one packageableElem related by self->
                                          C_EP[R4004]->C_I[R4003]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;
if isInGenericPackage
  // Find the previously created visibility list
  select any resultSet related by package->PE_SRS[R8005] where
        selected.Name == "" and selected.Type == ElementTypeConstants::DATATYPE;
  select any dt related by resultSet->PE_VIS[R8006]->
                     PE_PE[R8002]->S_DT[R8001] where selected.DT_ID == param.id;
  if not_empty component
    // Find the previously created visibility list
    select any compResultSet related by component->PE_CRS[R8007] where
        selected.Name == "" and selected.Type == ElementTypeConstants::DATATYPE;
    select any dt related by compResultSet->PE_CVS[R8008]->
                     PE_PE[R8004]->S_DT[R8001] where selected.DT_ID == param.id;
  end if;
  if(not_empty dt)
    if(self.isAllowedReturnType(typeName:dt.Name))
      return true;
    end if;
  end if;
  return false;
else
  select one interface related by self->C_EP[R4004]->C_I[R4003];
  select one system related by interface->IP_IP[R4303]->S_SYS[R4304];
  // Get S_SYS when in generic package
  if (empty system)
    select one system related by self->C_EP[R4004]->C_I[R4003]->PE_PE[R8001]->
                                   EP_PKG[R8000]->S_SYS[R1405];
  end if;
  select any dt related by system->SLD_SDINP[R4402]->S_DT[R4401]
                                             where (selected.DT_ID == param.id);
  if empty dt and not_empty system and system.useGlobals
    select any pe related by system->G_EIS[R9100]->PE_PE[R9100]
                                          where selected.Element_ID == param.id;
    select one dt related by pe->S_DT[R8001]; 
  end if;
  if(not_empty dt)
    // if the dt is at the system level and
    // is an allowed return type it is usable 
    if(self.isAllowedReturnType(typeName:dt.Name))
	  return true;
    end if;
  end if;
end if;
return false;',
	1,
	'',
	9081);
INSERT INTO O_TPARM
	VALUES (9082,
	9064,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9083,
	2992,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Id;',
	1,
	'',
	9072);
INSERT INTO O_TFR
	VALUES (9084,
	2992,
	'pastePropertyParameter',
	'',
	19,
	1,
	'select one ep related by self->C_EP[R4004];
ep.pastePropertyParameter(id:param.id);',
	1,
	'',
	9083);
INSERT INTO O_TPARM
	VALUES (9085,
	9084,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9086,
	2992,
	'checkIntegrity',
	'',
	19,
	1,
	'/**
 *  Create integrity issues if there are any other operations with a
 *  matching signature
 */
select one iface related by self->C_EP[R4004]->C_I[R4003];
select many operations related by iface->C_EP[R4003]->C_IO[R4004];
select one system related by iface->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405];
if(empty system)
  select one component related by iface->PE_PE[R8001]->C_C[R8003];
  pkgId = component.getPackageId();
  select any package from instances of EP_PKG 
                                           where (selected.Package_ID == pkgId);
  select one system related by package->S_SYS[R1405];
end if;
sys_id = GD::NULL_UNIQUE_ID();
if(not_empty system)
  sys_id = system.Sys_ID;
end if;
for each operation in operations
  if(operation != self and operation.getSignature() == self.getSignature())
    MI_IM::createIssue(sys_id:sys_id, description:
                    "Found another operation under the same interface with a " +
                           "matching signature." + GD::newline() + GD::newline()
                                          + "Signature: " + self.getSignature(),
                                       severity:Severity::Error, name:self.Name,
                           path:iface.getPath(path:self.Name, includeSelf:true),
                              id:self.Id, element:self.convertToInstance());
  end if;
end for;',
	1,
	'',
	9084);
INSERT INTO O_TFR
	VALUES (9087,
	2992,
	'getSignature',
	'',
	322,
	1,
	'/**
 *  Return a string representation of this operations signature
 *  signature = operation(param1_type, param2_type, param3_type)
 */
signature = self.Name;
count = 0;
select many parameters related by self->C_EP[R4004]->C_PP[R4006];
paramLength = cardinality parameters;
if(paramLength > 0)
  signature = signature + "(";
end if;
for each parameter in parameters
  select one type related by parameter->S_DT[R4007];
  if(count > 0 and count != paramLength - 1)
    signature = signature + ", ";
  end if;
  signature = signature + type.Name;
  count = count + 1;
end for;
if(paramLength > 0)
  signature = signature + ")";
end if;
return signature;',
	1,
	'',
	9086);
INSERT INTO O_REF
	VALUES (2992,
	3137,
	0,
	3136,
	8634,
	8636,
	8635,
	3083,
	9088,
	0,
	0,
	'',
	'Executable Property',
	'Id',
	'R4004');
INSERT INTO O_RATTR
	VALUES (3083,
	2992,
	3136,
	3137,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (3083,
	2992,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (9089,
	2992);
INSERT INTO O_BATTR
	VALUES (9089,
	2992);
INSERT INTO O_ATTR
	VALUES (9089,
	2992,
	9090,
	'Name',
	'Full Name: Operation Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (9091,
	2992);
INSERT INTO O_BATTR
	VALUES (9091,
	2992);
INSERT INTO O_ATTR
	VALUES (9091,
	2992,
	9089,
	'Descrip',
	'Full Name: Operation Description
Description: A textual description of this operation.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (9092,
	2992);
INSERT INTO O_BATTR
	VALUES (9092,
	2992);
INSERT INTO O_ATTR
	VALUES (9092,
	2992,
	9091,
	'Direction',
	'Full Name: Message Direction

Description: Indicates the direction this interface element is intended to be passed.

Data Domain: 0 = client to server, 1 = server to client',
	'',
	'Direction',
	0,
	4654,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (9093,
	2992);
INSERT INTO O_BATTR
	VALUES (9093,
	2992);
INSERT INTO O_ATTR
	VALUES (9093,
	2992,
	9092,
	'Return_Dimensions',
	'Full Name: Return Array Dimensions
DynamicReadOnly:isVoid',
	'',
	'Return_Dimensions',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (2992,
	2992,
	0,
	3083,
	8672,
	8674,
	8673,
	9094,
	9095,
	0,
	0,
	'',
	'Interface Operation',
	'Id',
	'R4019');
INSERT INTO O_RATTR
	VALUES (9094,
	2992,
	3136,
	3137,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (9094,
	2992,
	9093,
	'Previous_Id',
	'',
	'Previous_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2992,
	32,
	0,
	156,
	8644,
	8645,
	8646,
	9090,
	9096,
	0,
	0,
	'',
	'Data Type',
	'DT_ID',
	'R4008');
INSERT INTO O_RATTR
	VALUES (9090,
	2992,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (9090,
	2992,
	3083,
	'DT_ID',
	'',
	'',
	'Element_ID',
	2,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2992);
INSERT INTO O_OIDA
	VALUES (3083,
	2992,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	2992);
INSERT INTO O_ID
	VALUES (2,
	2992);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2809,
	'Interface',
	4001,
	'C_I',
	'',
	8619);
INSERT INTO O_TFR
	VALUES (9097,
	2809,
	'dispose',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many signals related by self->C_EP[R4003];
for each signal in signals
  unrelate self from signal across R4003;
  signal.dispose();
end for;
select one id related by self->IP_IP[R4303];
if(not_empty id)
  unrelate self from id across R4303;
end if;
select one pe related by self->PE_PE[R8001];
if (not_empty pe)
  unrelate self from pe across R8001;
  pe.dispose();
end if;
delete object instance self;',
	1,
	'',
	9098);
INSERT INTO O_TFR
	VALUES (9098,
	2809,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'return this;',
	0,
	'',
	0);
INSERT INTO O_TFR
	VALUES (9099,
	2809,
	'get_compartment_text',
	'',
	322,
	1,
	'select many signaExProps related by self->C_EP[R4003]->C_AS[R4004]->C_EP[R4004];
select many opExProps related by self->C_EP[R4003]->C_IO[R4004]->C_EP[R4004];
result = "";
if (param.comp_num == 1)
  if (param.at == Justification::Center_in_X)
    result = "interface";
    result = result + GD::newline();
    result = result + self.Name;
  end if;
elif(param.comp_num == 2)
  if(((empty opExProps) and (not_empty signaExProps)) and
  			(param.at == Justification::Center_in_X)) and (param.ent_num == 1)
    if(not_empty signaExProps)
      result = "signals" + GD::newline();
    end if;
  end if;
  if(param.at == Justification::Left)
    if(not_empty opExProps)
      result = self.get_operation_compartment_text(entry_num: param.ent_num);
    else
      if(not_empty signaExProps) and (param.ent_num > 1)
        result = self.get_signal_compartment_text(entry_num: param.ent_num);
      end if;
    end if;
  end if;
elif(param.comp_num == 3)
  if(param.at == Justification::Center_in_X) and (param.ent_num == 1)
    if(not_empty signaExProps)
      result = "signals" + GD::newline();
    end if;
  end if;
  if(param.at == Justification::Left) and (param.ent_num > 1)
    return self.get_signal_compartment_text(entry_num: param.ent_num);
  end if;
end if;
return result;',
	1,
	'',
	9097);
INSERT INTO O_TPARM
	VALUES (9100,
	9099,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9101,
	9099,
	'ent_num',
	298,
	0,
	'',
	9102,
	'');
INSERT INTO O_TPARM
	VALUES (9102,
	9099,
	'comp_num',
	298,
	0,
	'',
	9100,
	'');
INSERT INTO O_TFR
	VALUES (9103,
	2809,
	'get_compartments',
	'',
	298,
	1,
	'select many asyncSignals related by self->C_EP[R4003]->C_AS[R4004];
select many syncSignals related by self->C_EP[R4003]->C_IO[R4004];
if(not_empty asyncSignals) and (not_empty syncSignals)
  return 3;
else
  return 2;
end if;',
	1,
	'',
	9099);
INSERT INTO O_TFR
	VALUES (9104,
	2809,
	'get_entries',
	'',
	298,
	1,
	'if(param.comp_num == 3)
  select many sigs related by self->C_EP[R4003]->C_AS[R4004];
  return cardinality sigs + 1;
elif(param.comp_num == 2)
  select many ops related by self->C_EP[R4003]->C_IO[R4004];
  if(empty ops)
    select many sigs related by self->C_EP[R4003]->C_AS[R4004];
    if(not_empty sigs)
      return cardinality sigs + 1;
    end if;
  end if;
  return cardinality ops;
end if;
return 1;',
	1,
	'',
	9103);
INSERT INTO O_TPARM
	VALUES (9105,
	9104,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9106,
	2809,
	'initialize',
	'',
	19,
	1,
	'name = ::getUniqueInitialName( 
    instance: self.convertToInstance(), 
    candidateName: "Unnamed Interface" );
success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:true);    
if ( success!="") 
 self.Name=success;
else 
 self.dispose();
end if;           ',
	1,
	'',
	9107);
INSERT INTO O_TFR
	VALUES (9108,
	2809,
	'get_style',
	'',
	784,
	1,
	'return Style::Box;',
	1,
	'',
	9109);
INSERT INTO O_TFR
	VALUES (9110,
	2809,
	'get_text_style',
	'',
	784,
	1,
	'return Style::None;',
	1,
	'',
	9108);
INSERT INTO O_TPARM
	VALUES (9111,
	9110,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9112,
	9110,
	'ent_num',
	298,
	0,
	'',
	9113,
	'');
INSERT INTO O_TPARM
	VALUES (9113,
	9110,
	'comp_num',
	298,
	0,
	'',
	9111,
	'');
INSERT INTO O_TFR
	VALUES (9114,
	2809,
	'newExecutableProperty',
	'',
	296,
	1,
	'create object instance signal of C_EP;
relate self to signal across R4003;
select many references related by self->C_IR[R4012];
if(param.asynchronous)
 create object instance asignal of C_AS;
 relate signal to asignal across R4004;
 asignal.initialize();
else
 create object instance ssignal of C_IO;
 relate signal to ssignal across R4004;
 ssignal.initialize();
end if;
return signal.Id;',
	1,
	'',
	9115);
INSERT INTO O_TPARM
	VALUES (9116,
	9114,
	'asynchronous',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9117,
	2809,
	'get_operation_compartment_text',
	'',
	322,
	1,
	'result = "";
index = 1;
select any operation related by self->C_EP[R4003]->C_IO[R4004] where (selected.Previous_Id == GD::NULL_UNIQUE_ID());
while (not_empty operation)
  if(index == param.entry_num)
    result = result + operation.Name;
    result = result + "(";
    parm_separator = "";
    select any parameter related by operation->C_EP[R4004]->C_PP[R4006] where (selected.Previous_PP_Id == GD::NULL_UNIQUE_ID());
    while (not_empty parameter)
      result = result + parm_separator;
      result = result + parameter.Name;
      result = result + parameter.Dimensions;
      result = result + ":";
      select one dt related by parameter->S_DT[R4007];
      if ( not_empty dt )
        result = result + dt.Name;
      else
        result = result + ::getOrphanedElementName();
      end if;
      parm_separator = ", ";
      select one parameter related by parameter->C_PP[R4021.''precedes''];
    end while;
    result = result + ")";
    select one dt related by operation->S_DT[R4008];
    result = result + ":" + dt.Name;
    if dt.Name != "void"
      result = result + operation.Return_Dimensions;
    end if;
    result = result + GD::newline();
    return result;
  end if;
  index = index + 1;
  select one operation related by operation->C_IO[R4019.''precedes''];
end while;
return "";
',
	1,
	'',
	9104);
INSERT INTO O_TPARM
	VALUES (9118,
	9117,
	'entry_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9109,
	2809,
	'get_signal_compartment_text',
	'',
	322,
	1,
	'result = "";
// note that we must start at index 2 here.  The reason is that if we have any
// signals we always reserve the first slot for the signals title
index = 2;
select any signal related by self->C_EP[R4003]->C_AS[R4004] where (selected.Previous_Id == GD::NULL_UNIQUE_ID());
while (not_empty signal)
  if(index == param.entry_num)
    result = result + signal.Name;
    result = result + "(";
    parm_separator = "";
    select any parameter related by signal->C_EP[R4004]->C_PP[R4006] where (selected.Previous_PP_Id == GD::NULL_UNIQUE_ID());
    while (not_empty parameter)
      result = result + parm_separator;
      result = result + parameter.Name;
      result = result + parameter.Dimensions;
      result = result + ":";
      select one dt related by parameter->S_DT[R4007];
      if ( not_empty dt )
        result = result + dt.Name;
      else
        result = result + ::getOrphanedElementName();
      end if;
      parm_separator = ", ";
      select one parameter related by parameter->C_PP[R4021.''precedes''];
    end while;
    result = result + ")" + GD::newline();
    return result;
  end if;
  index = index + 1;
  select one signal related by signal->C_AS[R4020.''precedes''];
end while;
return "";',
	1,
	'',
	9117);
INSERT INTO O_TPARM
	VALUES (9119,
	9109,
	'entry_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9107,
	2809,
	'hasEPWithDirection',
	'',
	316,
	1,
	'select any op related by self->C_EP[R4003]->C_IO[R4004] 
							 	  where (selected.Direction == param.direction);
select any sig related by self->C_EP[R4003]->C_AS[R4004]
								  where (selected.Direction == param.direction);
return not_empty op or not_empty sig;
',
	1,
	'',
	9110);
INSERT INTO O_TPARM
	VALUES (9120,
	9107,
	'direction',
	4654,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9115,
	2809,
	'initializeOrder',
	'',
	19,
	1,
	'// Alpha-sort the C_AS elements if they have not yet been ordered
select many peers related by self->C_EP[R4003]->C_AS[R4004];
if (cardinality peers > 1)
    initialOrderingCheckPerformed = false;
	select any head related by self->C_EP[R4003]->C_AS[R4004] where (selected.Id == GD::NULL_UNIQUE_ID());
	endOfList = head;
	loopCnt = 0;
	for each peer in peers
	  if ( not initialOrderingCheckPerformed)
	    select one predecessor related by peer->C_AS[R4020.''precedes''];
	    select one successor related by peer->C_AS[R4020.''succeeds''];
	    initialOrderingCheckPerformed = true;
	    if (not_empty  predecessor or not_empty  successor)
	      // Already ordered
	      break;
	    end if;
	    head = peer;
	    endOfList = peer;
	  end if;
	  
      if (loopCnt == 1)
        if (peer.Name < head.Name)
          relate peer to head across R4020.''precedes'';
          endOfList = peer;
        else
          relate head to peer across R4020.''precedes'';
          head = peer;
        end if;
      elif (loopCnt > 1)
        insertPoint = head;
        select one next related by head->C_AS[R4020.''succeeds''];
        while (not_empty next)
          if (next.Name < peer.Name)
            break;
          else
            insertPoint = next;          
            select one next related by next->C_AS[R4020.''succeeds''];
          end if;
        end while;
        
        if (empty next)
          // New end of list
          relate peer to endOfList across R4020.''precedes'';   
          endOfList = peer;       
        else
          if ((insertPoint == head) and (peer.Name > head.Name))
            // New head
            relate head to peer across R4020.''precedes'';
            head = peer;
          else
            unrelate next from insertPoint across R4020.''precedes'';
            relate peer to insertPoint across R4020.''precedes'';
            relate next to peer across R4020.''precedes'';
          end if;          
        end if;
      end if;
      
      loopCnt = loopCnt + 1;
	end for;
end if;

// Alpha-sort the C_IO elements if they have not yet been ordered
select many ioPeers related by self->C_EP[R4003]->C_IO[R4004];
if (cardinality ioPeers > 1)
    initialOrderingCheckPerformed = false;
	select any head related by self->C_EP[R4003]->C_IO[R4004] where (selected.Id == GD::NULL_UNIQUE_ID());
	endOfList = head;
	loopCnt = 0;
	for each peer in ioPeers
	  if ( not initialOrderingCheckPerformed)
	    select one predecessor related by peer->C_IO[R4019.''precedes''];
	    select one successor related by peer->C_IO[R4019.''succeeds''];
	    initialOrderingCheckPerformed = true;
	    if (not_empty  predecessor or not_empty  successor)
	      // Already ordered
	      break;
	    end if;
	    head = peer;
	    endOfList = peer;
	  end if;
	  
      if (loopCnt == 1)
        if (peer.Name < head.Name)
          relate peer to head across R4019.''precedes'';
          endOfList = peer;
        else
          relate head to peer across R4019.''precedes'';
          head = peer;
        end if;
      elif (loopCnt > 1)
        insertPoint = head;
        select one next related by head->C_IO[R4019.''succeeds''];
        while (not_empty next)
          if (next.Name < peer.Name)
            break;
          else
            insertPoint = next;          
            select one next related by next->C_IO[R4019.''succeeds''];
          end if;
        end while;
        
        if (empty next)
          // New end of list
          relate peer to endOfList across R4019.''precedes'';   
          endOfList = peer;       
        else
          if ((insertPoint == head) and (peer.Name > head.Name))
            // New head
            relate head to peer across R4019.''precedes'';
            head = peer;
          else
            unrelate next from insertPoint across R4019.''precedes'';
            relate peer to insertPoint across R4019.''precedes'';
            relate next to peer across R4019.''precedes'';
          end if;          
        end if;
      end if;
      
      loopCnt = loopCnt + 1;
	end for;
end if;',
	1,
	'',
	9106);
INSERT INTO O_TFR
	VALUES (9121,
	2809,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Id;',
	1,
	'',
	9114);
INSERT INTO O_TFR
	VALUES (9122,
	2809,
	'pasteInterfaceOperation',
	'',
	19,
	1,
	'select any iop from instances of C_IO where (selected.Id == param.id);
if(not_empty iop)
  select one existingEP related by iop->C_EP[R4004];
  if(not_empty existingEP)
    select one existing related by existingEP->C_I[R4003];
    if(not_empty existing)
      unrelate existing from existingEP across R4003;
    end if;
    relate existingEP to self across R4003;  
    iop.Name = ::getUniqueInitialNameInParent(instance:iop.convertToInstance(),
  						name:iop.Name, parent:self.convertToInstance());
    self.addInterfaceOperationToOrder(id:iop.Id);
  end if;
end if;',
	1,
	'',
	9121);
INSERT INTO O_TPARM
	VALUES (9123,
	9122,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9124,
	2809,
	'addInterfaceOperationToOrder',
	'',
	19,
	1,
	'select any interfaceOperation from instances of C_IO
                                                where (selected.Id == param.id);
if(not_empty interfaceOperation)
  ::changeNotificationEnablement(enabled:false);
  select many peers related by self->C_EP[R4003]->C_IO[R4004];
  for each peer in peers
    if (peer != interfaceOperation)
      select one predecessor related by peer->C_IO[R4019.''precedes''];
      if (empty predecessor)
        relate interfaceOperation to peer across R4019.''succeeds'';
      end if;
    end if;
  end for;
  ::changeNotificationEnablement(enabled:true);
end if;
',
	1,
	'',
	9122);
INSERT INTO O_TPARM
	VALUES (9125,
	9124,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9126,
	2809,
	'pasteInterfaceSignal',
	'',
	19,
	1,
	'select any sig from instances of C_AS where (selected.Id == param.id);
if(not_empty sig)
  select one existingEP related by sig->C_EP[R4004];
  if(not_empty existingEP)
    select one existing related by existingEP->C_I[R4003];
    if(not_empty existing)
      unrelate existing from existingEP across R4003;
    end if;
    relate existingEP to self across R4003;
    sig.Name = ::getUniqueInitialNameInParent(instance:sig.convertToInstance(),
  						name:sig.Name, parent:self.convertToInstance());
    self.addInterfaceSignalToOrder(id:sig.Id);
  end if;  
end if;',
	1,
	'',
	9124);
INSERT INTO O_TPARM
	VALUES (9127,
	9126,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9128,
	2809,
	'addInterfaceSignalToOrder',
	'',
	19,
	1,
	'select any signal from instances of C_AS where (selected.Id == param.id);
::changeNotificationEnablement(enabled:false);
select many peers related by self->C_EP[R4003]->C_AS[R4004];
for each peer in peers
  if (peer != signal)
    select one predecessor related by peer->C_AS[R4020.''precedes''];
    if (empty predecessor)
      relate signal to peer across R4020.''succeeds'';
    end if;
  end if;
end for;
::changeNotificationEnablement(enabled:true);',
	1,
	'',
	9126);
INSERT INTO O_TPARM
	VALUES (9129,
	9128,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9130,
	2809,
	'getPath',
	'',
	322,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Data Type::getPath()
path = "";
if(param.includeSelf)
  path = self.Name;
end if;
if(param.path != "")
  path = path + "::" + param.path;
end if;
select one package related by self->PE_PE[R8001]->EP_PKG[R8000];
select one component related by self->PE_PE[R8001]->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;
if isInGenericPackage
  if not_empty package
    path = package.getQualifiedName();
  else
    path = component.getQualifiedName();
  end if;
else
  // not necessary or supported
  return "";
end if;
return path;',
	1,
	'',
	9128);
INSERT INTO O_TPARM
	VALUES (9131,
	9130,
	'path',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9132,
	9130,
	'includeSelf',
	316,
	0,
	'',
	9131,
	'');
INSERT INTO O_TFR
	VALUES (9133,
	2809,
	'collectReferencesForSynchronization',
	'',
	19,
	1,
	'/**
 *  Collect any references that require synchronization support
 */
// only push synchronizations are support here
if(param.syncType == SynchronizationType::Push)
  select many interfaceReferences related by self->C_IR[R4012];
  for each interfaceReference in interfaceReferences
    interfaceReference.collectReferencesForSynchronization(
                   referenceList:param.referenceList, syncType: param.syncType);
  end for;
end if;',
	1,
	'',
	9130);
INSERT INTO O_TPARM
	VALUES (9134,
	9133,
	'referenceList',
	317,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9135,
	9133,
	'syncType',
	3500,
	0,
	'',
	9134,
	'');
INSERT INTO O_NBATTR
	VALUES (9136,
	2809);
INSERT INTO O_BATTR
	VALUES (9136,
	2809);
INSERT INTO O_ATTR
	VALUES (9136,
	2809,
	9137,
	'Name',
	'Full Name: Interface Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (9138,
	2809);
INSERT INTO O_BATTR
	VALUES (9138,
	2809);
INSERT INTO O_ATTR
	VALUES (9138,
	2809,
	9136,
	'Descrip',
	'Full Name: Interface Description
Description: A textual description of this provided interface.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (2809,
	3435,
	0,
	3437,
	3447,
	3449,
	3448,
	9137,
	9139,
	0,
	0,
	'',
	'Interface Package',
	'Package_ID',
	'R4303');
INSERT INTO O_RATTR
	VALUES (9137,
	2809,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (9137,
	2809,
	8632,
	'Package_ID',
	'',
	'',
	'SpecificationPackage_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2809,
	26,
	0,
	25,
	868,
	2832,
	870,
	8632,
	9140,
	0,
	0,
	'',
	'Packageable Element',
	'Element_ID',
	'R8001');
INSERT INTO O_RATTR
	VALUES (8632,
	2809,
	25,
	26,
	0,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (8632,
	2809,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2809);
INSERT INTO O_OIDA
	VALUES (8632,
	2809,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	2809);
INSERT INTO O_ID
	VALUES (2,
	2809);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (3137,
	'Executable Property',
	4004,
	'C_EP',
	'',
	8619);
INSERT INTO O_TFR
	VALUES (9141,
	3137,
	'dispose',
	'',
	19,
	1,
	'select one asynchronousSignal related by self->C_AS[R4004];
select one synchronousSignal related by self->C_IO[R4004];
if(not_empty asynchronousSignal)
  unrelate self from asynchronousSignal across R4004;
  asynchronousSignal.dispose();
elif(not_empty synchronousSignal)
  unrelate self from synchronousSignal across R4004;
  synchronousSignal.dispose();
end if;
select many parms related by self->C_PP[R4006];
for each parm in parms
  unrelate self from parm across R4006;
  parm.dispose();
end for;
select one interface related by self->C_I[R4003];
if(not_empty interface)
  unrelate self from interface across R4003;
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (9142,
	3137,
	'initializeOrder',
	'',
	19,
	1,
	'// Alpha-sort the C_PP elements if they have not yet been ordered
select many peers related by self->C_PP[R4006];
if (cardinality peers > 1)
    initialOrderingCheckPerformed = false;
	select any head related by self->C_PP[R4006] where (selected.PP_Id == GD::NULL_UNIQUE_ID());
	endOfList = head;
	loopCnt = 0;
	for each peer in peers
	  if ( not initialOrderingCheckPerformed)
	    select one predecessor related by peer->C_PP[R4021.''precedes''];
	    select one successor related by peer->C_PP[R4021.''succeeds''];
	    initialOrderingCheckPerformed = true;
	    if (not_empty  predecessor or not_empty  successor)
	      // Already ordered
	      break;
	    end if;
	    head = peer;
	    endOfList = peer;
	  end if;
	  
      if (loopCnt == 1)
        if (peer.Name < head.Name)
          relate peer to head across R4021.''precedes'';
          endOfList = peer;
        else
          relate head to peer across R4021.''precedes'';
          head = peer;
        end if;
      elif (loopCnt > 1)
        insertPoint = head;
        select one next related by head->C_PP[R4021.''succeeds''];
        while (not_empty next)
          if (next.Name < peer.Name)
            break;
          else
            insertPoint = next;          
            select one next related by next->C_PP[R4021.''succeeds''];
          end if;
        end while;
        
        if (empty next)
          // New end of list
          relate peer to endOfList across R4021.''precedes'';   
          endOfList = peer;       
        else
          if ((insertPoint == head) and (peer.Name > head.Name))
            // New head
            relate head to peer across R4021.''precedes'';
            head = peer;
          else
            unrelate next from insertPoint across R4021.''precedes'';
            relate peer to insertPoint across R4021.''precedes'';
            relate next to peer across R4021.''precedes'';
          end if;          
        end if;
      end if;
      
      loopCnt = loopCnt + 1;
	end for;
end if;',
	1,
	'',
	9141);
INSERT INTO O_TFR
	VALUES (9143,
	3137,
	'pastePropertyParameter',
	'',
	19,
	1,
	'select any parameter from instances of C_PP where (selected.PP_Id == param.id);
if(not_empty parameter)
  select one existingEP related by parameter->C_EP[R4006];
  if(not_empty existingEP)
    unrelate existingEP from parameter across R4006;
  end if;
  relate parameter to self across R4006;
  parameter.Name = ::getUniqueInitialNameInParent(
                                         instance:parameter.convertToInstance(),
                          name:parameter.Name, parent:self.convertToInstance());
  self.addPropertyParameterToOrder(id:parameter.PP_Id);
  self.createMessageArgumentsForParameter(id:parameter.PP_Id);
end if;',
	1,
	'',
	9142);
INSERT INTO O_TPARM
	VALUES (9144,
	9143,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9145,
	3137,
	'convertToInstance',
	'Translate: native',
	317,
	1,
	'return this;',
	0,
	'',
	9143);
INSERT INTO O_TFR
	VALUES (9146,
	3137,
	'addPropertyParameterToOrder',
	'',
	19,
	1,
	'select any parameter from instances of C_PP where (selected.PP_Id == param.id);
::changeNotificationEnablement(enabled:false);
select many peers related by self->C_PP[R4006];
for each peer in peers
  if (peer != parameter)
    select one predecessor related by peer->C_PP[R4021.''precedes''];
    if (empty predecessor)
      relate parameter to peer across R4021.''succeeds'';
    end if;
  end if;
end for;
::changeNotificationEnablement(enabled:true);
',
	1,
	'',
	9145);
INSERT INTO O_TPARM
	VALUES (9147,
	9146,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9148,
	3137,
	'createMessageArgumentsForParameter',
	'',
	19,
	1,
	'select any parameter from instances of C_PP where (selected.PP_Id == param.id);
if(not_empty parameter)
  // for each message associated with this interface
  // create a message argument
  select many messages related by self->C_AS[R4004]->MSG_SIG[R1021]->
                                                    MSG_AM[R1019]->MSG_M[R1018];
  if(empty messages)
    select many messages related by self->C_IO[R4004]->MSG_IOP[R1022]->
    											    MSG_SM[R1020]->MSG_M[R1018];
  end if;
  for each message in messages
    create object instance arg of MSG_A;
    create object instance oa of MSG_EPA;
    relate oa to parameter across R1023;
    relate oa to arg across R1013;
    relate message to arg across R1001;
  end for;
end if;',
	1,
	'',
	9146);
INSERT INTO O_TPARM
	VALUES (9149,
	9148,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9150,
	3137,
	'getCachedName',
	'Translate:native',
	322,
	1,
	'	return m_name;',
	0,
	'',
	9148);
INSERT INTO O_TFR
	VALUES (9151,
	3137,
	'setCachedName',
	'Translate:native',
	19,
	1,
	'	m_name = p_Name;',
	0,
	'',
	9150);
INSERT INTO O_TPARM
	VALUES (9152,
	9151,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9153,
	3137,
	'getCachedDescrip',
	'Translate:native',
	322,
	1,
	'	return m_descrip;',
	0,
	'',
	9151);
INSERT INTO O_TFR
	VALUES (9154,
	3137,
	'setCachedDescrip',
	'Translate:native',
	19,
	1,
	'	m_descrip = p_Descrip;',
	0,
	'',
	9153);
INSERT INTO O_TPARM
	VALUES (9155,
	9154,
	'descrip',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_NBATTR
	VALUES (3136,
	3137);
INSERT INTO O_BATTR
	VALUES (3136,
	3137);
INSERT INTO O_ATTR
	VALUES (3136,
	3137,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	296,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (9156,
	3137);
INSERT INTO O_BATTR
	VALUES (9156,
	3137);
INSERT INTO O_ATTR
	VALUES (9156,
	3137,
	9157,
	'Direction',
	'User_Visible:false',
	'',
	'Direction',
	0,
	4654,
	'',
	'');
INSERT INTO O_REF
	VALUES (3137,
	2809,
	0,
	8632,
	8630,
	8633,
	8631,
	9157,
	9158,
	0,
	0,
	'',
	'Interface',
	'Id',
	'R4003');
INSERT INTO O_RATTR
	VALUES (9157,
	3137,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (9157,
	3137,
	3136,
	'Interface_Id',
	'',
	'Interface_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (9159,
	3137,
	'result = "";
select one interfaceOp related by self->C_IO[R4004];
if(not_empty interfaceOp)
  result = interfaceOp.Name;
end if;
select one interfaceSig related by self->C_AS[R4004];
if(not_empty interfaceSig)
  result = interfaceSig.Name;
end if;
if(result == "")
  result = self.getCachedName();
else
  self.setCachedName(name: result);
end if;
self.Name = result;',
	1);
INSERT INTO O_BATTR
	VALUES (9159,
	3137);
INSERT INTO O_ATTR
	VALUES (9159,
	3137,
	9156,
	'Name',
	'User_Visible:false',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (9160,
	3137,
	'result = "";
select one interfaceOp related by self->C_IO[R4004];
if(not_empty interfaceOp)
  result = interfaceOp.Descrip;
end if;
select one interfaceSig related by self->C_AS[R4004];
if(not_empty interfaceSig)
  result = interfaceSig.Descrip;
end if;
if(result == "")
  result = self.getCachedDescrip();
else
  self.setCachedDescrip(descrip: result);
end if;
self.Descrip = result;',
	1);
INSERT INTO O_BATTR
	VALUES (9160,
	3137);
INSERT INTO O_ATTR
	VALUES (9160,
	3137,
	9159,
	'Descrip',
	'User_Visible:false',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	3137);
INSERT INTO O_OIDA
	VALUES (3136,
	3137,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	3137);
INSERT INTO O_ID
	VALUES (2,
	3137);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2762,
	'Delegation',
	4012,
	'C_DG',
	'',
	8619);
INSERT INTO O_TFR
	VALUES (9161,
	2762,
	'dispose',
	'',
	19,
	1,
	'// Delegation.dispose()
select one pe related by self->PE_PE[R8001];
isInGenericPackage = not_empty pe;
if isInGenericPackage
  // PackageableElement.dispose() will call back down into here, so just return
  pe.dispose();
  return;
else
  select many mediums related by self->C_RID[R4013];
  for each medium in mediums
    select one reference related by medium->C_IR[R4013];
    unrelate self from reference across R4013 using medium;
    delete object instance medium;
  end for;

  select many references related by self->C_IR[R4014];
  for each ref in references
    unrelate self from ref across R4014;
  end for;

  select one importedRef related by self->CL_IIR[R4704];
  if(not_empty importedRef)
    unrelate self from importedRef across R4704;
  end if;

  select one dic related by self->PA_DIC[R9002];
  if (not_empty dic)
    select one comp related by dic->C_C[R9002];
    unrelate self from comp across R9002 using dic;
    // no need to dispose component, it will get
    // disposed later
    delete object instance dic;
  end if;
end if;
delete object instance self;',
	1,
	'',
	9162);
INSERT INTO O_TFR
	VALUES (9162,
	2762,
	'actionFilter',
	'',
	316,
	1,
	'// just ask the delegated reference whether or not
// the action is allowed
select any ir related by self->C_RID[R4013]->C_IR[R4013];
select one packageableElem related by ir->C_PO[R4016]->C_C[R4010]->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;
if(param.name == "can")
  if(param.value == "formalize spec pkg")
    if (isInGenericPackage)
      return false;
    end if;
  end if;
  if(param.value == "formalize generic pkg")
    if (not isInGenericPackage)
      return false;
    end if;
  end if;
end if;
select one provision related by ir->C_P[R4009];
if(not_empty provision)
  return provision.actionFilter(name:param.name, value:param.value);
end if;
select one requirement related by ir->C_R[R4009];
if(not_empty requirement)
  return requirement.actionFilter(name:param.name, value:param.value);
end if;
return false;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (9163,
	9162,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9164,
	9162,
	'value',
	322,
	0,
	'',
	9163,
	'');
INSERT INTO O_TFR
	VALUES (9165,
	2762,
	'get_connector_text',
	'',
	322,
	1,
	'return "";',
	1,
	'',
	9161);
INSERT INTO O_TPARM
	VALUES (9166,
	9165,
	'Obj_ID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9167,
	9165,
	'Obj_TypeIsImported',
	316,
	0,
	'',
	9166,
	'');
INSERT INTO O_TPARM
	VALUES (9168,
	9165,
	'at',
	880,
	0,
	'',
	9167,
	'');
INSERT INTO O_TPARM
	VALUES (9169,
	9165,
	'parent_ID',
	296,
	0,
	'',
	9168,
	'');
INSERT INTO O_TFR
	VALUES (9170,
	2762,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Id;',
	1,
	'',
	9165);
INSERT INTO O_TFR
	VALUES (9171,
	2762,
	'get_style',
	'',
	784,
	1,
	'select any ir related by self->C_RID[R4013]->C_IR[R4013];
select one interface related by ir->C_I[R4012];
if(param.at == End::End)
  select one pro related by ir->C_P[R4009];
  if(empty interface)
    if(empty pro)
      // default to UML 2 style
      return Style::OpenArrow;
    else
      return Style::None;
    end if;
  else
    if(not_empty pro)
      if(interface.hasEPWithDirection(direction:IFDirectionType::ServerClient))
        return Style::OpenArrow;
      elif(interface.hasEPWithDirection(direction:IFDirectionType::ClientServer))
        return Style::None;
      end if;
    else
      if(interface.hasEPWithDirection(direction:IFDirectionType::ClientServer))
        return Style::OpenArrow;
      elif(interface.hasEPWithDirection(direction:IFDirectionType::ServerClient))
        return Style::None;
      end if;      
    end if;
    // if we still make it here we have a formal
    // delegation with no signals or operations
    // default back to the UML style
    if(empty pro)
      return Style::OpenArrow;
    else
      return Style::None;
    end if;  
  end if;
elif(param.at == End::Start)
  select one pro related by ir->C_P[R4009];
  if(empty interface)
    if(not_empty pro)
      // default to UML 2 style
      return Style::OpenArrow;
    else
      return Style::None;
    end if;
  else
    if(not_empty pro)
      if(interface.hasEPWithDirection(direction:IFDirectionType::ClientServer))
        return Style::OpenArrow;
      elif(interface.hasEPWithDirection(direction:IFDirectionType::ServerClient))
        return Style::None;
      end if;
    else
      if(interface.hasEPWithDirection(direction:IFDirectionType::ServerClient))
        return Style::OpenArrow;
      elif(interface.hasEPWithDirection(direction:IFDirectionType::ClientServer))
        return Style::None;
      end if;
    end if;
    // if we still make it here we have a formal
    // delegation with no signals or operations
    // default back to the UML style
    if(not_empty pro)
      return Style::OpenArrow;
    else
      return Style::None;
    end if;  
  end if;
end if;
return Style::None;',
	1,
	'',
	9170);
INSERT INTO O_TPARM
	VALUES (9172,
	9171,
	'at',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9173,
	2762,
	'get_connector_tooltip',
	'',
	322,
	1,
	'/**
 *  For the end of the delegation connector, we want the associated
 *  Port name given as the tool tip text
 *
 */
if(param.end == End::Start)
  // the traversal across R4014 is one to many, however
  // the resulting port will always be the same
  select any port related by self->C_IR[R4014]->C_PO[R4016];
  if(not_empty port)
    return port.Name;
  end if;
end if;
return "";',
	1,
	'',
	9171);
INSERT INTO O_TPARM
	VALUES (9174,
	9173,
	'end',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9175,
	2762,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'return this;',
	0,
	'',
	9173);
INSERT INTO O_TFR
	VALUES (9176,
	2762,
	'getConfigurationInheritanceElementId',
	'',
	317,
	1,
	'select any interfaceRef related by self->C_IR[R4013];
if(not_empty interfaceRef)
  select one provision related by interfaceRef->C_P[R4009];
  if(not_empty provision)
    return provision.convertToInstance();
  end if;
  select one requirement related by interfaceRef->C_R[R4009];
  if(not_empty requirement)
    return requirement.convertToInstance();
  end if;
end if;
return self.convertToInstance();',
	1,
	'',
	9175);
INSERT INTO O_TFR
	VALUES (9177,
	2762,
	'get_name',
	'',
	322,
	1,
	'return self.Name;',
	1,
	'',
	9176);
INSERT INTO O_TFR
	VALUES (9178,
	2762,
	'getCachedName',
	'Translate:native',
	322,
	1,
	'	return m_name;',
	0,
	'',
	9177);
INSERT INTO O_TFR
	VALUES (9179,
	2762,
	'setCachedName',
	'Translate:native',
	19,
	1,
	'	m_name = p_Value;',
	0,
	'',
	9178);
INSERT INTO O_TPARM
	VALUES (9180,
	9179,
	'value',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (2762,
	26,
	0,
	25,
	868,
	2842,
	870,
	2771,
	9181,
	0,
	0,
	'',
	'Packageable Element',
	'Element_ID',
	'R8001');
INSERT INTO O_RATTR
	VALUES (2771,
	2762,
	25,
	26,
	0,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (2771,
	2762,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (9182,
	2762,
	'select any delegatee related by self->C_IR[R4014];
if(empty delegatee)
  self.Name = self.getCachedName();
else
  select one delegateePort related by delegatee->C_PO[R4016];
  select one delegateeComp related by delegateePort->C_C[R4010];
  result = "-> " + delegateeComp.Name
                 + "::" + delegateePort.Name + "::" + delegatee.interfaceName();
  self.setCachedName(value:result);
  self.Name = result;
end if;',
	1);
INSERT INTO O_BATTR
	VALUES (9182,
	2762);
INSERT INTO O_ATTR
	VALUES (9182,
	2762,
	2771,
	'Name',
	'User_Visible:false',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2762);
INSERT INTO O_OIDA
	VALUES (2771,
	2762,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	2762);
INSERT INTO O_ID
	VALUES (2,
	2762);
-- BP 7.1 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (9183,
	'Component Packaging',
	'',
	'CP',
	4600,
	1,
	0);
INSERT INTO O_IOBJ
	VALUES (9184,
	705,
	0,
	9183,
	'System Model',
	'S_SYS');
INSERT INTO O_IOBJ
	VALUES (9185,
	709,
	0,
	9183,
	'Component',
	'C_C');
INSERT INTO O_IOBJ
	VALUES (9186,
	3435,
	0,
	9183,
	'Interface Package',
	'IP_IP');
INSERT INTO O_IOBJ
	VALUES (9187,
	2807,
	0,
	9183,
	'Component Reference',
	'CL_IC');
INSERT INTO R_SIMP
	VALUES (9188);
INSERT INTO R_REL
	VALUES (9188,
	4600,
	'',
	9183);
INSERT INTO R_PART
	VALUES (707,
	9188,
	9189,
	0,
	0,
	'may be nested in');
INSERT INTO O_RTIDA
	VALUES (758,
	707,
	0,
	9188,
	9189);
INSERT INTO R_RTO
	VALUES (707,
	9188,
	9189,
	0);
INSERT INTO R_OIR
	VALUES (707,
	9188,
	9189,
	0);
INSERT INTO R_FORM
	VALUES (9190,
	9188,
	9191,
	1,
	1,
	'may nest');
INSERT INTO R_RGO
	VALUES (9190,
	9188,
	9191);
INSERT INTO R_OIR
	VALUES (9190,
	9188,
	9191,
	0);
INSERT INTO R_SIMP
	VALUES (9192);
INSERT INTO R_REL
	VALUES (9192,
	4601,
	'',
	9183);
INSERT INTO R_FORM
	VALUES (707,
	9192,
	9193,
	0,
	0,
	'provides nesting');
INSERT INTO R_RGO
	VALUES (707,
	9192,
	9193);
INSERT INTO R_OIR
	VALUES (707,
	9192,
	9193,
	0);
INSERT INTO R_PART
	VALUES (9190,
	9192,
	9194,
	0,
	1,
	'is nested through');
INSERT INTO O_RTIDA
	VALUES (9195,
	9190,
	0,
	9192,
	9194);
INSERT INTO R_RTO
	VALUES (9190,
	9192,
	9194,
	0);
INSERT INTO R_OIR
	VALUES (9190,
	9192,
	9194,
	0);
INSERT INTO R_SIMP
	VALUES (9196);
INSERT INTO R_REL
	VALUES (9196,
	4602,
	'',
	9183);
INSERT INTO R_PART
	VALUES (705,
	9196,
	9197,
	0,
	1,
	'may be contained within');
INSERT INTO O_RTIDA
	VALUES (754,
	705,
	0,
	9196,
	9197);
INSERT INTO R_RTO
	VALUES (705,
	9196,
	9197,
	0);
INSERT INTO R_OIR
	VALUES (705,
	9196,
	9197,
	9184);
INSERT INTO R_FORM
	VALUES (707,
	9196,
	9198,
	1,
	1,
	'may contain');
INSERT INTO R_RGO
	VALUES (707,
	9196,
	9198);
INSERT INTO R_OIR
	VALUES (707,
	9196,
	9198,
	0);
INSERT INTO R_SIMP
	VALUES (9199);
INSERT INTO R_REL
	VALUES (9199,
	4604,
	'',
	9183);
INSERT INTO R_PART
	VALUES (707,
	9199,
	9200,
	0,
	1,
	'may exist in');
INSERT INTO O_RTIDA
	VALUES (758,
	707,
	0,
	9199,
	9200);
INSERT INTO R_RTO
	VALUES (707,
	9199,
	9200,
	0);
INSERT INTO R_OIR
	VALUES (707,
	9199,
	9200,
	0);
INSERT INTO R_FORM
	VALUES (709,
	9199,
	9201,
	1,
	1,
	'may contain');
INSERT INTO R_RGO
	VALUES (709,
	9199,
	9201);
INSERT INTO R_OIR
	VALUES (709,
	9199,
	9201,
	9185);
INSERT INTO R_SIMP
	VALUES (9202);
INSERT INTO R_REL
	VALUES (9202,
	4606,
	'CrossComponent:true',
	9183);
INSERT INTO R_PART
	VALUES (705,
	9202,
	9203,
	0,
	0,
	'is containing system');
INSERT INTO O_RTIDA
	VALUES (754,
	705,
	0,
	9202,
	9203);
INSERT INTO R_RTO
	VALUES (705,
	9202,
	9203,
	0);
INSERT INTO R_OIR
	VALUES (705,
	9202,
	9203,
	9184);
INSERT INTO R_FORM
	VALUES (707,
	9202,
	9204,
	1,
	1,
	'has many defined');
INSERT INTO R_RGO
	VALUES (707,
	9202,
	9204);
INSERT INTO R_OIR
	VALUES (707,
	9202,
	9204,
	0);
INSERT INTO R_SIMP
	VALUES (3511);
INSERT INTO R_REL
	VALUES (3511,
	4607,
	'CrossComponent:true',
	9183);
INSERT INTO R_PART
	VALUES (707,
	3511,
	3513,
	0,
	1,
	'may exist in');
INSERT INTO O_RTIDA
	VALUES (758,
	707,
	0,
	3511,
	3513);
INSERT INTO R_RTO
	VALUES (707,
	3511,
	3513,
	0);
INSERT INTO R_OIR
	VALUES (707,
	3511,
	3513,
	0);
INSERT INTO R_FORM
	VALUES (3435,
	3511,
	3512,
	1,
	1,
	'may contain');
INSERT INTO R_RGO
	VALUES (3435,
	3511,
	3512);
INSERT INTO R_OIR
	VALUES (3435,
	3511,
	3512,
	9186);
INSERT INTO R_SIMP
	VALUES (9205);
INSERT INTO R_REL
	VALUES (9205,
	4605,
	'',
	9183);
INSERT INTO R_PART
	VALUES (707,
	9205,
	9206,
	0,
	1,
	'exists in');
INSERT INTO O_RTIDA
	VALUES (758,
	707,
	0,
	9205,
	9206);
INSERT INTO R_RTO
	VALUES (707,
	9205,
	9206,
	0);
INSERT INTO R_OIR
	VALUES (707,
	9205,
	9206,
	0);
INSERT INTO R_FORM
	VALUES (2807,
	9205,
	9207,
	1,
	1,
	'contains');
INSERT INTO R_RGO
	VALUES (2807,
	9205,
	9207);
INSERT INTO R_OIR
	VALUES (2807,
	9205,
	9207,
	9187);
INSERT INTO R_SIMP
	VALUES (9208);
INSERT INTO R_REL
	VALUES (9208,
	4608,
	'CrossComponent:true',
	9183);
INSERT INTO R_FORM
	VALUES (709,
	9208,
	9209,
	1,
	1,
	'is root for');
INSERT INTO R_RGO
	VALUES (709,
	9208,
	9209);
INSERT INTO R_OIR
	VALUES (709,
	9208,
	9209,
	9185);
INSERT INTO R_PART
	VALUES (707,
	9208,
	9210,
	0,
	1,
	'has root');
INSERT INTO O_RTIDA
	VALUES (758,
	707,
	0,
	9208,
	9210);
INSERT INTO R_RTO
	VALUES (707,
	9208,
	9210,
	0);
INSERT INTO R_OIR
	VALUES (707,
	9208,
	9210,
	0);
INSERT INTO S_SIS
	VALUES (8619,
	9183);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (9190,
	'Component Package in Package',
	4601,
	'CP_CPINP',
	'',
	9183);
INSERT INTO O_TFR
	VALUES (9211,
	9190,
	'dispose',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one componentPackage related by self->CP_CP[R4601];
if(not_empty componentPackage)
  unrelate self from componentPackage across R4601;
  componentPackage.dispose();
end if;
select one componentPackage related by self->CP_CP[R4600];
if(not_empty componentPackage)
  unrelate self from componentPackage across R4600;
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_NBATTR
	VALUES (9195,
	9190);
INSERT INTO O_BATTR
	VALUES (9195,
	9190);
INSERT INTO O_ATTR
	VALUES (9195,
	9190,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	296,
	'',
	'');
INSERT INTO O_REF
	VALUES (9190,
	707,
	0,
	758,
	9188,
	9191,
	9189,
	9212,
	9213,
	0,
	0,
	'',
	'Component Package',
	'Package_ID',
	'R4600');
INSERT INTO O_RATTR
	VALUES (9212,
	9190,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (9212,
	9190,
	9195,
	'Parent_Package_ID',
	'',
	'Parent_',
	'Package_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	9190);
INSERT INTO O_OIDA
	VALUES (9195,
	9190,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	9190);
INSERT INTO O_ID
	VALUES (2,
	9190);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (707,
	'Component Package',
	4600,
	'CP_CP',
	'',
	9183);
INSERT INTO O_TFR
	VALUES (9214,
	707,
	'dispose',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one componentPiP related by self->CP_CPINP[R4601];
if(not_empty componentPiP)
  unrelate self from componentPiP across R4601;
  componentPiP.dispose();
end if;
select many pips related by self->CP_CPINP[R4600];
for each pip in pips
  unrelate self from pip across R4600;
  pip.dispose();
end for;
select many components related by self->C_C[R4604];
for each component in components
  component.dispose();
end for;
select many icomponents related by self->CL_IC[R4605];
for each icomponent in icomponents
  icomponent.dispose();
end for;
select one system related by self->S_SYS[R4602];
if(not_empty system)
  unrelate self from system across R4602;
end if;
select one system related by self->S_SYS[R4606];
if(not_empty system)
  unrelate self from system across R4606;
end if;
select many interfacePackages related by self->IP_IP[R4607];
for each interfacePackage in interfacePackages
  unrelate interfacePackage from self across R4607;
  interfacePackage.dispose();
end for;
select many components related by self->C_C[R4608];
for each component in components
  unrelate component from self across R4608;
  component.dispose();
end for;

select many sicps related by self->PA_SICP[R9001];
for each sicp in sicps
  select one satisfaction related by sicp->C_SF[R9001];
  unrelate self from satisfaction across R9001 using sicp;
  // no need to dispose satisfaction, it will get
  // disposed later
  delete object instance sicp;
end for;

// dispose informal diagrams
select many sequences related by self->SQ_S[R951];
for each sequence in sequences
  unrelate self from sequence across R951;
  sequence.dispose();
end for;

select many activities related by self->A_A[R1114];
for each activity in activities
  unrelate self from activity across R1114;
  activity.dispose();
end for;

select many comms related by self->COMM_COMM[R1137];
for each comm in comms
  unrelate self from comm across R1137;
  comm.dispose();
end for;

select many uccs related by self->UC_UCC[R1212];
for each ucc in uccs
  unrelate self from ucc across R1212;
  ucc.dispose();
end for;

select one specPkg related by self->EP_SPKG[R1402];

delete object instance self;

// we must dispose the supertype after the
// subtype to allow access to the id through
// the supertype
if(not_empty specPkg)
  unrelate self from specPkg across R1402;
  specPkg.dispose();
end if;',
	1,
	'',
	9215);
INSERT INTO O_TFR
	VALUES (9216,
	707,
	'getPath',
	'',
	322,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
path = self.Name;
if(param.path != "")
  path = path + "::" + param.path;
end if;
select one system related by self->S_SYS[R4602];
if(not_empty system)
  return system.Name + "::" + path;
else
  select one cpip related by self->CP_CPINP[R4601]->CP_CP[R4600];
  if(not_empty cpip)
    return cpip.getPath(path:path);
  else
    select one package related by self->EP_SPKG[R1402]->EP_PKG[R1400];
    if(not_empty package)
      return package.getPath(path:path);
    end if;
  end if;
end if;
return "";',
	1,
	'',
	9214);
INSERT INTO O_TPARM
	VALUES (9217,
	9216,
	'path',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9218,
	707,
	'initialize',
	'',
	19,
	1,
	'self.Name = ::getUniqueInitialName( 
    instance: self.convertToInstance(), 
    candidateName: "Unnamed Component Package" );',
	1,
	'',
	9219);
INSERT INTO O_TFR
	VALUES (9220,
	707,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'return this;',
	0,
	'',
	9221);
INSERT INTO O_TFR
	VALUES (9222,
	707,
	'newRequirement',
	'',
	316,
	1,
	'select any component related by self->C_C[R4604] where (selected.Id == param.from);
select any provision related by self->C_C[R4604]->C_PO[R4010]->C_IR[R4016]->C_P[R4009] where (selected.Provision_Id == param.to);
select any importedRef from instances of CL_IIR where (selected.Id == param.to);
if(not_empty provision and not_empty component)
  return component.initializeRequirement(provision_id:provision.Provision_Id, requirement_id:GD::NULL_UNIQUE_ID(), proceed: true);
end if;
if(not_empty importedRef) and (not_empty component)
  return component.initializeRequirement(provision_id:importedRef.Id, requirement_id:GD::NULL_UNIQUE_ID(), proceed:true);
end if;
if(not_empty component)
  return component.initializeRequirement(provision_id:GD::NULL_UNIQUE_ID(), requirement_id:GD::NULL_UNIQUE_ID(), proceed:true);
end if;
return false;',
	1,
	'',
	9223);
INSERT INTO O_TPARM
	VALUES (9224,
	9222,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9225,
	9222,
	'to',
	296,
	0,
	'',
	9226,
	'');
INSERT INTO O_TPARM
	VALUES (9227,
	9222,
	'toIsImported',
	316,
	0,
	'',
	9225,
	'');
INSERT INTO O_TPARM
	VALUES (9226,
	9222,
	'fromIsImported',
	316,
	0,
	'',
	9224,
	'');
INSERT INTO O_TFR
	VALUES (9223,
	707,
	'newProvision',
	'',
	316,
	1,
	'select any component related by self->C_C[R4604] where (selected.Id == param.from);
select any requirement related by self->C_C[R4604]->C_PO[R4010]->C_IR[R4016]->C_R[R4009] where (selected.Requirement_Id == param.to);
select any importedRef from instances of CL_IIR where (selected.Id == param.to);
if(not_empty requirement) and (not_empty component)
  return component.initializeProvision(requirement_id:requirement.Requirement_Id, provision_id:GD::NULL_UNIQUE_ID(), proceed:true);
end if;
if(not_empty importedRef) and (not_empty component)
  return component.initializeProvision(requirement_id:importedRef.Id, provision_id:GD::NULL_UNIQUE_ID(), proceed:true);
end if;
if(empty requirement and not_empty component)
  return component.initializeProvision(requirement_id:GD::NULL_UNIQUE_ID(), provision_id:GD::NULL_UNIQUE_ID(), proceed:true);
end if;
return false;',
	1,
	'',
	9228);
INSERT INTO O_TPARM
	VALUES (9229,
	9223,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9230,
	9223,
	'fromIsImported',
	316,
	0,
	'',
	9229,
	'');
INSERT INTO O_TPARM
	VALUES (9231,
	9223,
	'toIsImported',
	316,
	0,
	'',
	9232,
	'');
INSERT INTO O_TPARM
	VALUES (9232,
	9223,
	'to',
	296,
	0,
	'',
	9230,
	'');
INSERT INTO O_TFR
	VALUES (9233,
	707,
	'newComponent',
	'',
	19,
	1,
	'create object instance component of C_C;
relate component to self across R4604;
relate self to component across R4608;
component.initialize();',
	1,
	'',
	9234);
INSERT INTO O_TFR
	VALUES (9235,
	707,
	'newImportedComponent',
	'',
	19,
	1,
	'create object instance importedComp of CL_IC;
relate importedComp to self across R4605;',
	1,
	'',
	9236);
INSERT INTO O_TFR
	VALUES (9237,
	707,
	'get_style',
	'',
	784,
	1,
	'return Style::Folder;',
	1,
	'',
	9238);
INSERT INTO O_TFR
	VALUES (9239,
	707,
	'get_entries',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	9240);
INSERT INTO O_TPARM
	VALUES (9241,
	9239,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9240,
	707,
	'get_compartments',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	9242);
INSERT INTO O_TFR
	VALUES (9242,
	707,
	'get_compartment_text',
	'',
	322,
	1,
	'// The component package symbol only contains its name
// appended by the component stereotype
result = "";
if (param.at == Justification::Center_in_X)
  result = "component";
elif (param.at == Justification::Center)
  result = self.Name;
end if;
return result;',
	1,
	'',
	9216);
INSERT INTO O_TPARM
	VALUES (9243,
	9242,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9244,
	9242,
	'ent_num',
	298,
	0,
	'',
	9245,
	'');
INSERT INTO O_TPARM
	VALUES (9245,
	9242,
	'comp_num',
	298,
	0,
	'',
	9243,
	'');
INSERT INTO O_TFR
	VALUES (9219,
	707,
	'get_text_style',
	'',
	784,
	1,
	'return Style::None;',
	1,
	'',
	9237);
INSERT INTO O_TPARM
	VALUES (9246,
	9219,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9247,
	9219,
	'ent_num',
	298,
	0,
	'',
	9248,
	'');
INSERT INTO O_TPARM
	VALUES (9248,
	9219,
	'comp_num',
	298,
	0,
	'',
	9246,
	'');
INSERT INTO O_TFR
	VALUES (9236,
	707,
	'newComponentPackage',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
create object instance package of CP_CP;
create object instance pip of CP_CPINP;
create object instance sp of EP_SPKG;
relate sp to package across R1402;
relate self to pip across R4600;
relate pip to package across R4601;
select one system related by self->S_SYS[R4606];
relate package to system across R4606;
package.initialize();',
	1,
	'',
	9233);
INSERT INTO O_TFR
	VALUES (9228,
	707,
	'newInterfacePackage',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
create object instance interfacePackage of IP_IP;
create object instance sp of EP_SPKG;
relate interfacePackage to sp across R1402;
relate self to interfacePackage across R4607;
select one system related by self->S_SYS[R4606];
relate system to interfacePackage across R4304;
interfacePackage.initialize();',
	1,
	'',
	9235);
INSERT INTO O_TFR
	VALUES (9249,
	707,
	'interfacePackageIsAlongParentPath',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// see if the interface package is defined in this
// component package or any nested one under this package
select any interfacePackage related by self->IP_IP[R4607] where (selected.Package_ID == param.id);
if(empty interfacePackage)
  select many interfacePackages related by self->IP_IP[R4607];
  for each interfacePkg in interfacePackages
    result = interfacePkg.isChildPackageOf(Id:interfacePkg.Package_ID);
    if(result)
      return true;
    end if;
  end for;
  select one parentSystem related by self->S_SYS[R4602];
  select one parentCP related by self->CP_CPINP[R4601]->CP_CP[R4600];
  while(empty parentSystem)
    select any interfacePackage related by parentCP->IP_IP[R4607] where (selected.Package_ID == param.id);
    if(empty interfacePackage)
      select many interfacePackages related by parentCP->IP_IP[R4607];
      for each interfacePkg in interfacePackages
        result = interfacePkg.isChildPackageOf(Id:interfacePkg.Package_ID);
        if(result)
          return true;
        end if;
      end for;
    else
      return true;
    end if;
    select one parentSystem related by parentCP->S_SYS[R4602];
    select one parentCP related by parentCP->CP_CPINP[R4601]->CP_CP[R4600];
  end while;
else
  return true;
end if;
select one system related by self->S_SYS[R4606];
select any interfacePackage related by system->IP_IP[R4302] where (selected.Package_ID == param.id);
if(not_empty interfacePackage)
  return true;
else
  // check all children which have a parent rooted
  // at the system package
  select many interfacePackages related by system->IP_IP[R4302];
  for each interfacePackage in interfacePackages
    result = interfacePackage.isChildPackageOf(Id:param.id);
    if(result)
      return true;
    end if;
  end for;
end if;
return false;',
	1,
	'',
	9218);
INSERT INTO O_TPARM
	VALUES (9250,
	9249,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9251,
	707,
	'associatePackageWithSystem',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any system from instances of S_SYS where (selected.Sys_ID == param.sysID);
if (not_empty system)
  // Relate this package to the system
  shouldRelate = true;
  select one existSystem related by self->S_SYS[R4606];
  if (not_empty existSystem)
    if(system == existSystem)
      shouldRelate = false;  
    end if; 
  end if;
  if(shouldRelate)
    if(not_empty existSystem)
      unrelate self from existSystem across R4606;
    end if;
    relate self to system across R4606;
  end if;

  // Setup R4304 for all CP_CPs that contain IP_IP''s
  select many ips related by self->IP_IP[R4607];  
  for each ip in ips 
    ip.associatePackageWithSystem(sysID:system.Sys_ID);
  end for;

  // Setup R4308 for all components that contain IP_IP''s
  select many components related by self->C_C[R4608];
  for each component in components
    select many ips related by component->IP_IP[R4206];
    for each ip in ips
      ip.associatePackageWithSystem(sysID:system.Sys_ID);
    end for;
  end for;

  // relate all child packages recursively
  select many childPkgs related by self->CP_CPINP[R4600]->CP_CP[R4601];
  for each childPkg in childPkgs
    childPkg.associatePackageWithSystem(sysID:system.Sys_ID);
  end for;
end if;',
	1,
	'',
	9252);
INSERT INTO O_TPARM
	VALUES (9253,
	9251,
	'sysID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9252,
	707,
	'actionFilter',
	'',
	316,
	1,
	'result = false;
if(param.name == "can")
  if(param.value == "launchVerifier")
    select many components related by self->C_C[R4604];
    for each component in components
      result = component.actionFilter(name:param.name, value:param.value);
      if(result)
        break;
      end if;
    end for;
    if(not result)
      select many importedComponents related by self->CL_IC[R4605];
      for each importedComponent in importedComponents
        result = importedComponent.actionFilter(name:param.name,
         	                    value:param.value);
        if(result)
          break;
        end if;
      end for;
    end if;
  end if;
end if;
return result;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (9254,
	9252,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9255,
	9252,
	'value',
	322,
	0,
	'',
	9254,
	'');
INSERT INTO O_TFR
	VALUES (9256,
	707,
	'newActivity',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
create object instance a of A_A;
create object instance sp of EP_SPKG;
relate a to sp across R1402;
relate self to a across R1114;
a.initialize();',
	1,
	'',
	9249);
INSERT INTO O_TFR
	VALUES (9257,
	707,
	'newUseCasePackage',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
create object instance ucc of UC_UCC;
create object instance sp of EP_SPKG;
relate ucc to sp across R1402;
relate self to ucc across R1212;
ucc.initialize();',
	1,
	'',
	9258);
INSERT INTO O_TFR
	VALUES (9258,
	707,
	'newSequence',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
create object instance sequence of SQ_S;
create object instance sp of EP_SPKG;
relate sequence to sp across R1402;
relate self to sequence across R951;
sequence.initialize();',
	1,
	'',
	9222);
INSERT INTO O_TFR
	VALUES (9234,
	707,
	'newCommunication',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
create object instance comm of COMM_COMM;
create object instance sp of EP_SPKG;
relate comm to sp across R1402;
relate comm to self across R1137;
comm.initialize();',
	1,
	'',
	9256);
INSERT INTO O_TFR
	VALUES (9238,
	707,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Package_ID;',
	1,
	'',
	9239);
INSERT INTO O_TFR
	VALUES (9259,
	707,
	'pasteActivity',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any activity from instances of A_A
                                        where (selected.Package_ID == param.id);
if(not_empty activity)
  // guarantee a unique name for the pasted element
  activity.Name = ::getUniqueInitialNameInParent
                                         (instance:activity.convertToInstance(),
     					   name:activity.Name, parent:self.convertToInstance());
  activity.associateWithComponentPackage(cpID:self.Package_ID);
end if;',
	1,
	'',
	9257);
INSERT INTO O_TPARM
	VALUES (9260,
	9259,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9261,
	707,
	'pasteCommunication',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any comm from instances of COMM_COMM
                                        where (selected.Package_ID == param.id);
if(not_empty comm)
  // guarantee a unique name for the pasted element
  comm.Name = ::getUniqueInitialNameInParent (instance:comm.convertToInstance(),
     					   name:comm.Name, parent:self.convertToInstance());
  comm.associateWithComponentPackage(cpID:self.Package_ID);
end if;',
	1,
	'',
	9259);
INSERT INTO O_TPARM
	VALUES (9262,
	9261,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9263,
	707,
	'associateWithPackage',
	'',
	19,
	1,
	'// unhook from current parent
self.deassociateFromParent();
// hook up with package
select any package from instances of EP_PKG
                                     where (selected.Package_ID == param.pkgID);
select one specPkg related by self->EP_SPKG[R1402];
relate specPkg to package across R1400;',
	1,
	'',
	9264);
INSERT INTO O_TPARM
	VALUES (9265,
	9263,
	'pkgID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9215,
	707,
	'deassociateFromParent',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one system related by self->S_SYS[R4602];
if(not_empty system)
  unrelate self from system across R4602;
end if;
select one specPkg related by self->EP_SPKG[R1402];
select one pkg related by specPkg->EP_PKG[R1400];
if(not_empty pkg)
  unrelate specPkg from pkg across R1400;
end if;
select one cpincp related by self->CP_CPINP[R4601];
if(not_empty cpincp)
  select one parent related by cpincp->CP_CP[R4600];
  unrelate cpincp from parent across R4600;
  unrelate cpincp from self across R4601;
  delete object instance cpincp;
end if;',
	1,
	'',
	9220);
INSERT INTO O_TFR
	VALUES (9221,
	707,
	'associateWithSystem',
	'',
	19,
	1,
	'// unhook from current parent
self.deassociateFromParent();
// hook up with system
select any system from instances of S_SYS
                                     where (selected.Sys_ID == param.sysID);
relate self to system across R4602;',
	1,
	'',
	9263);
INSERT INTO O_TPARM
	VALUES (9266,
	9221,
	'sysID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9264,
	707,
	'associateWithComponentPackage',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// unhook from current parent
self.deassociateFromParent();
// hook up with component package
select any compPkg from instances of CP_CP
                                     where (selected.Package_ID == param.cpID);
create object instance cpincp of CP_CPINP;
relate cpincp to self across R4601;
relate cpincp to compPkg across R4600;',
	1,
	'',
	9251);
INSERT INTO O_TPARM
	VALUES (9267,
	9264,
	'cpID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9268,
	707,
	'pasteComponentPackage',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any compPkg from instances of CP_CP where (selected.Package_ID == param.id);
if(not_empty compPkg)
  // guarantee a unique name for the pasted component package
  compPkg.Name = ::getUniqueInitialNameInParent(instance:compPkg.convertToInstance(),
  						name:compPkg.Name, parent:self.convertToInstance());
  compPkg.associateWithComponentPackage(cpID:self.Package_ID);  
  // associate component packages with the system 
  select one system related by self->S_SYS[R4606];
  compPkg.associatePackageWithSystem(sysID:system.Sys_ID);
  // assure that all signal events are resolved or removed
  compPkg.removeIncompleteSignalEvents();
end if;',
	1,
	'',
	9261);
INSERT INTO O_TPARM
	VALUES (9269,
	9268,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9270,
	707,
	'pasteInterfacePackage',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any ifacePkg from instances of IP_IP where (selected.Package_ID == param.id);
if(not_empty ifacePkg)
  // guarantee a unique name for the pasted dt package
  ifacePkg.Name = ::getUniqueInitialNameInParent(instance:ifacePkg.convertToInstance(),
  						name:ifacePkg.Name, parent:self.convertToInstance());
  ifacePkg.associateWithComponentPackage(cpID:self.Package_ID);  
  select one system related by self->S_SYS[R4606];
  ifacePkg.associatePackageWithSystem(sysID:system.Sys_ID);
end if;',
	1,
	'',
	9268);
INSERT INTO O_TPARM
	VALUES (9271,
	9270,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9272,
	707,
	'pasteSequence',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any seq from instances of SQ_S where (selected.Package_ID == param.id);
if(not_empty seq)
  // guarantee a unique name for the pasted element
  seq.Name = ::getUniqueInitialNameInParent (instance:seq.convertToInstance(),
         					    name:seq.Name, parent:self.convertToInstance());
  seq.associateWithComponentPackage(cpID:self.Package_ID);
end if;',
	1,
	'',
	9270);
INSERT INTO O_TPARM
	VALUES (9273,
	9272,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9274,
	707,
	'pasteUseCaseDiagram',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any ucd from instances of UC_UCC where (selected.Package_ID == param.id);
if(not_empty ucd)
  // guarantee a unique name for the pasted element
  ucd.Name = ::getUniqueInitialNameInParent (instance:ucd.convertToInstance(),
         					    name:ucd.Name, parent:self.convertToInstance());
  ucd.associateWithComponentPackage(cpID:self.Package_ID);
end if;',
	1,
	'',
	9272);
INSERT INTO O_TPARM
	VALUES (9275,
	9274,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9276,
	707,
	'getCompPckgCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many compPckgs related by self->CP_CPINP[R4600]->CP_CP[R4601];
return cardinality compPckgs;',
	1,
	'',
	9274);
INSERT INTO O_TFR
	VALUES (9277,
	707,
	'getCompPckgId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many compPckgs related by self->CP_CPINP[R4600]->CP_CP[R4601];
// We''re preincrementing the index
count = -1;
for each compPckg in compPckgs
  if (not_empty compPckg)
      count = count+1;
  end if;
  if (count == param.index)
      return compPckg.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	9276);
INSERT INTO O_TPARM
	VALUES (9278,
	9277,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9279,
	707,
	'getInterfacePckgCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many interfacePckgs related by self->IP_IP[R4607];
return cardinality interfacePckgs;',
	1,
	'',
	9277);
INSERT INTO O_TFR
	VALUES (9280,
	707,
	'getInterfacePckgId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many interfacePckgs related by self->IP_IP[R4607];
// We''re preincrementing the index
count = -1;
for each interfacePckg in interfacePckgs
  if (not_empty interfacePckg)
      count = count+1;
  end if;
  if (count == param.index)
      return interfacePckg.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	9279);
INSERT INTO O_TPARM
	VALUES (9281,
	9280,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9282,
	707,
	'getSequenceCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many sequences related by self->SQ_S[R951];
return cardinality sequences;',
	1,
	'',
	9280);
INSERT INTO O_TFR
	VALUES (9283,
	707,
	'getSequenceId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many sequences related by self->SQ_S[R951];
// We''re preincrementing the index
count = -1;
for each sequence in sequences
  if (not_empty sequence)
      count = count+1;
  end if;
  if (count == param.index)
      return sequence.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	9282);
INSERT INTO O_TPARM
	VALUES (9284,
	9283,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9285,
	707,
	'getCommunicationCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many communications related by self->COMM_COMM[R1137];
return cardinality communications;',
	1,
	'',
	9283);
INSERT INTO O_TFR
	VALUES (9286,
	707,
	'getCommunicationId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many communications related by self->COMM_COMM[R1137];
// We''re preincrementing the index
count = -1;
for each communication in communications
  if (not_empty communication)
      count = count+1;
  end if;
  if (count == param.index)
      return communication.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	9285);
INSERT INTO O_TPARM
	VALUES (9287,
	9286,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9288,
	707,
	'getUsecaseCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many usecases related by self->UC_UCC[R1212];
return cardinality usecases;',
	1,
	'',
	9286);
INSERT INTO O_TFR
	VALUES (9289,
	707,
	'getUsecaseId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many usecases related by self->UC_UCC[R1212];
// We''re preincrementing the index
count = -1;
for each usecase in usecases
  if (not_empty usecase)
      count = count+1;
  end if;
  if (count == param.index)
      return usecase.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	9288);
INSERT INTO O_TPARM
	VALUES (9290,
	9289,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9291,
	707,
	'getActivityCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many activities related by self->A_A[R1114];
return cardinality activities;',
	1,
	'',
	9289);
INSERT INTO O_TFR
	VALUES (9292,
	707,
	'getActivityId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many activities related by self->A_A[R1114];
// We''re preincrementing the index
count = -1;
for each activity in activities
  if (not_empty activity)
      count = count+1;
  end if;
  if (count == param.index)
      return activity.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	9291);
INSERT INTO O_TPARM
	VALUES (9293,
	9292,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9294,
	707,
	'getComponentCount',
	'',
	298,
	1,
	'select many components related by self->C_C[R4604];
return cardinality components;',
	1,
	'',
	9292);
INSERT INTO O_TFR
	VALUES (9295,
	707,
	'getComponentId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many components related by self->C_C[R4604];
// We''re preincrementing the index
count = -1;
for each component in components
  if (not_empty component)
      count = count+1;
  end if;
  if (count == param.index)
      return component.Id;  
  end if;
end for;
return id;',
	1,
	'',
	9294);
INSERT INTO O_TPARM
	VALUES (9296,
	9295,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9297,
	707,
	'getComponentRefCount',
	'',
	298,
	1,
	'select many impComponents related by self->CL_IC[R4605];
return cardinality impComponents;',
	1,
	'',
	9295);
INSERT INTO O_TFR
	VALUES (9298,
	707,
	'getComponentRefId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many impComponents related by self->CL_IC[R4605];
// We''re preincrementing the index
count = -1;
for each impComponent in impComponents
  if (not_empty impComponent)
      count = count+1;
  end if;
  if (count == param.index)
      return impComponent.Id;  
  end if;
end for;
return id;',
	1,
	'',
	9297);
INSERT INTO O_TPARM
	VALUES (9299,
	9298,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9300,
	707,
	'getSystemId',
	'',
	296,
	1,
	'// Component Package.getSystemId()
select one system related by self->S_SYS[R4606];
if not_empty system
  return system.Sys_ID;
end if;
USER::logError(msg:"Component Package.getSystemId: No system found.",path:"");
return GD::NULL_UNIQUE_ID();',
	1,
	'',
	9298);
INSERT INTO O_TFR
	VALUES (9301,
	707,
	'pasteComponent',
	'',
	19,
	1,
	'select any component from instances of C_C where (selected.Id == param.id);
if(not_empty component)
  relate component to self across R4604;
  relate component to self across R4608;
  component.rename(new_name: ::getUniqueInitialNameInParent(
                                         instance:component.convertToInstance(),
                        name: component.Name, parent:self.convertToInstance()));
  component.associateChildrenWithRootComponentPackage();
  // resolve any non local events associated with children of
  // this component
  component.removeIncompleteSignalEvents();
end if;',
	1,
	'',
	9300);
INSERT INTO O_TPARM
	VALUES (9302,
	9301,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9303,
	707,
	'pasteRequirement',
	'',
	19,
	1,
	'// no need to hook anything up, all data will be present',
	1,
	'',
	9301);
INSERT INTO O_TPARM
	VALUES (9304,
	9303,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9305,
	707,
	'pasteComponentReference',
	'',
	19,
	1,
	'select any ref from instances of CL_IC where (selected.Id == param.id);
if(not_empty ref)
  relate ref to self across R4605;
end if;',
	1,
	'',
	9303);
INSERT INTO O_TPARM
	VALUES (9306,
	9305,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9307,
	707,
	'pasteProvision',
	'',
	19,
	1,
	'select any provision from instances of C_P
                                      where (selected.Provision_Id == param.id);
if(not_empty provision)
  // dispose any satisfactions that are not complete
  // this can occur because the export includes them
  // regardless of whether or not they are complete
  select many satisfactions related by provision->C_SF[R4002];
  for each satisfaction in satisfactions
    select one requirement related by satisfaction->C_R[R4002];
    if(not_empty requirement
                     and Util::isProxy(element:requirement.convertToInstance()))
      // if this satisfaction is connected to an imported requirement, that
      // is not a proxy, we do not want to dispose
      select one importedReq related by satisfaction->CL_IR[R4706];
      if(empty importedReq 
                      or Util::isProxy(element:importedReq.convertToInstance()))
        satisfaction.dispose();
      end if;
    end if;
  end for;
end if;
',
	1,
	'',
	9305);
INSERT INTO O_TPARM
	VALUES (9308,
	9307,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9309,
	707,
	'removeIncompleteSignalEvents',
	'',
	19,
	1,
	'// for all components under this package, remove any non local
// events that cannot be resolved
select many components related by self->C_C[R4604];
for each component in components
  component.removeIncompleteSignalEvents();
end for;
// for all nested packages recursively call this method
select many packages related by self->CP_CPINP[R4600]->CP_CP[R4601];
for each package in packages
  package.removeIncompleteSignalEvents();
end for;',
	1,
	'',
	9307);
INSERT INTO O_TFR
	VALUES (9310,
	707,
	'pasteImportedProvision',
	'',
	19,
	1,
	'select any iPro from instances of CL_IP where (selected.Id == param.id);
if(not_empty iPro)
  // dispose any satisfactions that are not complete
  // this can occur because the export includes them
  // regardless of whether or not they are complete
  select many satisfactions related by iPro->CL_IPINS[R4705]->C_SF[R4705];
  for each satisfaction in satisfactions
    select one requirement related by satisfaction->C_R[R4002];
    if(not_empty requirement
                     and Util::isProxy(element:requirement.convertToInstance()))
      // if this satisfaction is connected to an imported requirement, that
      // is not a proxy, we do not want to dispose
      select one importedReq related by satisfaction->CL_IR[R4706];
      if(empty importedReq 
                      or Util::isProxy(element:importedReq.convertToInstance()))
        satisfaction.dispose();
      end if;
    end if;
  end for;
end if;',
	1,
	'',
	9309);
INSERT INTO O_TPARM
	VALUES (9311,
	9310,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9312,
	707,
	'pasteImportedRequirement',
	'',
	19,
	1,
	'// nothing needed here',
	1,
	'',
	9310);
INSERT INTO O_TPARM
	VALUES (9313,
	9312,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9314,
	707,
	'collectReferencesForSynchronization',
	'',
	19,
	1,
	'/**
 *  Call on all components are nested component packages, add all
 *  component references
 */
if(param.syncType == SynchronizationType::Pull)
  select many componentRefs related by self->CL_IC[R4605];
  for each componentRef in componentRefs
    Util::addElementToList(elementList:param.referenceList,
                                      element:componentRef.convertToInstance());
    componentRef.collectReferencesForSynchronization(
                    referenceList:param.referenceList, syncType:param.syncType);
  end for;
end if;
select many componentPkgs related by self->CP_CPINP[R4600]->CP_CP[R4601];
for each componentPkg in componentPkgs
  componentPkg.collectReferencesForSynchronization(
                   referenceList:param.referenceList, syncType: param.syncType);
end for;
select many components related by self->C_C[R4604];
for each component in components
  component.collectReferencesForSynchronization(
                   referenceList:param.referenceList, syncType: param.syncType);
end for;
select many interfacePkgs related by self->IP_IP[R4607];
for each interfacePkg in interfacePkgs
  interfacePkg.collectReferencesForSynchronization(
                   referenceList:param.referenceList, syncType: param.syncType);
end for;',
	1,
	'',
	9312);
INSERT INTO O_TPARM
	VALUES (9315,
	9314,
	'referenceList',
	317,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9316,
	9314,
	'syncType',
	3500,
	0,
	'',
	9315,
	'');
INSERT INTO O_NBATTR
	VALUES (9317,
	707);
INSERT INTO O_BATTR
	VALUES (9317,
	707);
INSERT INTO O_ATTR
	VALUES (9317,
	707,
	9318,
	'Name',
	'Full Name: Package Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (9319,
	707);
INSERT INTO O_BATTR
	VALUES (9319,
	707);
INSERT INTO O_ATTR
	VALUES (9319,
	707,
	9317,
	'Descrip',
	'Full Name: Package Description',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (707,
	9190,
	0,
	9195,
	9192,
	9193,
	9194,
	9320,
	9321,
	0,
	0,
	'',
	'Component Package in Package',
	'Id',
	'R4601');
INSERT INTO O_RATTR
	VALUES (9320,
	707,
	9195,
	9190,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (9320,
	707,
	758,
	'ParentLink_Id',
	'',
	'ParentLink_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (707,
	705,
	0,
	754,
	9196,
	9198,
	9197,
	9322,
	9323,
	0,
	0,
	'',
	'System Model',
	'Sys_ID',
	'R4602');
INSERT INTO O_RATTR
	VALUES (9322,
	707,
	754,
	705,
	1,
	'Sys_ID');
INSERT INTO O_ATTR
	VALUES (9322,
	707,
	9320,
	'Sys_ID',
	'',
	'',
	'Sys_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (707,
	705,
	0,
	754,
	9202,
	9204,
	9203,
	9318,
	9324,
	0,
	0,
	'',
	'System Model',
	'Sys_ID',
	'R4606');
INSERT INTO O_RATTR
	VALUES (9318,
	707,
	754,
	705,
	1,
	'Sys_ID');
INSERT INTO O_ATTR
	VALUES (9318,
	707,
	9322,
	'Containing_Sys_ID',
	'',
	'Containing_',
	'Sys_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (707,
	773,
	0,
	772,
	854,
	6808,
	856,
	758,
	9325,
	0,
	0,
	'',
	'Specification Package',
	'Package_ID',
	'R1402');
INSERT INTO O_RATTR
	VALUES (758,
	707,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (758,
	707,
	0,
	'Package_ID',
	'',
	'',
	'SpecificationPackage_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	707);
INSERT INTO O_OIDA
	VALUES (758,
	707,
	0,
	'Package_ID');
INSERT INTO O_ID
	VALUES (1,
	707);
INSERT INTO O_ID
	VALUES (2,
	707);
-- BP 7.1 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (9326,
	'Component Nesting',
	'// This is used by schema_gen to ignore this subsystem (for publication)
TRANSLATE_FOR_EXTERNAL_USE:FALSE

The Component Diagram subsystem captures data specific to diagram behavior.',
	'CD',
	4200,
	1,
	0);
INSERT INTO O_IOBJ
	VALUES (9327,
	709,
	0,
	9326,
	'Component',
	'C_C');
INSERT INTO O_IOBJ
	VALUES (9328,
	699,
	0,
	9326,
	'Domain',
	'S_DOM');
INSERT INTO O_IOBJ
	VALUES (9329,
	3435,
	0,
	9326,
	'Interface Package',
	'IP_IP');
INSERT INTO O_IOBJ
	VALUES (9330,
	2807,
	0,
	9326,
	'Component Reference',
	'CL_IC');
INSERT INTO R_SIMP
	VALUES (9331);
INSERT INTO R_REL
	VALUES (9331,
	4202,
	'',
	9326);
INSERT INTO R_PART
	VALUES (709,
	9331,
	9332,
	0,
	0,
	'can be nested in');
INSERT INTO O_RTIDA
	VALUES (762,
	709,
	0,
	9331,
	9332);
INSERT INTO R_RTO
	VALUES (709,
	9331,
	9332,
	0);
INSERT INTO R_OIR
	VALUES (709,
	9331,
	9332,
	9327);
INSERT INTO R_FORM
	VALUES (9333,
	9331,
	9334,
	1,
	1,
	'can nest');
INSERT INTO R_RGO
	VALUES (9333,
	9331,
	9334);
INSERT INTO R_OIR
	VALUES (9333,
	9331,
	9334,
	0);
INSERT INTO R_SIMP
	VALUES (9335);
INSERT INTO R_REL
	VALUES (9335,
	4203,
	'',
	9326);
INSERT INTO R_FORM
	VALUES (709,
	9335,
	9336,
	0,
	0,
	'nests');
INSERT INTO R_RGO
	VALUES (709,
	9335,
	9336);
INSERT INTO R_OIR
	VALUES (709,
	9335,
	9336,
	9327);
INSERT INTO R_PART
	VALUES (9333,
	9335,
	9337,
	0,
	1,
	'is nested through');
INSERT INTO O_RTIDA
	VALUES (9338,
	9333,
	0,
	9335,
	9337);
INSERT INTO R_RTO
	VALUES (9333,
	9335,
	9337,
	0);
INSERT INTO R_OIR
	VALUES (9333,
	9335,
	9337,
	0);
INSERT INTO R_ASSOC
	VALUES (9339);
INSERT INTO R_REL
	VALUES (9339,
	4204,
	'',
	9326);
INSERT INTO R_AONE
	VALUES (709,
	9339,
	9340,
	0,
	1,
	'defined subject matter for');
INSERT INTO O_RTIDA
	VALUES (762,
	709,
	0,
	9339,
	9340);
INSERT INTO R_RTO
	VALUES (709,
	9339,
	9340,
	0);
INSERT INTO R_OIR
	VALUES (709,
	9339,
	9340,
	9327);
INSERT INTO R_AOTH
	VALUES (699,
	9339,
	9341,
	0,
	1,
	'has subject matter of');
INSERT INTO O_RTIDA
	VALUES (712,
	699,
	0,
	9339,
	9341);
INSERT INTO R_RTO
	VALUES (699,
	9339,
	9341,
	0);
INSERT INTO R_OIR
	VALUES (699,
	9339,
	9341,
	9328);
INSERT INTO R_ASSR
	VALUES (9342,
	9339,
	9343,
	0);
INSERT INTO R_RGO
	VALUES (9342,
	9339,
	9343);
INSERT INTO R_OIR
	VALUES (9342,
	9339,
	9343,
	0);
INSERT INTO R_SIMP
	VALUES (3517);
INSERT INTO R_REL
	VALUES (3517,
	4206,
	'',
	9326);
INSERT INTO R_PART
	VALUES (709,
	3517,
	3519,
	0,
	1,
	'may be contained in');
INSERT INTO O_RTIDA
	VALUES (762,
	709,
	0,
	3517,
	3519);
INSERT INTO R_RTO
	VALUES (709,
	3517,
	3519,
	0);
INSERT INTO R_OIR
	VALUES (709,
	3517,
	3519,
	9327);
INSERT INTO R_FORM
	VALUES (3435,
	3517,
	3518,
	1,
	1,
	'may contain');
INSERT INTO R_RGO
	VALUES (3435,
	3517,
	3518);
INSERT INTO R_OIR
	VALUES (3435,
	3517,
	3518,
	9329);
INSERT INTO R_SIMP
	VALUES (9344);
INSERT INTO R_REL
	VALUES (9344,
	4201,
	'CrossComponent:true',
	9326);
INSERT INTO R_FORM
	VALUES (2807,
	9344,
	9345,
	1,
	1,
	'is represented by');
INSERT INTO R_RGO
	VALUES (2807,
	9344,
	9345);
INSERT INTO R_OIR
	VALUES (2807,
	9344,
	9345,
	9330);
INSERT INTO R_PART
	VALUES (709,
	9344,
	9346,
	0,
	1,
	'represents');
INSERT INTO O_RTIDA
	VALUES (762,
	709,
	0,
	9344,
	9346);
INSERT INTO R_RTO
	VALUES (709,
	9344,
	9346,
	0);
INSERT INTO R_OIR
	VALUES (709,
	9344,
	9346,
	9327);
INSERT INTO R_SIMP
	VALUES (9347);
INSERT INTO R_REL
	VALUES (9347,
	4205,
	'',
	9326);
INSERT INTO R_FORM
	VALUES (2807,
	9347,
	9348,
	1,
	1,
	'nests');
INSERT INTO R_RGO
	VALUES (2807,
	9347,
	9348);
INSERT INTO R_OIR
	VALUES (2807,
	9347,
	9348,
	9330);
INSERT INTO R_PART
	VALUES (709,
	9347,
	9349,
	0,
	1,
	'nested in');
INSERT INTO O_RTIDA
	VALUES (762,
	709,
	0,
	9347,
	9349);
INSERT INTO R_RTO
	VALUES (709,
	9347,
	9349,
	0);
INSERT INTO R_OIR
	VALUES (709,
	9347,
	9349,
	9327);
INSERT INTO S_SIS
	VALUES (8619,
	9326);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (9342,
	'Domain As Component',
	4203,
	'CN_DC',
	'',
	9326);
INSERT INTO O_REF
	VALUES (9342,
	699,
	0,
	712,
	9339,
	9343,
	9341,
	9350,
	9351,
	0,
	0,
	'',
	'Domain',
	'Dom_ID',
	'R4204');
INSERT INTO O_RATTR
	VALUES (9350,
	9342,
	712,
	699,
	1,
	'Dom_ID');
INSERT INTO O_ATTR
	VALUES (9350,
	9342,
	9352,
	'Dom_ID',
	'',
	'',
	'Dom_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (9342,
	709,
	0,
	762,
	9339,
	9343,
	9340,
	9352,
	9353,
	0,
	0,
	'',
	'Component',
	'Id',
	'R4204');
INSERT INTO O_RATTR
	VALUES (9352,
	9342,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (9352,
	9342,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	9342);
INSERT INTO O_OIDA
	VALUES (9350,
	9342,
	0,
	'Dom_ID');
INSERT INTO O_OIDA
	VALUES (9352,
	9342,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	9342);
INSERT INTO O_ID
	VALUES (2,
	9342);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (9333,
	'Component in Component',
	4202,
	'CN_CIC',
	'',
	9326);
INSERT INTO O_NBATTR
	VALUES (9338,
	9333);
INSERT INTO O_BATTR
	VALUES (9338,
	9333);
INSERT INTO O_ATTR
	VALUES (9338,
	9333,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	296,
	'',
	'');
INSERT INTO O_REF
	VALUES (9333,
	709,
	0,
	762,
	9331,
	9334,
	9332,
	9354,
	9355,
	0,
	0,
	'',
	'Component',
	'Id',
	'R4202');
INSERT INTO O_RATTR
	VALUES (9354,
	9333,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (9354,
	9333,
	9338,
	'Parent_Id',
	'',
	'Parent_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	9333);
INSERT INTO O_OIDA
	VALUES (9338,
	9333,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	9333);
INSERT INTO O_ID
	VALUES (2,
	9333);
-- BP 7.1 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (9356,
	'Component Library',
	'',
	'CL',
	4700,
	1,
	0);
INSERT INTO O_IOBJ
	VALUES (9357,
	8648,
	0,
	9356,
	'Interface Reference',
	'C_IR');
INSERT INTO O_IOBJ
	VALUES (9358,
	2762,
	0,
	9356,
	'Delegation',
	'C_DG');
INSERT INTO O_IOBJ
	VALUES (9359,
	2765,
	0,
	9356,
	'Satisfaction',
	'C_SF');
INSERT INTO R_SIMP
	VALUES (9360);
INSERT INTO R_REL
	VALUES (9360,
	4700,
	'',
	9356);
INSERT INTO R_PART
	VALUES (2807,
	9360,
	9361,
	0,
	0,
	'originates from');
INSERT INTO O_RTIDA
	VALUES (4175,
	2807,
	0,
	9360,
	9361);
INSERT INTO R_RTO
	VALUES (2807,
	9360,
	9361,
	0);
INSERT INTO R_OIR
	VALUES (2807,
	9360,
	9361,
	0);
INSERT INTO R_FORM
	VALUES (9362,
	9360,
	9363,
	1,
	1,
	'communicates through');
INSERT INTO R_RGO
	VALUES (9362,
	9360,
	9363);
INSERT INTO R_OIR
	VALUES (9362,
	9360,
	9363,
	0);
INSERT INTO R_SIMP
	VALUES (9364);
INSERT INTO R_REL
	VALUES (9364,
	4701,
	'CrossComponent:true',
	9356);
INSERT INTO R_PART
	VALUES (8648,
	9364,
	9365,
	0,
	1,
	'imports');
INSERT INTO O_RTIDA
	VALUES (8650,
	8648,
	0,
	9364,
	9365);
INSERT INTO R_RTO
	VALUES (8648,
	9364,
	9365,
	0);
INSERT INTO R_OIR
	VALUES (8648,
	9364,
	9365,
	9357);
INSERT INTO R_FORM
	VALUES (9362,
	9364,
	9366,
	1,
	1,
	'is imported');
INSERT INTO R_RGO
	VALUES (9362,
	9364,
	9366);
INSERT INTO R_OIR
	VALUES (9362,
	9364,
	9366,
	0);
INSERT INTO R_SUBSUP
	VALUES (9367);
INSERT INTO R_REL
	VALUES (9367,
	4703,
	'',
	9356);
INSERT INTO R_SUPER
	VALUES (9362,
	9367,
	9368);
INSERT INTO O_RTIDA
	VALUES (9369,
	9362,
	0,
	9367,
	9368);
INSERT INTO R_RTO
	VALUES (9362,
	9367,
	9368,
	0);
INSERT INTO R_OIR
	VALUES (9362,
	9367,
	9368,
	0);
INSERT INTO R_SUB
	VALUES (9370,
	9367,
	9371);
INSERT INTO R_RGO
	VALUES (9370,
	9367,
	9371);
INSERT INTO R_OIR
	VALUES (9370,
	9367,
	9371,
	0);
INSERT INTO R_SUB
	VALUES (9372,
	9367,
	9373);
INSERT INTO R_RGO
	VALUES (9372,
	9367,
	9373);
INSERT INTO R_OIR
	VALUES (9372,
	9367,
	9373,
	0);
INSERT INTO R_SIMP
	VALUES (9374);
INSERT INTO R_REL
	VALUES (9374,
	4704,
	'CrossComponent:true',
	9356);
INSERT INTO R_FORM
	VALUES (9362,
	9374,
	9375,
	0,
	1,
	'delivers communication through');
INSERT INTO R_RGO
	VALUES (9362,
	9374,
	9375);
INSERT INTO R_OIR
	VALUES (9362,
	9374,
	9375,
	0);
INSERT INTO R_PART
	VALUES (2762,
	9374,
	9376,
	0,
	1,
	'accepts communication through');
INSERT INTO O_RTIDA
	VALUES (2771,
	2762,
	0,
	9374,
	9376);
INSERT INTO R_RTO
	VALUES (2762,
	9374,
	9376,
	0);
INSERT INTO R_OIR
	VALUES (2762,
	9374,
	9376,
	9358);
INSERT INTO R_ASSOC
	VALUES (9377);
INSERT INTO R_REL
	VALUES (9377,
	4705,
	'CrossComponent:true',
	9356);
INSERT INTO R_AONE
	VALUES (2765,
	9377,
	9378,
	1,
	1,
	'provides satisfaction through');
INSERT INTO O_RTIDA
	VALUES (2778,
	2765,
	0,
	9377,
	9378);
INSERT INTO R_RTO
	VALUES (2765,
	9377,
	9378,
	0);
INSERT INTO R_OIR
	VALUES (2765,
	9377,
	9378,
	9359);
INSERT INTO R_AOTH
	VALUES (9370,
	9377,
	9379,
	0,
	1,
	'satisfaction made with');
INSERT INTO O_RTIDA
	VALUES (9380,
	9370,
	0,
	9377,
	9379);
INSERT INTO R_RTO
	VALUES (9370,
	9377,
	9379,
	0);
INSERT INTO R_OIR
	VALUES (9370,
	9377,
	9379,
	0);
INSERT INTO R_ASSR
	VALUES (9381,
	9377,
	9382,
	0);
INSERT INTO R_RGO
	VALUES (9381,
	9377,
	9382);
INSERT INTO R_OIR
	VALUES (9381,
	9377,
	9382,
	0);
INSERT INTO R_SIMP
	VALUES (9383);
INSERT INTO R_REL
	VALUES (9383,
	4706,
	'CrossComponent:true',
	9356);
INSERT INTO R_FORM
	VALUES (9372,
	9383,
	9384,
	0,
	1,
	'satisfaction made with');
INSERT INTO R_RGO
	VALUES (9372,
	9383,
	9384);
INSERT INTO R_OIR
	VALUES (9372,
	9383,
	9384,
	0);
INSERT INTO R_PART
	VALUES (2765,
	9383,
	9385,
	0,
	1,
	'provides satisfaction through');
INSERT INTO O_RTIDA
	VALUES (2778,
	2765,
	0,
	9383,
	9385);
INSERT INTO R_RTO
	VALUES (2765,
	9383,
	9385,
	0);
INSERT INTO R_OIR
	VALUES (2765,
	9383,
	9385,
	9359);
INSERT INTO S_SIS
	VALUES (8619,
	9356);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (9372,
	'Imported Requirement',
	4702,
	'CL_IR',
	'',
	9356);
INSERT INTO O_TFR
	VALUES (9386,
	9372,
	'get_connector_text',
	'',
	322,
	1,
	'select one satisfaction related by self->C_SF[R4706];
if(not_empty satisfaction and not param.connected_disabled)
  return "";  
else
  select one req related by self->CL_IIR[R4703]->C_IR[R4701]->C_R[R4009];
  if(empty req)
    return "";
  end if;
  if(param.at == End::Middle)
    return req.Name;
  elif(param.at == End::Start_Fixed)
    return req.get_connector_text(Obj_ID:param.Obj_ID,
    							   Obj_TypeIsImported:param.Obj_TypeIsImported,
 						    							   			at:param.at,
    							   					 parent_ID:param.parent_ID,
    				               connected_disabled:param.connected_disabled);
  end if;
end if;
return "";',
	1,
	'',
	9387);
INSERT INTO O_TPARM
	VALUES (9388,
	9386,
	'Obj_ID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9389,
	9386,
	'Obj_TypeIsImported',
	316,
	0,
	'',
	9388,
	'');
INSERT INTO O_TPARM
	VALUES (9390,
	9386,
	'at',
	880,
	0,
	'',
	9389,
	'');
INSERT INTO O_TPARM
	VALUES (9391,
	9386,
	'parent_ID',
	296,
	0,
	'',
	9390,
	'');
INSERT INTO O_TPARM
	VALUES (9392,
	9386,
	'connected_disabled',
	316,
	0,
	'',
	9391,
	'');
INSERT INTO O_TFR
	VALUES (9393,
	9372,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Id;',
	1,
	'',
	9386);
INSERT INTO O_TFR
	VALUES (9394,
	9372,
	'get_style',
	'',
	784,
	1,
	'select one requirement related by self->CL_IIR[R4703]->C_IR[R4701]->C_R[R4009];
if(not_empty requirement)
  return requirement.get_style(at:param.at);
end if;
return Style::None;',
	1,
	'',
	9393);
INSERT INTO O_TPARM
	VALUES (9395,
	9394,
	'at',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9396,
	9372,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'return this;',
	0,
	'',
	9397);
INSERT INTO O_TFR
	VALUES (9387,
	9372,
	'dispose',
	'',
	19,
	1,
	'self.dissatisfy();
select one importedRef related by self->CL_IIR[R4703];
if(not_empty importedRef)
  unrelate self from importedRef across R4703;
  importedRef.dispose();
end if;
delete object instance self;',
	1,
	'',
	9396);
INSERT INTO O_TFR
	VALUES (9398,
	9372,
	'linkConnector',
	'',
	316,
	1,
	'if(self.canLinkConnector(to:param.to))
  isLinked = false;
  select one selfImportedRef related by self->CL_IIR[R4703];
  select one component related by selfImportedRef->C_IR[R4701]->C_PO[R4016]->C_C[R4010];
  if (param.to != GD::NULL_UNIQUE_ID())
    select any provision from instances of C_P where(selected.Provision_Id == param.to);
    if (not_empty provision)
      isLinked = component.initializeRequirement(requirement_id:selfImportedRef.Id, provision_id:provision.Provision_Id, proceed:true);
    else
      select any importedRef from instances of CL_IIR where (selected.Id == param.to);
      if (not_empty importedRef)
        isLinked = component.initializeRequirement(requirement_id:selfImportedRef.Id, provision_id:importedRef.Id, proceed:true);
      end if;
    end if;    
  end if;
  return isLinked;
end if;
return false;
',
	1,
	'',
	9394);
INSERT INTO O_TPARM
	VALUES (9399,
	9398,
	'to',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9400,
	9372,
	'dissatisfy',
	'',
	19,
	1,
	'select one satisfaction related by self->C_SF[R4706];
if(not_empty satisfaction)
  unrelate self from satisfaction across R4706;
  satisfaction.dispose();
end if;',
	1,
	'',
	9398);
INSERT INTO O_TFR
	VALUES (9397,
	9372,
	'actionFilter',
	'',
	316,
	1,
	'if param.name == "can"
  if param.value == "dissatisfy"
    select one satisfaction related by self->C_SF[R4706];
    if not_empty satisfaction
      return true;
    end if;
  end if;
end if;
return false;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (9401,
	9397,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9402,
	9397,
	'value',
	322,
	0,
	'',
	9401,
	'');
INSERT INTO O_TFR
	VALUES (9403,
	9372,
	'getSatisfactionCount',
	'',
	298,
	1,
	'select one satisfaction related by self->C_SF[R4706];
if not_empty satisfaction
  return 1;
else
  return 0;
end if;',
	1,
	'',
	9400);
INSERT INTO O_TPARM
	VALUES (9404,
	9403,
	'filterDelegations',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9405,
	9372,
	'canLinkConnector',
	'',
	316,
	1,
	'isLinked = false;
select one selfImportedRef related by self->CL_IIR[R4703];
select one component related by selfImportedRef->C_IR[R4701]->C_PO[R4016]->C_C[R4010];
if (param.to != GD::NULL_UNIQUE_ID())
  select any provision from instances of C_P where(selected.Provision_Id == param.to);
  if (not_empty provision)
    isLinked = component.initializeRequirement(requirement_id:selfImportedRef.Id, provision_id:provision.Provision_Id, proceed:false);
  else
    select any importedRef from instances of CL_IIR where (selected.Id == param.to);
    if (not_empty importedRef)
      isLinked = component.initializeRequirement(requirement_id:selfImportedRef.Id, provision_id:importedRef.Id, proceed:false);
    end if;
  end if;    
end if;
return isLinked;
',
	1,
	'',
	9403);
INSERT INTO O_TPARM
	VALUES (9406,
	9405,
	'to',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9407,
	9372,
	'get_connector_tooltip',
	'',
	322,
	1,
	'select one req related by self->CL_IIR[R4703]->C_IR[R4701]->C_R[R4009];
if(not_empty req)
  return req.get_connector_tooltip(end:param.end);
end if;
return "";',
	1,
	'',
	9405);
INSERT INTO O_TPARM
	VALUES (9408,
	9407,
	'end',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9409,
	9372,
	'getConfigurationInheritanceElementId',
	'',
	317,
	1,
	'select one requirement related by self->CL_IIR[R4703]->C_IR[R4701]
                                                                   ->C_R[R4009];
if(not_empty requirement)
  return requirement.convertToInstance();
end if;
return self.convertToInstance();',
	1,
	'',
	9407);
INSERT INTO O_TFR
	VALUES (9410,
	9372,
	'isSynchronized',
	'',
	316,
	1,
	'// ask the supertype
select one importedRef related by self->CL_IIR[R4703];
if(not_empty importedRef)
  return importedRef.isSynchronized();
end if;
return true;',
	1,
	'',
	9409);
INSERT INTO O_TFR
	VALUES (9411,
	9372,
	'getCachedName',
	'Translate:native',
	322,
	1,
	'	return m_name;',
	0,
	'',
	9410);
INSERT INTO O_TFR
	VALUES (9412,
	9372,
	'setCachedName',
	'Translate:native',
	19,
	1,
	'	m_name = p_Name;',
	0,
	'',
	9411);
INSERT INTO O_TPARM
	VALUES (9413,
	9412,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9414,
	9372,
	'collectChanges',
	'',
	19,
	1,
	'/**
 *  Collect changes that will occur once this imported reference is synchronized
 */
if(not self.isSynchronized())
  // create a removal change
  Util::createElementChange(changeList: param.changeList,
                                        elementChanged:self.convertToInstance(),
                                     isRemoval:true, changeLabel:"removed");
end if;',
	1,
	'',
	9412);
INSERT INTO O_TPARM
	VALUES (9415,
	9414,
	'changeList',
	317,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9416,
	9372,
	'synchronize',
	'',
	19,
	1,
	'/*
 *  Synchronize by removing the local ref
 */
if(not self.isSynchronized())
  self.dispose();
end if;',
	1,
	'',
	9414);
INSERT INTO O_DBATTR
	VALUES (9417,
	9372,
	'name = self.getCachedName();
select one requirement related by self->CL_IIR[R4703]->C_IR[R4701]->C_R[R4009];
if(not_empty requirement)
  name = requirement.Name;
end if;
self.setCachedName(name:name);
self.Name = name;',
	1);
INSERT INTO O_BATTR
	VALUES (9417,
	9372);
INSERT INTO O_ATTR
	VALUES (9417,
	9372,
	9418,
	'Name',
	'Full Name: Imported Required Interface',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (9419,
	9372);
INSERT INTO O_BATTR
	VALUES (9419,
	9372);
INSERT INTO O_ATTR
	VALUES (9419,
	9372,
	9417,
	'Descrip',
	'Full Name: Imported Required Interface Description
Description: A textual description of this imported interface.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (9372,
	9362,
	0,
	9369,
	9367,
	9373,
	9368,
	9420,
	9421,
	0,
	0,
	'',
	'Imported Reference',
	'Id',
	'R4703');
INSERT INTO O_RATTR
	VALUES (9420,
	9372,
	9369,
	9362,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (9420,
	9372,
	0,
	'Id',
	'',
	'',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (9372,
	2765,
	0,
	2778,
	9383,
	9384,
	9385,
	9418,
	9422,
	0,
	0,
	'',
	'Satisfaction',
	'Id',
	'R4706');
INSERT INTO O_RATTR
	VALUES (9418,
	9372,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (9418,
	9372,
	9420,
	'Satisfaction_Element_Id',
	'',
	'Satisfaction_Element_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	9372);
INSERT INTO O_OIDA
	VALUES (9420,
	9372,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	9372);
INSERT INTO O_ID
	VALUES (2,
	9372);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (9362,
	'Imported Reference',
	4703,
	'CL_IIR',
	'',
	9356);
INSERT INTO O_TFR
	VALUES (9423,
	9362,
	'get_connector_text',
	'',
	322,
	1,
	'select one provision related by self->C_IR[R4701]->C_P[R4009];
if(not_empty provision)
  return provision.get_connector_text(Obj_ID:param.Obj_ID,
  		Obj_TypeIsImported:param.Obj_TypeIsImported,
  			at:param.at, parent_ID:param.parent_ID);
end if;
select one requirement related by self->C_IR[R4701]->C_R[R4009];
if(not_empty requirement)
  return requirement.get_connector_text(Obj_ID:param.Obj_ID,
  		Obj_TypeIsImported:param.Obj_TypeIsImported,
  			at:param.at, parent_ID:param.parent_ID, connected_disabled: 
  			                                          param.connected_disabled);
end if;
return "";',
	1,
	'',
	9424);
INSERT INTO O_TPARM
	VALUES (9425,
	9423,
	'Obj_ID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9426,
	9423,
	'Obj_TypeIsImported',
	316,
	0,
	'',
	9425,
	'');
INSERT INTO O_TPARM
	VALUES (9427,
	9423,
	'at',
	880,
	0,
	'',
	9426,
	'');
INSERT INTO O_TPARM
	VALUES (9428,
	9423,
	'parent_ID',
	296,
	0,
	'',
	9427,
	'');
INSERT INTO O_TPARM
	VALUES (9429,
	9423,
	'connected_disabled',
	316,
	0,
	'',
	9428,
	'');
INSERT INTO O_TFR
	VALUES (9430,
	9362,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Id;',
	1,
	'',
	9423);
INSERT INTO O_TFR
	VALUES (9431,
	9362,
	'get_style',
	'',
	784,
	1,
	'select one provision related by self->C_IR[R4701]->C_P[R4009];
if(not_empty provision)
  return provision.get_style(at:param.at);
end if;
select one requirement related by self->C_IR[R4701]->C_R[R4009];
if(not_empty requirement)
  return requirement.get_style(at:param.at);
end if;
return Style::None;',
	1,
	'',
	9430);
INSERT INTO O_TPARM
	VALUES (9432,
	9431,
	'at',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9433,
	9362,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'return this;',
	0,
	'',
	0);
INSERT INTO O_TFR
	VALUES (9424,
	9362,
	'dispose',
	'',
	19,
	1,
	'select one icomp related by self->CL_IC[R4700];
if(not_empty icomp)
  unrelate self from icomp across R4700;
end if;
select one ref related by self->C_IR[R4701];
if(not_empty ref)
  unrelate self from ref across R4701;
end if;
select one importedPro related by self->CL_IP[R4703];
if(not_empty importedPro)
  unrelate self from importedPro across R4703;
  importedPro.dispose();
end if;
select one importedReq related by self->CL_IR[R4703];
if(not_empty importedReq)
  unrelate self from importedReq across R4703;
  importedReq.dispose();
end if;
select one delegation related by self->C_DG[R4704];
if(not_empty delegation)
  delegation.dispose();
end if;
delete object instance self;',
	1,
	'',
	9433);
INSERT INTO O_TFR
	VALUES (9434,
	9362,
	'resolveInterfaceReference',
	'',
	19,
	1,
	'select one referenceProxy related by self->C_IR[R4701];
if(not_empty referenceProxy) and
					 (Util::isProxy(element:referenceProxy.convertToInstance())
					    and not Util::isProxy(element:self.convertToInstance()))
  // if this is still a proxy then we''ve entered this
  // code before the imported component has had a chance
  // to get resolved, its resolveComponent operation will
  // handle the resolution we require here
  select one importedComp related by self->CL_IC[R4700];
  if(not_empty importedComp)
    importedComp.resolveComponent();
  end if;
end if;',
	1,
	'',
	9431);
INSERT INTO O_TFR
	VALUES (9435,
	9362,
	'isSynchronized',
	'',
	316,
	1,
	'/**
 *  Determine if this imported interface reference is synchronized 
 */
select one interfaceReference related by self->C_IR[R4701];
select one port related by interfaceReference->C_PO[R4016];
select one thisComp related by self->CL_IC[R4700]->C_C[R4201];
select one refComp related by interfaceReference->C_PO[R4016]->C_C[R4010];
if(empty interfaceReference or
                  Util::isProxy(element:interfaceReference.convertToInstance())
                              or empty port or not interfaceReference.isFormal()
                                                         or thisComp != refComp)
  return false;
end if;
return true;',
	1,
	'',
	9434);
INSERT INTO O_TFR
	VALUES (9436,
	9362,
	'isReferringToDefaultInterfaceReference',
	'',
	316,
	1,
	'select one ir related by self->C_IR[R4701];
if(empty ir or Util::isProxy(element:ir.convertToInstance()))
  return true;
end if;
return false;',
	1,
	'',
	9435);
INSERT INTO O_TFR
	VALUES (9437,
	9362,
	'canReferToInterfaceReference',
	'',
	316,
	1,
	'select one component related by self->C_IR[R4701]->C_PO[R4016]->C_C[R4010];
select one selfComponent related by self->CL_IC[R4700]->C_C[R4201];
if(component.Id == selfComponent.Id)
  return true;
end if;
return false;',
	1,
	'',
	9436);
INSERT INTO O_DBATTR
	VALUES (9438,
	9362,
	'name = "";
select one provision related by self->C_IR[R4701]->C_P[R4009];
if(not_empty provision)
  name = provision.Name;
end if;
select one requirement related by self->C_IR[R4701]->C_R[R4009];
if(not_empty requirement)
  name = requirement.Name;
end if;
self.Name = name;',
	1);
INSERT INTO O_BATTR
	VALUES (9438,
	9362);
INSERT INTO O_ATTR
	VALUES (9438,
	9362,
	9439,
	'Name',
	'User_Visible:false',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (9440,
	9362);
INSERT INTO O_BATTR
	VALUES (9440,
	9362);
INSERT INTO O_ATTR
	VALUES (9440,
	9362,
	9438,
	'Descrip',
	'Full Name: Imported Provided Interface Description
Description: A textual description of this imported interface.
User_Visible:false',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (9369,
	9362);
INSERT INTO O_BATTR
	VALUES (9369,
	9362);
INSERT INTO O_ATTR
	VALUES (9369,
	9362,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	296,
	'',
	'');
INSERT INTO O_REF
	VALUES (9362,
	8648,
	0,
	8650,
	9364,
	9366,
	9365,
	9441,
	9442,
	0,
	0,
	'',
	'Interface Reference',
	'Id',
	'R4701');
INSERT INTO O_RATTR
	VALUES (9441,
	9362,
	8650,
	8648,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (9441,
	9362,
	9369,
	'Ref_Id',
	'',
	'Ref_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (9362,
	2807,
	0,
	4175,
	9360,
	9363,
	9361,
	9443,
	9444,
	0,
	0,
	'',
	'Component Reference',
	'Id',
	'R4700');
INSERT INTO O_RATTR
	VALUES (9443,
	9362,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (9443,
	9362,
	9441,
	'ImportedComp_Id',
	'',
	'ImportedComp_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (9362,
	2762,
	0,
	2771,
	9374,
	9375,
	9376,
	9439,
	9445,
	0,
	0,
	'',
	'Delegation',
	'Id',
	'R4704');
INSERT INTO O_RATTR
	VALUES (9439,
	9362,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (9439,
	9362,
	9443,
	'Delegation_Id',
	'',
	'Delegation_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	9362);
INSERT INTO O_OIDA
	VALUES (9369,
	9362,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	9362);
INSERT INTO O_ID
	VALUES (2,
	9362);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (9381,
	'Imported Provision In Satisfaction',
	4700,
	'CL_IPINS',
	'',
	9356);
INSERT INTO O_REF
	VALUES (9381,
	9370,
	0,
	9380,
	9377,
	9382,
	9379,
	9446,
	9447,
	0,
	0,
	'',
	'Imported Provision',
	'Id',
	'R4705');
INSERT INTO O_RATTR
	VALUES (9446,
	9381,
	9369,
	9362,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (9446,
	9381,
	9448,
	'ImportedProvision_Id',
	'',
	'ImportedProvision_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (9381,
	2765,
	0,
	2778,
	9377,
	9382,
	9378,
	9448,
	9449,
	0,
	0,
	'',
	'Satisfaction',
	'Id',
	'R4705');
INSERT INTO O_RATTR
	VALUES (9448,
	9381,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (9448,
	9381,
	0,
	'Satisfaction_Id',
	'',
	'Satisfaction_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	9381);
INSERT INTO O_OIDA
	VALUES (9446,
	9381,
	0,
	'ImportedProvision_Id');
INSERT INTO O_OIDA
	VALUES (9448,
	9381,
	0,
	'Satisfaction_Id');
INSERT INTO O_ID
	VALUES (1,
	9381);
INSERT INTO O_ID
	VALUES (2,
	9381);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (9370,
	'Imported Provision',
	4701,
	'CL_IP',
	'',
	9356);
INSERT INTO O_TFR
	VALUES (9450,
	9370,
	'get_connector_text',
	'',
	322,
	1,
	'select one provision related by self->CL_IIR[R4703]->C_IR[R4701]->C_P[R4009];
if(not_empty provision)
  return provision.get_connector_text(Obj_ID:param.Obj_ID,
  		Obj_TypeIsImported:param.Obj_TypeIsImported,
  			at:param.at, parent_ID:param.parent_ID);
end if;
return "";',
	1,
	'',
	9451);
INSERT INTO O_TPARM
	VALUES (9452,
	9450,
	'Obj_ID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9453,
	9450,
	'Obj_TypeIsImported',
	316,
	0,
	'',
	9452,
	'');
INSERT INTO O_TPARM
	VALUES (9454,
	9450,
	'at',
	880,
	0,
	'',
	9453,
	'');
INSERT INTO O_TPARM
	VALUES (9455,
	9450,
	'parent_ID',
	296,
	0,
	'',
	9454,
	'');
INSERT INTO O_TFR
	VALUES (9456,
	9370,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Id;',
	1,
	'',
	9450);
INSERT INTO O_TFR
	VALUES (9457,
	9370,
	'get_style',
	'',
	784,
	1,
	'select one provision related by self->CL_IIR[R4703]->C_IR[R4701]->C_P[R4009];
if(not_empty provision)
  return provision.get_style(at:param.at);
end if;
return Style::None;',
	1,
	'',
	9456);
INSERT INTO O_TPARM
	VALUES (9458,
	9457,
	'at',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9459,
	9370,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'return this;',
	0,
	'',
	9460);
INSERT INTO O_TFR
	VALUES (9451,
	9370,
	'dispose',
	'',
	19,
	1,
	'self.dissatisfy();
select one importedRef related by self->CL_IIR[R4703];
if(not_empty importedRef)
  unrelate self from importedRef across R4703;
  importedRef.dispose();
end if;
delete object instance self;',
	1,
	'',
	9459);
INSERT INTO O_TFR
	VALUES (9461,
	9370,
	'linkConnector',
	'',
	316,
	1,
	'if(self.canLinkConnector(to:param.to))
  isLinked = false;
  select one selfImportedRef related by self->CL_IIR[R4703];
  select one component related by selfImportedRef->C_IR[R4701]->C_PO[R4016]->C_C[R4010];
  if (param.to != GD::NULL_UNIQUE_ID())
    select any requirement from instances of C_R where(selected.Requirement_Id == param.to);
    if (not_empty requirement)
      isLinked = component.initializeProvision(requirement_id:requirement.Requirement_Id, provision_id:selfImportedRef.Id, proceed:true);
    else
      select any importedRef from instances of CL_IIR where (selected.Id == param.to);
      if (not_empty importedRef)
        isLinked = component.initializeProvision(requirement_id:importedRef.Id, provision_id:selfImportedRef.Id, proceed:true);
      end if;
    end if;    
  end if;
  return isLinked;
end if;
return false;
',
	1,
	'',
	9457);
INSERT INTO O_TPARM
	VALUES (9462,
	9461,
	'to',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9463,
	9370,
	'dissatisfy',
	'',
	19,
	1,
	'select many satisfactions related by self->CL_IPINS[R4705]->C_SF[R4705];
for each satisfaction in satisfactions
  select one ipins related by satisfaction->CL_IPINS[R4705];
  unrelate satisfaction from self across R4705 using ipins;
  delete object instance ipins;
  satisfaction.dispose();
end for;',
	1,
	'',
	9461);
INSERT INTO O_TFR
	VALUES (9460,
	9370,
	'actionFilter',
	'',
	316,
	1,
	'if param.name == "can"
  if param.value == "dissatisfy"
    select any satisfaction related by self->CL_IPINS[R4705]->C_SF[R4705];
    if not_empty satisfaction
      return true;
    end if;
  end if;
end if;
return false;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (9464,
	9460,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9465,
	9460,
	'value',
	322,
	0,
	'',
	9464,
	'');
INSERT INTO O_TFR
	VALUES (9466,
	9370,
	'getProvisionCount',
	'',
	298,
	1,
	'select many satisfactions related by self->CL_IPINS[R4705]->C_SF[R4705];
return cardinality satisfactions;',
	1,
	'',
	9463);
INSERT INTO O_TPARM
	VALUES (9467,
	9466,
	'filterDelegations',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9468,
	9370,
	'canLinkConnector',
	'',
	316,
	1,
	'isLinked = false;
select one selfImportedRef related by self->CL_IIR[R4703];
select one component related by selfImportedRef->C_IR[R4701]->C_PO[R4016]->C_C[R4010];
if (param.to != GD::NULL_UNIQUE_ID())
  select any requirement from instances of C_R where(selected.Requirement_Id == param.to);
  if (not_empty requirement)
    isLinked = component.initializeProvision(requirement_id:requirement.Requirement_Id, provision_id:selfImportedRef.Id, proceed:false);
  else
    select any importedRef from instances of CL_IIR where (selected.Id == param.to);
    if (not_empty importedRef)
      isLinked = component.initializeProvision(requirement_id:importedRef.Id, provision_id:selfImportedRef.Id, proceed:false);
    end if;
  end if;    
end if;
return isLinked;
',
	1,
	'',
	9466);
INSERT INTO O_TPARM
	VALUES (9469,
	9468,
	'to',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9470,
	9370,
	'get_connector_tooltip',
	'',
	322,
	1,
	'/**
 *  Delegate to the provision that we are importing
 */
select one provision related by self->CL_IIR[R4703]->C_IR[R4701]->C_P[R4009];
if(not_empty provision)
  return provision.get_connector_tooltip(end:param.end);
end if;
return "";',
	1,
	'',
	9468);
INSERT INTO O_TPARM
	VALUES (9471,
	9470,
	'end',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9472,
	9370,
	'getConfigurationInheritanceElementId',
	'',
	317,
	1,
	'select one provision related by self->CL_IIR[R4703]->C_IR[R4701]
                                                                   ->C_P[R4009];
if(not_empty provision)
  return provision.convertToInstance();
end if;
return self.convertToInstance();',
	1,
	'',
	9470);
INSERT INTO O_TFR
	VALUES (9473,
	9370,
	'isSynchronized',
	'',
	316,
	1,
	'// ask the supertype
select one importedRef related by self->CL_IIR[R4703];
if(not_empty importedRef)
  return importedRef.isSynchronized();
end if;
return true;',
	1,
	'',
	9472);
INSERT INTO O_TFR
	VALUES (9474,
	9370,
	'getCachedName',
	'Translate:native',
	322,
	1,
	'	return m_name;',
	0,
	'',
	9473);
INSERT INTO O_TFR
	VALUES (9475,
	9370,
	'setCachedName',
	'Translate:native',
	19,
	1,
	'	m_name = p_Name;',
	0,
	'',
	9474);
INSERT INTO O_TPARM
	VALUES (9476,
	9475,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9477,
	9370,
	'collectChanges',
	'',
	19,
	1,
	'/**
 *  Collect changes that will occur once this imported reference is synchronized
 */
if(not self.isSynchronized())
  // create a removal change
  Util::createElementChange(changeList: param.changeList,
                                        elementChanged:self.convertToInstance(),
                                     isRemoval:true, changeLabel:"removed");
end if;',
	1,
	'',
	9475);
INSERT INTO O_TPARM
	VALUES (9478,
	9477,
	'changeList',
	317,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9479,
	9370,
	'synchronize',
	'',
	19,
	1,
	'/*
 *  Synchronize by removing the local ref
 */
if(not self.isSynchronized())
  self.dispose();
end if;',
	1,
	'',
	9477);
INSERT INTO O_DBATTR
	VALUES (9480,
	9370,
	'name = self.getCachedName();
select one provision related by self->CL_IIR[R4703]->C_IR[R4701]->C_P[R4009];
if(not_empty provision)
  name = provision.Name;
end if;
self.setCachedName(name:name);
self.Name = name;',
	1);
INSERT INTO O_BATTR
	VALUES (9480,
	9370);
INSERT INTO O_ATTR
	VALUES (9480,
	9370,
	9380,
	'Name',
	'Full Name: Imported Provided Interface',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (9481,
	9370);
INSERT INTO O_BATTR
	VALUES (9481,
	9370);
INSERT INTO O_ATTR
	VALUES (9481,
	9370,
	9480,
	'Descrip',
	'Full Name: Imported Interface Description
Description: A textual description of this imported interface.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (9370,
	9362,
	0,
	9369,
	9367,
	9371,
	9368,
	9380,
	9482,
	0,
	0,
	'',
	'Imported Reference',
	'Id',
	'R4703');
INSERT INTO O_RATTR
	VALUES (9380,
	9370,
	9369,
	9362,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (9380,
	9370,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	9370);
INSERT INTO O_OIDA
	VALUES (9380,
	9370,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	9370);
INSERT INTO O_ID
	VALUES (2,
	9370);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2807,
	'Component Reference',
	4704,
	'CL_IC',
	'',
	9356);
INSERT INTO O_TFR
	VALUES (9483,
	2807,
	'actionFilter',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
if(param.name == "can")
  select one package related by self->PE_PE[R8001]->EP_PKG[R8000];
  select one component related by self->PE_PE[R8001]->C_C[R8003];
  isInGenericPackage = not_empty package or not_empty component;
    
  if((param.value == "assign spec pkg"))
    if (isInGenericPackage)
      return false;
    end if;
    
    if(self.isAssigned())
      // disabled until all bugs are resolved
      // with the reassignment feature
      return false;
    end if;
    
    /**
     *  Currently the only limitations are that a component
     *  may not be used if it defined in the same package or
     *  component, or if it is defined in the hierarchy under
     *  another component.  Additionally matching usable interfaces
     *  and matching interfaces (if already assigned) must be
     *  available 
     */
    nestedInComponent = false;
    select one container related by self->C_C[R4205];
    select one thisPackage related by self->CP_CP[R4605];
    if(empty thisPackage)
      if(not_empty container)
        nestedInComponent = true;
        select one compPackage related by container->CP_CP[R4604];
        while(empty thisPackage)
          select one thisPackage related by container->CP_CP[R4604];
          if(empty thisPackage)
            select one container related by container->CN_CIC[R4203]
                                                                   ->C_C[R4202];
          end if;
        end while;
      end if;
    end if;
    if(not_empty thisPackage)
      comp_id = GD::NULL_UNIQUE_ID();
      if(not_empty container)
        comp_id = container.Id;
      end if;
      select one system related by thisPackage->S_SYS[R4606];
      if (not_empty system)
        select many packages related by system->CP_CP[R4606];
        if(not nestedInComponent)
          // do not allow components defined within the component
          // package as this imported component
          select many packages related by system->CP_CP[R4606] where 
                                  selected.Package_ID != thisPackage.Package_ID;
        end if;
        // this selection prevents the component that hosts the
        // imported component from being available
        select many comps related by packages->C_C[R4604]
                                                 where (selected.Id != comp_id);
        foundNoComp = false;
        if(self.isAssigned())
          select one currentComp related by self->C_C[R4201];
          for each comp in comps
            if(self.componentHasMatchingInterfaces(id:comp.Id) and (not (comp.Id == currentComp.Id)))
              return true;
            end if;
          end for;
        else
          for each comp in comps
            if(self.componentHasMatchingInterfaces(id:comp.Id))
              return true;
            end if;
          end for;
        end if;
      end if;
    end if;    
  elif(param.value == "assign generic pkg")
    if (not isInGenericPackage)
      return false;
    end if;
    
    if(self.isAssigned())
      // disabled until all bugs are resolved
      // with the reassignment feature
      return false;
    end if;
    
    // Restrict based on visibility.
    if (empty package)
      component.clearScope();
      component.collectVisibleElementsForName(name:"", 
             type:ElementTypeConstants::COMPONENT,
             originatingContainerID:component.Id, 
             delegatingContainerID:GD::NULL_UNIQUE_ID(), collectGlobally:true);
    else
      package.clearScope();
      package.collectVisibleElementsForName(name:"", 
             type:ElementTypeConstants::COMPONENT,
             descending:false,
             originatingContainerID:package.Package_ID, 
             delegatingPkgID:GD::NULL_UNIQUE_ID(), collectGlobally:true);
    end if;
    select any resultSet related by package->PE_SRS[R8005] where
       selected.Name == "" and selected.Type == ElementTypeConstants::COMPONENT;
    select many results related by resultSet->PE_VIS[R8006]->PE_PE[R8002];   
    if empty package
      select any compResultSet related by component->PE_CRS[R8007] where
                           selected.Name == "" and selected.Type == 
                                                ElementTypeConstants::COMPONENT;
      select many results related by compResultSet->PE_CVS[R8008]->PE_PE[R8004];   
    end if;
    select many comps related by results->C_C[R8001];
    // The isContainedBy() call prevents a component that hosts the
    // imported component from being available
    if(self.isAssigned())
      select one currentComp related by self->C_C[R4201];
      for each comp in comps
        if(self.componentHasMatchingInterfaces(id:comp.Id) and
                           not comp.isContainedBy(element_id:comp.Id) and
                                                not (comp.Id == currentComp.Id))
          return true;
        end if;
      end for;
    else
      for each comp in comps
        candidatePkg = comp.getPackageId();
        if(self.componentHasMatchingInterfaces(id:comp.Id) and
                                     not comp.isContainedBy(element_id:comp.Id))
          return true;
        end if;
      end for;
    end if;
    return false;
  elif(param.value == "unassign")
    return self.isAssigned();
  elif(param.value == "launchVerifier")
    select one component related by self->C_C[R4201];
    select any engine related by self->I_EXE[R2963];
    // it must be formalized and not yet launched
    if((not_empty component) and (empty engine))
      return true;
    else   
      return false;
    end if;
  end if;
end if;
return false;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (9484,
	9483,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9485,
	9483,
	'value',
	322,
	0,
	'',
	9484,
	'');
INSERT INTO O_TFR
	VALUES (9486,
	2807,
	'isAssigned',
	'',
	316,
	1,
	'select one component related by self->C_C[R4201];
return not_empty component;',
	1,
	'',
	9487);
INSERT INTO O_TFR
	VALUES (9488,
	2807,
	'dispose',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one comp related by self->C_C[R4201];
if(not_empty comp)
  unrelate self from comp across R4201;
end if;
select one comp related by self->C_C[R4205];
if (not_empty comp)
  unrelate self from comp across R4205;
end if;
select many importedRefs related by self->CL_IIR[R4700];
for each importedRef in importedRefs
  importedRef.dispose();
end for;
select one package related by self->CP_CP[R4605];
if(not_empty package)
  unrelate self from package across R4605;
end if;
select many executionEngines related by self->I_EXE[R2963];
for each engine in executionEngines
  unrelate engine from self across R2963;
  engine.dispose();
end for;
select one pe related by self->PE_PE[R8001];
if (not_empty pe)
  unrelate self from pe across R8001;
  pe.dispose();
end if;
delete object instance self;',
	1,
	'',
	9489);
INSERT INTO O_TFR
	VALUES (9490,
	2807,
	'assignToComp',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Imported Component.assignToComp()
select any componentPackage from instances of CP_CP where
                                    selected.Package_ID == GD::NULL_UNIQUE_ID();
select any comp from instances of C_C where selected.Id == GD::NULL_UNIQUE_ID();
select one packageableElem related by self->PE_PE[R8001];
select one contPackage related by packageableElem->EP_PKG[R8000];
select one contComponent related by packageableElem->C_C[R8003];
isInGenericPackage = (not_empty contPackage or not_empty contComponent);
if isInGenericPackage
  select any pe from instances of PE_PE where selected.Element_ID == param.Id;
  select one comp related by pe->C_C[R8001];
else
  select one componentPackage related by self->CP_CP[R4605];
  if(empty componentPackage)
    select one component related by self->C_C[R4205];
    if(not_empty component)
      while(empty componentPackage)
        select one componentPackage related by component->CP_CP[R4604];
        select one component related by component->CN_CIC[R4203]->C_C[R4202];
      end while;
    end if;
  end if;

  if(not_empty componentPackage)
    select one system related by componentPackage->S_SYS[R4606];
    select any comp related by system->CP_CP[R4606]->C_C[R4604] where
                                                        selected.Id == param.Id;
  end if;
end if;
if(not_empty comp)
  if(self.isAssigned())
    select one existingComp related by self->C_C[R4201];
    unrelate self from existingComp across R4201;
    select many formalInterfaces related by comp->C_PO[R4010]->C_IR[R4016];
    for each formalInterface in formalInterfaces
      select many existingImportRefs related by self->CL_IIR[R4700];
      for each existingImportRef in existingImportRefs
        select one existingRef related by existingImportRef->C_IR[R4701];
        // if this existing ref is dangling
        // dispose it here and skip
        select one existingIface related by existingRef->C_I[R4012];
        skipDispose = false;
        if(not_empty existingIface and not Util::isProxy(element:existingIface.convertToInstance()))
          skipDispose = true;
        end if;
        if(Util::isProxy(element:existingRef.convertToInstance()) and not skipDispose)
          existingImportRef.dispose();
          continue;
        end if;
        if(existingRef.Formal_Interface_Id
                                        == formalInterface.Formal_Interface_Id)
          // if this ref has already been processed skip
          select one testComp related by existingRef->C_PO[R4016]->C_C[R4010];
          if(testComp != comp)
            // not from the same comp, go ahead and proceed
            select any importedRef related by self->CL_IIR[R4700]
                                      where (selected.Ref_Id == existingRef.Id);
            unrelate importedRef from existingRef across R4701;
            relate importedRef to formalInterface across R4701;
            select one currentProvision related by existingRef->C_P[R4009];
            if(not_empty currentProvision)
              select one importedPro related by importedRef->CL_IP[R4703];
              select many satisfactions related by importedPro
                                                 ->CL_IPINS[R4705]->C_SF[R4705];
              for each satisfaction in satisfactions
                select one ipins related by satisfaction->CL_IPINS[R4705];
                select one provision related by formalInterface->C_P[R4009];
                select one otherReq related by satisfaction->C_R[R4002];
                unrelate currentProvision from otherReq across R4002
                                                             using satisfaction;
                relate provision to otherReq across R4002 using satisfaction;
              end for;
            else
              select one currentRequirement related by existingRef->C_R[R4009];
              select one importedReq related by importedRef->CL_IR[R4703];
              select one satisfaction related by importedReq->C_SF[R4706];
              if(not_empty satisfaction)
                select one requirement related by formalInterface->C_R[R4009];
                select one otherPro related by satisfaction->C_P[R4002];
                unrelate currentRequirement from otherPro across R4002 using
              													   satisfaction;
                relate requirement to otherPro across R4002
                                                             using satisfaction;
              end if;            
            end if;
            // break out of the inner for loop as
            // we have processed what we need
            break;
          end if;
        end if;
      end for;
    end for;
  end if;
  relate self to comp across R4201;
  select many formalInterfaces related by comp->C_PO[R4010]->C_IR[R4016];
  for each formalInterface in formalInterfaces
    if(formalInterface.isFormal())
      select any existingImportRef related by self->CL_IIR[R4700]->C_IR[R4701]
        							  where (selected.Id == formalInterface.Id);
      if(empty existingImportRef)
        select one provision related by formalInterface->C_P[R4009];
        create object instance newImportedRef of CL_IIR;
        if(not_empty provision)
          create object instance importedPro of CL_IP;
          relate importedPro to newImportedRef across R4703;
        else
          create object instance importedReq of CL_IR;
          relate importedReq to newImportedRef across R4703;
        end if;
        relate newImportedRef to self across R4700;
        relate newImportedRef to formalInterface across R4701;
      end if;
    end if;
  end for;
end if;
',
	1,
	'',
	9483);
INSERT INTO O_TPARM
	VALUES (9491,
	9490,
	'Id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9492,
	2807,
	'unAssign',
	'',
	19,
	1,
	'select one comp related by self->C_C[R4201];
if(not_empty comp)
  unrelate self from comp across R4201;
  select many importedRefs related by self->CL_IIR[R4700];
  for each importedRef in importedRefs
    importedRef.dispose();
  end for;
end if;',
	1,
	'',
	9493);
INSERT INTO O_TFR
	VALUES (9489,
	2807,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'return this;',
	0,
	'',
	9494);
INSERT INTO O_TFR
	VALUES (9495,
	2807,
	'get_compartment_text',
	'',
	322,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
result = "";
if (param.at == Justification::Center)
  if(self.isAssigned())
    result = self.getCachedName();
    select one comp related by self->C_C[R4201];
    if(not Util::isProxy(element:comp.convertToInstance()))
      result = comp.getPath(path:"", includeSelf:true);
      if(self.ClassifierName != "")
        result = result + ":" + self.ClassifierName;
      end if;
      if(self.Mult == 1)
        result = result + "[*]";
      end if;
    end if;
    self.setCachedName(name:result);
  else
    result = "Unassigned Component Reference";
  end if;
end if;
return result;',
	1,
	'',
	9496);
INSERT INTO O_TPARM
	VALUES (9497,
	9495,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9498,
	9495,
	'ent_num',
	298,
	0,
	'',
	9499,
	'');
INSERT INTO O_TPARM
	VALUES (9499,
	9495,
	'comp_num',
	298,
	0,
	'',
	9497,
	'');
INSERT INTO O_TFR
	VALUES (9500,
	2807,
	'getElideCompartmentTextAtEnd',
	'',
	316,
	1,
	'// elide at the front if the given compartment/entry corresponds to
// the class''s path (and name), and a class has been assigned to this instance 
select one component related by self->C_C[R4201];
elideAtFront = false;	// necessary due to bug with boolean expressions
elideAtFront = param.comp_num == 1 and param.ent_num == 0 
	and not_empty component;
return elideAtFront;',
	1,
	'',
	9488);
INSERT INTO O_TPARM
	VALUES (9501,
	9500,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9502,
	9500,
	'ent_num',
	298,
	0,
	'',
	9501,
	'');
INSERT INTO O_TFR
	VALUES (9503,
	2807,
	'get_compartments',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	9495);
INSERT INTO O_TFR
	VALUES (9504,
	2807,
	'get_entries',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	9503);
INSERT INTO O_TPARM
	VALUES (9505,
	9504,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9506,
	2807,
	'get_style',
	'',
	784,
	1,
	'return Style::Component;',
	1,
	'',
	9504);
INSERT INTO O_TFR
	VALUES (9507,
	2807,
	'get_text_style',
	'',
	784,
	1,
	'return Style::None;',
	1,
	'',
	9506);
INSERT INTO O_TPARM
	VALUES (9508,
	9507,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9509,
	9507,
	'comp_num',
	298,
	0,
	'',
	9508,
	'');
INSERT INTO O_TPARM
	VALUES (9510,
	9507,
	'ent_num',
	298,
	0,
	'',
	9509,
	'');
INSERT INTO O_TFR
	VALUES (9511,
	2807,
	'manyMultAllowed',
	'',
	316,
	1,
	'return true;',
	1,
	'',
	9486);
INSERT INTO O_TFR
	VALUES (9512,
	2807,
	'canAssignToCompInPackage',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one pkg related by self->PE_PE[R8001]->EP_PKG[R8000];
if (not_empty pkg)
  // if in a generic package there will be no package assignment
  return false;
end if;
select one compPackage related by self->CP_CP[R4605];
nestedInComponent = false;
if(empty compPackage)
  select one container related by self->C_C[R4205];
  if(not_empty container)
    nestedInComponent = true;
    while(empty compPackage)
      select one compPackage related by container->CP_CP[R4604];
      select one container related by container->CN_CIC[R4203]->C_C[R4202];
    end while;
  end if;
end if;
if(nestedInComponent)
  if(compPackage.Package_ID == param.Id)
    // only return false if this imported component is nested
    // in a component which is along the path of the given
    // package and the only component available is the parent
    // component
    select many components related by compPackage->C_C[R4604];
    if(cardinality components == 1)
      return false;
    end if;
    for each component in components
      if(self.componentHasMatchingInterfaces(id:component.Id))
        return true;
      end if;
    end for;
  end if;
else
  if( (not_empty compPackage) and (compPackage.Package_ID == param.Id) )
    return false;
  end if;
end if;
select one system related by compPackage->S_SYS[R4606];
select any package related by system->CP_CP[R4606]
												where (selected.Package_ID == param.Id);
select many comps related by package->C_C[R4604];
if(cardinality comps == 0)
  return false;
else
  existingCompId = GD::NULL_UNIQUE_ID();
  if(self.isAssigned())
    // if assigned get the component id
    // so that we prevent packages which
    // only contain the component we are
    // assigned to
    select one existingComp related by self->C_C[R4201];
    existingCompId = existingComp.Id;
  end if;
  for each comp in comps
    if(self.componentHasMatchingInterfaces(id:comp.Id)
                                                  and comp.Id != existingCompId)
      return true;
    end if;
  end for;
end if;
return false;',
	1,
	'',
	9513);
INSERT INTO O_TPARM
	VALUES (9514,
	9512,
	'Id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9513,
	2807,
	'canAssignToComp',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one packageableElem related by self->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;

if (isInGenericPackage)
  // do not allow assignment to any parent component in this hierarchy
  parentPackage = package;
  parentComp = component;
  while(not_empty parentPackage or not_empty parentComp)
    if not_empty parentComp and parentComp.Id == param.Id
      return false;
    end if;
    // traverse to container
    select one parentPE related by parentPackage->PE_PE[R8001];
    if empty parentPE
      select one parentPE related by parentComp->PE_PE[R8001];
    end if;
    select one parentPackage related by parentPE->EP_PKG[R8000];
    select one parentComp related by parentPE->C_C[R8003];
  end while;

  select one system related by package->S_SYS[R1405];
  if (empty system)
    rootCompIdInPkg = component.getRootComponentId();
    select any rootComponent from instances of C_C where (selected.Id == rootCompIdInPkg);
    select one system related by rootComponent->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405];
  end if;
  select any component related by system->EP_PKG[R1405]->PE_PE[R8000]
  								   ->C_C[R8001] where (selected.Id == param.Id);
  if(not_empty component)
    existingCompId = GD::NULL_UNIQUE_ID();
    if(self.isAssigned())
      // if assigned get the component id
      // so that we prevent packages which
      // only contain the component we are
      // assigned to
      select one existingComp related by self->C_C[R4201];
      existingCompId = existingComp.Id;
    end if;
    if(self.componentHasMatchingInterfaces(id:component.Id))
      if(param.checkExistingType)
        if(component.Id == existingCompId)
          return false;
        end if;
      end if;
      return true;
    else
      return false;
    end if;
  end if;
  return true;
end if;

// Below this is for when we are NOT under a generic package

select one compPackage related by self->CP_CP[R4605];
if(empty compPackage)
  select one container related by self->C_C[R4205];
  if(not_empty container)
    while(empty compPackage)
      select one compPackage related by container->CP_CP[R4604];
      if(not_empty compPackage)
        if(container.Id == param.Id)
          // do not allow our top component parent
          return false;
        end if;
      end if;
      select one container related by container->CN_CIC[R4203]->C_C[R4202];
    end while;
  end if;
end if;
if(not_empty compPackage)
  select any component related by compPackage->S_SYS[R4606]->CP_CP[R4606]
  								   ->C_C[R4604] where (selected.Id == param.Id);
  if(not_empty component)
    existingCompId = GD::NULL_UNIQUE_ID();
    if(self.isAssigned())
      // if assigned get the component id
      // so that we prevent packages which
      // only contain the component we are
      // assigned to
      select one existingComp related by self->C_C[R4201];
      existingCompId = existingComp.Id;
    end if;
    if(self.componentHasMatchingInterfaces(id:component.Id))
      if(param.checkExistingType)
        if(component.Id == existingCompId)
          return false;
        end if;
      end if;
      return true;
    else
      return false;
    end if;
  end if;
else
  return false;					  
end if;
return true;',
	1,
	'',
	9490);
INSERT INTO O_TPARM
	VALUES (9515,
	9513,
	'Id',
	296,
	0,
	'',
	0,
	'The id of the C_C instance to test.');
INSERT INTO O_TPARM
	VALUES (9516,
	9513,
	'checkExistingType',
	316,
	0,
	'',
	9515,
	'');
INSERT INTO O_TFR
	VALUES (9517,
	2807,
	'getImportedProvisionCount',
	'',
	298,
	1,
	'select many importedReferences related by self->CL_IIR[R4700]->CL_IP[R4703];
return cardinality importedReferences;',
	1,
	'',
	9500);
INSERT INTO O_TPARM
	VALUES (9518,
	9517,
	'includeDelegations',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9519,
	2807,
	'getImportedRequirementCount',
	'',
	298,
	1,
	'select many importedReferences related by self->CL_IIR[R4700]->CL_IR[R4703];
return cardinality importedReferences;',
	1,
	'',
	9520);
INSERT INTO O_TPARM
	VALUES (9521,
	9519,
	'includeDelegations',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9522,
	2807,
	'getImportedProvisionID',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many importedRefs related by self->CL_IIR[R4700]->CL_IP[R4703];
// We''re preincrementing the index
count = -1;
for each importedRef in importedRefs
  count = count+1;
  if (count == param.index)
    return importedRef.Id;
  end if;
end for;
return id;',
	1,
	'',
	9517);
INSERT INTO O_TPARM
	VALUES (9523,
	9522,
	'filterDelegations',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9524,
	9522,
	'index',
	298,
	0,
	'',
	9523,
	'');
INSERT INTO O_TFR
	VALUES (9525,
	2807,
	'getImportedRequirementID',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many importedRefs related by self->CL_IIR[R4700]->CL_IR[R4703];
// We''re preincrementing the index
count = -1;
for each importedRef in importedRefs
  count = count+1;
  if (count == param.index)
    return importedRef.Id;
  end if;
end for;
return id;',
	1,
	'',
	9519);
INSERT INTO O_TPARM
	VALUES (9526,
	9525,
	'filterDelegations',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9527,
	9525,
	'index',
	298,
	0,
	'',
	9526,
	'');
INSERT INTO O_TFR
	VALUES (9487,
	2807,
	'hasImportedRequirement',
	'',
	316,
	1,
	'select any importedReq related by self->CL_IIR[R4700]->CL_IR[R4703]
	where (selected.Id == param.id);
if(not_empty importedReq)
  if(param.considerDelegations)
    select one delegation related by importedReq->CL_IIR[R4703]->C_DG[R4704];
    if(not_empty delegation)
      return false;
    end if;
  end if;
  return true;
end if;
return false;',
	1,
	'',
	9528);
INSERT INTO O_TPARM
	VALUES (9529,
	9487,
	'id',
	296,
	0,
	'',
	9530,
	'');
INSERT INTO O_TPARM
	VALUES (9530,
	9487,
	'considerDelegations',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9528,
	2807,
	'hasImportedProvision',
	'',
	316,
	1,
	'select any importedPro related by self->CL_IIR[R4700]->CL_IP[R4703]
	where (selected.Id == param.id);
if(not_empty importedPro)
  if(param.considerDelegations)
    select one delegation related by importedPro->CL_IIR[R4703]->C_DG[R4704];
    if(not_empty delegation)
      return false;
    end if;
  end if;
  return true;
end if;
return false;',
	1,
	'',
	9507);
INSERT INTO O_TPARM
	VALUES (9531,
	9528,
	'id',
	296,
	0,
	'',
	9532,
	'');
INSERT INTO O_TPARM
	VALUES (9532,
	9528,
	'considerDelegations',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9520,
	2807,
	'getImportedProvisionProvisionID',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many importedRefs related by self->CL_IIR[R4700]->CL_IP[R4703];
// We''re preincrementing the index
count = -1;
for each importedRef in importedRefs
  count = count+1;
  if (count == param.index)
    select one provision related by importedRef->CL_IIR[R4703]->C_IR[R4701]
    															   ->C_P[R4009];
    select one delegation related by importedRef->CL_IIR[R4703]->C_DG[R4704];
    if(not_empty delegation)
      return delegation.Id;
    end if;
    if(not_empty provision)
      return provision.Provision_Id;
    end if;
  end if;
end for;
return id;',
	1,
	'',
	9522);
INSERT INTO O_TPARM
	VALUES (9533,
	9520,
	'filterDelegations',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9534,
	9520,
	'index',
	298,
	0,
	'',
	9533,
	'');
INSERT INTO O_TFR
	VALUES (9496,
	2807,
	'getImportedRequirementRequirementID',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many importedRefs related by self->CL_IIR[R4700]->CL_IR[R4703];
// We''re preincrementing the index
count = -1;
for each importedRef in importedRefs
  count = count+1;
  if (count == param.index)
    select one requirement related by importedRef->CL_IIR[R4703]->C_IR[R4701]
    															   ->C_R[R4009];
    select one delegation related by importedRef->CL_IIR[R4703]->C_DG[R4704];
    if(not_empty delegation)
      return delegation.Id;
    end if;
    if(not_empty requirement)
      return requirement.Requirement_Id;
    end if;
  end if;
end for;
return id;',
	1,
	'',
	9525);
INSERT INTO O_TPARM
	VALUES (9535,
	9496,
	'index',
	298,
	0,
	'',
	9536,
	'');
INSERT INTO O_TPARM
	VALUES (9536,
	9496,
	'filterDelegations',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9537,
	2807,
	'componentHasMatchingInterfaces',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// if this imported component is not assigned, or assigned
// to a component with no imported refs then it''s allowed
if(not self.isAssigned())
  return true;
else
  // it is also allowed if assigned, but the currently
  // assigned component has no interface references that
  // are formal
  select any importedRef related by self->CL_IIR[R4700];
  if(empty importedRef)
    return true;
  end if;
end if;

select one packageableElem related by self->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one comp related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty comp;

// otherwise see that the component has matching interfaces
// for each imported reference
select one compPackage related by self->CP_CP[R4605];
if(empty compPackage and not isInGenericPackage)
  select one container related by self->C_C[R4205];
  if(not_empty container)
    while(empty compPackage)
      select one compPackage related by container->CP_CP[R4604];
      select one container related by container->CN_CIC[R4203]->C_C[R4202];
    end while;
  end if;
end if;

if(not_empty compPackage or isInGenericPackage)
  select one system related by compPackage->S_SYS[R4606];
  select any component related by compPackage->S_SYS[R4606]->CP_CP[R4606]
   								   ->C_C[R4604] where (selected.Id == param.id);
  if (isInGenericPackage)
    select any compPe from instances of PE_PE
                                        where (selected.Element_ID == param.id);
    select one component related by compPe->C_C[R8001];
  end if;
  if(not_empty component and not_empty system)
    select many importedRefs related by self->CL_IIR[R4700]->C_IR[R4701];
    for each importedRef in importedRefs
      select one importedInterface related by importedRef->C_I[R4012];
      select many compInterfaces related by component->C_PO[R4010]->C_IR[R4016]
						                  ->C_P[R4009]->C_IR[R4009]->C_I[R4012];
      select one provision related by importedRef->C_P[R4009];
      if(empty provision)
        select many compInterfaces related by component->C_PO[R4010]
                             ->C_IR[R4016]->C_R[R4009]->C_IR[R4009]->C_I[R4012];
      end if;
      if(cardinality compInterfaces == 0)
        return false;
      end if;
      foundMatch = false;
      for each compInterface in compInterfaces
        id = importedRef.findMatchingInterface(system_id:system.Sys_ID,
                                                                   pe:param.id);
        if(id == compInterface.Id)
          foundMatch = true;
        end if;
      end for;
      if(not foundMatch)
        return false;
      end if;
    end for;
  end if;
end if;
return true;',
	1,
	'',
	9512);
INSERT INTO O_TPARM
	VALUES (9538,
	9537,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9494,
	2807,
	'componentHasUnusableInterfaces',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
/*
 *  See if the given component has any interfaces that
 *  are not accessible in the parent of this imported
 *  component
 */
select one packageableElem related by self->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one comp related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty comp;
if isInGenericPackage
  select any pe from instances of PE_PE where selected.Element_ID == param.id;
  select one candidateComponent related by pe->C_C[R8001];
  if(not_empty candidateComponent)
    select many irs related by candidateComponent->C_PO[R4010]->C_IR[R4016];
    for each ir in irs
      select one interface related by ir->C_I[R4012];
      if not_empty interface
        if not_empty comp
          comp.collectVisibleElementsForName(name:interface.Name,
                                   type:ElementTypeConstants::INTERFACE,
                          originatingContainerID:comp.Id,
                                   delegatingContainerID:GD::NULL_UNIQUE_ID(),
                                                          collectGlobally:true);
        else
          package.collectVisibleElementsForName(name:interface.Name,
                  type:ElementTypeConstants::INTERFACE, descending:false,
                           originatingContainerID:package.Package_ID,
                                          delegatingPkgID:GD::NULL_UNIQUE_ID(),
                                                          collectGlobally:true);
        end if;
        select any resultSet related by comp->PE_CRS[R8007] where
                                 selected.Name == interface.Name and 
                               selected.Type == ElementTypeConstants::INTERFACE; 
        select many results related by resultSet->PE_CVS[R8008]->PE_PE[R8004];
        if not_empty package
          select any pkgResultSet related by package->PE_SRS[R8005] where
                                    selected.Name == interface.Name and 
                               selected.Type == ElementTypeConstants::INTERFACE; 
          select many results related by pkgResultSet->
                                                    PE_VIS[R8006]->PE_PE[R8002];
        end if;
        // We don''t care if more than one interface meets the criterion
        // because the parser will show an error when it is referenced
        if empty results  // so a simple empty test is sufficient
          return true;
        end if;
      end if;
    end for;
    // if we get here then there were none that were unusable
    return false;
  end if;
else // Specific package case
  nested = false;
  // Assertion: We''re either in a component package or a component
  select one compPackage related by self->CP_CP[R4605];
  if(empty compPackage)
    // We should be in a component
    select one container related by self->C_C[R4205];
    if(not_empty container)
      nested = true;
      // traverse up the component containment hierarchy until package is found
      while(empty compPackage)
        select one compPackage related by container->CP_CP[R4604];
        select one container related by container->CN_CIC[R4203]->C_C[R4202];
      end while;
    // else component container is not empty
      // can''t happen otherwise Assertion above is false
    end if;
  end if;
  // At this point comp package is the component package container of this
  // component reference and ''nested'' is true iff the reference was immediately
  // under a component.
  if(not_empty compPackage)
    select one system related by compPackage->S_SYS[R4606];
    select any component related by system->CP_CP[R4606]->C_C[R4604]
  												where (selected.Id == param.id);
    if(not_empty component)
      select many irs related by component->C_PO[R4010]->C_IR[R4016];
      for each ir in irs
        select one interface related by ir->C_I[R4012];
        if(not_empty interface)
          select one interfacePkg related by interface->IP_IP[R4303];
          if(nested)
            select one container related by self->C_C[R4205];
            if(not container.interfacePackageIsAlongParentPath(id:interfacePkg.Package_ID))
              return true;
            end if;
          else
            if(not compPackage.interfacePackageIsAlongParentPath(id:interfacePkg.Package_ID))
              return true;
            end if;
          end if;
        end if;
      end for;
      // if we get here then there were none that were unusable
      return false;
    end if;
  // else comp package is empty
    // cant happen otherwise while statement above would never exit
  end if;
end if;
return true;',
	1,
	'',
	9537);
INSERT INTO O_TPARM
	VALUES (9539,
	9494,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9493,
	2807,
	'resolveComponent',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one componentProxy related by self->C_C[R4201];
// if the component is not actually a proxy this imported
// component has already been handled
if(not_empty componentProxy) and
                    (Util::isProxy(element:componentProxy.convertToInstance()))
                       and (not Util::isProxy(element:self.convertToInstance()))
  name = componentProxy.Name;
  
  select one system related by self->CP_CP[R4605]->S_SYS[R4606];
  select any resolvedComp from instances of C_C
                          where (selected.Id == GD::NULL_UNIQUE_ID());
  select many resolvedComps related by system->CP_CP[R4606]->C_C[R4604]
                            where (selected.Name == name);
                            
  select one packageableElem related by self->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = not_empty package or not_empty component;
  
  
  if (isInGenericPackage)
    if (not_empty package)
      select one system related by package->S_SYS[R1405];
    else
      rootCompIdInPkg = component.getRootComponentId();
      select any rootComponent from instances of C_C
                                         where (selected.Id == rootCompIdInPkg);
      select one package related by rootComponent->PE_PE[R8001]->EP_PKG[R8000];
      select one system related by package->S_SYS[R1405];
    end if;
	select one packageableElement related by self->PE_PE[R8001];
	packageableElement.resolveComponentRelativeToSelf(expected_name:name);
	select many resolvedComps related by package->PE_VIS[R8002]->
                                                     PE_PE[R8002]->C_C[R8001];
    if (empty resolvedComps)
      select many resolvedComps related by component->PE_CVS[R8004]->
                       			                      PE_PE[R8004]->C_C[R8001];
    end if;	
  else
    select one system related by self->CP_CP[R4605]->S_SYS[R4606];
    if(empty system)
      // if the system is empty this imported component
      // is most likely nested within a component
      select one system related by self->C_C[R4205]->CP_CP[R4608]->S_SYS[R4606];
    end if;
    select many resolvedComps related by system->CP_CP[R4606]->C_C[R4604]
                                                  where (selected.Name == name);
    if(cardinality resolvedComps == 0 and system.useGlobals)
      // check globally if enabled
      select many resolvedComps related by system->G_EIS[R9100]->PE_PE[R9100]->
                                                                     C_C[R8001];
    end if;
  end if;
  
  for each comp in resolvedComps
    if(self.canAssignToComp(Id:comp.Id, checkExistingType:true))
       resolvedComp = comp;
       break;
    end if;
  end for;
  // if one was not resolved
  if(empty resolvedComp)
    // unassign this comp
	self.unAssign();
  else
    // update all of the imported refereces
    // to point at valid interfaces
    self.updateImportedReferences(Id:resolvedComp.Id);
    // otherwise associate the found component
    self.assignToComp(Id:resolvedComp.Id);
  end if;
end if;',
	1,
	'',
	9511);
INSERT INTO O_TFR
	VALUES (9540,
	2807,
	'updateImportedReferences',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any resolvedCompPe from instances of PE_PE
                                        where (selected.Element_ID == param.Id);
select any resolvedComp from instances of C_C
                                    where (selected.Id == GD::NULL_UNIQUE_ID());
isInGenericPackage = false;
if(empty resolvedCompPe)
  select any resolvedComp from instances of C_C where (selected.Id == param.Id);
else
  isInGenericPackage = true;
  select one resolvedComp related by resolvedCompPe->C_C[R8001];
end if;
if(not_empty resolvedComp)
  select many importedReferences related by self->CL_IIR[R4700];
  for each importedReference in importedReferences
    select one reference related by importedReference->C_IR[R4701];
    select one proxyInterface related by reference->C_I[R4012];
    if(not_empty proxyInterface and
                      Util::isProxy(element:proxyInterface.convertToInstance()))
      if (isInGenericPackage)
        select one package related by resolvedCompPe->EP_PKG[R8000];
        select one component related by resolvedCompPe->C_C[R8003];
        select one system related by package->S_SYS[R1405];
        if (empty system)
          rootCompIdInPkg = component.getRootComponentId();
          select any rootComponent from instances of C_C
                                         where (selected.Id == rootCompIdInPkg);
          select one package related by rootComponent->PE_PE[R8001]
                                                                ->EP_PKG[R8000];
          select one system related by rootComponent->PE_PE[R8001]
                                                  ->EP_PKG[R8000]->S_SYS[R1405];
        end if;
        id = reference.findMatchingInterface(system_id:system.Sys_ID, pe:resolvedCompPe.Element_ID);
        if(id != GD::NULL_UNIQUE_ID())
          select any ifacePe from instances of PE_PE where (selected.Element_ID == id);
          select one interface related by ifacePe->C_I[R8001];
          if(not_empty interface)
            unrelate reference from proxyInterface across R4012;
            relate reference to interface across R4012; 
          end if;
        end if;
      else
          select one compPkg related by resolvedComp->CP_CP[R4608];
          select one system related by compPkg->S_SYS[R4606];
          id = reference.findMatchingInterface(system_id:system.Sys_ID, pe:GD::NULL_UNIQUE_ID());
          if(id != GD::NULL_UNIQUE_ID())
            select any interface related by system->IP_IP[R4304]->C_I[R4303]
    												  where (selected.Id == id); 
            if(not_empty interface)
              unrelate reference from proxyInterface across R4012;
              relate reference to interface across R4012; 
            end if;
          end if;
      end if;
    end if;
  end for;
end if;',
	1,
	'',
	9492);
INSERT INTO O_TPARM
	VALUES (9541,
	9540,
	'Id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9542,
	2807,
	'isParentExecuting',
	'',
	316,
	1,
	'// Component Instance.isParentExecuting()
select any container related by self->I_EXE[R2963]->I_CIN[R2975];
return not_empty container;
',
	1,
	'',
	9540);
INSERT INTO O_TFR
	VALUES (9543,
	2807,
	'getImportedComponentNumber',
	'',
	298,
	1,
	'select one component related by self->C_C[R4201];
if(not_empty component)
  count = 0;
  select many icomps related by component->CL_IC[R4201];
  for each icomp in icomps
    count = count + 1;
    if(icomp == self)
      return count;
    end if;
  end for;
end if;
return 1;',
	1,
	'',
	9542);
INSERT INTO O_TFR
	VALUES (9544,
	2807,
	'isExecuting',
	'',
	316,
	1,
	'// Component Reference.isExecuting()
// TBD This is used to determine whether a Component Reference tree entry should
// show in the Session Explorer. The selection is actually incorrect, since it
// will make the entry appear under all components that nest this component
// reference, whether or not an instance was started for that component. For
// now, it is a reasonable interpretation.
select any instance related by self->I_EXE[R2963];
return not_empty instance;',
	1,
	'',
	9543);
INSERT INTO O_TFR
	VALUES (9545,
	2807,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Id;',
	1,
	'',
	9544);
INSERT INTO O_TFR
	VALUES (9546,
	2807,
	'getConfigurationInheritanceElementId',
	'',
	317,
	1,
	'select one component related by self->C_C[R4201];
if(not_empty component)
  return component.convertToInstance();
end if;
return self.convertToInstance();',
	1,
	'',
	9545);
INSERT INTO O_TFR
	VALUES (9547,
	2807,
	'isSynchronized',
	'',
	316,
	1,
	'/**
 *  Determine if this reference is synchronized
 */
// not synchronized if referring to a torn down component
select one component related by self->C_C[R4201];
if(empty component)
  // synchronized as the reference is not formal
  return true;
end if;
if(Util::isProxy(element:component.convertToInstance()))
  // is a proxy, means the referred to component is missing
  return false;
end if;
// see if the parent is missing or a proxy
select one pe related by component->PE_PE[R8001];
select one cp related by component->CP_CP[R4604];
select one compParent related by component->CN_CIC[R4203];
if(empty pe and empty cp and empty compParent)
  return false;
end if;
// now check to see if there are additional interface references added
select many interfaceRefs related by component->C_PO[R4010]->C_IR[R4016];
for each interfaceRef in interfaceRefs
  if(interfaceRef.isFormal())
    select any localRef related by self->CL_IIR[R4700]->C_IR[R4701]
                                         where (selected.Id == interfaceRef.Id);
    if(empty localRef)
      // not synchronized
      return false;
    end if;
  end if;
end for;
return true;',
	1,
	'',
	9546);
INSERT INTO O_TFR
	VALUES (9548,
	2807,
	'synchronize',
	'',
	19,
	1,
	'/**
 * Synchronize this reference, which is simply to unassign it
 */
// only unassign if the referenced component is a proxy
select one component related by self->C_C[R4201];
select one pe related by component->PE_PE[R8001];
select one cp related by component->CP_CP[R4604];
select one compParent related by component->CN_CIC[R4203];
if(Util::isProxy(element:component.convertToInstance()) or
                                   (empty pe and empty cp and empty compParent))
  self.unAssign();
else
  // we need to add local imported references for any not
  // already handled
  select many interfaceRefs related by component->C_PO[R4010]->C_IR[R4016];
  for each interfaceRef in interfaceRefs
    select any localRef related by self->CL_IIR[R4700]->C_IR[R4701]
                                         where (selected.Id == interfaceRef.Id);
    if(empty localRef and interfaceRef.isFormal())
      // create a local ref
      select one provision related by interfaceRef->C_P[R4009];
      create object instance importedRef of CL_IIR;
      if(not_empty provision)
        create object instance importedPro of CL_IP;
        relate importedPro to importedRef across R4703;
      else
        create object instance importedReq of CL_IR;
        relate importedReq to importedRef across R4703;        
      end if;
      relate importedRef to self across R4700;
      relate importedRef to interfaceRef across R4701;
    end if;
  end for;
end if;',
	1,
	'',
	9547);
INSERT INTO O_TFR
	VALUES (9549,
	2807,
	'collectChanges',
	'',
	19,
	1,
	'/**
 *  Collect changes that will occur once this reference is synchronized
 */
// for a component reference this will be is formalization state, satisfaction,
// as well as its imported interface references
if(not self.isSynchronized())
  select one comp related by self->C_C[R4201];
  select one pe related by comp->PE_PE[R8001];
  select one cp related by comp->CP_CP[R4604];
  select one compParent related by comp->CN_CIC[R4203];
  if(Util::isProxy(element:comp.convertToInstance()) or
                                   (empty pe and empty cp and empty compParent))
    // we only need to collect the unassign change
    Util::createElementChange(changeList: param.changeList,
                                        elementChanged:self.convertToInstance(),
                                     isRemoval:true, changeLabel:"Unassigned");
  else
    select many interfaceRefs related by comp->C_PO[R4010]->C_IR[R4016];
    for each interfaceRef in interfaceRefs
      if(interfaceRef.isFormal())
        select any localRef related by self->CL_IIR[R4700]->C_IR[R4701]
                                         where (selected.Id == interfaceRef.Id);
        if(empty localRef)
          Util::createElementChange(changeList:param.changeList, elementChanged:
                                      self.convertToInstance(), isRemoval:false,
                           changeLabel:interfaceRef.interfaceName() + " added");
        end if;
      end if;
    end for;
  end if;
end if;',
	1,
	'',
	9548);
INSERT INTO O_TPARM
	VALUES (9550,
	9549,
	'changeList',
	317,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9551,
	2807,
	'collectReferencesForSynchronization',
	'',
	19,
	1,
	'/*
 *  Collect imported interface references (for push or pull)
 */
select many importedProvisions related by self->CL_IIR[R4700]->CL_IP[R4703];
for each importedPro in importedProvisions
  Util::addElementToList(elementList:param.referenceList,
                                       element:importedPro.convertToInstance());
end for;
select many importedRequirements related by self->CL_IIR[R4700]->CL_IR[R4703];
for each importedReq in importedRequirements
  Util::addElementToList(elementList:param.referenceList,
                                       element:importedReq.convertToInstance());    
end for;',
	1,
	'',
	9549);
INSERT INTO O_TPARM
	VALUES (9552,
	9551,
	'referenceList',
	317,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9553,
	9551,
	'syncType',
	3500,
	0,
	'',
	9552,
	'');
INSERT INTO O_TFR
	VALUES (9554,
	2807,
	'getCachedName',
	'Translate:native',
	322,
	1,
	'	return m_name;',
	0,
	'',
	9551);
INSERT INTO O_TFR
	VALUES (9555,
	2807,
	'setCachedName',
	'Translate:native',
	19,
	1,
	'	m_name = p_Name;',
	0,
	'',
	9554);
INSERT INTO O_TPARM
	VALUES (9556,
	9555,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9557,
	2807,
	'isReferringToDefaultComponent',
	'',
	316,
	1,
	'select one component related by self->C_C[R4201];
if(not_empty component)
  return Util::isProxy(element:component.convertToInstance());
end if;
return true;',
	1,
	'',
	9555);
INSERT INTO O_TFR
	VALUES (9558,
	2807,
	'canReferToComponent',
	'',
	316,
	1,
	'select one comp related by self->C_C[R4201];
select one pe related by self->PE_PE[R8001];
isAccessible = true;
if(not_empty pe)
  // need to verify that the component in question
  // is accessible
  isAccessible = pe.isElementVisibleToSelf(type:
                            ElementTypeConstants::COMPONENT, elementId:comp.Id);
end if;
return isAccessible and self.canAssignToComp(Id:comp.Id,
                                                      checkExistingType: false);',
	1,
	'',
	9557);
INSERT INTO O_NBATTR
	VALUES (9559,
	2807);
INSERT INTO O_BATTR
	VALUES (9559,
	2807);
INSERT INTO O_ATTR
	VALUES (9559,
	2807,
	9560,
	'Mult',
	'Full Name: Multiplicity
Description: Multiplicity of the component.  Indicates how many instances of the component may exist.
Data Domain: 0 = one, 1 = many
enum0: One
enum1: Many',
	'',
	'Mult',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (9561,
	2807);
INSERT INTO O_BATTR
	VALUES (9561,
	2807);
INSERT INTO O_ATTR
	VALUES (9561,
	2807,
	9559,
	'ClassifierName',
	'Full Name: Classifier Name',
	'',
	'ClassifierName',
	0,
	322,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (9562,
	2807,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
result = self.getCachedName();
if(self.isAssigned())
  select one comp related by self->C_C[R4201];
  if(not Util::isProxy(element:comp.convertToInstance()))
    result = comp.getPath(path:"", includeSelf:true);
    if(self.ClassifierName != "")
      result = result + ":" + self.ClassifierName;
    end if;
  end if;
else
  result = "Unassigned Imported Component";
end if;
self.setCachedName(name:result);
self.Name = result;',
	1);
INSERT INTO O_BATTR
	VALUES (9562,
	2807);
INSERT INTO O_ATTR
	VALUES (9562,
	2807,
	9561,
	'Name',
	'User_Visible:false',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (9563,
	2807);
INSERT INTO O_BATTR
	VALUES (9563,
	2807);
INSERT INTO O_ATTR
	VALUES (9563,
	2807,
	9562,
	'Descrip',
	'Full Name: Imported Component Description
Description: A textual description of this imported component.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (2807,
	707,
	0,
	758,
	9205,
	9207,
	9206,
	9560,
	9564,
	0,
	0,
	'',
	'Component Package',
	'Package_ID',
	'R4605');
INSERT INTO O_RATTR
	VALUES (9560,
	2807,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (9560,
	2807,
	9565,
	'Component_Package_ID',
	'',
	'Component_',
	'Package_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2807,
	709,
	0,
	762,
	9344,
	9345,
	9346,
	9566,
	9567,
	0,
	0,
	'',
	'Component',
	'Id',
	'R4201');
INSERT INTO O_RATTR
	VALUES (9566,
	2807,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (9566,
	2807,
	4175,
	'AssignedComp_Id',
	'',
	'AssignedComp_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2807,
	709,
	0,
	762,
	9347,
	9348,
	9349,
	9565,
	9568,
	0,
	0,
	'',
	'Component',
	'Id',
	'R4205');
INSERT INTO O_RATTR
	VALUES (9565,
	2807,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (9565,
	2807,
	9566,
	'ParentComp_Id',
	'',
	'ParentComp_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2807,
	26,
	0,
	25,
	868,
	2831,
	870,
	4175,
	9569,
	0,
	0,
	'',
	'Packageable Element',
	'Element_ID',
	'R8001');
INSERT INTO O_RATTR
	VALUES (4175,
	2807,
	25,
	26,
	0,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (4175,
	2807,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2807);
INSERT INTO O_OIDA
	VALUES (4175,
	2807,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	2807);
INSERT INTO O_ID
	VALUES (2,
	2807);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (709,
	'Component',
	4000,
	'C_C',
	'A component defines the content of a system.  Its associations with other
components are defined through interfaces that are either provided or required
by the component.

A Component is related to an Interface through two different link classes,
Requirement and Provision.  The links are setup when either the Provision or
Requirement is formalized against an interface that is defined in an Interface
Diagram',
	8619);
INSERT INTO O_TFR
	VALUES (9570,
	709,
	'dispose',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one domainAsComponent related by self->CN_DC[R4204];
if(not_empty domainAsComponent)
  select one domain related by domainAsComponent->S_DOM[R4204];
  unrelate domain from self across R4204 using domainAsComponent;
  delete object instance domainAsComponent;
  domain.dispose();
end if;

select many importedComponents related by self->CL_IC[R4205];
for each importedComponent in importedComponents
  importedComponent.dispose();
end for;

select many cics related by self->CN_CIC[R4202];
for each cic in cics
  unrelate self from cic across R4202;
  select one comp related by cic->C_C[R4202];
  if not_empty comp
    unrelate comp from cic across R4203;
    comp.dispose();
  end if;
  delete object instance cic;
end for;

select one cic related by self->CN_CIC[R4203];
if (not_empty cic) 
  select one parent_comp related by cic->C_C[R4202];
  if not_empty parent_comp
    unrelate cic from parent_comp across R4202;
  end if;
  unrelate self from cic across R4203;
  delete object instance cic;
end if;

select one componentPackage related by self->CP_CP[R4604];
if(not_empty componentPackage)
  unrelate self from componentPackage across R4604;
end if;

select many ports related by self->C_PO[R4010];
for each port in ports
  unrelate self from port across R4010;
  port.dispose();
end for;

select many interfacePackages related by self->IP_IP[R4206];
for each interfacePackage in interfacePackages
  unrelate self from interfacePackage across R4206;
  interfacePackage.dispose();
end for;

select one rootPkg related by self->CP_CP[R4608];
if not_empty rootPkg
  unrelate self from rootPkg across R4608;
end if;

select many bodyInComponents related by self->ACT_BIC[R694];
for each bic in bodyInComponents
  select one body related by bic->ACT_ACT[R694];
  unrelate self from body across R694 using bic;
  delete object instance bic;
end for;

select many dics related by self->PA_DIC[R9002];
for each dic in dics
  select one delegation related by dic->C_DG[R9002];
  unrelate self from delegation across R9002 using dic;
  // no need to dispose the delegation, it will get
  // disposed later
  delete object instance dic;
end for;

select many sics related by self->PA_SIC[R9000];
for each sic in sics
  select one satisfaction related by sic->C_SF[R9000];
  unrelate self from satisfaction across R9000 using sic;
  // no need to dispose satisfaction, it will get
  // disposed later
  delete object instance sic;
end for;

select many executionEngines related by self->I_EXE[R2955];
for each engine in executionEngines
  unrelate engine from self across R2955;
  engine.dispose();
end for;

// dispose informal diagrams
select many sequences related by self->SQ_S[R952];
for each sequence in sequences
  unrelate self from sequence across R952;
  sequence.dispose();
end for;

select many activities related by self->A_A[R1115];
for each activity in activities
  unrelate self from activity across R1115;
  activity.dispose();
end for;

select many comms related by self->COMM_COMM[R1138];
for each comm in comms
  unrelate self from comm across R1138;
  comm.dispose();
end for;

select many uccs related by self->UC_UCC[R1213];
for each ucc in uccs
  unrelate self from ucc across R1213;
  ucc.dispose();
end for;

select many compParts related by self->SQ_COP[R955];
for each compPart in compParts
  compPart.unformalize();
end for;
self.clearScope();
// dispose Packagable Elements
select many pes related by self ->PE_PE[R8003];
for each pe in pes
  unrelate self from pe across R8003;
  pe.dispose();
end for;
select one pe related by self->PE_PE[R8001];
if (not_empty pe)
  unrelate self from pe across R8001;
  pe.dispose();
end if;
select many comVis related by self->PE_CVS[R8004];
for each comV in comVis
  select one pe related by comV->PE_PE[R8004];
  unrelate self from pe across R8004 using comV;
  delete object instance comV;
end for;
select many comRSs related by self->PE_CRS[R8007];
for each comRS in comRSs
  comRS.dispose();
end for;

delete object instance self;',
	1,
	'',
	9571);
INSERT INTO O_TFR
	VALUES (9572,
	709,
	'initialize',
	'',
	19,
	1,
	'name = ::getUniqueInitialName( 
    instance: self.convertToInstance(), 
    candidateName: "Unnamed Component" );
success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:true);    
if ( success!="") 
 self.Name=success;
else 
 self.dispose();
end if;        ',
	1,
	'',
	9573);
INSERT INTO O_TFR
	VALUES (9571,
	709,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'return this;',
	0,
	'',
	9574);
INSERT INTO O_TFR
	VALUES (9574,
	709,
	'actionFilter',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
if(param.name == "can")
  select one packageableElem related by self->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];
  isInGenericPackage = not_empty package or not_empty component;    
  if(param.value == "formalize")
    // formalization is not allowed under generic pacakges
    if (isInGenericPackage)
      return false;
    end if;
    // a component may be formalized if it has no
    // internal structure
    select any childComp related by self->CN_CIC[R4202];
    if(not_empty childComp)
      return false;
    end if;
    select any sequence related by self->SQ_S[R952];
    if(not_empty sequence)
      return false;
    end if;
    select any comm related by self->COMM_COMM[R1138];
    if(not_empty comm)
      return false;
    end if;
    select any activity related by self->A_A[R1115];
    if(not_empty activity)
      return false;
    end if;
    select any uc related by self->UC_UCC[R1213];
    if(not_empty uc)
      return false;
    end if;
    select any childIComp related by self->CL_IC[R4205];
    if(not_empty childIComp)
      return false;
    end if;
    select one system related by self->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405];
    // NOTE: When old packages are removed, the follow traversal  though the
    //       component package to find the S_SYS can be removed.
    if (not_empty system)
      // Do not allow formalize if this component is in a generic package
      return false;
    else
      select one compPackage related by self->CP_CP[R4604];
      select one parentComp related by self->CN_CIC[R4203]->C_C[R4202];
      while(empty compPackage and not_empty parentComp)
        select one compPackage related by parentComp->CP_CP[R4604];
        select one parentComp related by parentComp->CN_CIC[R4203]->C_C[R4202];
      end while;
      select one system related by compPackage->S_SYS[R4606];
    end if;
    select many domains related by system->S_DOM[R28];
	return not_empty domains;
  elif(param.value == "unformalize")
    if (isInGenericPackage)
      return false;
    end if;  
    select one domain related by self->CN_DC[R4204]->S_DOM[R4204];
    return not_empty domain;
  elif(param.value == "launchVerifier")
    return not self.isBeingVerified();
  elif param.value == "make public"
    select one pe related by self->PE_PE[R8001];
    select one pkg related by pe->EP_PKG[R8000];
    if not_empty pkg
      if not_empty pe 
        return pe.Visibility != Visibility::Public;
      end if;
    end if;
  elif param.value == "make protected"
    select one pe related by self->PE_PE[R8001];
    select one pkg related by pe->EP_PKG[R8000];
    if not_empty pkg
      if not_empty pe 
        return pe.Visibility != Visibility::Protected;
      end if;
    end if;
  elif param.value == "make private"
    select one pe related by self->PE_PE[R8001];
    select one pkg related by pe->EP_PKG[R8000];
    if not_empty pkg
      if not_empty pe 
        return pe.Visibility != Visibility::Private;
      end if;
    end if;
  end if;
elif(param.name == "new")
  isInGenericPackage = self.isInGenericPackage();

  if(param.value == "subsystem")
    return self.isFormal();
  elif(param.value == "external entity package")
    return self.isFormal();
  elif(param.value == "function package")
    return self.isFormal();
  elif(param.value == "dataType package")
    return self.isFormal();
  elif(param.value == "component")
    return not self.isFormal();
  elif(param.value == "imported component")
    return not self.isFormal();
  elif(param.value == "interface package")
    if (isInGenericPackage)
      return false;
    end if;
    return not self.isFormal();
  elif(param.value == "sequence diagram")
    if (isInGenericPackage)
      return false;
    end if;
    return true;
  elif(param.value == "communication diagram")
    if (isInGenericPackage)
      return false;
    end if;
    return true;
  elif(param.value == "use case diagram")
    if (isInGenericPackage)
      return false;
    end if;
    return true;
  elif(param.value == "activity diagram")
    if (isInGenericPackage)
      return false;
    end if;
    return true;
  elif(param.value == "package")
    if (isInGenericPackage)
      return true;
    end if;
    return false;
  end if;  
elif (param.name == "has")
  if (param.value == "realized components")
    return self.hasRealizedComponents();
  end if;
end if;
return false;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (9575,
	9574,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9576,
	9574,
	'value',
	322,
	0,
	'',
	9575,
	'');
INSERT INTO O_TFR
	VALUES (9577,
	709,
	'get_compartment_text',
	'',
	322,
	1,
	'result = "";
postResult = "";
if (param.at == Justification::Center)
  return self.Label;
end if;
return result;',
	1,
	'',
	9578);
INSERT INTO O_TPARM
	VALUES (9579,
	9577,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9580,
	9577,
	'ent_num',
	298,
	0,
	'',
	9581,
	'');
INSERT INTO O_TPARM
	VALUES (9581,
	9577,
	'comp_num',
	298,
	0,
	'',
	9579,
	'');
INSERT INTO O_TFR
	VALUES (9582,
	709,
	'get_entries',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	9583);
INSERT INTO O_TPARM
	VALUES (9584,
	9582,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9585,
	709,
	'get_style',
	'',
	784,
	1,
	'return Style::Component;',
	1,
	'',
	9582);
INSERT INTO O_TFR
	VALUES (9583,
	709,
	'get_compartments',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	9577);
INSERT INTO O_TFR
	VALUES (9586,
	709,
	'get_text_style',
	'',
	784,
	1,
	'return Style::None;',
	1,
	'',
	9585);
INSERT INTO O_TPARM
	VALUES (9587,
	9586,
	'ent_num',
	298,
	0,
	'',
	9588,
	'');
INSERT INTO O_TPARM
	VALUES (9589,
	9586,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9588,
	9586,
	'comp_num',
	298,
	0,
	'',
	9589,
	'');
INSERT INTO O_TFR
	VALUES (9590,
	709,
	'formalize',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one pkg related by self->PE_PE[R8001]->EP_PKG[R8000];
if (not_empty pkg)
  // there is no formalize under a generic package
  return;
end if;

if(self.isFormal())
  self.unformalize();
end if;
select one componentPackage related by self->CP_CP[R4604];
select one parentComp related by self->CN_CIC[R4203]->C_C[R4202];
while(empty componentPackage)
  select one componentPackage related by parentComp->CP_CP[R4604];
  select one parentComp related by parentComp->CN_CIC[R4203]->C_C[R4202];
end while;
if (not_empty componentPackage)
  select one system related by componentPackage->S_SYS[R4606];
  if (not_empty system)
    select any domain related by system->S_DOM[R28] where
                                                 selected.Dom_ID == param.domId;
    if(not_empty domain)
      create object instance dac of CN_DC;
      relate self to domain across R4204 using dac;
      if(domain.Descrip != "")
        self.Descrip = self.Descrip + GD::newline() +
                                                 GD::newline() + domain.Descrip;
      end if;
      self.Name=domain.Name;
      // now associate all domain children to the
      // new system level dts
      domain.associateChildrenWithSystemCoreTypes();
      // and associate all built-in types
      domain.associateChildrenWithSystemBuiltInTypes();
      // and finally suppress all core datatypes
      // that were previously associated with
      // the domain
      select many datatypes related by domain->S_DT[R14];
      for each datatype in datatypes
        select one coreDt related by datatype->S_CDT[R17]->S_DT[R17];
        if not_empty coreDt
          unrelate coreDt from domain across R14;
          create object instance datatypeInSuppression of S_DIS;
          relate coreDt to domain across R47 using datatypeInSuppression;
          select one dtip related by coreDt->S_DIP[R39];
          select one dtp related by dtip->S_DPK[R39];
          unrelate coreDt from dtp across R39 using dtip;
          delete object instance dtip;
        end if;
      end for;
      // also suppress any dts that have the built-in value set
      for each datatype in datatypes
        select one builtinDt related by datatype->S_UDT[R17];
        if not_empty builtinDt and  builtinDt.Gen_Type != 0
          select one dt related by builtinDt->S_DT[R17];
          unrelate dt from domain across R14;
          create object instance datatypeInSuppression of S_DIS;
          relate dt to domain across R47 using datatypeInSuppression;
          select one dtip related by dt->S_DIP[R39];
          select one dtp related by dtip->S_DPK[R39];
          unrelate dt from dtp across R39 using dtip;
          delete object instance dtip;
        end if;
      end for;
      select one system related by domain->S_SYS[R28];
      if(not_empty system)
        unrelate domain from system across R28;
      end if;
    end if;
  end if;
end if;',
	1,
	'',
	9570);
INSERT INTO O_TPARM
	VALUES (9591,
	9590,
	'domId',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9592,
	709,
	'unformalize',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one dac related by self->CN_DC[R4204];
if(not_empty dac)
  select one domain related by dac->S_DOM[R4204];
  if (not_empty domain)
    // Restore all suppressed data types
    domain.associateChildrenWithSuppressedDatatypes();
    unrelate self from domain across R4204 using dac;
    select many suppressions related by domain->S_DIS[R47];
    select any rootDtPkg related by domain->S_DPK[R40] where
                             selected.Parent_Package_ID == GD::NULL_UNIQUE_ID();
    for each suppression in suppressions
      select one dt related by suppression->S_DT[R47];
      unrelate dt from domain across R47 using suppression;
      delete object instance suppression;
      relate dt to domain across R14;
      create object instance dip of S_DIP;
      // Suppressed data types are always restored to the root DT Package
      relate dt to rootDtPkg across R39 using dip;
    end for;
  end if;
  delete object instance dac;
  select one componentPackage related by self->CP_CP[R4604];
  select one parentComp related by self->CN_CIC[R4203]->C_C[R4202];
  while(empty componentPackage)
    select one componentPackage related by parentComp->CP_CP[R4604];
    select one parentComp related by parentComp->CN_CIC[R4203]->C_C[R4202];
  end while;
  if (not_empty componentPackage)
    select one system related by componentPackage->S_SYS[R4606];
    relate domain to system across R28;
  end if;
end if;',
	1,
	'',
	9593);
INSERT INTO O_TFR
	VALUES (9594,
	709,
	'isFormal',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
isInGenericPkg = self.isInGenericPackage();
select one pkg related by self->PE_PE[R8001]->EP_PKG[R8000];

if (isInGenericPkg)
  // there is no concept of "formal component" in generic packages.
  return false;
else
  select one domain related by self->CN_DC[R4204]->S_DOM[R4204];
  return not_empty domain;
end if;   

',
	1,
	'',
	9595);
INSERT INTO O_TFR
	VALUES (9596,
	709,
	'getPath',
	'',
	322,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
path = "";
if param.includeSelf == true
  path = self.Name;
end if;
if(param.path != "")
  path = path + "::" + param.path;
end if;
select one pkg related by self->PE_PE[R8001]->EP_PKG[R8000];
if (not_empty pkg)
  return pkg.getPath(path:path);
end if;
select one comp related by self->PE_PE[R8001]->C_C[R8003];
if (not_empty comp)
  return comp.getPath(path:path, includeSelf:true);
end if;
select one package related by self->CP_CP[R4604];
if (not_empty package)
  return package.getPath(path:path);
else
  select one cic related by self->CN_CIC[R4203]->C_C[R4202];
  if(not_empty cic)
    return cic.getPath(path:path, includeSelf:true);
  end if;
end if;
return "";',
	1,
	'',
	9597);
INSERT INTO O_TPARM
	VALUES (9598,
	9596,
	'path',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9599,
	9596,
	'includeSelf',
	316,
	0,
	'',
	9598,
	'');
INSERT INTO O_TFR
	VALUES (9600,
	709,
	'manyMultAllowed',
	'',
	316,
	1,
	'return true;',
	1,
	'',
	9594);
INSERT INTO O_TFR
	VALUES (9601,
	709,
	'newComponent',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Component::newComponent()
isInGenericPackage = self.isInGenericPackage();
if isInGenericPackage
  create object instance component of C_C;
  // create Packageable Element supertype and hook up to this component.
  create object instance pe of PE_PE;
  relate component to pe across R8001;
  relate self to pe across R8003;
  component.initialize();
  pe.type = ElementTypeConstants::COMPONENT;
  pe.initialize();
  return component.Id;
else
  create object instance component of C_C;
  create object instance cic of CN_CIC;
  relate component to cic across R4203;
  relate self to cic across R4202;
  select one rootPkg related by self->CP_CP[R4608];
  relate component to rootPkg across R4608;
  component.initialize();
  return cic.Id;
end if;',
	1,
	'',
	9602);
INSERT INTO O_TFR
	VALUES (9603,
	709,
	'newProvision',
	'',
	316,
	1,
	'isInGenericPackage = self.isInGenericPackage();
// Create empty variable of type inst_ref<Component>
select any component from instances of C_C
                                        where selected.Id==GD::NULL_UNIQUE_ID();
	// if the component is empty, see if the given
	// id is actually this component''s as we are
	// creating an outer interface reference
if isInGenericPackage
	select any component related by self->PE_PE[R8003]->C_C[R8001]
	                                          where (selected.Id == param.from);
else 
	select any component related by self->CN_CIC[R4202]->C_C[R4203]
	                                          where (selected.Id == param.from);
end if;

if(empty component)
  if(param.from == self.Id)
    component = self;
  end if;
end if;

select any requirement from instances of C_R
                                    where (selected.Requirement_Id == param.to);
select any importedRef from instances of CL_IIR where (selected.Id == param.to);
if(not_empty importedRef) and (not_empty component)
  return component.initializeProvision(requirement_id:importedRef.Id,
                               provision_id:GD::NULL_UNIQUE_ID(), proceed:true);
end if;
if(not_empty requirement) and (not_empty component)
  return component.initializeProvision(
                                      requirement_id:requirement.Requirement_Id,
                               provision_id:GD::NULL_UNIQUE_ID(), proceed:true);
end if;
if(empty requirement and not_empty component)
  return component.initializeProvision(requirement_id:GD::NULL_UNIQUE_ID(),
                               provision_id:GD::NULL_UNIQUE_ID(), proceed:true);
end if;
return false;
',
	1,
	'',
	9604);
INSERT INTO O_TPARM
	VALUES (9605,
	9603,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9606,
	9603,
	'to',
	296,
	0,
	'',
	9607,
	'');
INSERT INTO O_TPARM
	VALUES (9607,
	9603,
	'fromIsImported',
	316,
	0,
	'',
	9605,
	'');
INSERT INTO O_TPARM
	VALUES (9608,
	9603,
	'toIsImported',
	316,
	0,
	'',
	9606,
	'');
INSERT INTO O_TFR
	VALUES (9609,
	709,
	'newRequirement',
	'',
	316,
	1,
	'isInGenericPackage = self.isInGenericPackage();
// Create empty variable of type inst_ref<Component>
select any component from instances of C_C
                                        where selected.Id==GD::NULL_UNIQUE_ID();
// id is actually this component''s as we are
// if the component is empty, see if the given
// creating an outer interface reference
if isInGenericPackage
	select any component related by self->PE_PE[R8003]->C_C[R8001]
	                                          where (selected.Id == param.from);
else 
	select any component related by self->CN_CIC[R4202]->C_C[R4203]
	                                          where (selected.Id == param.from);
end if;

if(empty component)
  if(param.from == self.Id)
    component = self;
  end if;
end if;
select any provision from instances of C_P
                                      where (selected.Provision_Id == param.to);
select any importedRef from instances of CL_IIR where (selected.Id == param.to);
if(not_empty provision and not_empty component)
  return component.initializeRequirement(provision_id:provision.Provision_Id,
                             requirement_id:GD::NULL_UNIQUE_ID(), proceed:true);
end if;
if(not_empty importedRef) and (not_empty component)
  return component.initializeRequirement(provision_id:importedRef.Id,
                             requirement_id:GD::NULL_UNIQUE_ID(), proceed:true);
end if;
if(not_empty component)
  return component.initializeRequirement(provision_id:GD::NULL_UNIQUE_ID(),
                             requirement_id:GD::NULL_UNIQUE_ID(), proceed:true);
end if;
return false;',
	1,
	'',
	9603);
INSERT INTO O_TPARM
	VALUES (9610,
	9609,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9611,
	9609,
	'fromIsImported',
	316,
	0,
	'',
	9610,
	'');
INSERT INTO O_TPARM
	VALUES (9612,
	9609,
	'to',
	296,
	0,
	'',
	9611,
	'');
INSERT INTO O_TPARM
	VALUES (9613,
	9609,
	'toIsImported',
	316,
	0,
	'',
	9612,
	'');
INSERT INTO O_TFR
	VALUES (9614,
	709,
	'newImportedComponent',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Component::newimportedComponent()
isInGenericPackage = self.isInGenericPackage();
if (isInGenericPackage)
  create object instance icomponent of CL_IC;
  
  create object instance pe of PE_PE;
  relate icomponent to pe across R8001;
  relate self to pe across R8003;
else
  create object instance icomponent of CL_IC;
  relate icomponent to self across R4205;
end if;',
	1,
	'',
	9615);
INSERT INTO O_TFR
	VALUES (9615,
	709,
	'newDelegation',
	'',
	316,
	1,
	'// Component.newDelegation()
select one pe related by self->PE_PE[R8001];
isInGenericPackage = not_empty pe;
sourceIsSelf = false;
if(param.from == self.Id)
  sourceIsSelf = true;
elif(param.to == self.Id)
  sourceIsSelf = true;
end if;

select any component from instances of C_C where selected.Id==GD::NULL_UNIQUE_ID();
if ( isInGenericPackage )

	select any component related by self->PE_PE[R8003]->C_C[R8001] where (selected.Id == param.to);
	if(empty component)
		select any component related by self->PE_PE[R8003]->C_C[R8001] where (selected.Id == param.from);
	end if;
else 
	select any component related by self->CN_CIC[R4202]->C_C[R4203] where (selected.Id == param.to);
	if(empty component)
		select any component related by self->CN_CIC[R4202]->C_C[R4203] where (selected.Id == param.from);
	end if;

end if;

select any destImportRef from instances of CL_IIR where (selected.Id == param.to);
if(empty destImportRef)
  select any destImportRef from instances of CL_IIR where (selected.Id == param.from);
end if;

select any destReference from instances of C_IR where selected.Id==GD::NULL_UNIQUE_ID();
if ( isInGenericPackage  )
	select any destReference related by self->PE_PE[R8003]->C_C[R8001]->C_PO[R4010]->C_IR[R4016] where (selected.Id == param.to);
	if(empty destReference)
		select any destReference related by self->PE_PE[R8003]->C_C[R8001]->C_PO[R4010]->C_IR[R4016] where (selected.Id == param.from);
	end if;

else
	select any destReference related by self->CN_CIC[R4202]->C_C[R4203]->C_PO[R4010]->C_IR[R4016] where (selected.Id == param.to);
	if(empty destReference)
		select any destReference related by self->CN_CIC[R4202]->C_C[R4203]->C_PO[R4010]->C_IR[R4016] where (selected.Id == param.from);
	end if;

end if;

if(empty destReference and not_empty destImportRef)
  select one destReference related by destImportRef->C_IR[R4701];
end if;
select any srcReference related by self->C_PO[R4010]->C_IR[R4016] where (selected.Id == param.from);
if(empty srcReference)
  select any srcReference related by self->C_PO[R4010]->C_IR[R4016] where (selected.Id == param.to);
end if;
if(sourceIsSelf)
  // ambiguous, we do not know what
  // to create in this situation so
  // disallow
  if(empty destReference)
    return false;
  else
    // allow creation of delegation as
    // well as create a new interface reference
    // for self
    create object instance reference of C_IR;
    create object instance delegation of C_DG;
    if isInGenericPackage
      create object instance dlgPe of PE_PE;
      dlgPe.type = ElementTypeConstants::DELEGATION;
      dlgPe.initialize();
      relate dlgPe to delegation across R8001;
      relate self to dlgPe across R8003;
    else
      create object instance dic of PA_DIC;
      relate delegation to self across R9002 using dic;
    end if;
    if(not empty destImportRef)
      relate destImportRef to delegation across R4704;
    end if;
    create object instance refInDelegation of C_RID;
    create object instance port of C_PO;
    relate port to reference across R4016;
    relate port to self across R4010;
    port.initialize();
    relate reference to delegation across R4013 using refInDelegation;
    relate destReference to delegation across R4014;
    if(not_empty destImportRef)
      relate delegation to destImportRef across R4704;
    end if;
    select one provision related by destReference->C_P[R4009];
    if(not_empty provision)
      create object instance new_provision of C_P;
      relate new_provision to reference across R4009;
      new_provision.initialize();
    else
      create object instance requirement of C_R;
      relate requirement to reference across R4009;
      requirement.initialize();
    end if;
    if(destReference.isFormal())
      select one interface related by destReference->C_I[R4012];
      reference.formalize(formalizeOther: false, id: interface.Id);
    end if;
    return true;
  end if;
else
  if(not_empty srcReference)
    if(not_empty component)
      // allow creation of delegation and create a reference
      // in the destination component
      create object instance reference of C_IR;
      create object instance delegation of C_DG;
      if isInGenericPackage
        create object instance dlgPe of PE_PE;
        dlgPe.type = ElementTypeConstants::DELEGATION;
        dlgPe.initialize();
        relate dlgPe to delegation across R8001;
        relate self to dlgPe across R8003;
      else
        create object instance dic of PA_DIC;
        relate delegation to self across R9002 using dic;
      end if;
      create object instance refInDelegation of C_RID;
      create object instance port of C_PO;
      relate port to reference across R4016;
      relate port to component across R4010;
      port.initialize();
      relate srcReference to delegation across R4013 using refInDelegation;
      relate reference to delegation across R4014;
      select one provision related by srcReference->C_P[R4009];
      if(not_empty provision)
        create object instance new_provision of C_P;
        relate new_provision to reference across R4009;
        new_provision.initialize();
      else
        create object instance requirement of C_R;
        relate requirement to reference across R4009;
        requirement.initialize();
      end if;
      if(srcReference.isFormal())
        select one interface related by srcReference->C_I[R4012];
        reference.formalize(formalizeOther: false, id: interface.Id);
      end if;
      return true;
    elif(not_empty destReference)
      // allow creation of delegation as long as the
      // source reference and dest reference are
      // similar.  This means that both are either
      // provisions or requirements and if formal
      // both are formalized to the same interface
      if(srcReference.isFormal() and destReference.isFormal())
        select one srcInterface related by srcReference->C_I[R4012];
        select one destInterface related by destReference->C_I[R4012];
        if(srcInterface != destInterface)
          return false;
        end if;
      end if;
      select one srcProvision related by srcReference->C_P[R4009];
      if(not_empty srcProvision)
        select one destProvision related by destReference->C_P[R4009];
        if(empty destProvision)
          return false;
        end if;
      else
        select one srcReq related by srcReference->C_R[R4009];
        if(not_empty srcReq)
          select one destReq related by destReference->C_R[R4009];
          if(empty destReq)
            return false;
          end if;
        end if;
      end if;
      create object instance delegation of C_DG;
      if isInGenericPackage
        create object instance dlgPe of PE_PE;
        dlgPe.type = ElementTypeConstants::DELEGATION;
        dlgPe.initialize();
        relate dlgPe to delegation across R8001;
        relate self to dlgPe across R8003;
      else
        create object instance dic of PA_DIC;
        relate delegation to self across R9002 using dic;
      end if;
      if(not empty destImportRef)
        relate destImportRef to delegation across R4704;
      end if;
      create object instance refInDelegation of C_RID;
      relate delegation to srcReference across R4013 using refInDelegation;
      relate delegation to destReference across R4014;
      if(not_empty destImportRef)
        relate delegation to destImportRef across R4704;
      end if;
      if(srcReference.isFormal())
        if(not destReference.isFormal())
          select one interface related by srcReference->C_I[R4012];
          destReference.formalize(formalizeOther: false, id: interface.Id);
        end if;
      end if;
      if(destReference.isFormal())
        if(not srcReference.isFormal())
          select one interface related by destReference->C_I[R4012];
          srcReference.formalize(formalizeOther: false, id: interface.Id);
        end if;
      end if;
      return true;
    end if;
  end if;
end if;
return false;',
	1,
	'',
	9601);
INSERT INTO O_TPARM
	VALUES (9616,
	9615,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9617,
	9615,
	'fromIsImported',
	316,
	0,
	'',
	9616,
	'');
INSERT INTO O_TPARM
	VALUES (9618,
	9615,
	'toIsImported',
	316,
	0,
	'',
	9619,
	'');
INSERT INTO O_TPARM
	VALUES (9619,
	9615,
	'to',
	296,
	0,
	'',
	9617,
	'');
INSERT INTO O_TFR
	VALUES (9604,
	709,
	'newInterfacePackage',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// When in a generic package we will not allow specialized packages by 
// filtering the option in the UI.  Therefore this not be invoked when the 
// component is under a generic package.
create object instance specPkg of EP_SPKG;
create object instance interfacePackage of IP_IP;
relate interfacePackage to specPkg across R1402;
relate self to interfacePackage across R4206;
select one componentPackage related by self->CP_CP[R4604];
if(empty componentPackage)
  select one parentComp related by self->CN_CIC[R4203]->C_C[R4202];
  while(empty componentPackage)
    select one componentPackage related by parentComp->CP_CP[R4604];
    select one parentComp related by parentComp->CN_CIC[R4203]->C_C[R4202];
  end while;
end if;
select one system related by componentPackage->S_SYS[R4606];
relate system to interfacePackage across R4304;
interfacePackage.initialize();',
	1,
	'',
	9614);
INSERT INTO O_TFR
	VALUES (9620,
	709,
	'interfacePackageIsAlongParentPath',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
/*
*  Check that the interface package given exists either at the
*  system level or along the parent path of this component.
*
*/
isInGenericPkg = self.isInGenericPackage();

if (isInGenericPkg)
  return false;
else
  select one componentPackage related by self->CP_CP[R4604];
  if(empty componentPackage)
    // walk the component nesting tree until we find a package
    // checking for the interface package at each level
    select one parentComponent related by self->CN_CIC[R4203]->C_C[R4202];
    if(not_empty parentComponent)
      while(empty componentPackage)
        select any interfacePackage related by parentComponent->IP_IP[R4206] where (selected.Package_ID == param.id);
        if(not_empty interfacePackage)
          return true;
        else
          select many interfacePkgs related by parentComponent->IP_IP[R4206];
          for each interfacePkg in interfacePkgs
            if(interfacePkg.isChildPackageOf(Id:param.id))
              return true;
            end if;
          end for;
        end if;
        select one componentPackage related by parentComponent->CP_CP[R4604];
        select one parentComponent related by parentComponent->CN_CIC[R4203]->C_C[R4202];
      end while;
    end if;
  end if;
  if(not_empty componentPackage)
    return componentPackage.interfacePackageIsAlongParentPath(id:param.id);
  end if;
end if;   


return false;',
	1,
	'',
	9621);
INSERT INTO O_TPARM
	VALUES (9622,
	9620,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9623,
	709,
	'initializeProvision',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this
// comment.
/*
 *  The rules for creating provided interfaces are:
 *
 *   * Common rules
 *     1. Allow to whitespace
 *     2. Allow to requirement if no other provision
 *        already satisfies the interface
 *     3. If both interfaces (Provision and Requirement) are already
 *        formalized, allow satisfaction only if the interfaces match.
 *     4. Formalize requirement if this provision is formalized.  
 *     5. Formalize provision if destination requirement
 *        is formalized.  
 *     6. If a satisfaction already exists to the given provision do not
 *        attempt to satisfy (return false).
 *
 * This routine is used when a new provision is being created as well as when 
 * a existing provision is being connected to a requirement.  In the case where
 * a new provision is being created the param.provision_id will be empty.
 */
select one system related by self->CP_CP[R4608]->S_SYS[R4606];
isInGenericPkg = self.isInGenericPackage();
if (isInGenericPkg)
  select one system related by self->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405];
  if (empty system)
    rootCompIdInPkg = self.getRootComponentId();
    select any rootComponent from instances of C_C
                                         where (selected.Id == rootCompIdInPkg);
    select one package related by rootComponent->PE_PE[R8001]->EP_PKG[R8000];
    select one system related by rootComponent->PE_PE[R8001]->EP_PKG[R8000]
                                                                 ->S_SYS[R1405];
  end if;
end if;

select any requirement from instances of C_R
                        where (selected.Requirement_Id == param.requirement_id);
select any importedRef from instances of CL_IIR
                                    where (selected.Id == param.requirement_id);

if(not_empty importedRef)
  select one requirement related by importedRef->C_IR[R4701]->C_R[R4009];
end if;
if(not_empty requirement)
  select many satisfactions related by requirement->C_SF[R4002];
  for each satisfaction in satisfactions
    if(not satisfaction.satisfiesWithImportedReq())
      select one satisfiedProvision related by satisfaction->C_P[R4002];
      // common rule 2 
      if(not_empty satisfiedProvision) and (empty importedRef)
        return false;
      end if;
    else
      // if this satisfaction is made with
      // the drawn to imported ref do not
      // allow
      select one satImportRef related by satisfaction->CL_IR[R4706];
      select one importedReq related by importedRef->CL_IR[R4703];
      if(satImportRef == importedReq)
        return false;
      end if;
    end if;
  end for;
end if;

// If the provision was passed-in use it, otherwise create it.
isNewProvision = false;
select any provision from instances of C_P 
                       where (selected.Provision_Id == param.provision_id);

// if the provision is empty, see if the element to initialize
// is an imported provision
select any importedProvisionRef from instances of CL_IIR
                                      where (selected.Id == param.provision_id);
if(empty provision)
  if(not_empty importedProvisionRef)
    select one provision related by importedProvisionRef->C_IR[R4701]
                                                                   ->C_P[R4009];
  end if;
end if;
if (empty provision and param.proceed)
  isNewProvision = true;
  create object instance provision of C_P;
  create object instance interfaceRef of C_IR;
  create object instance port of C_PO;
  relate provision to interfaceRef across R4009;
  relate interfaceRef to port across R4016;
  relate port to self across R4010;
  provision.initialize();
  port.initialize();
end if;

if(not_empty requirement)
  // If src and target are both formalized, but to different interfaces, 
  // then return false
  formalizeTarget = empty importedRef;
  formalizeSource = empty importedProvisionRef;
  select one targetInterface related by requirement->C_IR[R4009]->C_I[R4012];
  select one srcInterface related by provision->C_IR[R4009]->C_I[R4012];
  if ((not_empty srcInterface) and (not_empty targetInterface))
    if(targetInterface.Id != srcInterface.Id)
      // common rule 3
      return false;
    else 
      // If they are both already formalized, to the same interface
      // they do not need to be formalized again.
      formalizeTarget = false;
      formalizeSource = false;
    end if;
  end if;
  
  if(param.proceed)
    create object instance satisfaction of C_SF;
    if isInGenericPkg
     // create Packageable Element supertype and hook it up . . . 
      create object instance pe of PE_PE;
      relate satisfaction to pe across R8001;
      if(not_empty importedRef)
        select one importedComp related by importedRef->CL_IC[R4700];
        select one epPkg related by importedComp->PE_PE[R8001]->EP_PKG[R8000];
        select one comp related by importedComp->PE_PE[R8001]->C_C[R8003];
        if not_empty epPkg
          relate pe to epPkg across R8000;
        elif not_empty comp
          relate pe to comp across R8003;
        end if;
      else
        select one epPkg related by self->PE_PE[R8001]->EP_PKG[R8000];
        select one comp related by self->PE_PE[R8001]->C_C[R8003];
        if not_empty epPkg
          relate pe to epPkg across R8000;
        elif not_empty comp
          relate pe to comp across R8003;
        end if;
      end if;
      pe.type = ElementTypeConstants::SATISFACTION;
      pe.initialize();
    else
      if(not_empty importedRef)
        // relate this satisfaction to the diagram for which
        // the imported ref is on
        select one parentComp related by importedRef->CL_IC[R4700]->C_C[R4205];
        if(not_empty parentComp)
          create object instance sic of PA_SIC;
          relate parentComp to satisfaction across R9000 using sic;
        else
          // Note that although we do go through CP_CP here we do not have to 
          // refactor this for removal of specialized packes because with
          // removal of specifialized packages the need for R9001 shall go away
          select one parentPkg related by importedRef->CL_IC[R4700]
                                                                 ->CP_CP[R4605];
          if(not_empty parentPkg)
            create object instance sicp of PA_SICP;
            relate parentPkg to satisfaction across R9001 using sicp;
          end if;
        end if;
      else
        select one parentComp related by self->CN_CIC[R4203]->C_C[R4202];
        if(not_empty parentComp)
          create object instance sic of PA_SIC;
          relate parentComp to satisfaction across R9000 using sic;
        else
          // Note that although we do go through CP_CP here we do not have to 
          // refactor this for removal of specialized packes because with
          // removal of specifialized packages the need for R9001 shall go away
          select one parentPkg related by self->CP_CP[R4604];
          if(not_empty parentPkg)
            create object instance sicp of PA_SICP;
            relate parentPkg to satisfaction across R9001 using sicp;
          end if;
        end if;  
      end if;
    end if;
    relate provision to requirement across R4002 using satisfaction;
    if(not_empty importedRef)
      select one importedReq related by importedRef->CL_IR[R4703];
      relate satisfaction to importedReq across R4706;
    end if;
    if(not_empty importedProvisionRef)
      select one importedPro related by importedProvisionRef->CL_IP[R4703];
      create object instance ipins of CL_IPINS;
      relate importedPro to satisfaction across R4705 using ipins;
    end if;
    // formalize the provision if the requirement is formal
    if (not_empty srcInterface and formalizeTarget)
      // common rule 4
      requirement.formalize(Id:srcInterface.Id, formalizePro:false);
    elif (not_empty targetInterface and formalizeSource)
      // common rule 5
      provision.formalize(Id:targetInterface.Id, formalizeReq:false);
    end if;
  end if;
end if;
return true;',
	1,
	'',
	9572);
INSERT INTO O_TPARM
	VALUES (9624,
	9623,
	'requirement_id',
	296,
	0,
	'',
	9625,
	'');
INSERT INTO O_TPARM
	VALUES (9625,
	9623,
	'provision_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9626,
	9623,
	'proceed',
	316,
	0,
	'',
	9624,
	'This parameter will tell the operation whether or not the model transaction
shall proceed.  If true changes will be made to the model, if false the
operation is used to determine if the provision would be initialized.');
INSERT INTO O_TFR
	VALUES (9621,
	709,
	'initializeRequirement',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this
// comment.
/*
 *  The rules for creating required interfaces are:
 *
 *   * Common rules
 *     1. Allow to whitespace
 *     2. Allow to provision if no other requirements
 *        from the same component are connected to the
 *        destination provision
 *     3. If both interfaces (Provision and Requirement) are already
 *        formalized, allow satisfaction only if the interfaces match.
 *     4. Formalize provision if this requirement is formalized.  
 *     5. Formalize requirement if destination provision
 *        is formalized.  
 *     6. If a satisfaction already exists to the given requirement do not
 *        attempt to satisfy (return false).
 *
 * This routine is used when a new requirement is being created as well as when 
 * a existing requirement is being connected to a provision.  In the case where
 * a new requirement is being created the param.requirement_id will be empty.
 */
select one system related by self->CP_CP[R4608]->S_SYS[R4606];
isInGenericPkg = self.isInGenericPackage();
if (isInGenericPkg)
  select one system related by self->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405];
  if (empty system)
    rootCompIdInPkg = self.getRootComponentId();
    select any rootComponent from instances of C_C
                                         where (selected.Id == rootCompIdInPkg);
    select one package related by rootComponent->PE_PE[R8001]->EP_PKG[R8000];
    select one system related by rootComponent->PE_PE[R8001]->EP_PKG[R8000]
                                                                 ->S_SYS[R1405];
  end if;
end if;

select any provision from instances of C_P
                            where (selected.Provision_Id == param.provision_id);
select any importedRef from instances of CL_IIR
                                      where (selected.Id == param.provision_id);
if(not_empty importedRef)
  select one provision related by importedRef->C_IR[R4701]->C_P[R4009];
end if;
if(not_empty provision)
  select many reqs related by self->C_PO[R4010]->C_IR[R4016]->C_R[R4009];
  // check to see if any other requirements are connected to destination
  // provision
  for each req in reqs
    select many satisfactions related by req->C_SF[R4002];
    for each satisfaction in satisfactions
      if(not satisfaction.satisfiesWithImportedReq() and empty importedRef)
        select one existProvision related by satisfaction->C_P[R4002];
        if(not_empty existProvision) and (provision == existProvision)
            // common rule 2
            return false;
        end if;
      end if;
    end for;
  end for;
end if;
// If the requirement was passed-in use it, otherwise create it.
isNewRequirement = false;
select any requirement from instances of C_R 
                       where (selected.Requirement_Id == param.requirement_id);
// see if the passed in requirement id is that of
// an imported reference
select any importedReqRef from instances of CL_IIR
                                    where (selected.Id == param.requirement_id);
if(empty requirement)
  if(not_empty importedReqRef)
    select one requirement related by importedReqRef->C_IR[R4701]->C_R[R4009];
  end if;
end if;
if (empty requirement and param.proceed)
  isNewRequirement = true;
  create object instance requirement of C_R;
  create object instance interfaceRef of C_IR;
  create object instance port of C_PO;
  relate requirement to interfaceRef across R4009;
  relate interfaceRef to port across R4016;
  relate port to self across R4010;
  requirement.initialize();
  port.initialize();
else
  // if the element being dragged is
  // an imported reference
  if(not_empty importedReqRef)
    // see if it already is satisfied
    select one importReqSat related by importedReqRef->CL_IR[R4703]
												                  ->C_SF[R4706];
    if(not_empty importReqSat)
      return false;
    end if;
  else
    // check to see if this requirement is already satisfied within
    // the current parent
    select many existingSats related by requirement->C_SF[R4002];
    for each existingSat in existingSats
      if(not existingSat.satisfiesWithImportedReq())
        return false;
      end if;
    end for;
  end if;
end if;
if(not_empty provision)
  // If src and target are both formalized, but to different interfaces, 
  // then return false
  formalizeTarget = empty importedRef;
  formalizeSource = empty importedReqRef;
  select one targetInterface related by provision->C_IR[R4009]->C_I[R4012];
  select one srcInterface related by requirement->C_IR[R4009]->C_I[R4012];
  if ((not_empty srcInterface) and (not_empty targetInterface))
    if(targetInterface.Id != srcInterface.Id)
      // common rule 3
      return false;
    else 
      // If they are both already formalized, to the same interface
      // they do not need to be formalized again.
      formalizeTarget = false;
      formalizeSource = false;
    end if;
  end if;
  
  if(param.proceed)
    create object instance satisfaction of C_SF;
    if isInGenericPkg
      // create Packageable Element supertype and hook it up . . . 
      create object instance pe of PE_PE;
      relate satisfaction to pe across R8001;
      if(not_empty importedRef)
        select one importedComp related by importedRef->CL_IC[R4700];
        select one epPkg related by importedComp->PE_PE[R8001]->EP_PKG[R8000];
        select one comp related by importedComp->PE_PE[R8001]->C_C[R8003];
        if not_empty epPkg
          relate pe to epPkg across R8000;
        elif not_empty comp
          relate pe to comp across R8003;
        end if;
      else
        select one epPkg related by self->PE_PE[R8001]->EP_PKG[R8000];
        select one comp related by self->PE_PE[R8001]->C_C[R8003];
        if not_empty epPkg
          relate pe to epPkg across R8000;
        elif not_empty comp
          relate pe to comp across R8003;
        end if;
      end if;
      pe.type = ElementTypeConstants::SATISFACTION;
      pe.initialize();
    else
      if(not_empty importedRef)
        // relate this satisfaction to the diagram for which
        // the imported ref is on
        select one parentComp related by importedRef->CL_IC[R4700]->C_C[R4205];
        if(not_empty parentComp)
          create object instance sic of PA_SIC;
          relate parentComp to satisfaction across R9000 using sic;
        else
          // Note that although we do go through CP_CP here we do not have to 
          // refactor this for removal of specialized packes because with
          // removal of specifialized packages the need for R9001 shall go away
          select one parentPkg related by importedRef->CL_IC[R4700]
                                                                 ->CP_CP[R4605];
          if(not_empty parentPkg)
            create object instance sicp of PA_SICP;
            relate parentPkg to satisfaction across R9001 using sicp;
          end if;
        end if;
      else
        select one parentComp related by self->CN_CIC[R4203]->C_C[R4202];
        if(not_empty parentComp)
          create object instance sic of PA_SIC;    
          relate satisfaction to parentComp across R9000 using sic;
        else
          // Note that although we do go through CP_CP here we do not have to 
          // refactor this for removal of specialized packes because with
          // removal of specifialized packages the need for R9001 shall go away
          select one parentPkg related by self->CP_CP[R4604];
          if(not_empty parentPkg)
            create object instance sicp of PA_SICP;
            relate satisfaction to parentPkg across R9001 using sicp;
          end if;
        end if;
      end if;
    end if;
    relate provision to requirement across R4002 using satisfaction;
    if(not_empty importedRef)
      select any importedRef related by provision->C_IR[R4009]->CL_IIR[R4701]
    	  where (selected.Id == param.provision_id);
      if(not_empty importedRef)
        select one importedPro related by importedRef->CL_IP[R4703];
        create object instance ipins of CL_IPINS;
        relate importedPro to satisfaction across R4705 using ipins;
      end if;
    end if;
    if(not_empty importedReqRef)
      select one importedReq related by importedReqRef->CL_IR[R4703];
      relate satisfaction to importedReq across R4706;
    end if;
    // formalize the provision if the requirement is formal
    if (not_empty srcInterface and formalizeTarget)
      // common rule 4
      provision.formalize(Id:srcInterface.Id, formalizeReq:false);
    elif (not_empty targetInterface and formalizeSource)
      // common rule 5
      requirement.formalize(Id:targetInterface.Id, formalizePro:false);
    end if;
  end if;
end if;
return true;',
	1,
	'',
	9623);
INSERT INTO O_TPARM
	VALUES (9627,
	9621,
	'provision_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9628,
	9621,
	'requirement_id',
	296,
	0,
	'',
	9627,
	'');
INSERT INTO O_TPARM
	VALUES (9629,
	9621,
	'proceed',
	316,
	0,
	'',
	9628,
	'This parameter will tell the operation whether or not the model transaction
shall proceed.  If true changes will be made to the model, if false the
operation is used to determine if the requirement would be initialized.');
INSERT INTO O_TFR
	VALUES (9597,
	709,
	'getNameCompartmentText',
	'',
	322,
	1,
	'return "component: " + self.Name;',
	1,
	'',
	9590);
INSERT INTO O_TFR
	VALUES (9630,
	709,
	'getProvisionCount',
	'',
	298,
	1,
	'count = 0;
select many ireferences related by self->C_PO[R4010]->C_IR[R4016];
for each ireference in ireferences
  select one provision related by ireference->C_P[R4009];
  if (not_empty provision)
    if (not param.filterDelegations)
      count = count+1;
    else
      select one delegation related by ireference->C_DG[R4014];
      if (empty delegation)
        count = count + 1;
      end if;
    end if;
  end if;
end for;
return count;',
	1,
	'',
	9596);
INSERT INTO O_TPARM
	VALUES (9631,
	9630,
	'filterDelegations',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9632,
	709,
	'getRequirementCount',
	'',
	298,
	1,
	'count = 0;
select many ireferences related by self->C_PO[R4010]->C_IR[R4016];
for each ireference in ireferences
  select one requirement related by ireference->C_R[R4009];
  if (not_empty requirement)
    if (not param.filterDelegations)
      count = count+1;
    else
      select one delegation related by ireference->C_DG[R4014];
      if (empty delegation)
        count = count + 1;
      end if;
    end if;
  end if;
end for;
return count;',
	1,
	'',
	9633);
INSERT INTO O_TPARM
	VALUES (9634,
	9632,
	'filterDelegations',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9633,
	709,
	'getProvisionID',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many ireferences related by self->C_PO[R4010]->C_IR[R4016];
// We''re preincrementing the index
count = -1;
for each ireference in ireferences
  select one provision related by ireference->C_P[R4009];
  if (not_empty provision)
    if (not param.filterDelegations)
      count = count+1;
    else
      select one delegation related by ireference->C_DG[R4014];
      if (empty delegation)
        count = count + 1;
      end if;
    end if;
    if (count == param.index)
      return provision.Provision_Id;
    end if;    
  end if;
end for;
return id;',
	1,
	'',
	9635);
INSERT INTO O_TPARM
	VALUES (9636,
	9633,
	'filterDelegations',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9637,
	9633,
	'index',
	298,
	0,
	'',
	9636,
	'');
INSERT INTO O_TFR
	VALUES (9578,
	709,
	'getRequirementID',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many ireferences related by self->C_PO[R4010]->C_IR[R4016];
// We''re preincrementing the index
count = -1;
for each ireference in ireferences
  select one requirement related by ireference->C_R[R4009];
  if (not_empty requirement)
    if (not param.filterDelegations)
      count = count + 1;
    else
      select one delegation related by ireference->C_DG[R4014];
      if (empty delegation)
        count = count + 1;
      end if;
    end if;
    if (count == param.index)
      return requirement.Requirement_Id;
    end if;    
  end if;
end for;
return id;',
	1,
	'',
	9638);
INSERT INTO O_TPARM
	VALUES (9639,
	9578,
	'filterDelegations',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9640,
	9578,
	'index',
	298,
	0,
	'',
	9639,
	'');
INSERT INTO O_TFR
	VALUES (9573,
	709,
	'hasRequirement',
	'',
	316,
	1,
	'select any requirement related by self->C_PO[R4010]->C_IR[R4016]->C_R[R4009]
	where (selected.Requirement_Id == param.id);
if(param.considerDelegations) and (not_empty requirement)
  select one delegation related by requirement->C_IR[R4009]->C_DG[R4014];
  select one importedRef related by delegation->CL_IIR[R4704];
  if(empty importedRef)
    if(not_empty delegation)
      return false;
    end if;
  end if;
end if;
return not_empty requirement;',
	1,
	'',
	9641);
INSERT INTO O_TPARM
	VALUES (9642,
	9573,
	'id',
	296,
	0,
	'',
	9643,
	'');
INSERT INTO O_TPARM
	VALUES (9643,
	9573,
	'considerDelegations',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9641,
	709,
	'hasProvision',
	'',
	316,
	1,
	'select any provision related by self->C_PO[R4010]->C_IR[R4016]->C_P[R4009]
	where (selected.Provision_Id == param.id);
if(param.considerDelegations) and (not_empty provision)
  select one delegation related by provision->C_IR[R4009]->C_DG[R4014];
  select one importedRef related by delegation->CL_IIR[R4704];
  if(empty importedRef)
    if(not_empty delegation)
      return false;
    end if;
  end if;
end if;
return not_empty provision;',
	1,
	'',
	9586);
INSERT INTO O_TPARM
	VALUES (9644,
	9641,
	'id',
	296,
	0,
	'',
	9645,
	'');
INSERT INTO O_TPARM
	VALUES (9645,
	9641,
	'considerDelegations',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9635,
	709,
	'getProvisionDelegationID',
	'',
	296,
	1,
	'// Component.getProvisionDelegationID()
// Note the includeDelegations argument is deliberately ignored,
// since this operation is always called in the context of delegations.
select many ireferences related by self->C_PO[R4010]->C_IR[R4016];
// We''re preincrementing the index
count = -1;
for each ireference in ireferences
  select one provision related by ireference->C_P[R4009];
  if (not_empty provision)
    count = count + 1;
    if (count == param.index)
      select one delegation related by ireference->C_DG[R4014];
      if not_empty delegation
        return delegation.Id;
      else
        select any delegation related by ireference->C_RID[R4013]->C_DG[R4013];
        if(not_empty delegation)
          return delegation.Id;
        end if;
      end if;
    end if;    
  end if;
end for;
return GD::NULL_UNIQUE_ID();',
	1,
	'',
	9630);
INSERT INTO O_TPARM
	VALUES (9646,
	9635,
	'index',
	298,
	0,
	'',
	9647,
	'');
INSERT INTO O_TPARM
	VALUES (9647,
	9635,
	'includeDelegations',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9638,
	709,
	'getRequirementDelegationID',
	'',
	296,
	1,
	'// Component.getRequirementDelegationID()
// Note the includeDelegations argument is deliberately ignored,
// since this operation is always called in the context of delegations.
select many ireferences related by self->C_PO[R4010]->C_IR[R4016];
// We''re preincrementing the index
count = -1;
for each ireference in ireferences
  select one requirement related by ireference->C_R[R4009];
  if (not_empty requirement)
    count = count + 1;
    if (count == param.index)
      select one delegation related by ireference->C_DG[R4014];
      if not_empty delegation
        return delegation.Id;
      else
        select any delegation related by ireference->C_RID[R4013]->C_DG[R4013];
        if(not_empty delegation)
          return delegation.Id;
        end if;
      end if;
    end if;    
  end if;
end for;
return GD::NULL_UNIQUE_ID();',
	1,
	'',
	9632);
INSERT INTO O_TPARM
	VALUES (9648,
	9638,
	'index',
	298,
	0,
	'',
	9649,
	'');
INSERT INTO O_TPARM
	VALUES (9649,
	9638,
	'includeDelegations',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9650,
	709,
	'parentHasProvision',
	'',
	316,
	1,
	'select any provision related by self->C_PO[R4010]->C_IR[R4016]->C_P[R4009]
	where (selected.Provision_Id == param.id);
return not_empty provision;',
	1,
	'',
	9651);
INSERT INTO O_TPARM
	VALUES (9652,
	9650,
	'considerDelegation',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9653,
	9650,
	'id',
	296,
	0,
	'',
	9652,
	'');
INSERT INTO O_TFR
	VALUES (9654,
	709,
	'parentHasRequirement',
	'',
	316,
	1,
	'select any requirement related by self->C_PO[R4010]->C_IR[R4016]->C_R[R4009]
	where (selected.Requirement_Id == param.id);
return not_empty requirement;',
	1,
	'',
	9650);
INSERT INTO O_TPARM
	VALUES (9655,
	9654,
	'considerDelegation',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9656,
	9654,
	'id',
	296,
	0,
	'',
	9655,
	'');
INSERT INTO O_TFR
	VALUES (9595,
	709,
	'isBeingVerified',
	'',
	316,
	1,
	'select any exeEng related by self->I_EXE[R2955];
return not_empty exeEng;',
	1,
	'',
	9620);
INSERT INTO O_TFR
	VALUES (9657,
	709,
	'newActivity',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// When in a generic package we will not allow specialized packages by 
// filtering the option in the UI.  Therefore this not be invoked when the 
// component is under a generic package.
create object instance a of A_A;
create object instance sp of EP_SPKG;
relate a to sp across R1402;
relate self to a across R1115;
a.initialize();',
	1,
	'',
	9600);
INSERT INTO O_TFR
	VALUES (9602,
	709,
	'newCommunication',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// When in a generic package we will not allow specialized packages by 
// filtering the option in the UI.  Therefore this not be invoked when the 
// component is under a generic package.
create object instance comm of COMM_COMM;
create object instance sp of EP_SPKG;
relate comm to sp across R1402;
relate comm to self across R1138;
comm.initialize();',
	1,
	'',
	9657);
INSERT INTO O_TFR
	VALUES (9658,
	709,
	'newSequence',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// When in a generic package we will not allow specialized packages by 
// filtering the option in the UI.  Therefore this not be invoked when the 
// component is under a generic package.
create object instance sequence of SQ_S;
create object instance sp of EP_SPKG;
relate sequence to sp across R1402;
relate self to sequence across R952;
sequence.initialize();',
	1,
	'',
	9609);
INSERT INTO O_TFR
	VALUES (9651,
	709,
	'newUseCasePackage',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// When in a generic package we will not allow specialized packages by 
// filtering the option in the UI.  Therefore this not be invoked when the 
// component is under a generic package.
create object instance ucc of UC_UCC;
create object instance sp of EP_SPKG;
relate ucc to sp across R1402;
relate self to ucc across R1213;
ucc.initialize();',
	1,
	'',
	9658);
INSERT INTO O_TFR
	VALUES (9659,
	709,
	'pasteActivity',
	'',
	19,
	1,
	'// if this component is formalized to a domain, then pass on the
// paste call
select one domain related by self->CN_DC[R4204]->S_DOM[R4204];
if(not_empty domain)
  domain.pasteActivity(id:param.id);
end if;
// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// When in a generic package we will not allow specialized packages to be 
// pasted.  Therefore, this code will never get called when teh component is
// inside a EP_PKG. 
select any activity from instances of A_A
                                        where (selected.Package_ID == param.id);
if(not_empty activity)
  // guarantee a unique name for the pasted element
  activity.Name = ::getUniqueInitialNameInParent
                                         (instance:activity.convertToInstance(),
     					   name:activity.Name, parent:self.convertToInstance());
  activity.associateWithComponent(compID:self.Id);
end if;',
	1,
	'',
	9654);
INSERT INTO O_TPARM
	VALUES (9660,
	9659,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9661,
	709,
	'pasteCommunication',
	'',
	19,
	1,
	'// if this component is formalized to a domain, then pass on the
// paste call
select one domain related by self->CN_DC[R4204]->S_DOM[R4204];
if(not_empty domain)
  domain.pasteCommunication(id:param.id);
end if;
// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// When in a generic package we will not allow specialized packages by 
// filtering the option in the UI.  Therefore this not be invoked when the 
// component is under a generic package.
select any comm from instances of COMM_COMM
                                        where (selected.Package_ID == param.id);
if(not_empty comm)
  // guarantee a unique name for the pasted element
  comm.Name = ::getUniqueInitialNameInParent (instance:comm.convertToInstance(),
     					   name:comm.Name, parent:self.convertToInstance());
  comm.associateWithComponent(compID:self.Id);
end if;',
	1,
	'',
	9659);
INSERT INTO O_TPARM
	VALUES (9662,
	9661,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9663,
	709,
	'pasteInterfacePackage',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// When in a generic package we will not allow specialized packages by 
// filtering the option in the UI.  Therefore this not be invoked when the 
// component is under a generic package.
select any ifacePkg from instances of IP_IP where (selected.Package_ID == param.id);
if(not_empty ifacePkg)
  // guarantee a unique name for the pasted dt package
  ifacePkg.Name = ::getUniqueInitialNameInParent(instance:ifacePkg.convertToInstance(),
  						name:ifacePkg.Name, parent:self.convertToInstance());
  ifacePkg.associateWithComponent(compID:self.Id);  
  select one system related by self->CP_CP[R4608]->S_SYS[R4606];
  ifacePkg.associatePackageWithSystem(sysID:system.Sys_ID);
end if;',
	1,
	'',
	9661);
INSERT INTO O_TPARM
	VALUES (9664,
	9663,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9665,
	709,
	'pasteSequence',
	'',
	19,
	1,
	'// if this component is formalized to a domain, then pass on the
// paste call
select one domain related by self->CN_DC[R4204]->S_DOM[R4204];
if(not_empty domain)
  domain.pasteSequence(id:param.id);
end if;
// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// When in a generic package we will not allow specialized packages by 
// filtering the option in the UI.  Therefore this not be invoked when the 
// component is under a generic package.
select any seq from instances of SQ_S where (selected.Package_ID == param.id);
if(not_empty seq)
  // guarantee a unique name for the pasted element
  seq.Name = ::getUniqueInitialNameInParent (instance:seq.convertToInstance(),
         					    name:seq.Name, parent:self.convertToInstance());
  seq.associateWithComponent(compID:self.Id);
end if;',
	1,
	'',
	9663);
INSERT INTO O_TPARM
	VALUES (9666,
	9665,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9593,
	709,
	'pasteUseCaseDiagram',
	'',
	19,
	1,
	'// if this component is formalized to a domain, then pass on the
// paste call
select one domain related by self->CN_DC[R4204]->S_DOM[R4204];
if(not_empty domain)
  domain.pasteUseCaseDiagram(id:param.id);
end if;
// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// When in a generic package we will not allow specialized packages by 
// filtering the option in the UI.  Therefore this not be invoked when the 
// component is under a generic package.
select any ucd from instances of UC_UCC where (selected.Package_ID == param.id);
if(not_empty ucd)
  // guarantee a unique name for the pasted element
  ucd.Name = ::getUniqueInitialNameInParent (instance:ucd.convertToInstance(),
         					    name:ucd.Name, parent:self.convertToInstance());
  ucd.associateWithComponent(compID:self.Id);
end if;',
	1,
	'',
	9665);
INSERT INTO O_TPARM
	VALUES (9667,
	9593,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9668,
	709,
	'isParentExecuting',
	'',
	316,
	1,
	'// Component.isParentExecuting()
select any container related by self->I_EXE[R2955]->I_CIN[R2975];
return not_empty container;
',
	1,
	'',
	9592);
INSERT INTO O_TFR
	VALUES (9669,
	709,
	'isExecutingOrIsChildExecuting',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any engine related by self->I_EXE[R2955];
if(not_empty engine)
  return true;
end if;

isInGenericPackage = self.isInGenericPackage();
if (isInGenericPackage)
  select many children related by self->PE_PE[R8003]->C_C[R8001];

  for each child in children
    if(child.isExecutingOrIsChildExecuting())
      return true;
    end if;
  end for;
  select many importedComponentExecutionEngines related by self->PE_PE[R8003]->CL_IC[R8001]->I_EXE[R2963];
  if(not_empty importedComponentExecutionEngines)
    return true;
  end if;
else
  select many children related by self->CN_CIC[R4202]->C_C[R4203];

  for each child in children
    if(child.isExecutingOrIsChildExecuting())
      return true;
    end if;
  end for;
  select many importedComponentExecutionEngines related by self->CL_IC[R4205]->I_EXE[R2963];
  if(not_empty importedComponentExecutionEngines)
    return true;
  end if;
end if;
return false;
',
	1,
	'',
	9668);
INSERT INTO O_TFR
	VALUES (9670,
	709,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Id;',
	1,
	'',
	9669);
INSERT INTO O_TFR
	VALUES (9671,
	709,
	'getInterfacePckgCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many interfacePckgs related by self->IP_IP[R4206];
return cardinality interfacePckgs;',
	1,
	'',
	9670);
INSERT INTO O_TFR
	VALUES (9672,
	709,
	'getInterfacePckgId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many interfacePckgs related by self->IP_IP[R4206];
// We''re preincrementing the index
count = -1;
for each interfacePckg in interfacePckgs
  if (not_empty interfacePckg)
      count = count+1;
  end if;
  if (count == param.index)
      return interfacePckg.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	9671);
INSERT INTO O_TPARM
	VALUES (9673,
	9672,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9674,
	709,
	'getSequenceCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many sequences related by self->SQ_S[R952];
return cardinality sequences;',
	1,
	'',
	9672);
INSERT INTO O_TFR
	VALUES (9675,
	709,
	'getSequenceId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many sequences related by self->SQ_S[R952];
// We''re preincrementing the index
count = -1;
for each sequence in sequences
  if (not_empty sequence)
      count = count+1;
  end if;
  if (count == param.index)
      return sequence.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	9674);
INSERT INTO O_TPARM
	VALUES (9676,
	9675,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9677,
	709,
	'getCommunicationCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many communications related by self->COMM_COMM[R1138];
return cardinality communications;',
	1,
	'',
	9675);
INSERT INTO O_TFR
	VALUES (9678,
	709,
	'getCommunicationId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many communications related by self->COMM_COMM[R1138];
// We''re preincrementing the index
count = -1;
for each communication in communications
  if (not_empty communication)
      count = count+1;
  end if;
  if (count == param.index)
      return communication.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	9677);
INSERT INTO O_TPARM
	VALUES (9679,
	9678,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9680,
	709,
	'getUsecaseCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many usecases related by self->UC_UCC[R1213];
return cardinality usecases;',
	1,
	'',
	9678);
INSERT INTO O_TFR
	VALUES (9681,
	709,
	'getUsecaseId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many usecases related by self->UC_UCC[R1213];
// We''re preincrementing the index
count = -1;
for each usecase in usecases
  if (not_empty usecase)
      count = count+1;
  end if;
  if (count == param.index)
      return usecase.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	9680);
INSERT INTO O_TPARM
	VALUES (9682,
	9681,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9683,
	709,
	'getActivityCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many activities related by self->A_A[R1115];
return cardinality activities;',
	1,
	'',
	9681);
INSERT INTO O_TFR
	VALUES (9684,
	709,
	'getActivityId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many activities related by self->A_A[R1115];
// We''re preincrementing the index
count = -1;
for each activity in activities
  if (not_empty activity)
      count = count+1;
  end if;
  if (count == param.index)
      return activity.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	9683);
INSERT INTO O_TPARM
	VALUES (9685,
	9684,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9686,
	709,
	'getComponentCount',
	'',
	298,
	1,
	'isInGenericPackage = self.isInGenericPackage();
select many components from instances of C_C where selected.Id==GD::NULL_UNIQUE_ID();
if ( isInGenericPackage  )
	select many components related by self->PE_PE[R8003]->C_C[R8001];
else
	select many components related by self->CN_CIC[R4202]->C_C[R4203];
end if;
return cardinality components;',
	1,
	'',
	9684);
INSERT INTO O_TFR
	VALUES (9687,
	709,
	'getComponentId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
isInGenericPackage = self.isInGenericPackage();
select many components from instances of C_C where selected.Id==GD::NULL_UNIQUE_ID();
if ( isInGenericPackage )
	select many components related by self->PE_PE[R8003]->C_C[R8001];
else
	select many components related by self->CN_CIC[R4202]->C_C[R4203];
end if;
// We''re preincrementing the index
count = -1;
for each component in components
  if (not_empty component)
      count = count+1;
  end if;
  if (count == param.index)
      return component.Id;  
  end if;
end for;
return id;',
	1,
	'',
	9686);
INSERT INTO O_TPARM
	VALUES (9688,
	9687,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9689,
	709,
	'getComponentRefCount',
	'',
	298,
	1,
	'isInGenericPackage = self.isInGenericPackage();
if(isInGenericPackage)
  select many impComponents related by self->PE_PE[R8003]->CL_IC[R8001];
  return cardinality impComponents;
else
  select many impComponents related by self->CL_IC[R4205];
  return cardinality impComponents;
end if;',
	1,
	'',
	9687);
INSERT INTO O_TFR
	VALUES (9690,
	709,
	'getComponentRefId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
isInGenericPackage = self.isInGenericPackage();
select many impComponents from instances of CL_IC
                                        where selected.Id==GD::NULL_UNIQUE_ID();
if(isInGenericPackage)
  select many impComponents related by self->PE_PE[R8003]->CL_IC[R8001];
else
  select many impComponents related by self->CL_IC[R4205];
end if;
// We''re preincrementing the index
count = -1;
for each impComponent in impComponents
  if (not_empty impComponent)
      count = count+1;
  end if;
  if (count == param.index)
      return impComponent.Id;  
  end if;
end for;
return id;',
	1,
	'',
	9689);
INSERT INTO O_TPARM
	VALUES (9691,
	9690,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9692,
	709,
	'newPackage',
	'',
	19,
	1,
	'// Component::newPackage()
create object instance package of EP_PKG;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate package to pe across R8001;
rootCompIdInPkg = self.getRootComponentId();
select any rootComponent from instances of C_C where (selected.Id == rootCompIdInPkg);
select one system related by rootComponent->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405];
relate package to system across R1405;
relate self to pe across R8003;
package.initialize();
pe.type = ElementTypeConstants::PACKAGE;
pe.initialize();',
	1,
	'',
	9690);
INSERT INTO O_TFR
	VALUES (9693,
	709,
	'collectVisibleElementsForName',
	'',
	19,
	1,
	'// Component::collectVisibleElementsForName()
// This operation is recursive. It is designed to be called in multiple places,
// both when preparing selection lists and from the parser.
// It originally gets called from the place where a reference is being evaluated
// for visibility. The originating package id is the id of the package that
// contains the reference being evaluated. The originating call takes the form:
// pkg.collectVisibleElementsForName(name:"element name or *",
//                 type:ElementTypeConstants::requiredType,
//                          considerPublicOnly:false, considerParents:true,
//                                          originatingPkgID:self.Package_ID,
//                                       delegatingPkgID: GD::NULL_UNIQUE_ID(),
//                       findFirst:<true for parser use, false for picker use>);
// If findFirst is true, this operation can returns a newline delimited string
// list of duplicate names, if duplicates are found. Otherwise it returns the
// empty string.
// See also: Package.collectElementsForName()
select any originatingComponent from instances of C_C where
                                    selected.Id == param.originatingContainerID;
if self == originatingComponent
  select any resultSet related by self->PE_CRS[R8007] where
                    selected.Name == param.name and selected.Type == param.type;
  if not_empty resultSet
    // search has already been made and cached, just return immediately;
    return;
  else
    // create the search set
    create object instance resultSet of PE_CRS;
    resultSet.Name = param.name;
    resultSet.Type = param.type;
    relate self to resultSet across R8007;
  end if;
  // Visit all child elements
  select many elements related by self->PE_PE[R8003];
  for each element in elements
    // visit all elements, regardless of visibility
    element.collectVisibleElementsForName(name:param.name, type:param.type,
         descending:true, originatingContainerID: param.originatingContainerID,
                                   delegatingPkgID:param.delegatingContainerID,
                                         collectGlobally:param.collectGlobally);
  end for;
else // not originating Component
  // Visit all child elements
  select many elements related by self->PE_PE[R8003];
  for each element in elements
    if element.getVisibilityValue() == Visibility::Public
      element.collectVisibleElementsForName(name:param.name, type:param.type,
         descending:true, originatingContainerID: param.originatingContainerID,
                                   delegatingPkgID:param.delegatingContainerID,
                                         collectGlobally:param.collectGlobally);
    end if;
  end for;
end if;
// Visit all child elements
select many elements related by self->PE_PE[R8003];
for each element in elements
  if element.Visibility == Visibility::Public
      element.collectVisibleElementsForName(name:param.name, type:param.type,
         descending:true, originatingContainerID: param.originatingContainerID,
                                   delegatingPkgID:param.delegatingContainerID,
                                         collectGlobally:param.collectGlobally);
  end if;
end for;
// We now ascend the hierarchy. Note that components are never
// descended when looking for elements, so the delegating package
// is passed as NULL.
select one parentPkg related by self->PE_PE[R8001]->EP_PKG[R8000]->PE_PE[R8001];
if not_empty parentPkg
  parentPkg.collectVisibleElementsForName(name:param.name,
        type:param.type, descending:false,
                      originatingContainerID: param.originatingContainerID,
                                          delegatingPkgID:GD::NULL_UNIQUE_ID(),
                                         collectGlobally:param.collectGlobally);
else
  select one parentComponent related by self->PE_PE[R8001]->C_C[R8003];
  if not_empty parentComponent
    parentComponent.collectVisibleElementsForName(name:param.name,
        type:param.type, originatingContainerID: param.originatingContainerID,
                                    delegatingContainerID:GD::NULL_UNIQUE_ID(),
                                         collectGlobally:param.collectGlobally);
  end if;
end if;',
	1,
	'',
	9692);
INSERT INTO O_TPARM
	VALUES (9694,
	9693,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9695,
	9693,
	'type',
	2878,
	0,
	'',
	9694,
	'');
INSERT INTO O_TPARM
	VALUES (9696,
	9693,
	'originatingContainerID',
	296,
	0,
	'',
	9695,
	'');
INSERT INTO O_TPARM
	VALUES (9697,
	9693,
	'delegatingContainerID',
	296,
	0,
	'',
	9696,
	'');
INSERT INTO O_TPARM
	VALUES (9698,
	9693,
	'collectGlobally',
	316,
	0,
	'',
	9697,
	'');
INSERT INTO O_TFR
	VALUES (9699,
	709,
	'newClass',
	'',
	19,
	1,
	'// Component::newClass()
create object instance clazz of O_OBJ;
// create Packageable Element supertype and hook up to this class.
create object instance pe of PE_PE;
relate clazz to pe across R8001;
relate self to pe across R8003;
clazz.initialize();
pe.type = ElementTypeConstants::CLASS;
pe.initialize();',
	1,
	'',
	9693);
INSERT INTO O_TFR
	VALUES (9700,
	709,
	'newInterface',
	'',
	19,
	1,
	'// Component.newInterface
create object instance ifc of C_I;
// create Packageable Element supertype and hook up to this class.
create object instance pe of PE_PE;
relate ifc to pe across R8001;
relate self to pe across R8003;
ifc.initialize();
pe.type = ElementTypeConstants::INTERFACE;
pe.initialize();
',
	1,
	'',
	9699);
INSERT INTO O_TFR
	VALUES (9701,
	709,
	'newDatatype',
	'',
	19,
	1,
	'// Component::newDatatype()

// Create the new data type
create object instance dt of S_DT;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate dt to pe across R8001;
relate pe to self across R8003;
pe.type = ElementTypeConstants::DATATYPE;
pe.initialize();

create object instance udt of S_UDT;
relate dt to udt across R17;

// Default to core integer type
rootCompId = self.getRootComponentId();
select any comp from instances of C_C where selected.Id == rootCompId;
select one pkg related by comp->PE_PE[R8001]->EP_PKG[R8000];
if not_empty pkg
  select one system related by pkg->S_SYS[R1405];
  int_dt_id = GD::NULL_UNIQUE_ID();
  if not_empty system
    int_dt_id = system.getCoreTypeId(name:"integer");
  end if;
  select any pe from instances of PE_PE where selected.Element_ID == int_dt_id;
  select one int_dt related by pe->S_DT[R8001]; 
  relate udt to int_dt across R18;
end if;
dt.initialize(newname:"Unnamed Data Type");
pe.initialize();',
	1,
	'',
	9700);
INSERT INTO O_TFR
	VALUES (9702,
	709,
	'getQualifiedName',
	'',
	322,
	1,
	'//Component::getQualifiedName()
result = "";
select one package related by self->PE_PE[R8001]->EP_PKG[R8000];
if not_empty package
  result = package.getQualifiedName();
else
  select one comp related by self->PE_PE[R8001]->C_C[R8003];
  if not_empty comp
    result = comp.getQualifiedName();
  end if;
end if;
if result != ""
  result = result + "::";
end if;
result = result + self.Name;
return result;',
	1,
	'',
	9701);
INSERT INTO O_TFR
	VALUES (9703,
	709,
	'newIClass',
	'',
	19,
	1,
	'// Component::newIClass()
create object instance icl of O_IOBJ;
// create Packageable Element supertype and hook up to this package.
create object instance pe of PE_PE;
relate icl to pe across R8001;
relate pe to self across R8003;
pe.type = ElementTypeConstants::IMPORTED_CLASS;
pe.initialize();
//
// Note that no class is assigned to this imported
// class at creation time. This is achieved by a separate
// Context Menu action.',
	1,
	'',
	9702);
INSERT INTO O_TFR
	VALUES (9704,
	709,
	'clearScope',
	'',
	19,
	1,
	'// Component.clearScope()
// dispose all search results
select many crs related by self->PE_CRS[R8007];
for each sr in crs
  sr.dispose();
end for;',
	1,
	'',
	9703);
INSERT INTO O_TFR
	VALUES (9705,
	709,
	'rename',
	'',
	19,
	1,
	'self.Name = param.new_name;
',
	1,
	'',
	9704);
INSERT INTO O_TPARM
	VALUES (9706,
	9705,
	'new_name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9707,
	709,
	'initializeClasses',
	'',
	19,
	1,
	'// Component.initializeClasses()
select many packages related by self->PE_PE[R8003]->EP_PKG[R8001];
for each childPkg in packages
  childPkg.initializeClasses(compInstID:param.componentInstanceID);
end for;',
	1,
	'',
	9705);
INSERT INTO O_TPARM
	VALUES (9708,
	9707,
	'componentInstanceID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9709,
	709,
	'canPasteSequence',
	'',
	316,
	1,
	'isInGenericPackage = self.isInGenericPackage();
return not isInGenericPackage;
',
	1,
	'',
	9707);
INSERT INTO O_TFR
	VALUES (9710,
	709,
	'canPasteInterfacePackage',
	'',
	316,
	1,
	'isInGenericPackage = self.isInGenericPackage();
result = not isInGenericPackage;
if(result)
  // if formalized to a domain, do not allow
  select one domain related by self->CN_DC[R4204]->S_DOM[R4204];
  if(not_empty domain)
    return false;
  end if;
end if;
return result;',
	1,
	'',
	9709);
INSERT INTO O_TFR
	VALUES (9711,
	709,
	'canPasteCommunication',
	'',
	316,
	1,
	'isInGenericPackage = self.isInGenericPackage();
return not isInGenericPackage;
',
	1,
	'',
	9710);
INSERT INTO O_TFR
	VALUES (9712,
	709,
	'canPasteUseCaseDiagram',
	'',
	316,
	1,
	'isInGenericPackage = self.isInGenericPackage();
return not isInGenericPackage;
',
	1,
	'',
	9711);
INSERT INTO O_TFR
	VALUES (9713,
	709,
	'canPasteActivity',
	'',
	316,
	1,
	'isInGenericPackage = self.isInGenericPackage();
return not isInGenericPackage;
',
	1,
	'',
	9712);
INSERT INTO O_TFR
	VALUES (9714,
	709,
	'canPastePackage',
	'',
	316,
	1,
	'isInGenericPackage = self.isInGenericPackage();
return isInGenericPackage;
',
	1,
	'',
	9713);
INSERT INTO O_TFR
	VALUES (9715,
	709,
	'pastePackage',
	'',
	19,
	1,
	'// Component::pastePackage()
select any pkg from instances of EP_PKG where (selected.Package_ID == param.id);
if(not_empty pkg)
  select one directSystem related by pkg->S_SYS[R1401];
  if(not_empty directSystem)
    unrelate pkg from directSystem across R1401;
  end if;
  select one system related by pkg->S_SYS[R1405];
  if(not_empty system)
    unrelate pkg from system across R1405;
  end if;
  select one pe related by pkg->PE_PE[R8001];  
  // guarantee a unique name for the pasted dt package
  pkg.Name = ::getUniqueInitialNameInParent(instance:pkg.convertToInstance(),
  						name:pkg.Name, parent:self.convertToInstance());
  relate self to pe across R8003;
  sysId = self.getSystemId();
  select any thisSystem from instances of S_SYS where selected.Sys_ID == sysId;
  relate pkg to thisSystem across R1405;
  // associate all children with this
  // system
  pkg.associateWithSystem(sysID:sysId);
  // for any non local event below this package
  // remove incomplete ones (those that are not
  // resolvable)
  pkg.removeIncompleteSignalEvents();
end if;',
	1,
	'',
	9714);
INSERT INTO O_TPARM
	VALUES (9716,
	9715,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9717,
	709,
	'isInGenericPackage',
	'',
	316,
	1,
	'select one pkg related by self->PE_PE[R8001]->EP_PKG[R8000];
select one comp related by self->PE_PE[R8001]->C_C[R8003];
isInGenericPackage = not_empty pkg or not_empty comp;
return isInGenericPackage;',
	1,
	'',
	9715);
INSERT INTO O_TFR
	VALUES (9718,
	709,
	'getSystemId',
	'',
	296,
	1,
	'// Component.getSystemId()
// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one packageableElem related by self->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;
if (isInGenericPackage)
  if not_empty package
    return package.getSystemId();
  elif not_empty component
    return component.getSystemId();
  end if; 
else
  select one parentComponent related by self->CN_CIC[R4203]->C_C[R4202];
  if not_empty parentComponent
    return parentComponent.getSystemId();
  end if;
  select one rootPackage related by self->CP_CP[R4608];
  if not_empty rootPackage
    return rootPackage.getSystemId();
  end if; 
end if;
USER::logError(msg:"Component.getSystemId: No parent found.",path:"");
return GD::NULL_UNIQUE_ID();',
	1,
	'',
	9717);
INSERT INTO O_TFR
	VALUES (9719,
	709,
	'associateChildrenWithRootComponentPackage',
	'',
	19,
	1,
	'select one cp related by self->CP_CP[R4608];
select many components related by self->CN_CIC[R4202]->C_C[R4203];
for each component in components
  relate component to cp across R4608;
  component.associateChildrenWithRootComponentPackage();
end for;',
	1,
	'',
	9718);
INSERT INTO O_TFR
	VALUES (9720,
	709,
	'pasteComponent',
	'',
	19,
	1,
	'select any component from instances of C_C where (selected.Id == param.id);
if(not_empty component)
  if(not self.isInGenericPackage())
    create object instance cic of CN_CIC;
    relate component to cic across R4203;
    relate cic to self across R4202;
    select one rootCp related by self->CP_CP[R4608];
    relate component to rootCp across R4608;
    component.associateChildrenWithRootComponentPackage();
  else
    select one pe related by component->PE_PE[R8001];
    relate pe to self across R8003;
  end if;
  component.rename(new_name: ::getUniqueInitialNameInParent(
                                         instance:component.convertToInstance(),
                        name: component.Name, parent:self.convertToInstance()));
  component.removeIncompleteSignalEvents();
end if;',
	1,
	'',
	9719);
INSERT INTO O_TPARM
	VALUES (9721,
	9720,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9722,
	709,
	'pasteInterface',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any iface from instances of C_I where (selected.Id == param.id);
if(not_empty iface)
  // guarantee a unique name for the pasted dt package
  iface.Name = ::getUniqueInitialNameInParent(instance:iface.convertToInstance(),
  						name:iface.Name, parent:self.convertToInstance());
  select one pe related by iface->PE_PE[R8001];
  relate pe to self across R8003;
end if;',
	1,
	'',
	9720);
INSERT INTO O_TPARM
	VALUES (9723,
	9722,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9724,
	709,
	'pasteUserDataType',
	'',
	19,
	1,
	'select any udt from instances of S_UDT where (selected.DT_ID == param.id);
if(not_empty udt)
  select one dt related by udt->S_DT[R17];
  // guarantee a unique name for the pasted dt
  dt.Name = ::getUniqueInitialNameInParent(instance:dt.convertToInstance(),
  						name:dt.Name, parent:self.convertToInstance());
  select one pe related by dt->PE_PE[R8001];
  relate pe to self across R8003;
end if;',
	1,
	'',
	9722);
INSERT INTO O_TPARM
	VALUES (9725,
	9724,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9726,
	709,
	'associatePackagesWithSystem',
	'',
	19,
	1,
	'select any system from instances of S_SYS where (selected.Sys_ID == param.id);
if(not_empty system)
  select many packages related by self->PE_PE[R8003]->EP_PKG[R8001];
  for each package in packages
    relate package to system across R1405;
    package.associateWithSystem(sysID:param.id);
  end for;
  select many components related by self->PE_PE[R8003]->C_C[R8001];
  for each component in components
    component.associatePackagesWithSystem(id:param.id);
  end for;
end if;',
	1,
	'',
	9724);
INSERT INTO O_TPARM
	VALUES (9727,
	9726,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9728,
	709,
	'pasteRequirement',
	'',
	19,
	1,
	'// no need to hook anything up, all data will be present',
	1,
	'',
	9726);
INSERT INTO O_TPARM
	VALUES (9729,
	9728,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9730,
	709,
	'pasteProvision',
	'',
	19,
	1,
	'select any provision from instances of C_P
                                      where (selected.Provision_Id == param.id);
if(not_empty provision)
  // dispose any satisfactions that are not complete
  // this can occur because the export includes them
  // regardless of whether or not they are complete
  select many satisfactions related by provision->C_SF[R4002];
  for each satisfaction in satisfactions
    select one requirement related by satisfaction->C_R[R4002];
    if(not_empty requirement
                     and Util::isProxy(element:requirement.convertToInstance()))
      // if this satisfaction is connected to an imported requirement, that
      // is not a proxy, we do not want to dispose
      select one importedReq related by satisfaction->CL_IR[R4706];
      if(empty importedReq 
                      or Util::isProxy(element:importedReq.convertToInstance()))
        satisfaction.dispose();
      end if;
    end if;
  end for;
end if;
',
	1,
	'',
	9728);
INSERT INTO O_TPARM
	VALUES (9731,
	9730,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9732,
	709,
	'pasteComponentReference',
	'',
	19,
	1,
	'select any ref from instances of CL_IC where (selected.Id == param.id);
if(not_empty ref)
  isInGenericPackage = self.isInGenericPackage();
  if(isInGenericPackage)
    select one pe related by ref->PE_PE[R8001];
    relate pe to self across R8003;
  else
    relate ref to self across R4205;
  end if;
end if;',
	1,
	'',
	9730);
INSERT INTO O_TPARM
	VALUES (9733,
	9732,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9734,
	709,
	'pasteSubsystem',
	'',
	19,
	1,
	'// pass on to the formal domain if present
select one domain related by self->CN_DC[R4204]->S_DOM[R4204];
if(not_empty domain)
  domain.pasteSubsystem(id:param.id);
end if;',
	1,
	'',
	9732);
INSERT INTO O_TPARM
	VALUES (9735,
	9734,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9736,
	709,
	'canPasteSubsystem',
	'',
	316,
	1,
	'// only allow if formalized to a domain
select one domain related by self->CN_DC[R4204]->S_DOM[R4204];
if(not_empty domain)
  return true;
end if;
return false;',
	1,
	'',
	9734);
INSERT INTO O_TFR
	VALUES (9737,
	709,
	'pasteExternalEntityPackage',
	'',
	19,
	1,
	'// pass on to the formal domain if present
select one domain related by self->CN_DC[R4204]->S_DOM[R4204];
if(not_empty domain)
  domain.pasteExternalEntityPackage(id:param.id);
end if;',
	1,
	'',
	9736);
INSERT INTO O_TPARM
	VALUES (9738,
	9737,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9739,
	709,
	'canPasteExternalEntityPackage',
	'',
	316,
	1,
	'// only allow if formalized to a domain
select one domain related by self->CN_DC[R4204]->S_DOM[R4204];
if(not_empty domain)
  return true;
end if;
return false;',
	1,
	'',
	9737);
INSERT INTO O_TFR
	VALUES (9740,
	709,
	'pasteFunctionPackage',
	'',
	19,
	1,
	'// pass on to the formal domain if present
select one domain related by self->CN_DC[R4204]->S_DOM[R4204];
if(not_empty domain)
  domain.pasteFunctionPackage(id:param.id);
end if;',
	1,
	'',
	9739);
INSERT INTO O_TPARM
	VALUES (9741,
	9740,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9742,
	709,
	'canPasteFunctionPackage',
	'',
	316,
	1,
	'// only allow if formalized to a domain
select one domain related by self->CN_DC[R4204]->S_DOM[R4204];
if(not_empty domain)
  return true;
end if;
return false;',
	1,
	'',
	9740);
INSERT INTO O_TFR
	VALUES (9743,
	709,
	'pasteDataTypePackage',
	'',
	19,
	1,
	'// pass on to the formal domain if present
select one domain related by self->CN_DC[R4204]->S_DOM[R4204];
if(not_empty domain)
  domain.pasteDataTypePackage(id:param.id);
end if;',
	1,
	'',
	9742);
INSERT INTO O_TPARM
	VALUES (9744,
	9743,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9745,
	709,
	'canPasteDataTypePackage',
	'',
	316,
	1,
	'// only allow if formalized to a domain
select one domain related by self->CN_DC[R4204]->S_DOM[R4204];
if(not_empty domain)
  return true;
end if;
return false;',
	1,
	'',
	9743);
INSERT INTO O_TFR
	VALUES (9746,
	709,
	'getPackageId',
	'',
	296,
	1,
	'// Component.getPackageId()
// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
result = GD::NULL_UNIQUE_ID();
select one package related by self->PE_PE[R8001]->EP_PKG[R8000];
select one component related by self->PE_PE[R8001]->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;
if (isInGenericPackage)
  if not_empty package
    return package.Package_ID;
  elif not_empty component
    return component.getPackageId();
  end if;   
end if;
return result;',
	1,
	'',
	9745);
INSERT INTO O_TFR
	VALUES (9747,
	709,
	'removeIncompleteSignalEvents',
	'',
	19,
	1,
	'// for any packages under this component make
// sure that we resolve pasted transitions assigned
// to signals
select many packages related by self->PE_PE[R8003]->EP_PKG[R8001];
for each package in packages
  package.removeIncompleteSignalEvents();
end for;
// do the same for all children components
select many components related by self->PE_PE[R8003]->C_C[R8001];
for each component in components
  component.removeIncompleteSignalEvents();
end for;
// and the same for old style nesting
select many components related by self->CN_CIC[R4202]->C_C[R4203];
for each component in components
  component.removeIncompleteSignalEvents();
end for;
// if this component is assigned to a domain, do the
// same
select one domain related by self->CN_DC[R4204]->S_DOM[R4204];
if(not_empty domain)
  select many subsystems related by domain->S_SS[R1];
  for each subsystem in subsystems
    subsystem.removeIncompleteSignalEvents();
  end for;
end if;
',
	1,
	'',
	9746);
INSERT INTO O_TFR
	VALUES (9748,
	709,
	'pasteImportedProvision',
	'',
	19,
	1,
	'select any iPro from instances of CL_IP where (selected.Id == param.id);
if(not_empty iPro)
  // dispose any satisfactions that are not complete
  // this can occur because the export includes them
  // regardless of whether or not they are complete
  select many satisfactions related by iPro->CL_IPINS[R4705]->C_SF[R4705];
  for each satisfaction in satisfactions
    select one requirement related by satisfaction->C_R[R4002];
    if(not_empty requirement
                     and Util::isProxy(element:requirement.convertToInstance()))
      // if this satisfaction is connected to an imported requirement, that
      // is not a proxy, we do not want to dispose
      select one importedReq related by satisfaction->CL_IR[R4706];
      if(empty importedReq 
                      or Util::isProxy(element:importedReq.convertToInstance()))
        satisfaction.dispose();
      end if;
    end if;
  end for;
end if;',
	1,
	'',
	9747);
INSERT INTO O_TPARM
	VALUES (9749,
	9748,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9750,
	709,
	'pasteImportedRequirement',
	'',
	19,
	1,
	'// nothing needed here',
	1,
	'',
	9748);
INSERT INTO O_TPARM
	VALUES (9751,
	9750,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9752,
	709,
	'getPkgCount',
	'',
	298,
	1,
	'select many packages related by self->PE_PE[R8003]->EP_PKG[R8001];
return cardinality packages;',
	1,
	'',
	9750);
INSERT INTO O_TFR
	VALUES (9753,
	709,
	'getPkgId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many packages related by self->PE_PE[R8003]->EP_PKG[R8001];
// We''re preincrementing the index
count = -1;
for each pkg in packages
  if (not_empty pkg)
      count = count+1;
  end if;
  if (count == param.index)
      return pkg.Package_ID;  
  end if;
end for;
return id;',
	1,
	'',
	9752);
INSERT INTO O_TPARM
	VALUES (9754,
	9753,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9755,
	709,
	'getIfaceCount',
	'',
	298,
	1,
	'select many interfaces related by self->PE_PE[R8003]->C_I[R8001];
return cardinality interfaces;',
	1,
	'',
	9753);
INSERT INTO O_TFR
	VALUES (9756,
	709,
	'getIfaceId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many ifaces related by self->PE_PE[R8003]->C_I[R8001];
// We''re preincrementing the index
count = -1;
for each iface in ifaces
  if (not_empty iface)
      count = count+1;
  end if;
  if (count == param.index)
      return iface.Id;  
  end if;
end for;
return id;',
	1,
	'',
	9755);
INSERT INTO O_TPARM
	VALUES (9757,
	9756,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9758,
	709,
	'getUDTCount',
	'',
	298,
	1,
	'select many udts related by self->PE_PE[R8003]->S_DT[R8001]->S_UDT[R17];
return cardinality udts;',
	1,
	'',
	9756);
INSERT INTO O_TFR
	VALUES (9759,
	709,
	'getUDTId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many udts related by self->PE_PE[R8003]->S_DT[R8001]->S_UDT[R17];
// We''re preincrementing the index
count = -1;
for each udt in udts
  if (not_empty udt)
      count = count+1;
  end if;
  if (count == param.index)
      return udt.DT_ID;  
  end if;
end for;
return id;',
	1,
	'',
	9758);
INSERT INTO O_TPARM
	VALUES (9760,
	9759,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9761,
	709,
	'isContainedBy',
	'',
	316,
	1,
	'// Component.isContainedBy() GenericPackages only
select one component related by self->PE_PE[R8001]->C_C[R8003];
select one package related by self->PE_PE[R8001]->EP_PKG[R8000];
if not_empty component
  select one pe related by component->PE_PE[R8001];
  if not empty pe and pe.Element_ID == param.element_id
    return true;
  else
    return component.isContainedBy(element_id:param.element_id);
  end if;
elif not_empty package
  select one pe related by package->PE_PE[R8001];
  if not empty pe and pe.Element_ID == param.element_id
    return true;
  else
    return package.isContainedBy(element_id:param.element_id);
  end if;
else
  return false;
end if;
',
	1,
	'',
	9759);
INSERT INTO O_TPARM
	VALUES (9762,
	9761,
	'element_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (9763,
	709,
	'getRootComponentId',
	'',
	296,
	1,
	'// Component.getRootComponentId
// NOTE: Only intended for use in a generic package context
// Ascends the Component hierarchy to find the top component.
// The "top component" is the first component in this package. Note that
// this package may be nested.  The package could also by under a 
// component.  However, this routine finds the first component in 
// this package.  It does NOT search beyond the package boundary.
select one parentComponent related by self->PE_PE[R8001]->C_C[R8003];
if not_empty parentComponent
  return parentComponent.getRootComponentId();
end if;
return self.Id;',
	1,
	'',
	9761);
INSERT INTO O_TFR
	VALUES (9764,
	709,
	'collectReferencesForSynchronization',
	'',
	19,
	1,
	'/**
 *  Collect all elements that require synchronization
 *  For components that is component references if
 *  synchronization type is push.
 */
if(param.syncType == SynchronizationType::Pull)
  // find component references under this component generic
  select many componentRefs related by self->PE_PE[R8003]->CL_IC[R8001];
  for each componentRef in componentRefs
    Util::addElementToList(element: componentRef.convertToInstance(),
                                               elementList:param.referenceList);
    componentRef.collectReferencesForSynchronization(
                    referenceList:param.referenceList, syncType:param.syncType);
  end for;  
  // find component references under this component specialized
  select many componentRefs related by self->CL_IC[R4205];
  for each componentRef in componentRefs
    Util::addElementToList(element: componentRef.convertToInstance(),
                                               elementList:param.referenceList);
    componentRef.collectReferencesForSynchronization(
                    referenceList:param.referenceList, syncType:param.syncType);
  end for;
else
  // find component references referring to this component
  select many componentRefs related by self->CL_IC[R4201];
  for each componentRef in componentRefs
    Util::addElementToList(element: componentRef.convertToInstance(),
                                               elementList:param.referenceList);
    componentRef.collectReferencesForSynchronization(
                    referenceList:param.referenceList, syncType:param.syncType);
  end for;
end if;
// recursively call for all children
select many pkgs related by self->PE_PE[R8003]->EP_PKG[R8001];
for each pkg in pkgs
  pkg.collectReferencesForSynchronization(referenceList:param.referenceList,
                                                       syncType:param.syncType);
end for;
// all component children
select many components related by self->PE_PE[R8003]->C_C[R8001];
for each component in components
  component.collectReferencesForSynchronization(
                    referenceList:param.referenceList, syncType:param.syncType);
end for;
// port children
select many ports related by self->C_PO[R4010];
for each port in ports
  port.collectReferencesForSynchronization(
                    referenceList:param.referenceList, syncType:param.syncType);
end for;
// now for specialized packages
select many interfacePackages related by self->IP_IP[R4206];
for each interfacePackage in interfacePackages
  interfacePackage.collectReferencesForSynchronization(
                    referenceList:param.referenceList, syncType:param.syncType);
end for;
select many components related by self->CN_CIC[R4202]->C_C[R4203];
for each component in components
  component.collectReferencesForSynchronization(
                    referenceList:param.referenceList, syncType:param.syncType);
end for;',
	1,
	'',
	9763);
INSERT INTO O_TPARM
	VALUES (9765,
	9764,
	'referenceList',
	317,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (9766,
	9764,
	'syncType',
	3500,
	0,
	'',
	9765,
	'');
INSERT INTO O_TFR
	VALUES (9767,
	709,
	'hasRealizedComponents',
	'',
	316,
	1,
	'//Package::hasRealizedComponents()
result = false;
if self.isRealized == true
  result = true;
else
  select many packages related by self->PE_PE[R8003]->EP_PKG[R8001];
  for each package in packages
    if package.hasRealizedComponents() == true
      result = true;
      break;
    end if;
  end for;
  select many components related by self->PE_PE[R8003]->C_C[R8001];
  for each component in components
    if component.hasRealizedComponents() == true
      result = true;
      break;
    end if;
  end for;
  select many compRefs related by self->PE_PE[R8003]->CL_IC[R8001];
  for each compRef in compRefs
    select one component related by compRef->C_C[R4201];
    if component.hasRealizedComponents() == true
      result = true;
      break;
    end if;
  end for;
end if;
return result;',
	1,
	'',
	9764);
INSERT INTO O_TFR
	VALUES (9768,
	709,
	'get_name',
	'',
	322,
	1,
	'return self.get_compartment_text(at: Justification::Center,
                                                                                 comp_num:1, ent_num:1);',
	1,
	'',
	9767);
INSERT INTO O_NBATTR
	VALUES (9769,
	709);
INSERT INTO O_BATTR
	VALUES (9769,
	709);
INSERT INTO O_ATTR
	VALUES (9769,
	709,
	9770,
	'Name',
	'Full Name: Component Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (9771,
	709);
INSERT INTO O_BATTR
	VALUES (9771,
	709);
INSERT INTO O_ATTR
	VALUES (9771,
	709,
	9769,
	'Descrip',
	'Full Name: Component Description
Description: A textual description of this component.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (9772,
	709);
INSERT INTO O_BATTR
	VALUES (9772,
	709);
INSERT INTO O_ATTR
	VALUES (9772,
	709,
	9771,
	'Mult',
	'Full Name: Multiplicity
Description: Multiplicity of the component.  Indicates how many instances of the component may exist.
Data Domain: 0 = one, 1 = many
enum0: One
enum1: Many',
	'',
	'Mult',
	0,
	298,
	'',
	'');
INSERT INTO O_REF
	VALUES (709,
	9333,
	0,
	9338,
	9335,
	9336,
	9337,
	9770,
	9773,
	0,
	0,
	'',
	'Component in Component',
	'Id',
	'R4203');
INSERT INTO O_RATTR
	VALUES (9770,
	709,
	9338,
	9333,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (9770,
	709,
	9774,
	'NestedComponent_Id',
	'',
	'NestedComponent_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (9775,
	709,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
result = "";
if(self.isFormal())
  select one domain related by self->CN_DC[R4204]->S_DOM[R4204];
  result = domain.Name;
else
  result = self.Name;
end if;
if(self.Mult == 1)
  result = result + "[*]";
end if;
select one pe related by self->PE_PE[R8001];
if not_empty pe
  result = pe.getVisibilityAdornment() + result;
end if;
if(self.isRealized)
  if(self.Realized_Class_Path != "")
    result = result + " realized by " +
                               Util::getLastSegmentForPath(path:self.Realized_Class_Path);
  end if;
end if;
self.Label = result;
',
	1);
INSERT INTO O_BATTR
	VALUES (9775,
	709);
INSERT INTO O_ATTR
	VALUES (9775,
	709,
	9772,
	'Label',
	'User_Visible:false
Persistent:false',
	'',
	'Label',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (709,
	707,
	0,
	758,
	9199,
	9201,
	9200,
	9774,
	9776,
	0,
	0,
	'',
	'Component Package',
	'Package_ID',
	'R4604');
INSERT INTO O_RATTR
	VALUES (9774,
	709,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (9774,
	709,
	762,
	'Package_ID',
	'',
	'',
	'SpecificationPackage_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (709,
	707,
	0,
	758,
	9208,
	9209,
	9210,
	9777,
	9778,
	0,
	0,
	'',
	'Component Package',
	'Package_ID',
	'R4608');
INSERT INTO O_RATTR
	VALUES (9777,
	709,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (9777,
	709,
	9775,
	'Root_Package_ID',
	'',
	'Root_',
	'Package_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (709,
	26,
	0,
	25,
	868,
	2830,
	870,
	762,
	9779,
	0,
	0,
	'',
	'Packageable Element',
	'Element_ID',
	'R8001');
INSERT INTO O_RATTR
	VALUES (762,
	709,
	25,
	26,
	0,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (762,
	709,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (9780,
	709);
INSERT INTO O_BATTR
	VALUES (9780,
	709);
INSERT INTO O_ATTR
	VALUES (9780,
	709,
	9777,
	'isRealized',
	'Full Name: Realized Component
Description: If true, Verifier will bind to an externally supplied implementation.',
	'',
	'isRealized',
	0,
	316,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (9781,
	709);
INSERT INTO O_BATTR
	VALUES (9781,
	709);
INSERT INTO O_ATTR
	VALUES (9781,
	709,
	9780,
	'Realized_Class_Path',
	'Full Name: Realized Component Path
Description: Specifies where Verifier will look for a realized executable resource.',
	'',
	'Realized_Class_Path',
	0,
	322,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	709);
INSERT INTO O_OIDA
	VALUES (762,
	709,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	709);
INSERT INTO O_ID
	VALUES (2,
	709);
-- BP 7.1 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (9782,
	'Communication And Access',
	'Interactions between classes (O_OBJ) are modeled by communication (CA_COMM) and access (CA_ACC) paths. Communication paths show the asynchronous (event) and synchronous (data access) communication in the system between two classes and class/external entity (S_EE) pairs.  ',
	'CA',
	401,
	1,
	9783);
INSERT INTO S_SID
	VALUES (1,
	9782);
INSERT INTO O_IOBJ
	VALUES (9784,
	7235,
	5,
	9782,
	'External Entity in Model',
	'S_EEM');
INSERT INTO O_IOBJ
	VALUES (9785,
	7278,
	5,
	9782,
	'External Entity Data Item',
	'S_EEDI');
INSERT INTO O_IOBJ
	VALUES (9786,
	6622,
	5,
	9782,
	'External Entity Event',
	'S_EEEVT');
INSERT INTO O_IOBJ
	VALUES (9787,
	7235,
	5,
	9782,
	'External Entity in Model',
	'S_EEM');
INSERT INTO O_IOBJ
	VALUES (9788,
	37,
	5,
	9782,
	'Attribute',
	'O_ATTR');
INSERT INTO O_IOBJ
	VALUES (9789,
	30,
	5,
	9782,
	'Model Class',
	'O_OBJ');
INSERT INTO O_IOBJ
	VALUES (9790,
	1050,
	5,
	9782,
	'Imported Class',
	'O_IOBJ');
INSERT INTO O_IOBJ
	VALUES (9791,
	1488,
	5,
	9782,
	'State Machine Event',
	'SM_EVT');
INSERT INTO O_IOBJ
	VALUES (9792,
	565,
	5,
	9782,
	'State Machine',
	'SM_SM');
INSERT INTO R_SUBSUP
	VALUES (9793);
INSERT INTO R_REL
	VALUES (9793,
	401,
	'

Notes:

',
	9782);
INSERT INTO R_SUPER
	VALUES (7225,
	9793,
	9794);
INSERT INTO O_RTIDA
	VALUES (9795,
	7225,
	0,
	9793,
	9794);
INSERT INTO R_RTO
	VALUES (7225,
	9793,
	9794,
	0);
INSERT INTO R_OIR
	VALUES (7225,
	9793,
	9794,
	0);
INSERT INTO R_SUB
	VALUES (9796,
	9793,
	9797);
INSERT INTO R_RGO
	VALUES (9796,
	9793,
	9797);
INSERT INTO R_OIR
	VALUES (9796,
	9793,
	9797,
	0);
INSERT INTO R_SUB
	VALUES (9798,
	9793,
	9799);
INSERT INTO R_RGO
	VALUES (9798,
	9793,
	9799);
INSERT INTO R_OIR
	VALUES (9798,
	9793,
	9799,
	0);
INSERT INTO R_SUB
	VALUES (9800,
	9793,
	9801);
INSERT INTO R_RGO
	VALUES (9800,
	9793,
	9801);
INSERT INTO R_OIR
	VALUES (9800,
	9793,
	9801,
	0);
INSERT INTO R_SIMP
	VALUES (9802);
INSERT INTO R_REL
	VALUES (9802,
	404,
	'

Notes:

',
	9782);
INSERT INTO R_PART
	VALUES (9796,
	9802,
	9803,
	0,
	0,
	'is carried by');
INSERT INTO O_RTIDA
	VALUES (9804,
	9796,
	0,
	9802,
	9803);
INSERT INTO R_RTO
	VALUES (9796,
	9802,
	9803,
	0);
INSERT INTO R_OIR
	VALUES (9796,
	9802,
	9803,
	0);
INSERT INTO R_FORM
	VALUES (9805,
	9802,
	9806,
	1,
	1,
	'carries');
INSERT INTO R_RGO
	VALUES (9805,
	9802,
	9806);
INSERT INTO R_OIR
	VALUES (9805,
	9802,
	9806,
	0);
INSERT INTO R_SIMP
	VALUES (9807);
INSERT INTO R_REL
	VALUES (9807,
	408,
	'

Notes:

',
	9782);
INSERT INTO R_PART
	VALUES (9800,
	9807,
	9808,
	0,
	0,
	'is carried by');
INSERT INTO O_RTIDA
	VALUES (9809,
	9800,
	0,
	9807,
	9808);
INSERT INTO R_RTO
	VALUES (9800,
	9807,
	9808,
	0);
INSERT INTO R_OIR
	VALUES (9800,
	9807,
	9808,
	0);
INSERT INTO R_FORM
	VALUES (9810,
	9807,
	9811,
	1,
	1,
	'carries');
INSERT INTO R_RGO
	VALUES (9810,
	9807,
	9811);
INSERT INTO R_OIR
	VALUES (9810,
	9807,
	9811,
	0);
INSERT INTO R_SIMP
	VALUES (9812);
INSERT INTO R_REL
	VALUES (9812,
	412,
	'

Notes:

',
	9782);
INSERT INTO R_PART
	VALUES (9798,
	9812,
	9813,
	0,
	0,
	'is carried by');
INSERT INTO O_RTIDA
	VALUES (9814,
	9798,
	0,
	9812,
	9813);
INSERT INTO R_RTO
	VALUES (9798,
	9812,
	9813,
	0);
INSERT INTO R_OIR
	VALUES (9798,
	9812,
	9813,
	0);
INSERT INTO R_FORM
	VALUES (9815,
	9812,
	9816,
	1,
	1,
	'carries');
INSERT INTO R_RGO
	VALUES (9815,
	9812,
	9816);
INSERT INTO R_OIR
	VALUES (9815,
	9812,
	9816,
	0);
INSERT INTO R_SIMP
	VALUES (9817);
INSERT INTO R_REL
	VALUES (9817,
	413,
	'

Notes:

',
	9782);
INSERT INTO R_PART
	VALUES (6622,
	9817,
	9818,
	0,
	0,
	'represents communication of');
INSERT INTO O_RTIDA
	VALUES (6637,
	6622,
	0,
	9817,
	9818);
INSERT INTO O_RTIDA
	VALUES (6638,
	6622,
	0,
	9817,
	9818);
INSERT INTO R_RTO
	VALUES (6622,
	9817,
	9818,
	0);
INSERT INTO R_OIR
	VALUES (6622,
	9817,
	9818,
	9786);
INSERT INTO R_FORM
	VALUES (9815,
	9817,
	9819,
	1,
	1,
	'is carried to EE via');
INSERT INTO R_RGO
	VALUES (9815,
	9817,
	9819);
INSERT INTO R_OIR
	VALUES (9815,
	9817,
	9819,
	0);
INSERT INTO R_SIMP
	VALUES (9820);
INSERT INTO R_REL
	VALUES (9820,
	414,
	'

Notes:

',
	9782);
INSERT INTO R_FORM
	VALUES (9800,
	9820,
	9821,
	1,
	1,
	'represents the destination SM for');
INSERT INTO R_RGO
	VALUES (9800,
	9820,
	9821);
INSERT INTO R_OIR
	VALUES (9800,
	9820,
	9821,
	0);
INSERT INTO R_PART
	VALUES (1050,
	9820,
	9822,
	0,
	1,
	'destination SM can be represented by');
INSERT INTO O_RTIDA
	VALUES (1360,
	1050,
	0,
	9820,
	9822);
INSERT INTO R_RTO
	VALUES (1050,
	9820,
	9822,
	0);
INSERT INTO R_OIR
	VALUES (1050,
	9820,
	9822,
	9790);
INSERT INTO R_SUBSUP
	VALUES (9823);
INSERT INTO R_REL
	VALUES (9823,
	415,
	'

Notes:

',
	9782);
INSERT INTO R_SUPER
	VALUES (7227,
	9823,
	9824);
INSERT INTO O_RTIDA
	VALUES (9825,
	7227,
	0,
	9823,
	9824);
INSERT INTO R_RTO
	VALUES (7227,
	9823,
	9824,
	0);
INSERT INTO R_OIR
	VALUES (7227,
	9823,
	9824,
	0);
INSERT INTO R_SUB
	VALUES (9826,
	9823,
	9827);
INSERT INTO R_RGO
	VALUES (9826,
	9823,
	9827);
INSERT INTO R_OIR
	VALUES (9826,
	9823,
	9827,
	0);
INSERT INTO R_SUB
	VALUES (9828,
	9823,
	9829);
INSERT INTO R_RGO
	VALUES (9828,
	9823,
	9829);
INSERT INTO R_OIR
	VALUES (9828,
	9823,
	9829,
	0);
INSERT INTO R_SIMP
	VALUES (9830);
INSERT INTO R_REL
	VALUES (9830,
	417,
	'

Notes:

',
	9782);
INSERT INTO R_FORM
	VALUES (9826,
	9830,
	9831,
	1,
	1,
	'has data access represented by');
INSERT INTO R_RGO
	VALUES (9826,
	9830,
	9831);
INSERT INTO R_OIR
	VALUES (9826,
	9830,
	9831,
	0);
INSERT INTO R_PART
	VALUES (30,
	9830,
	9832,
	0,
	0,
	'shows accesses of data from');
INSERT INTO O_RTIDA
	VALUES (150,
	30,
	0,
	9830,
	9832);
INSERT INTO R_RTO
	VALUES (30,
	9830,
	9832,
	0);
INSERT INTO R_OIR
	VALUES (30,
	9830,
	9832,
	9789);
INSERT INTO R_SIMP
	VALUES (9833);
INSERT INTO R_REL
	VALUES (9833,
	418,
	'

Notes:

',
	9782);
INSERT INTO R_PART
	VALUES (9826,
	9833,
	9834,
	0,
	0,
	'is carried by ');
INSERT INTO O_RTIDA
	VALUES (9835,
	9826,
	1,
	9833,
	9834);
INSERT INTO O_RTIDA
	VALUES (9836,
	9826,
	1,
	9833,
	9834);
INSERT INTO R_RTO
	VALUES (9826,
	9833,
	9834,
	1);
INSERT INTO R_OIR
	VALUES (9826,
	9833,
	9834,
	0);
INSERT INTO R_FORM
	VALUES (9837,
	9833,
	9838,
	1,
	1,
	'carries');
INSERT INTO R_RGO
	VALUES (9837,
	9833,
	9838);
INSERT INTO R_OIR
	VALUES (9837,
	9833,
	9838,
	0);
INSERT INTO R_SIMP
	VALUES (9839);
INSERT INTO R_REL
	VALUES (9839,
	419,
	'

Notes:

',
	9782);
INSERT INTO R_FORM
	VALUES (9837,
	9839,
	9840,
	1,
	1,
	'is accessed by');
INSERT INTO R_RGO
	VALUES (9837,
	9839,
	9840);
INSERT INTO R_OIR
	VALUES (9837,
	9839,
	9840,
	0);
INSERT INTO R_PART
	VALUES (37,
	9839,
	9841,
	0,
	0,
	'represents access of');
INSERT INTO O_RTIDA
	VALUES (168,
	37,
	0,
	9839,
	9841);
INSERT INTO O_RTIDA
	VALUES (169,
	37,
	0,
	9839,
	9841);
INSERT INTO R_RTO
	VALUES (37,
	9839,
	9841,
	0);
INSERT INTO R_OIR
	VALUES (37,
	9839,
	9841,
	9788);
INSERT INTO R_SIMP
	VALUES (9842);
INSERT INTO R_REL
	VALUES (9842,
	420,
	'

Notes:

',
	9782);
INSERT INTO R_FORM
	VALUES (9826,
	9842,
	9843,
	1,
	1,
	'represents the destination OBJ for');
INSERT INTO R_RGO
	VALUES (9826,
	9842,
	9843);
INSERT INTO R_OIR
	VALUES (9826,
	9842,
	9843,
	0);
INSERT INTO R_PART
	VALUES (1050,
	9842,
	9844,
	0,
	1,
	'destination OBJ can be represented by');
INSERT INTO O_RTIDA
	VALUES (1360,
	1050,
	0,
	9842,
	9844);
INSERT INTO R_RTO
	VALUES (1050,
	9842,
	9844,
	0);
INSERT INTO R_OIR
	VALUES (1050,
	9842,
	9844,
	9790);
INSERT INTO R_SIMP
	VALUES (9845);
INSERT INTO R_REL
	VALUES (9845,
	421,
	'

Notes:

',
	9782);
INSERT INTO R_PART
	VALUES (7235,
	9845,
	9846,
	0,
	0,
	'accesses data of');
INSERT INTO O_RTIDA
	VALUES (7901,
	7235,
	0,
	9845,
	9846);
INSERT INTO O_RTIDA
	VALUES (7903,
	7235,
	0,
	9845,
	9846);
INSERT INTO R_RTO
	VALUES (7235,
	9845,
	9846,
	0);
INSERT INTO R_OIR
	VALUES (7235,
	9845,
	9846,
	9784);
INSERT INTO R_FORM
	VALUES (9828,
	9845,
	9847,
	1,
	1,
	'has data access represented by');
INSERT INTO R_RGO
	VALUES (9828,
	9845,
	9847);
INSERT INTO R_OIR
	VALUES (9828,
	9845,
	9847,
	0);
INSERT INTO R_SIMP
	VALUES (9848);
INSERT INTO R_REL
	VALUES (9848,
	422,
	'

Notes:

',
	9782);
INSERT INTO R_PART
	VALUES (9828,
	9848,
	9849,
	0,
	0,
	'is carried by');
INSERT INTO O_RTIDA
	VALUES (9850,
	9828,
	1,
	9848,
	9849);
INSERT INTO O_RTIDA
	VALUES (9851,
	9828,
	1,
	9848,
	9849);
INSERT INTO R_RTO
	VALUES (9828,
	9848,
	9849,
	1);
INSERT INTO R_OIR
	VALUES (9828,
	9848,
	9849,
	0);
INSERT INTO R_FORM
	VALUES (9852,
	9848,
	9853,
	1,
	1,
	'carries');
INSERT INTO R_RGO
	VALUES (9852,
	9848,
	9853);
INSERT INTO R_OIR
	VALUES (9852,
	9848,
	9853,
	0);
INSERT INTO R_SIMP
	VALUES (9854);
INSERT INTO R_REL
	VALUES (9854,
	423,
	'

Notes:

',
	9782);
INSERT INTO R_PART
	VALUES (7278,
	9854,
	9855,
	0,
	0,
	'represents access of');
INSERT INTO O_RTIDA
	VALUES (7936,
	7278,
	0,
	9854,
	9855);
INSERT INTO O_RTIDA
	VALUES (7938,
	7278,
	0,
	9854,
	9855);
INSERT INTO R_RTO
	VALUES (7278,
	9854,
	9855,
	0);
INSERT INTO R_OIR
	VALUES (7278,
	9854,
	9855,
	9785);
INSERT INTO R_FORM
	VALUES (9852,
	9854,
	9856,
	1,
	1,
	'is accessed by');
INSERT INTO R_RGO
	VALUES (9852,
	9854,
	9856);
INSERT INTO R_OIR
	VALUES (9852,
	9854,
	9856,
	0);
INSERT INTO R_SIMP
	VALUES (9857);
INSERT INTO R_REL
	VALUES (9857,
	424,
	'',
	9782);
INSERT INTO R_FORM
	VALUES (9800,
	9857,
	9858,
	1,
	1,
	'represents the origination SM for');
INSERT INTO R_RGO
	VALUES (9800,
	9857,
	9858);
INSERT INTO R_OIR
	VALUES (9800,
	9857,
	9858,
	0);
INSERT INTO R_PART
	VALUES (1050,
	9857,
	9859,
	0,
	1,
	'origination SM can be represented by');
INSERT INTO O_RTIDA
	VALUES (1360,
	1050,
	0,
	9857,
	9859);
INSERT INTO R_RTO
	VALUES (1050,
	9857,
	9859,
	0);
INSERT INTO R_OIR
	VALUES (1050,
	9857,
	9859,
	9790);
INSERT INTO R_SIMP
	VALUES (9860);
INSERT INTO R_REL
	VALUES (9860,
	425,
	'',
	9782);
INSERT INTO R_FORM
	VALUES (7227,
	9860,
	9861,
	1,
	1,
	'represents origination OBJ for');
INSERT INTO R_RGO
	VALUES (7227,
	9860,
	9861);
INSERT INTO R_OIR
	VALUES (7227,
	9860,
	9861,
	0);
INSERT INTO R_PART
	VALUES (1050,
	9860,
	9862,
	0,
	1,
	'origination OBJ can be represented by');
INSERT INTO O_RTIDA
	VALUES (1360,
	1050,
	0,
	9860,
	9862);
INSERT INTO R_RTO
	VALUES (1050,
	9860,
	9862,
	0);
INSERT INTO R_OIR
	VALUES (1050,
	9860,
	9862,
	9790);
INSERT INTO R_SIMP
	VALUES (9863);
INSERT INTO R_REL
	VALUES (9863,
	405,
	'',
	9782);
INSERT INTO R_FORM
	VALUES (9805,
	9863,
	9864,
	1,
	1,
	'is carried to other SMs via');
INSERT INTO R_RGO
	VALUES (9805,
	9863,
	9864);
INSERT INTO R_OIR
	VALUES (9805,
	9863,
	9864,
	0);
INSERT INTO R_PART
	VALUES (1488,
	9863,
	9865,
	0,
	0,
	'represents communication of');
INSERT INTO O_RTIDA
	VALUES (1604,
	1488,
	0,
	9863,
	9865);
INSERT INTO R_RTO
	VALUES (1488,
	9863,
	9865,
	0);
INSERT INTO R_OIR
	VALUES (1488,
	9863,
	9865,
	9791);
INSERT INTO R_SIMP
	VALUES (9866);
INSERT INTO R_REL
	VALUES (9866,
	409,
	'',
	9782);
INSERT INTO R_FORM
	VALUES (9810,
	9866,
	9867,
	1,
	1,
	'is carried to other SMs via');
INSERT INTO R_RGO
	VALUES (9810,
	9866,
	9867);
INSERT INTO R_OIR
	VALUES (9810,
	9866,
	9867,
	0);
INSERT INTO R_PART
	VALUES (1488,
	9866,
	9868,
	0,
	0,
	'represents communication of');
INSERT INTO O_RTIDA
	VALUES (1604,
	1488,
	0,
	9866,
	9868);
INSERT INTO R_RTO
	VALUES (1488,
	9866,
	9868,
	0);
INSERT INTO R_OIR
	VALUES (1488,
	9866,
	9868,
	9791);
INSERT INTO R_SIMP
	VALUES (9869);
INSERT INTO R_REL
	VALUES (9869,
	403,
	'',
	9782);
INSERT INTO R_FORM
	VALUES (9796,
	9869,
	9870,
	1,
	1,
	'has received event communication represented by');
INSERT INTO R_RGO
	VALUES (9796,
	9869,
	9870);
INSERT INTO R_OIR
	VALUES (9796,
	9869,
	9870,
	0);
INSERT INTO R_PART
	VALUES (565,
	9869,
	9871,
	0,
	0,
	'shows event communication to');
INSERT INTO O_RTIDA
	VALUES (564,
	565,
	0,
	9869,
	9871);
INSERT INTO R_RTO
	VALUES (565,
	9869,
	9871,
	0);
INSERT INTO R_OIR
	VALUES (565,
	9869,
	9871,
	9792);
INSERT INTO R_SIMP
	VALUES (9872);
INSERT INTO R_REL
	VALUES (9872,
	402,
	'',
	9782);
INSERT INTO R_PART
	VALUES (7235,
	9872,
	9873,
	0,
	0,
	'originates from');
INSERT INTO O_RTIDA
	VALUES (7901,
	7235,
	0,
	9872,
	9873);
INSERT INTO O_RTIDA
	VALUES (7903,
	7235,
	0,
	9872,
	9873);
INSERT INTO R_RTO
	VALUES (7235,
	9872,
	9873,
	0);
INSERT INTO R_OIR
	VALUES (7235,
	9872,
	9873,
	9787);
INSERT INTO R_FORM
	VALUES (9796,
	9872,
	9874,
	1,
	1,
	'originates');
INSERT INTO R_RGO
	VALUES (9796,
	9872,
	9874);
INSERT INTO R_OIR
	VALUES (9796,
	9872,
	9874,
	0);
INSERT INTO R_SIMP
	VALUES (9875);
INSERT INTO R_REL
	VALUES (9875,
	410,
	'',
	9782);
INSERT INTO R_FORM
	VALUES (9798,
	9875,
	9876,
	1,
	1,
	'originates');
INSERT INTO R_RGO
	VALUES (9798,
	9875,
	9876);
INSERT INTO R_OIR
	VALUES (9798,
	9875,
	9876,
	0);
INSERT INTO R_PART
	VALUES (565,
	9875,
	9877,
	0,
	0,
	'originates from');
INSERT INTO O_RTIDA
	VALUES (564,
	565,
	0,
	9875,
	9877);
INSERT INTO R_RTO
	VALUES (565,
	9875,
	9877,
	0);
INSERT INTO R_OIR
	VALUES (565,
	9875,
	9877,
	9792);
INSERT INTO R_SIMP
	VALUES (9878);
INSERT INTO R_REL
	VALUES (9878,
	411,
	'',
	9782);
INSERT INTO R_PART
	VALUES (7235,
	9878,
	9879,
	0,
	0,
	'shows event communication to');
INSERT INTO O_RTIDA
	VALUES (7901,
	7235,
	0,
	9878,
	9879);
INSERT INTO O_RTIDA
	VALUES (7903,
	7235,
	0,
	9878,
	9879);
INSERT INTO R_RTO
	VALUES (7235,
	9878,
	9879,
	0);
INSERT INTO R_OIR
	VALUES (7235,
	9878,
	9879,
	9787);
INSERT INTO R_FORM
	VALUES (9798,
	9878,
	9880,
	1,
	1,
	'has received event communication represented by');
INSERT INTO R_RGO
	VALUES (9798,
	9878,
	9880);
INSERT INTO R_OIR
	VALUES (9798,
	9878,
	9880,
	0);
INSERT INTO R_SIMP
	VALUES (9881);
INSERT INTO R_REL
	VALUES (9881,
	406,
	'',
	9782);
INSERT INTO R_FORM
	VALUES (9800,
	9881,
	9882,
	1,
	1,
	'originates');
INSERT INTO R_RGO
	VALUES (9800,
	9881,
	9882);
INSERT INTO R_OIR
	VALUES (9800,
	9881,
	9882,
	0);
INSERT INTO R_PART
	VALUES (565,
	9881,
	9883,
	0,
	0,
	'originates from');
INSERT INTO O_RTIDA
	VALUES (564,
	565,
	0,
	9881,
	9883);
INSERT INTO R_RTO
	VALUES (565,
	9881,
	9883,
	0);
INSERT INTO R_OIR
	VALUES (565,
	9881,
	9883,
	9792);
INSERT INTO R_SIMP
	VALUES (9884);
INSERT INTO R_REL
	VALUES (9884,
	407,
	'',
	9782);
INSERT INTO R_FORM
	VALUES (9800,
	9884,
	9885,
	1,
	1,
	'represents the destination SM for');
INSERT INTO R_RGO
	VALUES (9800,
	9884,
	9885);
INSERT INTO R_OIR
	VALUES (9800,
	9884,
	9885,
	0);
INSERT INTO R_PART
	VALUES (565,
	9884,
	9886,
	0,
	0,
	'shows event communication to');
INSERT INTO O_RTIDA
	VALUES (564,
	565,
	0,
	9884,
	9886);
INSERT INTO R_RTO
	VALUES (565,
	9884,
	9886,
	0);
INSERT INTO R_OIR
	VALUES (565,
	9884,
	9886,
	9792);
INSERT INTO R_SIMP
	VALUES (9887);
INSERT INTO R_REL
	VALUES (9887,
	416,
	'',
	9782);
INSERT INTO R_FORM
	VALUES (7227,
	9887,
	9888,
	1,
	1,
	'originates');
INSERT INTO R_RGO
	VALUES (7227,
	9887,
	9888);
INSERT INTO R_OIR
	VALUES (7227,
	9887,
	9888,
	0);
INSERT INTO R_PART
	VALUES (565,
	9887,
	9889,
	0,
	0,
	'originates from');
INSERT INTO O_RTIDA
	VALUES (564,
	565,
	0,
	9887,
	9889);
INSERT INTO R_RTO
	VALUES (565,
	9887,
	9889,
	0);
INSERT INTO R_OIR
	VALUES (565,
	9887,
	9889,
	9792);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (9810,
	'SM to SM Event Comm',
	406,
	'CA_SMSME',
	'This class represents the event communication attributed to the SM to SM communication path (CA_SMSMC).',
	9782);
INSERT INTO O_TFR
	VALUES (9890,
	9810,
	'dispose',
	'The dispose operation for this class.  Check to see if this is the last event on the communication line.  If so, dispose the whole line.  Otherwise just delete self.',
	19,
	1,
	'select many peers related by self->CA_SMSMC[R408]->CA_SMSME[R408];
if ( cardinality peers == 1 )
  select one path related by self->CA_SMSMC[R408]->CA_COMM[R401];
  path.dispose();
else
  select one smsmc related by self->CA_SMSMC[R408];
  unrelate self from smsmc across R408;
  select one smevt related by self->SM_EVT[R409];
  unrelate self from smevt across R409;
  delete object instance self;
end if;',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (9810,
	9800,
	0,
	9809,
	9807,
	9811,
	9808,
	9891,
	9892,
	0,
	0,
	'

Notes:

',
	'SM to SM Comm Path',
	'CPath_ID',
	'R408');
INSERT INTO O_RATTR
	VALUES (9891,
	9810,
	9795,
	7225,
	1,
	'CPath_ID');
INSERT INTO O_ATTR
	VALUES (9891,
	9810,
	0,
	'CPath_ID',
	'',
	'',
	'CPath_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (9810,
	1488,
	0,
	1604,
	9866,
	9867,
	9868,
	9893,
	9894,
	0,
	0,
	'',
	'State Machine Event',
	'SMevt_ID',
	'R409');
INSERT INTO O_RATTR
	VALUES (9893,
	9810,
	1604,
	1488,
	1,
	'SMevt_ID');
INSERT INTO O_ATTR
	VALUES (9893,
	9810,
	9891,
	'SMevt_ID',
	'',
	'',
	'SMevt_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	9810);
INSERT INTO O_OIDA
	VALUES (9891,
	9810,
	0,
	'CPath_ID');
INSERT INTO O_OIDA
	VALUES (9893,
	9810,
	0,
	'SMevt_ID');
INSERT INTO O_ID
	VALUES (1,
	9810);
INSERT INTO O_ID
	VALUES (2,
	9810);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (9800,
	'SM to SM Comm Path',
	403,
	'CA_SMSMC',
	'An SM to SM communication path represents a path on the Communication Diagram that originates at State Machine and terminates at a State Machine.  ',
	9782);
INSERT INTO O_TFR
	VALUES (9895,
	9800,
	'dispose',
	'Dispose this CA_SMSMC.',
	19,
	1,
	'select many smsmes related by self->CA_SMSME[R408];
for each smsme in smsmes
  select one smEvt related by smsme->SM_EVT[R409];
  unrelate smsme from smEvt across R409;
  unrelate smsme from self across R408;
  delete object instance smsme;
 end for;
select one oiobj related by self->O_IOBJ[R424];
if not_empty oiobj
  unrelate self from oiobj across R424;
end if;
select one diobj related by self->O_IOBJ[R414];
if not_empty diobj
  unrelate self from diobj across R414;
end if;
select one dsm related by self->SM_SM[R407];
unrelate self from dsm across R407;
select one osm related by self->SM_SM[R406];
unrelate self from osm across R406;
select one cp related by self->CA_COMM[R401];
unrelate self from cp across R401;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (9800,
	7225,
	0,
	9795,
	9793,
	9801,
	9794,
	9809,
	9896,
	0,
	0,
	'

Notes:

',
	'Communication Path',
	'CPath_ID',
	'R401');
INSERT INTO O_RATTR
	VALUES (9809,
	9800,
	9795,
	7225,
	1,
	'CPath_ID');
INSERT INTO O_ATTR
	VALUES (9809,
	9800,
	0,
	'CPath_ID',
	'',
	'',
	'CPath_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (9800,
	565,
	0,
	564,
	9881,
	9882,
	9883,
	9897,
	9898,
	0,
	0,
	'',
	'State Machine',
	'SM_ID',
	'R406');
INSERT INTO O_RATTR
	VALUES (9897,
	9800,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (9897,
	9800,
	9809,
	'OSM_ID',
	'',
	'O',
	'SM_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (9800,
	565,
	0,
	564,
	9884,
	9885,
	9886,
	9899,
	9900,
	0,
	0,
	'',
	'State Machine',
	'SM_ID',
	'R407');
INSERT INTO O_RATTR
	VALUES (9899,
	9800,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (9899,
	9800,
	9897,
	'DSM_ID',
	'',
	'D',
	'SM_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (9800,
	1050,
	0,
	1360,
	9820,
	9821,
	9822,
	9901,
	9902,
	0,
	0,
	'',
	'Imported Class',
	'IObj_ID',
	'R414');
INSERT INTO O_RATTR
	VALUES (9901,
	9800,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (9901,
	9800,
	9903,
	'DIObj_ID',
	'',
	'D',
	'IObj_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (9800,
	1050,
	0,
	1360,
	9857,
	9858,
	9859,
	9903,
	9904,
	0,
	0,
	'',
	'Imported Class',
	'IObj_ID',
	'R424');
INSERT INTO O_RATTR
	VALUES (9903,
	9800,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (9903,
	9800,
	9899,
	'OIObj_ID',
	'',
	'O',
	'IObj_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	9800);
INSERT INTO O_OIDA
	VALUES (9809,
	9800,
	0,
	'CPath_ID');
INSERT INTO O_ID
	VALUES (1,
	9800);
INSERT INTO O_OIDA
	VALUES (9897,
	9800,
	1,
	'OSM_ID');
INSERT INTO O_OIDA
	VALUES (9899,
	9800,
	1,
	'DSM_ID');
INSERT INTO O_ID
	VALUES (2,
	9800);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (9837,
	'SM to OBJ Attribute Access',
	411,
	'CA_SMOAA',
	'This class represents the data access attributed to the SM to OBJ data access path (CA_SMOA).',
	9782);
INSERT INTO O_TFR
	VALUES (9905,
	9837,
	'dispose',
	'The dispose operation for this class.  If it is the last access then delete the whole access path, otherwise just delete self.',
	19,
	1,
	'select many peers related by self->CA_SMOA[R418]->CA_SMOAA[R418];
if ( cardinality peers == 1 )
  select one path related by self->CA_SMOA[R418]->CA_ACC[R415];
  path.dispose();
else 
  select one smoa related by self->CA_SMOA[R418];
  unrelate self from smoa across R418;
  select one attr related by self->O_ATTR[R419];
  unrelate self from attr across R419;
  delete object instance self;
end if;',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (9837,
	9826,
	1,
	9835,
	9833,
	9838,
	9834,
	9906,
	9907,
	0,
	0,
	'',
	'SM to OBJ Access Path',
	'APath_ID',
	'R418');
INSERT INTO O_RATTR
	VALUES (9906,
	9837,
	9825,
	7227,
	1,
	'APath_ID');
INSERT INTO O_ATTR
	VALUES (9906,
	9837,
	0,
	'APath_ID',
	'',
	'',
	'APath_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (9837,
	37,
	0,
	168,
	9839,
	9840,
	9841,
	9908,
	9909,
	0,
	0,
	'

Notes:

',
	'Attribute',
	'Attr_ID',
	'R419');
INSERT INTO O_RATTR
	VALUES (9908,
	9837,
	168,
	37,
	1,
	'Attr_ID');
INSERT INTO O_ATTR
	VALUES (9908,
	9837,
	9906,
	'Attr_ID',
	'

Domain:


Notes:

',
	'',
	'Attr_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (9837,
	37,
	0,
	169,
	9839,
	9840,
	9841,
	9910,
	9911,
	0,
	0,
	'',
	'Attribute',
	'Obj_ID',
	'R419');
INSERT INTO O_REF
	VALUES (9837,
	9826,
	1,
	9836,
	9833,
	9838,
	9834,
	9910,
	9912,
	9911,
	0,
	'',
	'SM to OBJ Access Path',
	'Obj_ID',
	'R418');
INSERT INTO O_RATTR
	VALUES (9910,
	9837,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (9910,
	9837,
	9908,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	9837);
INSERT INTO O_OIDA
	VALUES (9908,
	9837,
	0,
	'Attr_ID');
INSERT INTO O_OIDA
	VALUES (9906,
	9837,
	0,
	'APath_ID');
INSERT INTO O_OIDA
	VALUES (9910,
	9837,
	0,
	'Obj_ID');
INSERT INTO O_ID
	VALUES (1,
	9837);
INSERT INTO O_ID
	VALUES (2,
	9837);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (9826,
	'SM to OBJ Access Path',
	409,
	'CA_SMOA',
	'An SM to OBJ access path represents a path on the Communication Diagram that originates at a State Machine  and terminates at a class.  ',
	9782);
INSERT INTO O_TFR
	VALUES (9913,
	9826,
	'dispose',
	'Dispose this CA_SMOA.',
	19,
	1,
	'select many smoaas related by self->CA_SMOAA[R418];
for each smoaa in smoaas
  select one attr related by smoaa->O_ATTR[R419];
  unrelate smoaa from attr across R419;
  unrelate smoaa from self across R418;
    delete object instance smoaa;
end for;
select one obj related by self->O_OBJ[R417];
unrelate self from obj across R417;
select one iobj related by self->O_IOBJ[R420];
if not_empty iobj
  unrelate self from iobj across R420;
end if;
select one acp related by self->CA_ACC[R415];
unrelate self from acp across R415;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (9826,
	7227,
	0,
	9825,
	9823,
	9827,
	9824,
	9835,
	9914,
	0,
	0,
	'

Notes:

',
	'Access Path',
	'APath_ID',
	'R415');
INSERT INTO O_RATTR
	VALUES (9835,
	9826,
	9825,
	7227,
	1,
	'APath_ID');
INSERT INTO O_ATTR
	VALUES (9835,
	9826,
	0,
	'APath_ID',
	'',
	'',
	'APath_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (9826,
	30,
	0,
	150,
	9830,
	9831,
	9832,
	9836,
	9915,
	0,
	0,
	'',
	'Model Class',
	'Obj_ID',
	'R417');
INSERT INTO O_RATTR
	VALUES (9836,
	9826,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (9836,
	9826,
	9835,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (9826,
	1050,
	0,
	1360,
	9842,
	9843,
	9844,
	9916,
	9917,
	0,
	0,
	'',
	'Imported Class',
	'IObj_ID',
	'R420');
INSERT INTO O_RATTR
	VALUES (9916,
	9826,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (9916,
	9826,
	9836,
	'IObj_ID',
	'',
	'',
	'IObj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	9826);
INSERT INTO O_OIDA
	VALUES (9835,
	9826,
	0,
	'APath_ID');
INSERT INTO O_ID
	VALUES (1,
	9826);
INSERT INTO O_OIDA
	VALUES (9835,
	9826,
	1,
	'APath_ID');
INSERT INTO O_OIDA
	VALUES (9836,
	9826,
	1,
	'Obj_ID');
INSERT INTO O_ID
	VALUES (2,
	9826);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (9815,
	'SM to EE Event Comm',
	407,
	'CA_SMEEE',
	'This class represents the event communication attributed to the SM to EE communication path (CA_SMEEC).',
	9782);
INSERT INTO O_TFR
	VALUES (9918,
	9815,
	'dispose',
	'The dispose operation for this class.  Check to see if this is the last event on the communication line.  If so, dispose the whole line.  Otherwise just delete self.',
	19,
	1,
	'select many peers related by self->CA_SMEEC[R412]->CA_SMEEE[R412];
if ( cardinality peers == 1)
  select one path related by self->CA_SMEEC[R412]->CA_COMM[R401];
  path.dispose();
else
  select one smeec related by self->CA_SMEEC[R412];
  unrelate self from smeec across R412;
  select one eeevt related by self->S_EEEVT[R413];
  unrelate self from eeevt across R413;
  delete object instance self;
end if;',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (9815,
	9798,
	0,
	9814,
	9812,
	9816,
	9813,
	9919,
	9920,
	0,
	0,
	'

Notes:

',
	'SM to EE Comm Path',
	'CPath_ID',
	'R412');
INSERT INTO O_RATTR
	VALUES (9919,
	9815,
	9795,
	7225,
	1,
	'CPath_ID');
INSERT INTO O_ATTR
	VALUES (9919,
	9815,
	0,
	'CPath_ID',
	'',
	'',
	'CPath_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (9815,
	6622,
	0,
	6637,
	9817,
	9819,
	9818,
	9921,
	9922,
	0,
	0,
	'

Notes:

',
	'External Entity Event',
	'EEevt_ID',
	'R413');
INSERT INTO O_RATTR
	VALUES (9921,
	9815,
	6637,
	6622,
	1,
	'EEevt_ID');
INSERT INTO O_ATTR
	VALUES (9921,
	9815,
	9923,
	'EEevt_ID',
	'',
	'',
	'EEevt_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (9815,
	6622,
	0,
	6638,
	9817,
	9819,
	9818,
	9923,
	9924,
	0,
	0,
	'',
	'External Entity Event',
	'EE_ID',
	'R413');
INSERT INTO O_RATTR
	VALUES (9923,
	9815,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (9923,
	9815,
	9919,
	'EE_ID',
	'',
	'',
	'EE_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	9815);
INSERT INTO O_OIDA
	VALUES (9921,
	9815,
	0,
	'EEevt_ID');
INSERT INTO O_OIDA
	VALUES (9919,
	9815,
	0,
	'CPath_ID');
INSERT INTO O_OIDA
	VALUES (9923,
	9815,
	0,
	'EE_ID');
INSERT INTO O_ID
	VALUES (1,
	9815);
INSERT INTO O_ID
	VALUES (2,
	9815);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (9852,
	'SM to EE Data Item Access',
	412,
	'CA_SMEED',
	'This class represents the data access attributed to the SM to EE data access path (CA_SMEEA).',
	9782);
INSERT INTO O_TFR
	VALUES (9925,
	9852,
	'dispose',
	'The dispose operation for this class.  If this is the last access on the path, delete the whole path, otherwise just delete self.',
	19,
	1,
	'select many peers related by self->CA_SMEEA[R422]->CA_SMEED[R422];
if ( cardinality peers == 1 )
  select one path related by self->CA_SMEEA[R422]->CA_ACC[R415];
  path.dispose();
else
  select one smeea related by self->CA_SMEEA[R422];
  unrelate self from smeea across R422;
  select one eedi related by self->S_EEDI[R423];
  unrelate self from eedi across R423;
  delete object instance self;
end if;',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (9852,
	9828,
	1,
	9850,
	9848,
	9853,
	9849,
	9926,
	9927,
	0,
	0,
	'',
	'SM to EE Access Path',
	'APath_ID',
	'R422');
INSERT INTO O_RATTR
	VALUES (9926,
	9852,
	9825,
	7227,
	1,
	'APath_ID');
INSERT INTO O_ATTR
	VALUES (9926,
	9852,
	0,
	'APath_ID',
	'',
	'',
	'APath_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (9852,
	7278,
	0,
	7936,
	9854,
	9856,
	9855,
	9928,
	9929,
	0,
	0,
	'

Notes:

',
	'External Entity Data Item',
	'EEdi_ID',
	'R423');
INSERT INTO O_RATTR
	VALUES (9928,
	9852,
	7936,
	7278,
	1,
	'EEdi_ID');
INSERT INTO O_ATTR
	VALUES (9928,
	9852,
	9926,
	'EEdi_ID',
	'

Domain:


Notes:

',
	'',
	'EEdi_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (9852,
	7278,
	0,
	7938,
	9854,
	9856,
	9855,
	9930,
	9931,
	0,
	0,
	'',
	'External Entity Data Item',
	'EE_ID',
	'R423');
INSERT INTO O_REF
	VALUES (9852,
	9828,
	1,
	9851,
	9848,
	9853,
	9849,
	9930,
	9932,
	9931,
	0,
	'',
	'SM to EE Access Path',
	'EE_ID',
	'R422');
INSERT INTO O_RATTR
	VALUES (9930,
	9852,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (9930,
	9852,
	9928,
	'EE_ID',
	'',
	'',
	'EE_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	9852);
INSERT INTO O_OIDA
	VALUES (9928,
	9852,
	0,
	'EEdi_ID');
INSERT INTO O_OIDA
	VALUES (9926,
	9852,
	0,
	'APath_ID');
INSERT INTO O_OIDA
	VALUES (9930,
	9852,
	0,
	'EE_ID');
INSERT INTO O_ID
	VALUES (1,
	9852);
INSERT INTO O_ID
	VALUES (2,
	9852);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (9798,
	'SM to EE Comm Path',
	404,
	'CA_SMEEC',
	'An SM to EE communication path represents a path on the Communication Diagram that originates at a State Machine  and terminates at an External Entity.  ',
	9782);
INSERT INTO O_TFR
	VALUES (9933,
	9798,
	'dispose',
	'Dispose this CA_SMEEC.',
	19,
	1,
	'select many smeees related by self->CA_SMEEE[R412];
for each smeee in smeees
  select one eeevt related by smeee->S_EEEVT[R413];
  unrelate smeee from eeevt across R413;
  unrelate smeee from self across R412;
  delete object instance smeee; 
end for;
select one sm related by self->SM_SM[R410];
unrelate self from sm across R410;
select one eem related by self->S_EEM[R411];
unrelate self from eem across R411;
select one cp related by self->CA_COMM[R401];
unrelate self from cp across R401;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (9798,
	7225,
	0,
	9795,
	9793,
	9799,
	9794,
	9814,
	9934,
	0,
	0,
	'

Notes:

',
	'Communication Path',
	'CPath_ID',
	'R401');
INSERT INTO O_RATTR
	VALUES (9814,
	9798,
	9795,
	7225,
	1,
	'CPath_ID');
INSERT INTO O_ATTR
	VALUES (9814,
	9798,
	0,
	'CPath_ID',
	'',
	'',
	'CPath_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (9798,
	565,
	0,
	564,
	9875,
	9876,
	9877,
	9935,
	9936,
	0,
	0,
	'',
	'State Machine',
	'SM_ID',
	'R410');
INSERT INTO O_RATTR
	VALUES (9935,
	9798,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (9935,
	9798,
	9814,
	'SM_ID',
	'',
	'',
	'SM_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (9798,
	7235,
	0,
	7901,
	9878,
	9880,
	9879,
	9937,
	9938,
	0,
	0,
	'',
	'External Entity in Model',
	'EEmod_ID',
	'R411');
INSERT INTO O_RATTR
	VALUES (9937,
	9798,
	7901,
	7235,
	1,
	'EEmod_ID');
INSERT INTO O_ATTR
	VALUES (9937,
	9798,
	9939,
	'EEmod_ID',
	'',
	'',
	'EEmod_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (9798,
	7235,
	0,
	7903,
	9878,
	9880,
	9879,
	9939,
	9940,
	0,
	0,
	'',
	'External Entity in Model',
	'EE_ID',
	'R411');
INSERT INTO O_RATTR
	VALUES (9939,
	9798,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (9939,
	9798,
	9935,
	'EE_ID',
	'',
	'',
	'EE_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	9798);
INSERT INTO O_OIDA
	VALUES (9814,
	9798,
	0,
	'CPath_ID');
INSERT INTO O_ID
	VALUES (1,
	9798);
INSERT INTO O_OIDA
	VALUES (9935,
	9798,
	1,
	'SM_ID');
INSERT INTO O_OIDA
	VALUES (9939,
	9798,
	1,
	'EE_ID');
INSERT INTO O_ID
	VALUES (2,
	9798);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (9828,
	'SM to EE Access Path',
	410,
	'CA_SMEEA',
	'An SM to EE access path represents a path on the Synchronous Communication Diagram that originates at a State Machine  and terminates at an external entity.  ',
	9782);
INSERT INTO O_TFR
	VALUES (9941,
	9828,
	'dispose',
	'Dispose this CA_SMEEA.
',
	19,
	1,
	'select many smeeds related by self->CA_SMEED[R422];
for each smeed in smeeds
  select one eedi related by smeed->S_EEDI[R423];
  unrelate smeed from eedi across R423;
  unrelate self from smeed across R422;
  delete object instance smeed;
end for;
select one eem related by self->S_EEM[R421];
unrelate self from eem across R421;
select one acp related by self->CA_ACC[R415];
unrelate self from acp across R415;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (9828,
	7227,
	0,
	9825,
	9823,
	9829,
	9824,
	9850,
	9942,
	0,
	0,
	'

Notes:

',
	'Access Path',
	'APath_ID',
	'R415');
INSERT INTO O_RATTR
	VALUES (9850,
	9828,
	9825,
	7227,
	1,
	'APath_ID');
INSERT INTO O_ATTR
	VALUES (9850,
	9828,
	0,
	'APath_ID',
	'

Domain:


Notes:

',
	'',
	'APath_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (9828,
	7235,
	0,
	7901,
	9845,
	9847,
	9846,
	9943,
	9944,
	0,
	0,
	'

Notes:

',
	'External Entity in Model',
	'EEmod_ID',
	'R421');
INSERT INTO O_RATTR
	VALUES (9943,
	9828,
	7901,
	7235,
	1,
	'EEmod_ID');
INSERT INTO O_ATTR
	VALUES (9943,
	9828,
	9851,
	'EEmod_ID',
	'

Domain:


Notes:

',
	'',
	'EEmod_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (9828,
	7235,
	0,
	7903,
	9845,
	9847,
	9846,
	9851,
	9945,
	0,
	0,
	'',
	'External Entity in Model',
	'EE_ID',
	'R421');
INSERT INTO O_RATTR
	VALUES (9851,
	9828,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (9851,
	9828,
	9850,
	'EE_ID',
	'

Domain:


Notes:

',
	'',
	'EE_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	9828);
INSERT INTO O_OIDA
	VALUES (9850,
	9828,
	0,
	'APath_ID');
INSERT INTO O_ID
	VALUES (1,
	9828);
INSERT INTO O_OIDA
	VALUES (9850,
	9828,
	1,
	'APath_ID');
INSERT INTO O_OIDA
	VALUES (9851,
	9828,
	1,
	'EE_ID');
INSERT INTO O_ID
	VALUES (2,
	9828);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (9805,
	'EE to SM Event Comm',
	405,
	'CA_EESME',
	'This class represents the event communication attributed to the EE to SM communication path (CA_EESMC).',
	9782);
INSERT INTO O_TFR
	VALUES (9946,
	9805,
	'dispose',
	'The dispose operation for this class.  Check to see if this is the last event on the communication line.  If so, dispose the whole line.  Otherwise just delete self.',
	19,
	1,
	'select many peers related by self->CA_EESMC[R404]->CA_EESME[R404];
if ( cardinality peers == 1)
  select one path related by self->CA_EESMC[R404]->CA_COMM[R401];
  path.dispose();
else
  select one eesmc related by self->CA_EESMC[R404];
  unrelate self from eesmc across R404;
  select one smevt related by self->SM_EVT[R405];
  unrelate self from smevt across R405;
  delete object instance self;
end if;',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (9805,
	9796,
	0,
	9804,
	9802,
	9806,
	9803,
	9947,
	9948,
	0,
	0,
	'

Notes:

',
	'EE to SM Comm Path',
	'CPath_ID',
	'R404');
INSERT INTO O_RATTR
	VALUES (9947,
	9805,
	9795,
	7225,
	1,
	'CPath_ID');
INSERT INTO O_ATTR
	VALUES (9947,
	9805,
	0,
	'CPath_ID',
	'',
	'',
	'CPath_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (9805,
	1488,
	0,
	1604,
	9863,
	9864,
	9865,
	9949,
	9950,
	0,
	0,
	'',
	'State Machine Event',
	'SMevt_ID',
	'R405');
INSERT INTO O_RATTR
	VALUES (9949,
	9805,
	1604,
	1488,
	1,
	'SMevt_ID');
INSERT INTO O_ATTR
	VALUES (9949,
	9805,
	9947,
	'SMevt_ID',
	'',
	'',
	'SMevt_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	9805);
INSERT INTO O_OIDA
	VALUES (9949,
	9805,
	0,
	'SMevt_ID');
INSERT INTO O_OIDA
	VALUES (9947,
	9805,
	0,
	'CPath_ID');
INSERT INTO O_ID
	VALUES (1,
	9805);
INSERT INTO O_ID
	VALUES (2,
	9805);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (9796,
	'EE to SM Comm Path',
	402,
	'CA_EESMC',
	'An EE to SM communication path represents a path on the Communication Diagram that originates at an External Entity and terminates at a State Machine.  ',
	9782);
INSERT INTO O_TFR
	VALUES (9951,
	9796,
	'dispose',
	'Delete this CA_EESMC.
',
	19,
	1,
	'select many eesmes related by self->CA_EESME[R404];
for each eesme in eesmes
  select one evt related by eesme->SM_EVT[R405];
  unrelate eesme from evt across R405;
  unrelate eesme from self across R404;
  delete object instance eesme;
end for;
select one eem related by self->S_EEM[R402];
unrelate self from eem across R402;
select one sm related by self->SM_SM[R403];
unrelate self from sm across R403;
select one cp related by self->CA_COMM[R401];
unrelate self from cp across R401;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (9796,
	7225,
	0,
	9795,
	9793,
	9797,
	9794,
	9804,
	9952,
	0,
	0,
	'

Notes:

',
	'Communication Path',
	'CPath_ID',
	'R401');
INSERT INTO O_RATTR
	VALUES (9804,
	9796,
	9795,
	7225,
	1,
	'CPath_ID');
INSERT INTO O_ATTR
	VALUES (9804,
	9796,
	0,
	'CPath_ID',
	'',
	'',
	'CPath_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (9796,
	7235,
	0,
	7901,
	9872,
	9874,
	9873,
	9953,
	9954,
	0,
	0,
	'',
	'External Entity in Model',
	'EEmod_ID',
	'R402');
INSERT INTO O_RATTR
	VALUES (9953,
	9796,
	7901,
	7235,
	1,
	'EEmod_ID');
INSERT INTO O_ATTR
	VALUES (9953,
	9796,
	9804,
	'EEmod_ID',
	'',
	'',
	'EEmod_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (9796,
	565,
	0,
	564,
	9869,
	9870,
	9871,
	9955,
	9956,
	0,
	0,
	'',
	'State Machine',
	'SM_ID',
	'R403');
INSERT INTO O_RATTR
	VALUES (9955,
	9796,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (9955,
	9796,
	9957,
	'SM_ID',
	'',
	'',
	'SM_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (9796,
	7235,
	0,
	7903,
	9872,
	9874,
	9873,
	9957,
	9958,
	0,
	0,
	'',
	'External Entity in Model',
	'EE_ID',
	'R402');
INSERT INTO O_RATTR
	VALUES (9957,
	9796,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (9957,
	9796,
	9953,
	'EE_ID',
	'',
	'',
	'EE_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	9796);
INSERT INTO O_OIDA
	VALUES (9804,
	9796,
	0,
	'CPath_ID');
INSERT INTO O_ID
	VALUES (1,
	9796);
INSERT INTO O_ID
	VALUES (2,
	9796);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (7225,
	'Communication Path',
	401,
	'CA_COMM',
	'A communication path (CA_COMM) represents modeled event communication path (on the Communication Diagram) between two of the following elements: State Machines (SM_SM) and External Entities (S_EEM).  The communication path is created by the tool in fully-derived mode, or by the user in partially-derived mode.',
	9782);
INSERT INTO O_TFR
	VALUES (9959,
	7225,
	'dispose',
	'The dispose operation for the CA_COMM class.',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one smeec related by self->CA_SMEEC[R401];
if (not_empty smeec)
  smeec.dispose();
end if;
select one smsmc related by self->CA_SMSMC[R401];
if (not_empty smsmc)
  smsmc.dispose();
end if;
select one eesmc related by self->CA_EESMC[R401];
if not_empty eesmc
  eesmc.dispose();
end if;
//
// Domain subsystem
select one ss related by self->S_SS[R5];
if ( not_empty ss )
  unrelate self from ss across R5;
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (9960,
	7225,
	'get_oaa_id',
	'',
	296,
	1,
	'return self.CPath_ID;',
	1,
	'',
	9959);
INSERT INTO O_NBATTR
	VALUES (9795,
	7225);
INSERT INTO O_BATTR
	VALUES (9795,
	7225);
INSERT INTO O_ATTR
	VALUES (9795,
	7225,
	0,
	'CPath_ID',
	'Full Name: Communication Path Identifier',
	'',
	'CPath_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_REF
	VALUES (7225,
	701,
	0,
	717,
	7296,
	7298,
	7297,
	9961,
	9962,
	0,
	0,
	'

Notes:

',
	'Subsystem',
	'SS_ID',
	'R5');
INSERT INTO O_RATTR
	VALUES (9961,
	7225,
	717,
	701,
	1,
	'SS_ID');
INSERT INTO O_ATTR
	VALUES (9961,
	7225,
	9795,
	'SS_ID',
	'',
	'',
	'SS_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	7225);
INSERT INTO O_OIDA
	VALUES (9795,
	7225,
	0,
	'CPath_ID');
INSERT INTO O_ID
	VALUES (1,
	7225);
INSERT INTO O_ID
	VALUES (2,
	7225);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (7227,
	'Access Path',
	408,
	'CA_ACC',
	'An access path (CA_ACC) represents modeled data access path (on the Synchronous Communication Diagram) between two of the following elements: classes (O_OBJ) and External Entities (S_EEM).  The access path is created by the tool in fully-derived mode, or by the user in partially-derived mode.',
	9782);
INSERT INTO O_TFR
	VALUES (9963,
	7227,
	'dispose',
	'The dispose operation for the CA_ACC class.',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one sm related by self->SM_SM[R416];
unrelate self from sm across R416;
select one smeea related by self->CA_SMEEA[R415];
if not_empty smeea
  smeea.dispose();
end if;
select one smoa related by self->CA_SMOA[R415];
if not_empty smoa
  smoa.dispose();
end if;
select one iobj related by self->O_IOBJ[R425];
if not_empty iobj
  unrelate self from iobj across R425;
end if;
//
// Domain subsystem
select one ss related by self->S_SS[R6];
if ( not_empty ss )
  unrelate self from ss across R6;
end if;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (9964,
	7227,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.APath_ID;',
	1,
	'',
	9963);
INSERT INTO O_NBATTR
	VALUES (9825,
	7227);
INSERT INTO O_BATTR
	VALUES (9825,
	7227);
INSERT INTO O_ATTR
	VALUES (9825,
	7227,
	0,
	'APath_ID',
	'Full Name: Access Path Identifier',
	'',
	'APath_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_REF
	VALUES (7227,
	701,
	0,
	717,
	7299,
	7301,
	7300,
	9965,
	9966,
	0,
	0,
	'

Notes:

',
	'Subsystem',
	'SS_ID',
	'R6');
INSERT INTO O_RATTR
	VALUES (9965,
	7227,
	717,
	701,
	1,
	'SS_ID');
INSERT INTO O_ATTR
	VALUES (9965,
	7227,
	9825,
	'SS_ID',
	'',
	'',
	'SS_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (7227,
	565,
	0,
	564,
	9887,
	9888,
	9889,
	9967,
	9968,
	0,
	0,
	'',
	'State Machine',
	'SM_ID',
	'R416');
INSERT INTO O_RATTR
	VALUES (9967,
	7227,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (9967,
	7227,
	9965,
	'SM_ID',
	'',
	'',
	'SM_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (7227,
	1050,
	0,
	1360,
	9860,
	9861,
	9862,
	9969,
	9970,
	0,
	0,
	'',
	'Imported Class',
	'IObj_ID',
	'R425');
INSERT INTO O_RATTR
	VALUES (9969,
	7227,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (9969,
	7227,
	9967,
	'IObj_ID',
	'',
	'',
	'IObj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	7227);
INSERT INTO O_OIDA
	VALUES (9825,
	7227,
	0,
	'APath_ID');
INSERT INTO O_ID
	VALUES (1,
	7227);
INSERT INTO O_ID
	VALUES (2,
	7227);
-- BP 7.1 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (9971,
	'Communication',
	'// This is used by schema_gen to ignore this subsystem (for publication)
TRANSLATE_FOR_EXTERNAL_USE:FALSE',
	'COMM',
	1125,
	1,
	0);
INSERT INTO S_SID
	VALUES (1,
	9971);
INSERT INTO O_IOBJ
	VALUES (9972,
	703,
	0,
	9971,
	'Interaction Participant',
	'SQ_P');
INSERT INTO O_IOBJ
	VALUES (9973,
	699,
	0,
	9971,
	'Domain',
	'S_DOM');
INSERT INTO O_IOBJ
	VALUES (9974,
	701,
	0,
	9971,
	'Subsystem',
	'S_SS');
INSERT INTO O_IOBJ
	VALUES (9975,
	2322,
	0,
	9971,
	'Association',
	'R_REL');
INSERT INTO O_IOBJ
	VALUES (9976,
	2141,
	0,
	9971,
	'Message',
	'MSG_M');
INSERT INTO O_IOBJ
	VALUES (9977,
	705,
	0,
	9971,
	'System Model',
	'S_SYS');
INSERT INTO O_IOBJ
	VALUES (9978,
	707,
	0,
	9971,
	'Component Package',
	'CP_CP');
INSERT INTO O_IOBJ
	VALUES (9979,
	709,
	0,
	9971,
	'Component',
	'C_C');
INSERT INTO R_SIMP
	VALUES (9980);
INSERT INTO R_REL
	VALUES (9980,
	1129,
	'',
	9971);
INSERT INTO R_FORM
	VALUES (6800,
	9980,
	9981,
	1,
	1,
	'has children');
INSERT INTO R_RGO
	VALUES (6800,
	9980,
	9981);
INSERT INTO R_OIR
	VALUES (6800,
	9980,
	9981,
	0);
INSERT INTO R_PART
	VALUES (9982,
	9980,
	9983,
	0,
	1,
	'is connection to parent');
INSERT INTO O_RTIDA
	VALUES (9984,
	9982,
	0,
	9980,
	9983);
INSERT INTO R_RTO
	VALUES (9982,
	9980,
	9983,
	0);
INSERT INTO R_OIR
	VALUES (9982,
	9980,
	9983,
	0);
INSERT INTO R_SIMP
	VALUES (9985);
INSERT INTO R_REL
	VALUES (9985,
	1130,
	'',
	9971);
INSERT INTO R_PART
	VALUES (6800,
	9985,
	9986,
	0,
	0,
	'is shown in');
INSERT INTO O_RTIDA
	VALUES (9987,
	6800,
	0,
	9985,
	9986);
INSERT INTO R_RTO
	VALUES (6800,
	9985,
	9986,
	0);
INSERT INTO R_OIR
	VALUES (6800,
	9985,
	9986,
	0);
INSERT INTO R_FORM
	VALUES (9982,
	9985,
	9988,
	0,
	1,
	'has children');
INSERT INTO R_RGO
	VALUES (9982,
	9985,
	9988);
INSERT INTO R_OIR
	VALUES (9982,
	9985,
	9988,
	0);
INSERT INTO R_SIMP
	VALUES (9989);
INSERT INTO R_REL
	VALUES (9989,
	1132,
	'',
	9971);
INSERT INTO R_PART
	VALUES (699,
	9989,
	9990,
	0,
	1,
	'can be displayed in');
INSERT INTO O_RTIDA
	VALUES (712,
	699,
	0,
	9989,
	9990);
INSERT INTO R_RTO
	VALUES (699,
	9989,
	9990,
	0);
INSERT INTO R_OIR
	VALUES (699,
	9989,
	9990,
	9973);
INSERT INTO R_FORM
	VALUES (6800,
	9989,
	9991,
	1,
	1,
	'can display');
INSERT INTO R_RGO
	VALUES (6800,
	9989,
	9991);
INSERT INTO R_OIR
	VALUES (6800,
	9989,
	9991,
	0);
INSERT INTO R_ASSOC
	VALUES (9992);
INSERT INTO R_REL
	VALUES (9992,
	1126,
	'',
	9971);
INSERT INTO R_AONE
	VALUES (6800,
	9992,
	9993,
	0,
	1,
	'is displayed in');
INSERT INTO O_RTIDA
	VALUES (9987,
	6800,
	0,
	9992,
	9993);
INSERT INTO R_RTO
	VALUES (6800,
	9992,
	9993,
	0);
INSERT INTO R_OIR
	VALUES (6800,
	9992,
	9993,
	0);
INSERT INTO R_AOTH
	VALUES (703,
	9992,
	9994,
	1,
	1,
	'can display');
INSERT INTO O_RTIDA
	VALUES (743,
	703,
	0,
	9992,
	9994);
INSERT INTO R_RTO
	VALUES (703,
	9992,
	9994,
	0);
INSERT INTO R_OIR
	VALUES (703,
	9992,
	9994,
	9972);
INSERT INTO R_ASSR
	VALUES (9995,
	9992,
	9996,
	0);
INSERT INTO R_RGO
	VALUES (9995,
	9992,
	9996);
INSERT INTO R_OIR
	VALUES (9995,
	9992,
	9996,
	0);
INSERT INTO R_SIMP
	VALUES (9997);
INSERT INTO R_REL
	VALUES (9997,
	1131,
	'',
	9971);
INSERT INTO R_PART
	VALUES (701,
	9997,
	9998,
	0,
	1,
	'can be displayed in');
INSERT INTO O_RTIDA
	VALUES (717,
	701,
	0,
	9997,
	9998);
INSERT INTO R_RTO
	VALUES (701,
	9997,
	9998,
	0);
INSERT INTO R_OIR
	VALUES (701,
	9997,
	9998,
	9974);
INSERT INTO R_FORM
	VALUES (6800,
	9997,
	9999,
	1,
	1,
	'can display');
INSERT INTO R_RGO
	VALUES (6800,
	9997,
	9999);
INSERT INTO R_OIR
	VALUES (6800,
	9997,
	9999,
	0);
INSERT INTO R_SIMP
	VALUES (10000);
INSERT INTO R_REL
	VALUES (10000,
	1128,
	'CrossComponent:true',
	9971);
INSERT INTO R_FORM
	VALUES (10001,
	10000,
	10002,
	1,
	1,
	'represents formal instance');
INSERT INTO R_RGO
	VALUES (10001,
	10000,
	10002);
INSERT INTO R_OIR
	VALUES (10001,
	10000,
	10002,
	0);
INSERT INTO R_PART
	VALUES (2322,
	10000,
	10003,
	0,
	1,
	'may be formalized against');
INSERT INTO O_RTIDA
	VALUES (2368,
	2322,
	0,
	10000,
	10003);
INSERT INTO R_RTO
	VALUES (2322,
	10000,
	10003,
	0);
INSERT INTO R_OIR
	VALUES (2322,
	10000,
	10003,
	9975);
INSERT INTO R_SIMP
	VALUES (10004);
INSERT INTO R_REL
	VALUES (10004,
	1133,
	'',
	9971);
INSERT INTO R_PART
	VALUES (703,
	10004,
	10005,
	0,
	0,
	'starts at');
INSERT INTO O_RTIDA
	VALUES (743,
	703,
	0,
	10004,
	10005);
INSERT INTO R_RTO
	VALUES (703,
	10004,
	10005,
	0);
INSERT INTO R_OIR
	VALUES (703,
	10004,
	10005,
	9972);
INSERT INTO R_FORM
	VALUES (10001,
	10004,
	10006,
	1,
	1,
	'is start point');
INSERT INTO R_RGO
	VALUES (10001,
	10004,
	10006);
INSERT INTO R_OIR
	VALUES (10001,
	10004,
	10006,
	0);
INSERT INTO R_SIMP
	VALUES (10007);
INSERT INTO R_REL
	VALUES (10007,
	1134,
	'',
	9971);
INSERT INTO R_PART
	VALUES (703,
	10007,
	10008,
	0,
	0,
	'is destined for');
INSERT INTO O_RTIDA
	VALUES (743,
	703,
	0,
	10007,
	10008);
INSERT INTO R_RTO
	VALUES (703,
	10007,
	10008,
	0);
INSERT INTO R_OIR
	VALUES (703,
	10007,
	10008,
	9972);
INSERT INTO R_FORM
	VALUES (10001,
	10007,
	10009,
	1,
	1,
	'is destination');
INSERT INTO R_RGO
	VALUES (10001,
	10007,
	10009);
INSERT INTO R_OIR
	VALUES (10001,
	10007,
	10009,
	0);
INSERT INTO R_ASSOC
	VALUES (10010);
INSERT INTO R_REL
	VALUES (10010,
	1135,
	'',
	9971);
INSERT INTO R_AONE
	VALUES (6800,
	10010,
	10011,
	0,
	1,
	'can be displayed in');
INSERT INTO O_RTIDA
	VALUES (9987,
	6800,
	0,
	10010,
	10011);
INSERT INTO R_RTO
	VALUES (6800,
	10010,
	10011,
	0);
INSERT INTO R_OIR
	VALUES (6800,
	10010,
	10011,
	0);
INSERT INTO R_AOTH
	VALUES (2141,
	10010,
	10012,
	1,
	1,
	'may display');
INSERT INTO O_RTIDA
	VALUES (2177,
	2141,
	0,
	10010,
	10012);
INSERT INTO R_RTO
	VALUES (2141,
	10010,
	10012,
	0);
INSERT INTO R_OIR
	VALUES (2141,
	10010,
	10012,
	9976);
INSERT INTO R_ASSR
	VALUES (10013,
	10010,
	10014,
	0);
INSERT INTO R_RGO
	VALUES (10013,
	10010,
	10014);
INSERT INTO R_OIR
	VALUES (10013,
	10010,
	10014,
	0);
INSERT INTO R_SIMP
	VALUES (10015);
INSERT INTO R_REL
	VALUES (10015,
	1136,
	'',
	9971);
INSERT INTO R_PART
	VALUES (705,
	10015,
	10016,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (754,
	705,
	0,
	10015,
	10016);
INSERT INTO R_RTO
	VALUES (705,
	10015,
	10016,
	0);
INSERT INTO R_OIR
	VALUES (705,
	10015,
	10016,
	9977);
INSERT INTO R_FORM
	VALUES (6800,
	10015,
	10017,
	1,
	1,
	'is displayed in');
INSERT INTO R_RGO
	VALUES (6800,
	10015,
	10017);
INSERT INTO R_OIR
	VALUES (6800,
	10015,
	10017,
	0);
INSERT INTO R_SIMP
	VALUES (10018);
INSERT INTO R_REL
	VALUES (10018,
	1137,
	'',
	9971);
INSERT INTO R_PART
	VALUES (707,
	10018,
	10019,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (758,
	707,
	0,
	10018,
	10019);
INSERT INTO R_RTO
	VALUES (707,
	10018,
	10019,
	0);
INSERT INTO R_OIR
	VALUES (707,
	10018,
	10019,
	9978);
INSERT INTO R_FORM
	VALUES (6800,
	10018,
	10020,
	1,
	1,
	'is displayed in');
INSERT INTO R_RGO
	VALUES (6800,
	10018,
	10020);
INSERT INTO R_OIR
	VALUES (6800,
	10018,
	10020,
	0);
INSERT INTO R_SIMP
	VALUES (10021);
INSERT INTO R_REL
	VALUES (10021,
	1138,
	'',
	9971);
INSERT INTO R_PART
	VALUES (709,
	10021,
	10022,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (762,
	709,
	0,
	10021,
	10022);
INSERT INTO R_RTO
	VALUES (709,
	10021,
	10022,
	0);
INSERT INTO R_OIR
	VALUES (709,
	10021,
	10022,
	9979);
INSERT INTO R_FORM
	VALUES (6800,
	10021,
	10023,
	1,
	1,
	'is displayed in');
INSERT INTO R_RGO
	VALUES (6800,
	10021,
	10023);
INSERT INTO R_OIR
	VALUES (6800,
	10021,
	10023,
	0);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (9995,
	'Participant in Communication',
	1129,
	'COMM_PIC',
	'',
	9971);
INSERT INTO O_REF
	VALUES (9995,
	6800,
	0,
	9987,
	9992,
	9996,
	9993,
	10024,
	10025,
	0,
	0,
	'',
	'Communication',
	'Package_ID',
	'R1126');
INSERT INTO O_RATTR
	VALUES (10024,
	9995,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (10024,
	9995,
	0,
	'Package_ID',
	'',
	'',
	'Package_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (9995,
	703,
	0,
	743,
	9992,
	9996,
	9994,
	10026,
	10027,
	0,
	0,
	'',
	'Interaction Participant',
	'Part_ID',
	'R1126');
INSERT INTO O_RATTR
	VALUES (10026,
	9995,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (10026,
	9995,
	10024,
	'Part_ID',
	'',
	'',
	'Part_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	9995);
INSERT INTO O_OIDA
	VALUES (10024,
	9995,
	0,
	'Package_ID');
INSERT INTO O_OIDA
	VALUES (10026,
	9995,
	0,
	'Part_ID');
INSERT INTO O_ID
	VALUES (1,
	9995);
INSERT INTO O_ID
	VALUES (2,
	9995);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10013,
	'Message in Communication',
	1128,
	'COMM_MIC',
	'',
	9971);
INSERT INTO O_REF
	VALUES (10013,
	6800,
	0,
	9987,
	10010,
	10014,
	10011,
	10028,
	10029,
	0,
	0,
	'',
	'Communication',
	'Package_ID',
	'R1135');
INSERT INTO O_RATTR
	VALUES (10028,
	10013,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (10028,
	10013,
	0,
	'Package_ID',
	'',
	'',
	'Package_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10013,
	2141,
	0,
	2177,
	10010,
	10014,
	10012,
	10030,
	10031,
	0,
	0,
	'',
	'Message',
	'Msg_ID',
	'R1135');
INSERT INTO O_RATTR
	VALUES (10030,
	10013,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (10030,
	10013,
	10028,
	'Msg_ID',
	'',
	'',
	'Msg_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10013);
INSERT INTO O_OIDA
	VALUES (10028,
	10013,
	0,
	'Package_ID');
INSERT INTO O_OIDA
	VALUES (10030,
	10013,
	0,
	'Msg_ID');
INSERT INTO O_ID
	VALUES (1,
	10013);
INSERT INTO O_ID
	VALUES (2,
	10013);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10001,
	'Communication Link',
	1126,
	'COMM_LNK',
	'This class represents a link between two participants which communicate with
each other.',
	9971);
INSERT INTO O_TFR
	VALUES (10032,
	10001,
	'dispose',
	'',
	19,
	1,
	'select one toParticipant related by self->SQ_P[R1134];
select one fromParticipant related by self->SQ_P[R1133];
if(not_empty toParticipant)
  unrelate self from toParticipant across R1134;
end if;
if(not_empty fromParticipant)
  unrelate self from fromParticipant across R1133;
end if;
select one assoc related by self->R_REL[R1128];
if(not_empty assoc)
  unrelate self from assoc across R1128;
end if;
delete object instance self;',
	1,
	'',
	10033);
INSERT INTO O_TFR
	VALUES (10034,
	10001,
	'get_style',
	'',
	784,
	1,
	'if(param.at == End::End)
  if(self.EndVisibility == Visibility::Public)
    return Style::OpenArrow;
  end if;
elif(param.at == End::Start)
  if(self.StartVisibility == Visibility::Public)
    return Style::OpenArrow;
  end if;
end if;
return Style::Solid;',
	1,
	'',
	10035);
INSERT INTO O_TPARM
	VALUES (10036,
	10034,
	'at',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10037,
	10001,
	'get_connector_text',
	'',
	322,
	1,
	'select one assoc related by self->R_REL[R1128];
if(not_empty assoc)
  if(param.at == End::Middle)
    return "R" + GD::int_to_string(value:assoc.Numb);
  elif(param.at == End::Start)
    return self.getAssociationText(at:End::Start);
  elif(param.at == End::End)
    return self.getAssociationText(at:End::End);
  end if;
else
  if(param.at == End::Middle)
    // if the number is uninitialized
    // do not show it
    if(self.Numb != "")
      return "R" + self.Numb;
    end if;
  elif(param.at == End::Start)
    return self.StartText;
  elif(param.at == End::End)
    return self.EndText;
  end if;
end if;
return "";',
	1,
	'',
	10038);
INSERT INTO O_TPARM
	VALUES (10039,
	10037,
	'Obj_ID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (10040,
	10037,
	'Obj_TypeIsImported',
	316,
	0,
	'',
	10039,
	'');
INSERT INTO O_TPARM
	VALUES (10041,
	10037,
	'at',
	880,
	0,
	'',
	10040,
	'');
INSERT INTO O_TPARM
	VALUES (10042,
	10037,
	'parent_ID',
	296,
	0,
	'',
	10041,
	'');
INSERT INTO O_TFR
	VALUES (10035,
	10001,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Link_ID;',
	1,
	'',
	10043);
INSERT INTO O_TFR
	VALUES (10044,
	10001,
	'participatesWithFormalParticipants',
	'',
	316,
	1,
	'/**
 *
 *  This operation checks that the association with the given
 *  id exists between the classes that the source participant
 *  and destination participant between this link represent
 *
 */
select one startClass related by self->SQ_P[R1133]->SQ_CIP[R930]->O_OBJ[R934];
select one destClass related by self->SQ_P[R1134]->SQ_CIP[R930]->O_OBJ[R934];
if(not_empty startClass and not_empty destClass)
  select any assoc from instances of R_REL where (selected.Rel_ID == param.assocId);
  if(not_empty assoc)
    foundStart = false;
    foundEnd = false;
    select one simple related by assoc->R_SIMP[R206];
    select one associative related by assoc->R_ASSOC[R206];
    select one superSub related by assoc->R_SUBSUP[R206];
    select one derived related by assoc->R_COMP[R206];
    // see if the start and end classes participate in
    // a simple association
    if(not_empty simple)
      select any part_obj related by simple->R_PART[R207]->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201];
      select many part_objs related by simple->R_PART[R207]->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201];
      // the association is not formalized, check both part instances
      if(cardinality part_objs > 1)
        for each obj in part_objs
          if(obj == startClass)
            foundStart = true;
          elif(obj == destClass)
            foundEnd = true;
          end if;
        end for;
      else
        // otherwise the association is formalized, check both
        // the part object and the form object
        select one form_obj related by simple->R_FORM[R208]->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201];
          if(form_obj == startClass) or (part_obj == startClass)
            foundStart = true;
          end if;
          if(form_obj == destClass) or (part_obj == destClass)
            foundEnd = true;
          end if;
      end if;
    elif(not_empty associative)
      select one aone_obj related by associative->R_AONE[R209]->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201];
      select one aoth_obj related by associative->R_AOTH[R210]->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201];
      select one assr_obj related by associative->R_ASSR[R211]->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201];
      if(startClass == aone_obj) or (startClass == aoth_obj) or (startClass == assr_obj)
        foundStart = true;
      end if;
      if(destClass == aone_obj) or (destClass == aoth_obj) or (destClass == assr_obj)
        foundEnd = true;
      end if;
    elif(not_empty superSub)
      select one super_obj related by superSub->R_SUPER[R212]->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201];
      select many sub_objs related by superSub->R_SUB[R213]->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201];
      if(super_obj == startClass)
        foundStart = true;
      end if;
      if(super_obj == destClass)
        foundEnd = true;
      end if;
      // for each subtype class check to see if it is either
      // the start or destination class between the link
      for each sub_obj in sub_objs
        if(sub_obj == startClass)
          foundStart = true;
        end if;
        if(sub_obj == destClass)
          foundEnd = true;
        end if;
      end for;
    elif(not_empty derived)
      select one cone_obj related by derived->R_CONE[R214]->R_OIR[R203]->O_OBJ[R201];
      select one coth_obj related by derived->R_COTH[R215]->R_OIR[R203]->O_OBJ[R201];
      if(startClass == cone_obj) or (startClass == coth_obj)
        foundStart = true;
      end if;
      if(destClass == cone_obj) or (destClass == coth_obj)
        foundEnd = true;
      end if;
    end if;
    // if this association is not reflexive but the
    // start and destination classes are the same
    // do not allow it
    if(startClass == destClass and not assoc.is_reflexive())
      return false;
    elif(startClass != destClass and assoc.is_reflexive())
      select one assr_obj related by associative->R_ASSR[R211]->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201];
      if(assr_obj == startClass or assr_obj == destClass)
        if(foundStart and foundEnd)
          return true;
        end if;
      else
        return false;
      end if;
    end if;
    // if the start class was matched and the end class was matched
    if(foundStart and foundEnd)
      return true;
    end if;
  end if;
end if;
return false;',
	1,
	'',
	10045);
INSERT INTO O_TPARM
	VALUES (10046,
	10044,
	'assocId',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10047,
	10001,
	'formalize',
	'',
	19,
	1,
	'select any assoc from instances of R_REL where (selected.Rel_ID == param.assocId);
if(not_empty assoc)
  if(self.isFormal)
    self.unformalize();
  end if;
  relate self to assoc across R1128;
end if;',
	1,
	'',
	10032);
INSERT INTO O_TPARM
	VALUES (10048,
	10047,
	'assocId',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10033,
	10001,
	'actionFilter',
	'',
	316,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
if(param.name == "can" )
  if(param.value == "formalize" )
    select one comm related by self->SQ_P[R1133]->COMM_COMM[R1126];
	isInGenericPkg = false;
	select one pkg related by self->SQ_P[R1133]->PE_PE[R8001]->EP_PKG[R8000];
	if (not_empty pkg)
	  isInGenericPkg = true;
	end if;

	if (isInGenericPkg)
     select many assocs related by pkg->S_SYS[R1405]->EP_PKG[R1405]->PE_PE[R8000]->R_REL[R8001];
      for each assoc in assocs
        if(self.participatesWithFormalParticipants(assocId:assoc.Rel_ID))
          return true;
        end if;
      end for;
	else
      domName = comm.getPath(domainNameOnly:true);
      select any domain from instances of S_DOM where (selected.Name == domName);
      if(not_empty domain)
        select many assocs related by domain->S_SS[R1]->O_OBJ[R2]->R_OIR[R201]->R_REL[R201];
        for each assoc in assocs
          if(self.participatesWithFormalParticipants(assocId:assoc.Rel_ID))
            return true;
          end if;
        end for;
      end if;
	end if;   
  elif(param.value == "unformalize")
    return self.isFormal;
  end if;
end if;
return false;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (10049,
	10033,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (10050,
	10033,
	'value',
	322,
	0,
	'',
	10049,
	'');
INSERT INTO O_TFR
	VALUES (10051,
	10001,
	'unformalize',
	'',
	19,
	1,
	'select one assoc related by self->R_REL[R1128];
if(not_empty assoc)
  unrelate self from assoc across R1128;
end if;',
	1,
	'',
	10052);
INSERT INTO O_TFR
	VALUES (10045,
	10001,
	'initialize',
	'',
	19,
	1,
	'self.StartVisibility = Visibility::Private;
self.EndVisibility = Visibility::Private;',
	1,
	'',
	10034);
INSERT INTO O_TFR
	VALUES (10038,
	10001,
	'getAssociationText',
	'',
	322,
	1,
	'/**
 *
 *  This operation finds the text phrase for the association that this
 *  link is formalized against.
 *
 */
select one assoc related by self->R_REL[R1128];
select one mclass related by self->SQ_P[R1133]->SQ_CIP[R930]->O_OBJ[R934];
if(empty mclass)
  select one mclass related by self->SQ_P[R1133]->SQ_CP[R930]->O_OBJ[R939];
end if;
if(param.at == End::End)
  select one mclass related by self->SQ_P[R1134]->SQ_CIP[R930]->O_OBJ[R934];
  if(empty mclass)
    select one mclass related by self->SQ_P[R1134]->SQ_CP[R930]->O_OBJ[R939];
  end if;
end if;
if((not_empty mclass) and (not_empty assoc))
  // select all the possible subtypes which have the same class id as the
  // participant represents
  select many parts related by assoc->R_SIMP[R206]->R_PART[R207] where (selected.Obj_ID == mclass.Obj_ID);
  select any part related by assoc->R_SIMP[R206]->R_PART[R207] where (selected.Obj_ID == mclass.Obj_ID);
  select one form related by assoc->R_SIMP[R206]->R_FORM[R208] where (selected.Obj_ID == mclass.Obj_ID);
  select one aone related by assoc->R_ASSOC[R206]->R_AONE[R209] where (selected.Obj_ID == mclass.Obj_ID);
  select one aoth related by assoc->R_ASSOC[R206]->R_AOTH[R210] where (selected.Obj_ID == mclass.Obj_ID);
  select one sup related by assoc->R_SUBSUP[R206]->R_SUPER[R212] where (selected.Obj_ID == mclass.Obj_ID);
  select any sub related by assoc->R_SUBSUP[R206]->R_SUB[R213] where (selected.Obj_ID == mclass.Obj_ID);
  select one cone related by assoc->R_COMP[R206]->R_CONE[R214] where (selected.Obj_ID == mclass.Obj_ID);
  select one coth related by assoc->R_COMP[R206]->R_COTH[R215] where (selected.Obj_ID == mclass.Obj_ID);
  // if the participant and formalizer are not empty
  // then this is a reflexive association, use the
  // formalizer as the start and the participant as
  // the end
  if(cardinality parts == 1) and (not_empty form)
    if(param.at == End::Start)
      return form.Txt_Phrs;
    else
      return part.Txt_Phrs;
    end if;
  // if more than one part exists the association
  // itself is not formalized use the first part
  // as the start and the second as the end
  elif(cardinality parts > 0)
    if(cardinality parts == 2)
      part_num = 0;
      for each part in parts
        part_num = part_num + 1;
        if(param.at == End::Start and part_num == 1)
          return part.Txt_Phrs;
        elif(param.at == End::End and part_num == 2)
          return part.Txt_Phrs;
        end if;
      end for;
    else
      return part.Txt_Phrs;
    end if;
  elif(not_empty form)
    return form.Txt_Phrs;
  // if the both sides are not empty
  // then this is a reflexive association, use the
  // aone instance as the start and the
  // aoth instance as the end
  elif(not_empty aone and not_empty aoth)
    if(param.at == End::Start)
      return aone.Txt_Phrs;
    else
      return aoth.Txt_Phrs;
    end if;
  elif(not_empty aone)
    return aone.Txt_Phrs;    
  elif(not_empty aoth)
    return aoth.Txt_Phrs;
  elif(not_empty sup)
    return "supertype";
  elif(not_empty sub)
    return "subtype";
  elif(not_empty cone)
    return cone.Txt_Phrs;
  elif(not_empty coth)
    return coth.Txt_Phrs;
  end if;
end if;
return "";',
	1,
	'',
	10047);
INSERT INTO O_TPARM
	VALUES (10053,
	10038,
	'at',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10043,
	10001,
	'get_name',
	'',
	322,
	1,
	'if(self.isFormal)
  select one assoc related by self->R_REL[R1128];
  if(not_empty assoc)
    return assoc.get_name();
  end if;
else
  if(self.Numb != "")
    return "R" + self.Numb;
  end if;
end if;
return "";',
	1,
	'',
	10037);
INSERT INTO O_TFR
	VALUES (10052,
	10001,
	'toggleVisibility',
	'',
	19,
	1,
	'/**
 *  This operation will toggle the visibility of
 *  the link on one the side given.
 */
if(param.end == End::Start)
  if(self.StartVisibility == Visibility::Private)
    self.StartVisibility = Visibility::Public;
  else
    self.StartVisibility = Visibility::Private;
  end if;
elif(param.end == End::End)
  if(self.EndVisibility == Visibility::Private)
    self.EndVisibility = Visibility::Public;
  else
    self.EndVisibility = Visibility::Private;
  end if;
end if;',
	1,
	'',
	10044);
INSERT INTO O_TPARM
	VALUES (10054,
	10052,
	'end',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10055,
	10001,
	'getConfigurationInheritanceElementId',
	'',
	317,
	1,
	'select one assoc related by self->R_REL[R1128];
if(not_empty assoc)
  return assoc.convertToInstance();
end if;
return self.convertToInstance();',
	1,
	'',
	10051);
INSERT INTO O_TFR
	VALUES (10056,
	10001,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'// just return this instance as an Object
return this;',
	0,
	'',
	10055);
INSERT INTO O_NBATTR
	VALUES (10057,
	10001);
INSERT INTO O_BATTR
	VALUES (10057,
	10001);
INSERT INTO O_ATTR
	VALUES (10057,
	10001,
	10058,
	'Numb',
	'Full Name: Association Number',
	'',
	'Numb',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10059,
	10001);
INSERT INTO O_BATTR
	VALUES (10059,
	10001);
INSERT INTO O_ATTR
	VALUES (10059,
	10001,
	10060,
	'StartText',
	'Full Name: Start Text Phrase',
	'',
	'StartText',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10061,
	10001);
INSERT INTO O_BATTR
	VALUES (10061,
	10001);
INSERT INTO O_ATTR
	VALUES (10061,
	10001,
	10059,
	'EndText',
	'Full Name: End Text Phrase',
	'',
	'EndText',
	0,
	322,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (10062,
	10001,
	'select one assoc related by self->R_REL[R1128];
if(not_empty assoc)
  self.isFormal = true;
else
  self.isFormal = false;
end if;',
	1);
INSERT INTO O_BATTR
	VALUES (10062,
	10001);
INSERT INTO O_ATTR
	VALUES (10062,
	10001,
	10061,
	'isFormal',
	'Full Name: Is Formal',
	'',
	'isFormal',
	0,
	316,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10063,
	10001);
INSERT INTO O_BATTR
	VALUES (10063,
	10001);
INSERT INTO O_ATTR
	VALUES (10063,
	10001,
	10062,
	'StartVisibility',
	'Full Name: Start Visibility
Description: Indicates the visibility of the start side of the link
Data Domain: 0 = not visible, 1 = visible

',
	'',
	'StartVisibility',
	0,
	2901,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10064,
	10001);
INSERT INTO O_BATTR
	VALUES (10064,
	10001);
INSERT INTO O_ATTR
	VALUES (10064,
	10001,
	10063,
	'EndVisibility',
	'Full Name: End Visibility
Description: Indicates the visibility of the end side of the link
Data Domain: 0 = Not Visible, 1 = Visible',
	'',
	'EndVisibility',
	0,
	2901,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10065,
	10001);
INSERT INTO O_BATTR
	VALUES (10065,
	10001);
INSERT INTO O_ATTR
	VALUES (10065,
	10001,
	0,
	'Link_ID',
	'',
	'',
	'Link_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10060,
	10001);
INSERT INTO O_BATTR
	VALUES (10060,
	10001);
INSERT INTO O_ATTR
	VALUES (10060,
	10001,
	10057,
	'Descrip',
	'Full Name: Link Description
Description: A textual description of this communication link.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (10001,
	703,
	0,
	743,
	10004,
	10006,
	10005,
	10066,
	10067,
	0,
	0,
	'',
	'Interaction Participant',
	'Part_ID',
	'R1133');
INSERT INTO O_RATTR
	VALUES (10066,
	10001,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (10066,
	10001,
	10064,
	'Start_Part_ID',
	'',
	'Start_',
	'Part_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10001,
	703,
	0,
	743,
	10007,
	10009,
	10008,
	10068,
	10069,
	0,
	0,
	'',
	'Interaction Participant',
	'Part_ID',
	'R1134');
INSERT INTO O_RATTR
	VALUES (10068,
	10001,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (10068,
	10001,
	10066,
	'Destination_Part_ID',
	'',
	'Destination_',
	'Part_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10001,
	2322,
	0,
	2368,
	10000,
	10002,
	10003,
	10058,
	10070,
	0,
	0,
	'',
	'Association',
	'Rel_ID',
	'R1128');
INSERT INTO O_RATTR
	VALUES (10058,
	10001,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (10058,
	10001,
	10065,
	'Rel_ID',
	'',
	'',
	'Rel_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10001);
INSERT INTO O_OIDA
	VALUES (10065,
	10001,
	0,
	'Link_ID');
INSERT INTO O_ID
	VALUES (1,
	10001);
INSERT INTO O_ID
	VALUES (2,
	10001);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (9982,
	'Communication in Communication',
	1127,
	'COMM_CIC',
	'',
	9971);
INSERT INTO O_REF
	VALUES (9982,
	6800,
	0,
	9987,
	9985,
	9988,
	9986,
	9984,
	10071,
	0,
	0,
	'',
	'Communication',
	'Package_ID',
	'R1130');
INSERT INTO O_RATTR
	VALUES (9984,
	9982,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (9984,
	9982,
	0,
	'Package_ID',
	'',
	'',
	'Package_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	9982);
INSERT INTO O_OIDA
	VALUES (9984,
	9982,
	0,
	'Package_ID');
INSERT INTO O_ID
	VALUES (1,
	9982);
INSERT INTO O_ID
	VALUES (2,
	9982);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (6800,
	'Communication',
	1125,
	'COMM_COMM',
	'',
	9971);
INSERT INTO O_TFR
	VALUES (10072,
	6800,
	'newClassInstance',
	'',
	19,
	1,
	'create object instance cip of SQ_CIP;
create object instance part of SQ_P;
create object instance pic of COMM_PIC;
relate cip to part across R930;
relate part to self across R1126 using pic;
cip.initialize();',
	1,
	'',
	10073);
INSERT INTO O_TFR
	VALUES (10074,
	6800,
	'newClassParticipant',
	'',
	19,
	1,
	'create object instance iClass of SQ_CP;
create object instance part of SQ_P;
create object instance pic of COMM_PIC;
relate iClass to part across R930;
relate part to self across R1126 using pic;
iClass.initialize();',
	1,
	'',
	10072);
INSERT INTO O_TFR
	VALUES (10075,
	6800,
	'newExternalEntityParticipant',
	'',
	19,
	1,
	'create object instance participant of SQ_P;
create object instance eep of SQ_EEP;
create object instance pic of COMM_PIC;
relate participant to eep across R930;
relate participant to self across R1126 using pic;
eep.initialize();',
	1,
	'',
	10076);
INSERT INTO O_TFR
	VALUES (10077,
	6800,
	'newFunctionPackageParticipant',
	'',
	19,
	1,
	'create object instance participant of SQ_P;
create object instance fpp of SQ_FPP;
create object instance pic of COMM_PIC;
relate participant to fpp across R930;
relate participant to self across R1126 using pic;
fpp.initialize();',
	1,
	'',
	10075);
INSERT INTO O_TFR
	VALUES (10078,
	6800,
	'newLink',
	'',
	316,
	1,
	'select any fromParticipant from instances of SQ_P where (selected.Part_ID == param.from);
select any toParticipant from instances of SQ_P where (selected.Part_ID == param.to);
// it only matters that there is a toParticipant
if(not_empty toParticipant) and (not_empty fromParticipant)
  create object instance link of COMM_LNK;
  relate link to toParticipant across R1134;
  relate link to fromParticipant across R1133;
  link.initialize();
  return true;
end if;
return false;',
	1,
	'',
	10077);
INSERT INTO O_TPARM
	VALUES (10079,
	10078,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (10080,
	10078,
	'to',
	296,
	0,
	'',
	10081,
	'');
INSERT INTO O_TPARM
	VALUES (10081,
	10078,
	'fromIsImported',
	316,
	0,
	'',
	10079,
	'');
INSERT INTO O_TPARM
	VALUES (10082,
	10078,
	'toIsImported',
	316,
	0,
	'',
	10080,
	'');
INSERT INTO O_TFR
	VALUES (10083,
	6800,
	'newActor',
	'',
	19,
	1,
	'create object instance actor of SQ_AP;
create object instance participant of SQ_P;
create object instance pic of COMM_PIC;
relate actor to participant across R930;
relate participant to self across R1126 using pic;
actor.initialize();',
	1,
	'',
	10084);
INSERT INTO O_TFR
	VALUES (10085,
	6800,
	'newSyncMessage',
	'',
	316,
	1,
	'// only create the message if it does not connect
// to anything
select any toPart from instances of SQ_P where (selected.Part_ID == param.to);
select any fromPart from instances of SQ_P where (selected.Part_ID == param.from);
if(empty toPart and empty fromPart)
  create object instance message of MSG_M;
  create object instance sm of MSG_SM;
  create object instance mic of COMM_MIC;
  relate message to sm across R1018;
  relate message to self across R1135 using mic;
  sm.initialize();
  return true;
else
  return false;
end if;',
	1,
	'',
	10086);
INSERT INTO O_TPARM
	VALUES (10087,
	10085,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (10088,
	10085,
	'to',
	296,
	0,
	'',
	10089,
	'');
INSERT INTO O_TPARM
	VALUES (10089,
	10085,
	'fromIsImported',
	316,
	0,
	'',
	10087,
	'');
INSERT INTO O_TPARM
	VALUES (10090,
	10085,
	'toIsImported',
	316,
	0,
	'',
	10088,
	'');
INSERT INTO O_TFR
	VALUES (10073,
	6800,
	'newAsyncMessage',
	'',
	316,
	1,
	'// only create the message if it does not connect
// to anything
select any toPart from instances of SQ_P where (selected.Part_ID == param.to);
select any fromPart from instances of SQ_P where (selected.Part_ID == param.from);
if(empty toPart and empty fromPart)
  create object instance message of MSG_M;
  create object instance am of MSG_AM;
  create object instance mic of COMM_MIC;
  relate message to am across R1018;
  relate message to self across R1135 using mic;
  am.initialize();
  return true;
else
  return false;
end if;',
	1,
	'',
	10083);
INSERT INTO O_TPARM
	VALUES (10091,
	10073,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (10092,
	10073,
	'to',
	296,
	0,
	'',
	10093,
	'');
INSERT INTO O_TPARM
	VALUES (10093,
	10073,
	'fromIsImported',
	316,
	0,
	'',
	10091,
	'');
INSERT INTO O_TPARM
	VALUES (10094,
	10073,
	'toIsImported',
	316,
	0,
	'',
	10092,
	'');
INSERT INTO O_TFR
	VALUES (10086,
	6800,
	'newReturnMessage',
	'',
	316,
	1,
	'// only create the message if it does not connect
// to anything
select any toPart from instances of SQ_P where (selected.Part_ID == param.to);
select any fromPart from instances of SQ_P where (selected.Part_ID == param.from);
if(empty toPart and empty fromPart)
  create object instance message of MSG_M;
  create object instance rm of MSG_R;
  create object instance mic of COMM_MIC;
  relate message to rm across R1018;
  relate message to self across R1135 using mic;
  rm.initialize();
  return true;
else
  return false;
end if;',
	1,
	'',
	10078);
INSERT INTO O_TPARM
	VALUES (10095,
	10086,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (10096,
	10086,
	'to',
	296,
	0,
	'',
	10097,
	'');
INSERT INTO O_TPARM
	VALUES (10097,
	10086,
	'fromIsImported',
	316,
	0,
	'',
	10095,
	'');
INSERT INTO O_TPARM
	VALUES (10098,
	10086,
	'toIsImported',
	316,
	0,
	'',
	10096,
	'');
INSERT INTO O_TFR
	VALUES (10099,
	6800,
	'newCommunication',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one commInComm related by self->COMM_CIC[R1130];
if(empty commInComm)
  create object instance commInComm of COMM_CIC;
  relate commInComm to self across R1130;
end if;
create object instance comm of COMM_COMM;
create object instance sp of EP_SPKG;
relate sp to comm across R1402;
relate commInComm to comm across R1129;
comm.initialize();',
	1,
	'',
	10074);
INSERT INTO O_TFR
	VALUES (10084,
	6800,
	'initialize',
	'',
	19,
	1,
	'self.Name = ::getUniqueInitialName( 
    instance: self.convertToInstance(), 
    candidateName: "Unnamed Communication" );',
	1,
	'',
	10100);
INSERT INTO O_TFR
	VALUES (10101,
	6800,
	'dispose',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one dom related by self->S_DOM[R1132];
select one ss related by self->S_SS[R1131];
select one system related by self->S_SYS[R1136];
select one compPackage related by self->CP_CP[R1137];
select one comp related by self->C_C[R1138];
if(not_empty system)
  unrelate self from system across R1136;
end if;
if(not_empty compPackage)
  unrelate self from compPackage across R1137;
end if;
if(not_empty comp)
  unrelate self from comp across R1138;
end if;
if(not_empty dom)
  unrelate self from dom across R1132;
end if;
if(not_empty ss)
  unrelate self from ss across R1131;
end if;

// unrelate from parent
select one cic related by self->COMM_CIC[R1129];
if(not_empty cic)
  unrelate self from cic across R1129;
  // are there any other children?
  select any other_child related by cic->COMM_COMM[R1129];
  if empty other_child
    // no, dispose the communication in communication placeholder
    select one parent related by cic->COMM_COMM[R1130];
    if(not_empty parent)
      unrelate cic from parent across R1130;
    end if;
    delete object instance cic;
  end if;
end if;

// delete child comm diagrams
select one cic related by self->COMM_CIC[R1130];
select many comms related by cic->COMM_COMM[R1129];
for each comm in comms
  comm.dispose();
end for;
// last child will delete the cic instance

select many pics related by self->COMM_PIC[R1126];
for each pic in pics
  select one participant related by pic->SQ_P[R1126];
  if (not_empty participant)
    unrelate self from participant across R1126 using pic;
    participant.dispose();
  end if;
end for;
select many mics related by self->COMM_MIC[R1135];
for each mic in mics
  select one message related by mic->MSG_M[R1135];
  if (not_empty message)
    unrelate self from message across R1135 using mic;
    message.dispose();
  end if;
end for;

select one specPkg related by self->EP_SPKG[R1402];



if(not_empty specPkg)
  unrelate self from specPkg across R1402;
  specPkg.dispose();
end if;
delete object instance self;',
	1,
	'',
	10102);
INSERT INTO O_TFR
	VALUES (10103,
	6800,
	'get_compartments',
	'',
	298,
	1,
	'// The communication package symbol only contains its name
return 1;',
	1,
	'',
	10104);
INSERT INTO O_TFR
	VALUES (10105,
	6800,
	'get_entries',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	10103);
INSERT INTO O_TPARM
	VALUES (10106,
	10105,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10100,
	6800,
	'get_text_style',
	'',
	784,
	1,
	'return Style::None;',
	1,
	'',
	10107);
INSERT INTO O_TPARM
	VALUES (10108,
	10100,
	'comp_num',
	298,
	0,
	'',
	10109,
	'');
INSERT INTO O_TPARM
	VALUES (10110,
	10100,
	'ent_num',
	298,
	0,
	'',
	10108,
	'');
INSERT INTO O_TPARM
	VALUES (10109,
	10100,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10104,
	6800,
	'get_compartment_text',
	'',
	322,
	1,
	'// The communication package symbol only contains its name
// appended by the communication stereotype
result = "";
if (param.at == Justification::Center_in_X)
  result = "communication";
elif (param.at == Justification::Center)
  result = self.Name;
end if;
return result;',
	1,
	'',
	10111);
INSERT INTO O_TPARM
	VALUES (10112,
	10104,
	'comp_num',
	298,
	0,
	'',
	10113,
	'');
INSERT INTO O_TPARM
	VALUES (10114,
	10104,
	'ent_num',
	298,
	0,
	'',
	10112,
	'');
INSERT INTO O_TPARM
	VALUES (10113,
	10104,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10107,
	6800,
	'get_style',
	'',
	784,
	1,
	'return Style::Folder;',
	1,
	'',
	10115);
INSERT INTO O_TFR
	VALUES (10115,
	6800,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Package_ID;',
	1,
	'',
	10105);
INSERT INTO O_TFR
	VALUES (10111,
	6800,
	'getPath',
	'',
	322,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one domain related by self->S_DOM[R1132];
domainName = "";
result = self.Name;
if(empty domain)
  select one ss related by self->S_SS[R1131];
  if (not_empty ss)
    select one domain related by ss->S_DOM[R1];
    // check subsystems
    if(not_empty ss and (not_empty domain))
      result = ss.getPath(path:"") + "::" + result;
      domainName = domain.Name;
    end if;
  end if;
    // check communications in communications
    if(empty ss)
      select one cic related by self->COMM_CIC[R1129]->COMM_COMM[R1130];
      while (not_empty cic)
        result = cic.Name + "::" + result;
        prev = cic;
        select one cic related by cic->COMM_CIC[R1129]->COMM_COMM[R1130];
        if(empty cic)
          if(param.domainNameOnly)
            return prev.getPath(domainNameOnly:true);
          else
            result = prev.getPath(domainNameOnly:param.domainNameOnly) + result;
          end if;
        end if;
      end while;
    end if;
else
  domainName = domain.Name;
  result = domainName + "::" + result;
end if;
if(param.domainNameOnly and (not_empty domain))
  return domain.Name;
else
  return result;
end if;',
	1,
	'',
	10101);
INSERT INTO O_TPARM
	VALUES (10116,
	10111,
	'domainNameOnly',
	316,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10117,
	6800,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'// just return this instance as an Object
return this;',
	0,
	'',
	10118);
INSERT INTO O_TFR
	VALUES (10076,
	6800,
	'newComponentParticipant',
	'',
	19,
	1,
	'create object instance component of SQ_COP;
create object instance part of SQ_P;
create object instance pic of COMM_PIC;
relate component to part across R930;
relate part to self across R1126 using pic;
component.initialize();',
	1,
	'',
	10099);
INSERT INTO O_TFR
	VALUES (10119,
	6800,
	'associateWithPackage',
	'',
	19,
	1,
	'// unhook from current parent
self.deassociateFromParent();
// hook up with package
select any package from instances of EP_PKG
                                     where (selected.Package_ID == param.pkgID);
select one specPkg related by self->EP_SPKG[R1402];
relate specPkg to package across R1400;',
	1,
	'',
	10120);
INSERT INTO O_TPARM
	VALUES (10121,
	10119,
	'pkgID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10102,
	6800,
	'deassociateFromParent',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one system related by self->S_SYS[R1136];
if(not_empty system)
  unrelate self from system across R1136;
end if;
select one domain related by self->S_DOM[R1132];
if(not_empty domain)
  unrelate self from domain across R1132;
end if;
select one subsystem related by self->S_SS[R1131];
if(not_empty subsystem)
  unrelate self from subsystem across R1131;
end if;
select one cp related by self->CP_CP[R1137];
if(not_empty cp)
  unrelate self from cp across R1137;
end if;
select one comp related by self->C_C[R1138];
if(not_empty comp)
  unrelate self from comp across R1138;
end if;
select one specPkg related by self->EP_SPKG[R1402];
select one package related by specPkg->EP_PKG[R1400];
if(not_empty package)
  unrelate specPkg from package across R1400;
end if;
select one cic related by self->COMM_CIC[R1129];
if(not_empty cic)
  select one comm related by cic->COMM_COMM[R1130];
  unrelate cic from self across R1129;
  select many otherComms related by cic->COMM_COMM[R1129];
  if(empty otherComms)
    unrelate cic from comm across R1130;
    delete object instance cic;
  end if;
end if;',
	1,
	'',
	10117);
INSERT INTO O_TFR
	VALUES (10122,
	6800,
	'associateWithCommunication',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// unhook from current parent
self.deassociateFromParent();
// hook up with communication
select any comm from instances of COMM_COMM
                                     where (selected.Package_ID == param.commID);
select one cic related by comm->COMM_CIC[R1130];
if(empty cic)
  create object instance cic of COMM_CIC;
  relate comm to cic across R1130;
end if;
relate self to cic across R1129;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (10123,
	10122,
	'commID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10124,
	6800,
	'pasteCommunication',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any comm from instances of COMM_COMM
                                        where (selected.Package_ID == param.id);
if(not_empty comm)
  // guarantee a unique name for the pasted element
  comm.Name = ::getUniqueInitialNameInParent (instance:comm.convertToInstance(),
     					   name:comm.Name, parent:self.convertToInstance());
  comm.associateWithCommunication(commID:self.Package_ID);
end if;',
	1,
	'',
	10085);
INSERT INTO O_TPARM
	VALUES (10125,
	10124,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10118,
	6800,
	'associateWithSystem',
	'',
	19,
	1,
	'// unhook from current parent
self.deassociateFromParent();
// hook up with system
select any system from instances of S_SYS
                                         where (selected.Sys_ID == param.sysID);
relate system to self across R1136;',
	1,
	'',
	10126);
INSERT INTO O_TPARM
	VALUES (10127,
	10118,
	'sysID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10128,
	6800,
	'associateWithComponent',
	'',
	19,
	1,
	'// unhook from current parent
self.deassociateFromParent();
// hook up with component
select any component from instances of C_C
                                    where (selected.Id == param.compID);
relate self to component across R1138;',
	1,
	'',
	10122);
INSERT INTO O_TPARM
	VALUES (10129,
	10128,
	'compID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10130,
	6800,
	'associateWithComponentPackage',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// unhook from current parent
self.deassociateFromParent();
// hook up with component package
select any cp from instances of CP_CP where (selected.Package_ID == param.cpID);
relate cp to self across R1137;',
	1,
	'',
	10128);
INSERT INTO O_TPARM
	VALUES (10131,
	10130,
	'cpID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10120,
	6800,
	'associateWithDomain',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// unhook from current parent
self.deassociateFromParent();
// hook up with domain
select any domain from instances of S_DOM
                                         where (selected.Dom_ID == param.domID);
relate domain to self across R1132;',
	1,
	'',
	10130);
INSERT INTO O_TPARM
	VALUES (10132,
	10120,
	'domID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10126,
	6800,
	'associateWithSubsystem',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// unhook from current parent
self.deassociateFromParent();
// hook up with domain
select any ss from instances of S_SS where (selected.SS_ID == param.ssID);
relate ss to self across R1131;',
	1,
	'',
	10119);
INSERT INTO O_TPARM
	VALUES (10133,
	10126,
	'ssID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10134,
	6800,
	'getCommunicationCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many communications related by self->COMM_CIC[R1130]->COMM_COMM[R1129];
return cardinality communications;',
	1,
	'',
	10124);
INSERT INTO O_TFR
	VALUES (10135,
	6800,
	'getCommunicationId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many communications related by self->COMM_CIC[R1130]->COMM_COMM[R1129];
// We''re preincrementing the index
count = -1;
for each communication in communications
  if (not_empty communication)
      count = count+1;
  end if;
  
  if (count == param.index)
      return communication.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	10134);
INSERT INTO O_TPARM
	VALUES (10136,
	10135,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10137,
	6800,
	'getComponentCount',
	'',
	298,
	1,
	'select many components related by self->SQ_P[R1126]->SQ_COP[R930];
return cardinality components;',
	1,
	'',
	10135);
INSERT INTO O_TFR
	VALUES (10138,
	6800,
	'getComponentId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many components related by self->SQ_P[R1126]->SQ_COP[R930];
// We''re preincrementing the index
count = -1;
for each component in components
  if (not_empty component)
      count = count+1;
  end if;
  
  if (count == param.index)
      return component.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	10137);
INSERT INTO O_TPARM
	VALUES (10139,
	10138,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10140,
	6800,
	'getInstanceCount',
	'',
	298,
	1,
	'select many classInstances related by self->SQ_P[R1126]->SQ_CIP[R930];
return cardinality classInstances;',
	1,
	'',
	10138);
INSERT INTO O_TFR
	VALUES (10141,
	6800,
	'getInstanceId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many classInstances related by self->SQ_P[R1126]->SQ_CIP[R930];
// We''re preincrementing the index
count = -1;
for each classInstance in classInstances
  if (not_empty classInstance)
      count = count+1;
  end if;
  
  if (count == param.index)
      return classInstance.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	10140);
INSERT INTO O_TPARM
	VALUES (10142,
	10141,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10143,
	6800,
	'getActorCount',
	'',
	298,
	1,
	'select many actors related by self->SQ_P[R1126]->SQ_AP[R930];
return cardinality actors;',
	1,
	'',
	10141);
INSERT INTO O_TFR
	VALUES (10144,
	6800,
	'getActorId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many actors related by self->SQ_P[R1126]->SQ_AP[R930];
// We''re preincrementing the index
count = -1;
for each actor in actors
  if (not_empty actor)
      count = count+1;
  end if;
  
  if (count == param.index)
      return actor.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	10143);
INSERT INTO O_TPARM
	VALUES (10145,
	10144,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10146,
	6800,
	'getExternalEntityCount',
	'',
	298,
	1,
	'select many externalEntities related by self->SQ_P[R1126]->SQ_EEP[R930];
return cardinality externalEntities;',
	1,
	'',
	10144);
INSERT INTO O_TFR
	VALUES (10147,
	6800,
	'getExternalEntityId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many externalEntities related by self->SQ_P[R1126]->SQ_EEP[R930];
// We''re preincrementing the index
count = -1;
for each externalEntity in externalEntities
  if (not_empty externalEntity)
      count = count+1;
  end if;
  
  if (count == param.index)
      return externalEntity.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	10146);
INSERT INTO O_TPARM
	VALUES (10148,
	10147,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10149,
	6800,
	'getClassCount',
	'',
	298,
	1,
	'select many classes related by self->SQ_P[R1126]->SQ_CP[R930];
return cardinality classes;',
	1,
	'',
	10147);
INSERT INTO O_TFR
	VALUES (10150,
	6800,
	'getClassId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many classes related by self->SQ_P[R1126]->SQ_CP[R930];
// We''re preincrementing the index
count = -1;
for each classParticipant in classes
  if (not_empty classParticipant)
      count = count+1;
  end if;
  
  if (count == param.index)
      return classParticipant.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	10149);
INSERT INTO O_TPARM
	VALUES (10151,
	10150,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10152,
	6800,
	'getFunctionPckgCount',
	'',
	298,
	1,
	'select many functionsPckgs related by self->SQ_P[R1126]->SQ_FPP[R930];
return cardinality functionsPckgs;',
	1,
	'',
	10150);
INSERT INTO O_TFR
	VALUES (10153,
	6800,
	'getFunctionPckgId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many functionsPckgs related by self->SQ_P[R1126]->SQ_FPP[R930];
// We''re preincrementing the index
count = -1;
for each functionsPckg in functionsPckgs
  if (not_empty functionsPckg)
      count = count+1;
  end if;
  
  if (count == param.index)
      return functionsPckg.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	10152);
INSERT INTO O_TPARM
	VALUES (10154,
	10153,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10155,
	6800,
	'getSystemId',
	'',
	296,
	1,
	'// Communication.getSystemId()
select one system related by self->S_SYS[R1136];
if not_empty system
  return system.Sys_ID;
end if;
select one compPkg related by self->CP_CP[R1137];
if not_empty compPkg
  return compPkg.getSystemId();
end if;
select one component related by self->C_C[R1138];
if not_empty compPkg
  return component.getSystemId();
end if;
select one parentComm related by self->COMM_CIC[R1129]->COMM_COMM[R1130];
if not_empty parentComm
  return parentComm.getSystemId();
end if;
select one domain related by self->S_DOM[R1132];
if not_empty domain
  return domain.getSystemId();
end if;
select one subsystem related by self->S_SS[R1131];
if not_empty subsystem
  return subsystem.getSystemId();
end if;
USER::logError(msg:"getSystemId()::No parent found for sequence",path:"");
return GD::NULL_UNIQUE_ID();',
	1,
	'',
	10153);
INSERT INTO O_TFR
	VALUES (10156,
	6800,
	'pasteActorParticipant',
	'',
	19,
	1,
	'select any actor from instances of SQ_AP
                                           where (selected.Part_ID == param.id);
if(not_empty actor)
  select one part related by actor->SQ_P[R930];
  create object instance pic of COMM_PIC;
  relate part to self across R1126 using pic;
end if;',
	1,
	'',
	10155);
INSERT INTO O_TPARM
	VALUES (10157,
	10156,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10158,
	6800,
	'pasteClassParticipant',
	'',
	19,
	1,
	'select any cp from instances of SQ_CP where (selected.Part_ID == param.id);
if(not_empty cp)
  select one part related by cp->SQ_P[R930];
  create object instance pic of COMM_PIC;
  relate part to self across R1126 using pic;
end if;',
	1,
	'',
	10156);
INSERT INTO O_TPARM
	VALUES (10159,
	10158,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10160,
	6800,
	'pasteClassInstanceParticipant',
	'',
	19,
	1,
	'select any cip from instances of SQ_CIP where (selected.Part_ID == param.id);
if(not_empty cip)
  select one part related by cip->SQ_P[R930];
  create object instance pic of COMM_PIC;
  relate part to self across R1126 using pic;
end if;',
	1,
	'',
	10158);
INSERT INTO O_TPARM
	VALUES (10161,
	10160,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10162,
	6800,
	'pasteExternalEntityParticipant',
	'',
	19,
	1,
	'select any eep from instances of SQ_EEP where (selected.Part_ID == param.id);
if(not_empty eep)
  select one part related by eep->SQ_P[R930];
  create object instance pic of COMM_PIC;
  relate part to self across R1126 using pic;
end if;',
	1,
	'',
	10160);
INSERT INTO O_TPARM
	VALUES (10163,
	10162,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10164,
	6800,
	'pasteComponentParticipant',
	'',
	19,
	1,
	'select any comp from instances of SQ_COP where (selected.Part_ID == param.id);
if(not_empty comp)
  select one part related by comp->SQ_P[R930];
  create object instance pic of COMM_PIC;
  relate part to self across R1126 using pic;
end if;',
	1,
	'',
	10162);
INSERT INTO O_TPARM
	VALUES (10165,
	10164,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10166,
	6800,
	'pasteFunctionPackageParticipant',
	'',
	19,
	1,
	'select any fpp from instances of SQ_FPP where (selected.Part_ID == param.id);
if(not_empty fpp)
  select one part related by fpp->SQ_P[R930];
  create object instance pic of COMM_PIC;
  relate part to self across R1126 using pic;
end if;',
	1,
	'',
	10164);
INSERT INTO O_TPARM
	VALUES (10167,
	10166,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10168,
	6800,
	'pasteSynchronousMessage',
	'',
	19,
	1,
	'select any sync from instances of MSG_SM where (selected.Msg_ID == param.id);
if(not_empty sync)
  select one message related by sync->MSG_M[R1018];
  select one destPart related by message->SQ_P[R1007];
  if(empty destPart)
    // this is the only time the source will need
    // to be hooked up
    create object instance mic of COMM_MIC;
    relate self to message across R1135 using mic;
  end if;
end if;',
	1,
	'',
	10166);
INSERT INTO O_TPARM
	VALUES (10169,
	10168,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10170,
	6800,
	'pasteAsynchronousMessage',
	'',
	19,
	1,
	'select any async from instances of MSG_AM where (selected.Msg_ID == param.id);
if(not_empty async)
  select one message related by async->MSG_M[R1018];
  select one destPart related by message->SQ_P[R1007];
  if(empty destPart)
    // this is the only time the source will need
    // to be hooked up
    create object instance mic of COMM_MIC;
    relate self to message across R1135 using mic;
  end if;
end if;',
	1,
	'',
	10168);
INSERT INTO O_TPARM
	VALUES (10171,
	10170,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10172,
	6800,
	'pasteReturnMessage',
	'',
	19,
	1,
	'select any rm from instances of MSG_SM where (selected.Msg_ID == param.id);
if(not_empty rm)
  select one message related by rm->MSG_M[R1018];
  create object instance mic of COMM_MIC;
  relate self to message across R1135 using mic;
end if;',
	1,
	'',
	10170);
INSERT INTO O_TPARM
	VALUES (10173,
	10172,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10174,
	6800,
	'pasteCommunicationLink',
	'',
	19,
	1,
	'// this method does not need to do anything, just exist
// so that the menu is enabled',
	1,
	'',
	10172);
INSERT INTO O_TPARM
	VALUES (10175,
	10174,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_NBATTR
	VALUES (10176,
	6800);
INSERT INTO O_BATTR
	VALUES (10176,
	6800);
INSERT INTO O_ATTR
	VALUES (10176,
	6800,
	10177,
	'Name',
	'Full Name: Communication Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10178,
	6800);
INSERT INTO O_BATTR
	VALUES (10178,
	6800);
INSERT INTO O_ATTR
	VALUES (10178,
	6800,
	10176,
	'Descrip',
	'Full Name: Communication Description
Description: A textual description of this communication.',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (6800,
	699,
	0,
	712,
	9989,
	9991,
	9990,
	10179,
	10180,
	0,
	0,
	'',
	'Domain',
	'Dom_ID',
	'R1132');
INSERT INTO O_RATTR
	VALUES (10179,
	6800,
	712,
	699,
	1,
	'Dom_ID');
INSERT INTO O_ATTR
	VALUES (10179,
	6800,
	9987,
	'Dom_ID',
	'',
	'',
	'Dom_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (6800,
	701,
	0,
	717,
	9997,
	9999,
	9998,
	10181,
	10182,
	0,
	0,
	'',
	'Subsystem',
	'SS_ID',
	'R1131');
INSERT INTO O_RATTR
	VALUES (10181,
	6800,
	717,
	701,
	1,
	'SS_ID');
INSERT INTO O_ATTR
	VALUES (10181,
	6800,
	10179,
	'SS_ID',
	'',
	'',
	'SS_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (6800,
	705,
	0,
	754,
	10015,
	10017,
	10016,
	10183,
	10184,
	0,
	0,
	'',
	'System Model',
	'Sys_ID',
	'R1136');
INSERT INTO O_RATTR
	VALUES (10183,
	6800,
	754,
	705,
	1,
	'Sys_ID');
INSERT INTO O_ATTR
	VALUES (10183,
	6800,
	10178,
	'Sys_ID',
	'',
	'',
	'Sys_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (6800,
	773,
	0,
	772,
	854,
	6807,
	856,
	9987,
	10185,
	0,
	0,
	'',
	'Specification Package',
	'Package_ID',
	'R1402');
INSERT INTO O_RATTR
	VALUES (9987,
	6800,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (9987,
	6800,
	0,
	'Package_ID',
	'',
	'',
	'SpecificationPackage_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (6800,
	707,
	0,
	758,
	10018,
	10020,
	10019,
	10186,
	10187,
	0,
	0,
	'',
	'Component Package',
	'Package_ID',
	'R1137');
INSERT INTO O_RATTR
	VALUES (10186,
	6800,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (10186,
	6800,
	10183,
	'Component_Package_ID',
	'',
	'Component_',
	'Package_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (6800,
	9982,
	0,
	9984,
	9980,
	9981,
	9983,
	10177,
	10188,
	0,
	0,
	'',
	'Communication in Communication',
	'Package_ID',
	'R1129');
INSERT INTO O_RATTR
	VALUES (10177,
	6800,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (10177,
	6800,
	10181,
	'CIC_Package_ID',
	'',
	'CIC_',
	'Package_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (6800,
	709,
	0,
	762,
	10021,
	10023,
	10022,
	10189,
	10190,
	0,
	0,
	'',
	'Component',
	'Id',
	'R1138');
INSERT INTO O_RATTR
	VALUES (10189,
	6800,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (10189,
	6800,
	10186,
	'Component_Id',
	'',
	'Component_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	6800);
INSERT INTO O_OIDA
	VALUES (9987,
	6800,
	0,
	'Package_ID');
INSERT INTO O_ID
	VALUES (1,
	6800);
INSERT INTO O_ID
	VALUES (2,
	6800);
-- BP 7.1 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (10191,
	'Body',
	'This subsystem abstracts the action itself, the blocks and statements
it contains together with the flow of control statements such as ''while'',
''for each'' and ''if''.
Notify_Changes:false
Persistent:false
// This is used by schema_gen to ignore this subsystem (for publication)
TRANSLATE_FOR_EXTERNAL_USE:FALSE
',
	'ACT',
	600,
	1,
	10192);
INSERT INTO S_SID
	VALUES (1,
	10191);
INSERT INTO O_IOBJ
	VALUES (10193,
	30,
	5,
	10191,
	'Model Class',
	'O_OBJ');
INSERT INTO O_IOBJ
	VALUES (10194,
	8,
	5,
	10191,
	'Function',
	'S_SYNC');
INSERT INTO O_IOBJ
	VALUES (10195,
	43,
	5,
	10191,
	'Operation',
	'O_TFR');
INSERT INTO O_IOBJ
	VALUES (10196,
	6,
	5,
	10191,
	'Bridge',
	'S_BRG');
INSERT INTO O_IOBJ
	VALUES (10197,
	1559,
	5,
	10191,
	'Action',
	'SM_ACT');
INSERT INTO O_IOBJ
	VALUES (10198,
	1023,
	5,
	10191,
	'Derived Base Attribute',
	'O_DBATTR');
INSERT INTO O_IOBJ
	VALUES (10199,
	655,
	5,
	10191,
	'Bridge Invocation',
	'ACT_BRG');
INSERT INTO O_IOBJ
	VALUES (10200,
	661,
	5,
	10191,
	'Function Invocation',
	'ACT_FNC');
INSERT INTO O_IOBJ
	VALUES (10201,
	3310,
	5,
	10191,
	'Return Stmt',
	'ACT_RET');
INSERT INTO O_IOBJ
	VALUES (10202,
	648,
	5,
	10191,
	'Operation Invocation',
	'ACT_TFM');
INSERT INTO O_IOBJ
	VALUES (10203,
	4019,
	5,
	10191,
	'Create',
	'ACT_CR');
INSERT INTO O_IOBJ
	VALUES (10204,
	4031,
	5,
	10191,
	'Create No Variable',
	'ACT_CNV');
INSERT INTO O_IOBJ
	VALUES (10205,
	4023,
	5,
	10191,
	'Delete',
	'ACT_DEL');
INSERT INTO O_IOBJ
	VALUES (10206,
	2332,
	5,
	10191,
	'Select',
	'ACT_SEL');
INSERT INTO O_IOBJ
	VALUES (10207,
	2350,
	5,
	10191,
	'Select From Instances',
	'ACT_FIO');
INSERT INTO O_IOBJ
	VALUES (10208,
	2340,
	5,
	10191,
	'Select From Instances Where',
	'ACT_FIW');
INSERT INTO O_IOBJ
	VALUES (10209,
	2643,
	5,
	10191,
	'Relate',
	'ACT_REL');
INSERT INTO O_IOBJ
	VALUES (10210,
	2650,
	5,
	10191,
	'Relate Using',
	'ACT_RU');
INSERT INTO O_IOBJ
	VALUES (10211,
	2660,
	5,
	10191,
	'Unrelate',
	'ACT_UNR');
INSERT INTO O_IOBJ
	VALUES (10212,
	2667,
	5,
	10191,
	'Unrelate Using',
	'ACT_URU');
INSERT INTO O_IOBJ
	VALUES (10213,
	4015,
	5,
	10191,
	'Assign to Member',
	'ACT_AI');
INSERT INTO O_IOBJ
	VALUES (10214,
	129,
	5,
	10191,
	'Variable',
	'V_VAR');
INSERT INTO O_IOBJ
	VALUES (10215,
	70,
	5,
	10191,
	'Value',
	'V_VAL');
INSERT INTO O_IOBJ
	VALUES (10216,
	667,
	5,
	10191,
	'Event Specification Statement',
	'E_ESS');
INSERT INTO O_IOBJ
	VALUES (10217,
	6687,
	5,
	10191,
	'Generate Preexisting Event',
	'E_GPR');
INSERT INTO O_IOBJ
	VALUES (10218,
	3306,
	0,
	10191,
	'Provided Operation',
	'SPR_PO');
INSERT INTO O_IOBJ
	VALUES (10219,
	1483,
	0,
	10191,
	'Provided Signal',
	'SPR_PS');
INSERT INTO O_IOBJ
	VALUES (10220,
	3308,
	0,
	10191,
	'Required Operation',
	'SPR_RO');
INSERT INTO O_IOBJ
	VALUES (10221,
	1485,
	0,
	10191,
	'Required Signal',
	'SPR_RS');
INSERT INTO O_IOBJ
	VALUES (10222,
	679,
	0,
	10191,
	'Signal Invocation',
	'ACT_SGN');
INSERT INTO O_IOBJ
	VALUES (10223,
	673,
	0,
	10191,
	'Interface Operation Invocation',
	'ACT_IOP');
INSERT INTO O_IOBJ
	VALUES (10224,
	709,
	0,
	10191,
	'Component',
	'C_C');
INSERT INTO O_IOBJ
	VALUES (10225,
	26,
	0,
	10191,
	'Packageable Element',
	'PE_PE');
INSERT INTO R_SIMP
	VALUES (10226);
INSERT INTO R_REL
	VALUES (10226,
	666,
	'R612/R650 and R601/R666 are similar but are separate to allow parsing to be
decoupled from Verifier/Export.  As parsing occurs R612/R650 are used, however 
R601/R666 are populated only when one of the following three conditions happens:
1) Verifier is launched
2) OAL is saved after being edited
3) Model export is performed
This allows a user to make a change to the OAL while running a verifier session, 
but not have verifier "see" the change until the change is explicitly saved by
the user.',
	10191);
INSERT INTO R_FORM
	VALUES (10227,
	10226,
	10228,
	0,
	1,
	'is outer committed level of');
INSERT INTO R_RGO
	VALUES (10227,
	10226,
	10228);
INSERT INTO R_OIR
	VALUES (10227,
	10226,
	10228,
	0);
INSERT INTO R_PART
	VALUES (35,
	10226,
	10229,
	0,
	1,
	'has committed outer');
INSERT INTO O_RTIDA
	VALUES (163,
	35,
	0,
	10226,
	10229);
INSERT INTO R_RTO
	VALUES (35,
	10226,
	10229,
	0);
INSERT INTO R_OIR
	VALUES (35,
	10226,
	10229,
	0);
INSERT INTO R_SIMP
	VALUES (10230);
INSERT INTO R_REL
	VALUES (10230,
	661,
	'',
	10191);
INSERT INTO R_FORM
	VALUES (686,
	10230,
	10231,
	0,
	1,
	'precedes');
INSERT INTO R_RGO
	VALUES (686,
	10230,
	10231);
INSERT INTO R_OIR
	VALUES (686,
	10230,
	10231,
	0);
INSERT INTO R_PART
	VALUES (686,
	10230,
	10232,
	0,
	1,
	'succeeds');
INSERT INTO O_RTIDA
	VALUES (685,
	686,
	1,
	10230,
	10232);
INSERT INTO O_RTIDA
	VALUES (10233,
	686,
	1,
	10230,
	10232);
INSERT INTO R_RTO
	VALUES (686,
	10230,
	10232,
	1);
INSERT INTO R_OIR
	VALUES (686,
	10230,
	10232,
	0);
INSERT INTO R_SIMP
	VALUES (10234);
INSERT INTO R_REL
	VALUES (10234,
	658,
	'',
	10191);
INSERT INTO R_PART
	VALUES (35,
	10234,
	10235,
	0,
	0,
	'controls');
INSERT INTO O_RTIDA
	VALUES (163,
	35,
	0,
	10234,
	10235);
INSERT INTO R_RTO
	VALUES (35,
	10234,
	10235,
	0);
INSERT INTO R_OIR
	VALUES (35,
	10234,
	10235,
	0);
INSERT INTO R_FORM
	VALUES (10236,
	10234,
	10237,
	0,
	1,
	'');
INSERT INTO R_RGO
	VALUES (10236,
	10234,
	10237);
INSERT INTO R_OIR
	VALUES (10236,
	10234,
	10237,
	0);
INSERT INTO R_SIMP
	VALUES (10238);
INSERT INTO R_REL
	VALUES (10238,
	608,
	'',
	10191);
INSERT INTO R_FORM
	VALUES (10239,
	10238,
	10240,
	0,
	1,
	'');
INSERT INTO R_RGO
	VALUES (10239,
	10238,
	10240);
INSERT INTO R_OIR
	VALUES (10239,
	10238,
	10240,
	0);
INSERT INTO R_PART
	VALUES (35,
	10238,
	10241,
	0,
	0,
	'controls');
INSERT INTO O_RTIDA
	VALUES (163,
	35,
	0,
	10238,
	10241);
INSERT INTO R_RTO
	VALUES (35,
	10238,
	10241,
	0);
INSERT INTO R_OIR
	VALUES (35,
	10238,
	10241,
	0);
INSERT INTO R_SIMP
	VALUES (10242);
INSERT INTO R_REL
	VALUES (10242,
	606,
	'',
	10191);
INSERT INTO R_FORM
	VALUES (10243,
	10242,
	10244,
	0,
	1,
	'');
INSERT INTO R_RGO
	VALUES (10243,
	10242,
	10244);
INSERT INTO R_OIR
	VALUES (10243,
	10242,
	10244,
	0);
INSERT INTO R_PART
	VALUES (35,
	10242,
	10245,
	0,
	0,
	'controls');
INSERT INTO O_RTIDA
	VALUES (163,
	35,
	0,
	10242,
	10245);
INSERT INTO R_RTO
	VALUES (35,
	10242,
	10245,
	0);
INSERT INTO R_OIR
	VALUES (35,
	10242,
	10245,
	0);
INSERT INTO R_SIMP
	VALUES (10246);
INSERT INTO R_REL
	VALUES (10246,
	605,
	'',
	10191);
INSERT INTO R_FORM
	VALUES (10247,
	10246,
	10248,
	0,
	1,
	'');
INSERT INTO R_RGO
	VALUES (10247,
	10246,
	10248);
INSERT INTO R_OIR
	VALUES (10247,
	10246,
	10248,
	0);
INSERT INTO R_PART
	VALUES (35,
	10246,
	10249,
	0,
	0,
	'controls');
INSERT INTO O_RTIDA
	VALUES (163,
	35,
	0,
	10246,
	10249);
INSERT INTO R_RTO
	VALUES (35,
	10246,
	10249,
	0);
INSERT INTO R_OIR
	VALUES (35,
	10246,
	10249,
	0);
INSERT INTO R_SIMP
	VALUES (10250);
INSERT INTO R_REL
	VALUES (10250,
	607,
	'',
	10191);
INSERT INTO R_FORM
	VALUES (10251,
	10250,
	10252,
	0,
	1,
	'');
INSERT INTO R_RGO
	VALUES (10251,
	10250,
	10252);
INSERT INTO R_OIR
	VALUES (10251,
	10250,
	10252,
	0);
INSERT INTO R_PART
	VALUES (35,
	10250,
	10253,
	0,
	0,
	'controls');
INSERT INTO O_RTIDA
	VALUES (163,
	35,
	0,
	10250,
	10253);
INSERT INTO R_RTO
	VALUES (35,
	10250,
	10253,
	0);
INSERT INTO R_OIR
	VALUES (35,
	10250,
	10253,
	0);
INSERT INTO R_SIMP
	VALUES (10254);
INSERT INTO R_REL
	VALUES (10254,
	602,
	'',
	10191);
INSERT INTO R_FORM
	VALUES (686,
	10254,
	10255,
	1,
	1,
	'contained by');
INSERT INTO R_RGO
	VALUES (686,
	10254,
	10255);
INSERT INTO R_OIR
	VALUES (686,
	10254,
	10255,
	0);
INSERT INTO R_PART
	VALUES (35,
	10254,
	10256,
	0,
	0,
	'contains');
INSERT INTO O_RTIDA
	VALUES (163,
	35,
	0,
	10254,
	10256);
INSERT INTO R_RTO
	VALUES (35,
	10254,
	10256,
	0);
INSERT INTO R_OIR
	VALUES (35,
	10254,
	10256,
	0);
INSERT INTO R_SUBSUP
	VALUES (2386);
INSERT INTO R_REL
	VALUES (2386,
	603,
	'',
	10191);
INSERT INTO R_SUPER
	VALUES (686,
	2386,
	2388);
INSERT INTO O_RTIDA
	VALUES (685,
	686,
	0,
	2386,
	2388);
INSERT INTO R_RTO
	VALUES (686,
	2386,
	2388,
	0);
INSERT INTO R_OIR
	VALUES (686,
	2386,
	2388,
	0);
INSERT INTO R_SUB
	VALUES (10247,
	2386,
	10257);
INSERT INTO R_RGO
	VALUES (10247,
	2386,
	10257);
INSERT INTO R_OIR
	VALUES (10247,
	2386,
	10257,
	0);
INSERT INTO R_SUB
	VALUES (10239,
	2386,
	10258);
INSERT INTO R_RGO
	VALUES (10239,
	2386,
	10258);
INSERT INTO R_OIR
	VALUES (10239,
	2386,
	10258,
	0);
INSERT INTO R_SUB
	VALUES (10251,
	2386,
	10259);
INSERT INTO R_RGO
	VALUES (10251,
	2386,
	10259);
INSERT INTO R_OIR
	VALUES (10251,
	2386,
	10259,
	0);
INSERT INTO R_SUB
	VALUES (10236,
	2386,
	10260);
INSERT INTO R_RGO
	VALUES (10236,
	2386,
	10260);
INSERT INTO R_OIR
	VALUES (10236,
	2386,
	10260,
	0);
INSERT INTO R_SUB
	VALUES (10243,
	2386,
	10261);
INSERT INTO R_RGO
	VALUES (10243,
	2386,
	10261);
INSERT INTO R_OIR
	VALUES (10243,
	2386,
	10261,
	0);
INSERT INTO R_SUB
	VALUES (655,
	2386,
	3423);
INSERT INTO R_RGO
	VALUES (655,
	2386,
	3423);
INSERT INTO R_OIR
	VALUES (655,
	2386,
	3423,
	10199);
INSERT INTO R_SUB
	VALUES (661,
	2386,
	3411);
INSERT INTO R_RGO
	VALUES (661,
	2386,
	3411);
INSERT INTO R_OIR
	VALUES (661,
	2386,
	3411,
	10200);
INSERT INTO R_SUB
	VALUES (3310,
	2386,
	3369);
INSERT INTO R_RGO
	VALUES (3310,
	2386,
	3369);
INSERT INTO R_OIR
	VALUES (3310,
	2386,
	3369,
	10201);
INSERT INTO R_SUB
	VALUES (648,
	2386,
	3379);
INSERT INTO R_RGO
	VALUES (648,
	2386,
	3379);
INSERT INTO R_OIR
	VALUES (648,
	2386,
	3379,
	10202);
INSERT INTO R_SUB
	VALUES (4015,
	2386,
	4069);
INSERT INTO R_RGO
	VALUES (4015,
	2386,
	4069);
INSERT INTO R_OIR
	VALUES (4015,
	2386,
	4069,
	10213);
INSERT INTO R_SUB
	VALUES (4023,
	2386,
	4039);
INSERT INTO R_RGO
	VALUES (4023,
	2386,
	4039);
INSERT INTO R_OIR
	VALUES (4023,
	2386,
	4039,
	10205);
INSERT INTO R_SUB
	VALUES (4031,
	2386,
	4046);
INSERT INTO R_RGO
	VALUES (4031,
	2386,
	4046);
INSERT INTO R_OIR
	VALUES (4031,
	2386,
	4046,
	10204);
INSERT INTO R_SUB
	VALUES (4019,
	2386,
	4056);
INSERT INTO R_RGO
	VALUES (4019,
	2386,
	4056);
INSERT INTO R_OIR
	VALUES (4019,
	2386,
	4056,
	10203);
INSERT INTO R_SUB
	VALUES (2332,
	2386,
	2418);
INSERT INTO R_RGO
	VALUES (2332,
	2386,
	2418);
INSERT INTO R_OIR
	VALUES (2332,
	2386,
	2418,
	10206);
INSERT INTO R_SUB
	VALUES (2350,
	2386,
	2404);
INSERT INTO R_RGO
	VALUES (2350,
	2386,
	2404);
INSERT INTO R_OIR
	VALUES (2350,
	2386,
	2404,
	10207);
INSERT INTO R_SUB
	VALUES (2340,
	2386,
	2387);
INSERT INTO R_RGO
	VALUES (2340,
	2386,
	2387);
INSERT INTO R_OIR
	VALUES (2340,
	2386,
	2387,
	10208);
INSERT INTO R_SUB
	VALUES (2667,
	2386,
	2691);
INSERT INTO R_RGO
	VALUES (2667,
	2386,
	2691);
INSERT INTO R_OIR
	VALUES (2667,
	2386,
	2691,
	10212);
INSERT INTO R_SUB
	VALUES (2660,
	2386,
	2710);
INSERT INTO R_RGO
	VALUES (2660,
	2386,
	2710);
INSERT INTO R_OIR
	VALUES (2660,
	2386,
	2710,
	10211);
INSERT INTO R_SUB
	VALUES (2650,
	2386,
	2727);
INSERT INTO R_RGO
	VALUES (2650,
	2386,
	2727);
INSERT INTO R_OIR
	VALUES (2650,
	2386,
	2727,
	10210);
INSERT INTO R_SUB
	VALUES (2643,
	2386,
	2746);
INSERT INTO R_RGO
	VALUES (2643,
	2386,
	2746);
INSERT INTO R_OIR
	VALUES (2643,
	2386,
	2746,
	10209);
INSERT INTO R_SUB
	VALUES (10262,
	2386,
	10263);
INSERT INTO R_RGO
	VALUES (10262,
	2386,
	10263);
INSERT INTO R_OIR
	VALUES (10262,
	2386,
	10263,
	0);
INSERT INTO R_SUB
	VALUES (10264,
	2386,
	10265);
INSERT INTO R_RGO
	VALUES (10264,
	2386,
	10265);
INSERT INTO R_OIR
	VALUES (10264,
	2386,
	10265,
	0);
INSERT INTO R_SUB
	VALUES (10266,
	2386,
	10267);
INSERT INTO R_RGO
	VALUES (10266,
	2386,
	10267);
INSERT INTO R_OIR
	VALUES (10266,
	2386,
	10267,
	0);
INSERT INTO R_SUB
	VALUES (667,
	2386,
	6741);
INSERT INTO R_RGO
	VALUES (667,
	2386,
	6741);
INSERT INTO R_OIR
	VALUES (667,
	2386,
	6741,
	10216);
INSERT INTO R_SUB
	VALUES (6687,
	2386,
	6716);
INSERT INTO R_RGO
	VALUES (6687,
	2386,
	6716);
INSERT INTO R_OIR
	VALUES (6687,
	2386,
	6716,
	10217);
INSERT INTO R_SUB
	VALUES (673,
	2386,
	3394);
INSERT INTO R_RGO
	VALUES (673,
	2386,
	3394);
INSERT INTO R_OIR
	VALUES (673,
	2386,
	3394,
	10223);
INSERT INTO R_SUB
	VALUES (679,
	2386,
	3354);
INSERT INTO R_RGO
	VALUES (679,
	2386,
	3354);
INSERT INTO R_OIR
	VALUES (679,
	2386,
	3354,
	10222);
INSERT INTO R_SIMP
	VALUES (10268);
INSERT INTO R_REL
	VALUES (10268,
	614,
	'',
	10191);
INSERT INTO R_FORM
	VALUES (10247,
	10268,
	10269,
	1,
	1,
	'is loop variable');
INSERT INTO R_RGO
	VALUES (10247,
	10268,
	10269);
INSERT INTO R_OIR
	VALUES (10247,
	10268,
	10269,
	0);
INSERT INTO R_PART
	VALUES (129,
	10268,
	10270,
	0,
	0,
	'loop');
INSERT INTO O_RTIDA
	VALUES (131,
	129,
	0,
	10268,
	10270);
INSERT INTO R_RTO
	VALUES (129,
	10268,
	10270,
	0);
INSERT INTO R_OIR
	VALUES (129,
	10268,
	10270,
	10214);
INSERT INTO R_SIMP
	VALUES (10271);
INSERT INTO R_REL
	VALUES (10271,
	626,
	'',
	10191);
INSERT INTO R_FORM
	VALUES (10239,
	10271,
	10272,
	0,
	1,
	'');
INSERT INTO R_RGO
	VALUES (10239,
	10271,
	10272);
INSERT INTO R_OIR
	VALUES (10239,
	10271,
	10272,
	0);
INSERT INTO R_PART
	VALUES (70,
	10271,
	10273,
	0,
	0,
	'continue result');
INSERT INTO O_RTIDA
	VALUES (72,
	70,
	0,
	10271,
	10273);
INSERT INTO R_RTO
	VALUES (70,
	10271,
	10273,
	0);
INSERT INTO R_OIR
	VALUES (70,
	10271,
	10273,
	10215);
INSERT INTO R_SIMP
	VALUES (10274);
INSERT INTO R_REL
	VALUES (10274,
	625,
	'',
	10191);
INSERT INTO R_FORM
	VALUES (10251,
	10274,
	10275,
	0,
	1,
	'');
INSERT INTO R_RGO
	VALUES (10251,
	10274,
	10275);
INSERT INTO R_OIR
	VALUES (10251,
	10274,
	10275,
	0);
INSERT INTO R_PART
	VALUES (70,
	10274,
	10276,
	0,
	0,
	'test result');
INSERT INTO O_RTIDA
	VALUES (72,
	70,
	0,
	10274,
	10276);
INSERT INTO R_RTO
	VALUES (70,
	10274,
	10276,
	0);
INSERT INTO R_OIR
	VALUES (70,
	10274,
	10276,
	10215);
INSERT INTO R_SIMP
	VALUES (10277);
INSERT INTO R_REL
	VALUES (10277,
	659,
	'',
	10191);
INSERT INTO R_FORM
	VALUES (10236,
	10277,
	10278,
	0,
	1,
	'');
INSERT INTO R_RGO
	VALUES (10236,
	10277,
	10278);
INSERT INTO R_OIR
	VALUES (10236,
	10277,
	10278,
	0);
INSERT INTO R_PART
	VALUES (70,
	10277,
	10279,
	0,
	0,
	'test result');
INSERT INTO O_RTIDA
	VALUES (72,
	70,
	0,
	10277,
	10279);
INSERT INTO R_RTO
	VALUES (70,
	10277,
	10279,
	0);
INSERT INTO R_OIR
	VALUES (70,
	10277,
	10279,
	10215);
INSERT INTO R_SIMP
	VALUES (10280);
INSERT INTO R_REL
	VALUES (10280,
	670,
	'',
	10191);
INSERT INTO R_FORM
	VALUES (10247,
	10280,
	10281,
	1,
	1,
	'');
INSERT INTO R_RGO
	VALUES (10247,
	10280,
	10281);
INSERT INTO R_OIR
	VALUES (10247,
	10280,
	10281,
	0);
INSERT INTO R_PART
	VALUES (30,
	10280,
	10282,
	0,
	0,
	'iterates a set of');
INSERT INTO O_RTIDA
	VALUES (150,
	30,
	0,
	10280,
	10282);
INSERT INTO R_RTO
	VALUES (30,
	10280,
	10282,
	0);
INSERT INTO R_OIR
	VALUES (30,
	10280,
	10282,
	10193);
INSERT INTO R_SIMP
	VALUES (10283);
INSERT INTO R_REL
	VALUES (10283,
	601,
	'R612/R650 and R601/R666 are similar but are separate to allow parsing to be
decoupled from Verifier/Export.  As parsing occurs R612/R650 are used, however 
R601/R666 are populated only when one of the following four conditions happens:
1) Verifier is launched
2) OAL is saved after being edited
3) Model export is performed
4) During model import when the parse on import option is selected
This allows a user to make a change to the OAL while running a verifier session, 
but not have verifier "see" the change until the change is explicitly saved by
the user.',
	10191);
INSERT INTO R_PART
	VALUES (10227,
	10283,
	10284,
	0,
	0,
	'is committed from');
INSERT INTO O_RTIDA
	VALUES (10285,
	10227,
	0,
	10283,
	10284);
INSERT INTO R_RTO
	VALUES (10227,
	10283,
	10284,
	0);
INSERT INTO R_OIR
	VALUES (10227,
	10283,
	10284,
	0);
INSERT INTO R_FORM
	VALUES (35,
	10283,
	10286,
	1,
	1,
	'has committed');
INSERT INTO R_RGO
	VALUES (35,
	10283,
	10286);
INSERT INTO R_OIR
	VALUES (35,
	10283,
	10286,
	0);
INSERT INTO R_SIMP
	VALUES (10287);
INSERT INTO R_REL
	VALUES (10287,
	652,
	'',
	10191);
INSERT INTO R_FORM
	VALUES (10247,
	10287,
	10288,
	1,
	1,
	'is set variable');
INSERT INTO R_RGO
	VALUES (10247,
	10287,
	10288);
INSERT INTO R_OIR
	VALUES (10247,
	10287,
	10288,
	0);
INSERT INTO R_PART
	VALUES (129,
	10287,
	10289,
	0,
	0,
	'set');
INSERT INTO O_RTIDA
	VALUES (131,
	129,
	0,
	10287,
	10289);
INSERT INTO R_RTO
	VALUES (129,
	10287,
	10289,
	0);
INSERT INTO R_OIR
	VALUES (129,
	10287,
	10289,
	10214);
INSERT INTO R_SIMP
	VALUES (10290);
INSERT INTO R_REL
	VALUES (10290,
	682,
	'',
	10191);
INSERT INTO R_PART
	VALUES (10251,
	10290,
	10291,
	0,
	0,
	'');
INSERT INTO O_RTIDA
	VALUES (10292,
	10251,
	0,
	10290,
	10291);
INSERT INTO R_RTO
	VALUES (10251,
	10290,
	10291,
	0);
INSERT INTO R_OIR
	VALUES (10251,
	10290,
	10291,
	0);
INSERT INTO R_FORM
	VALUES (10236,
	10290,
	10293,
	1,
	1,
	'has');
INSERT INTO R_RGO
	VALUES (10236,
	10290,
	10293);
INSERT INTO R_OIR
	VALUES (10236,
	10290,
	10293,
	0);
INSERT INTO R_SIMP
	VALUES (10294);
INSERT INTO R_REL
	VALUES (10294,
	683,
	'',
	10191);
INSERT INTO R_PART
	VALUES (10251,
	10294,
	10295,
	0,
	0,
	'');
INSERT INTO O_RTIDA
	VALUES (10292,
	10251,
	0,
	10294,
	10295);
INSERT INTO R_RTO
	VALUES (10251,
	10294,
	10295,
	0);
INSERT INTO R_OIR
	VALUES (10251,
	10294,
	10295,
	0);
INSERT INTO R_FORM
	VALUES (10243,
	10294,
	10296,
	0,
	1,
	'has');
INSERT INTO R_RGO
	VALUES (10243,
	10294,
	10296);
INSERT INTO R_OIR
	VALUES (10243,
	10294,
	10296,
	0);
INSERT INTO R_SIMP
	VALUES (10297);
INSERT INTO R_REL
	VALUES (10297,
	691,
	'',
	10191);
INSERT INTO R_PART
	VALUES (1559,
	10297,
	10298,
	0,
	0,
	'specifies processing for');
INSERT INTO O_RTIDA
	VALUES (1561,
	1559,
	0,
	10297,
	10298);
INSERT INTO O_RTIDA
	VALUES (1562,
	1559,
	0,
	10297,
	10298);
INSERT INTO R_RTO
	VALUES (1559,
	10297,
	10298,
	0);
INSERT INTO R_OIR
	VALUES (1559,
	10297,
	10298,
	10197);
INSERT INTO R_FORM
	VALUES (10299,
	10297,
	10300,
	0,
	1,
	'');
INSERT INTO R_RGO
	VALUES (10299,
	10297,
	10300);
INSERT INTO R_OIR
	VALUES (10299,
	10297,
	10300,
	0);
INSERT INTO R_SIMP
	VALUES (10301);
INSERT INTO R_REL
	VALUES (10301,
	693,
	'',
	10191);
INSERT INTO R_PART
	VALUES (1023,
	10301,
	10302,
	0,
	0,
	'specifies processing for');
INSERT INTO O_RTIDA
	VALUES (1366,
	1023,
	0,
	10301,
	10302);
INSERT INTO O_RTIDA
	VALUES (1369,
	1023,
	0,
	10301,
	10302);
INSERT INTO R_RTO
	VALUES (1023,
	10301,
	10302,
	0);
INSERT INTO R_OIR
	VALUES (1023,
	10301,
	10302,
	10198);
INSERT INTO R_FORM
	VALUES (10303,
	10301,
	10304,
	0,
	1,
	'');
INSERT INTO R_RGO
	VALUES (10303,
	10301,
	10304);
INSERT INTO R_OIR
	VALUES (10303,
	10301,
	10304,
	0);
INSERT INTO R_SIMP
	VALUES (10305);
INSERT INTO R_REL
	VALUES (10305,
	695,
	'',
	10191);
INSERT INTO R_PART
	VALUES (8,
	10305,
	10306,
	0,
	0,
	'specifies processing for');
INSERT INTO O_RTIDA
	VALUES (11,
	8,
	0,
	10305,
	10306);
INSERT INTO R_RTO
	VALUES (8,
	10305,
	10306,
	0);
INSERT INTO R_OIR
	VALUES (8,
	10305,
	10306,
	10194);
INSERT INTO R_FORM
	VALUES (10307,
	10305,
	10308,
	0,
	1,
	'');
INSERT INTO R_RGO
	VALUES (10307,
	10305,
	10308);
INSERT INTO R_OIR
	VALUES (10307,
	10305,
	10308,
	0);
INSERT INTO R_SIMP
	VALUES (10309);
INSERT INTO R_REL
	VALUES (10309,
	696,
	'',
	10191);
INSERT INTO R_PART
	VALUES (43,
	10309,
	10310,
	0,
	0,
	'specifies processing for');
INSERT INTO O_RTIDA
	VALUES (201,
	43,
	0,
	10309,
	10310);
INSERT INTO R_RTO
	VALUES (43,
	10309,
	10310,
	0);
INSERT INTO R_OIR
	VALUES (43,
	10309,
	10310,
	10195);
INSERT INTO R_FORM
	VALUES (10311,
	10309,
	10312,
	0,
	1,
	'');
INSERT INTO R_RGO
	VALUES (10311,
	10309,
	10312);
INSERT INTO R_OIR
	VALUES (10311,
	10309,
	10312,
	0);
INSERT INTO R_SIMP
	VALUES (10313);
INSERT INTO R_REL
	VALUES (10313,
	697,
	'',
	10191);
INSERT INTO R_PART
	VALUES (6,
	10313,
	10314,
	0,
	0,
	'specifies processing for');
INSERT INTO O_RTIDA
	VALUES (16,
	6,
	0,
	10313,
	10314);
INSERT INTO R_RTO
	VALUES (6,
	10313,
	10314,
	0);
INSERT INTO R_OIR
	VALUES (6,
	10313,
	10314,
	10196);
INSERT INTO R_FORM
	VALUES (10315,
	10313,
	10316,
	0,
	1,
	'');
INSERT INTO R_RGO
	VALUES (10315,
	10313,
	10316);
INSERT INTO R_OIR
	VALUES (10315,
	10313,
	10316,
	0);
INSERT INTO R_SUBSUP
	VALUES (10317);
INSERT INTO R_REL
	VALUES (10317,
	698,
	'',
	10191);
INSERT INTO R_SUPER
	VALUES (10227,
	10317,
	10318);
INSERT INTO O_RTIDA
	VALUES (10285,
	10227,
	0,
	10317,
	10318);
INSERT INTO R_RTO
	VALUES (10227,
	10317,
	10318,
	0);
INSERT INTO R_OIR
	VALUES (10227,
	10317,
	10318,
	0);
INSERT INTO R_SUB
	VALUES (10299,
	10317,
	10319);
INSERT INTO R_RGO
	VALUES (10299,
	10317,
	10319);
INSERT INTO R_OIR
	VALUES (10299,
	10317,
	10319,
	0);
INSERT INTO R_SUB
	VALUES (10303,
	10317,
	10320);
INSERT INTO R_RGO
	VALUES (10303,
	10317,
	10320);
INSERT INTO R_OIR
	VALUES (10303,
	10317,
	10320,
	0);
INSERT INTO R_SUB
	VALUES (10307,
	10317,
	10321);
INSERT INTO R_RGO
	VALUES (10307,
	10317,
	10321);
INSERT INTO R_OIR
	VALUES (10307,
	10317,
	10321,
	0);
INSERT INTO R_SUB
	VALUES (10311,
	10317,
	10322);
INSERT INTO R_RGO
	VALUES (10311,
	10317,
	10322);
INSERT INTO R_OIR
	VALUES (10311,
	10317,
	10322,
	0);
INSERT INTO R_SUB
	VALUES (10315,
	10317,
	10323);
INSERT INTO R_RGO
	VALUES (10315,
	10317,
	10323);
INSERT INTO R_OIR
	VALUES (10315,
	10317,
	10323,
	0);
INSERT INTO R_SUB
	VALUES (10324,
	10317,
	10325);
INSERT INTO R_RGO
	VALUES (10324,
	10317,
	10325);
INSERT INTO R_OIR
	VALUES (10324,
	10317,
	10325,
	0);
INSERT INTO R_SUB
	VALUES (10326,
	10317,
	10327);
INSERT INTO R_RGO
	VALUES (10326,
	10317,
	10327);
INSERT INTO R_OIR
	VALUES (10326,
	10317,
	10327,
	0);
INSERT INTO R_SUB
	VALUES (10328,
	10317,
	10329);
INSERT INTO R_RGO
	VALUES (10328,
	10317,
	10329);
INSERT INTO R_OIR
	VALUES (10328,
	10317,
	10329,
	0);
INSERT INTO R_SUB
	VALUES (10330,
	10317,
	10331);
INSERT INTO R_RGO
	VALUES (10330,
	10317,
	10331);
INSERT INTO R_OIR
	VALUES (10330,
	10317,
	10331,
	0);
INSERT INTO R_SUB
	VALUES (10332,
	10317,
	10333);
INSERT INTO R_RGO
	VALUES (10332,
	10317,
	10333);
INSERT INTO R_OIR
	VALUES (10332,
	10317,
	10333,
	0);
INSERT INTO R_SIMP
	VALUES (10334);
INSERT INTO R_REL
	VALUES (10334,
	699,
	'',
	10191);
INSERT INTO R_PART
	VALUES (35,
	10334,
	10335,
	0,
	1,
	'has current scope');
INSERT INTO O_RTIDA
	VALUES (163,
	35,
	0,
	10334,
	10335);
INSERT INTO R_RTO
	VALUES (35,
	10334,
	10335,
	0);
INSERT INTO R_OIR
	VALUES (35,
	10334,
	10335,
	0);
INSERT INTO R_FORM
	VALUES (10227,
	10334,
	10336,
	0,
	1,
	'is current scope for');
INSERT INTO R_RGO
	VALUES (10227,
	10334,
	10336);
INSERT INTO R_OIR
	VALUES (10227,
	10334,
	10336,
	0);
INSERT INTO R_SIMP
	VALUES (10337);
INSERT INTO R_REL
	VALUES (10337,
	690,
	'',
	10191);
INSERT INTO R_FORM
	VALUES (10251,
	10337,
	10338,
	0,
	1,
	'');
INSERT INTO R_RGO
	VALUES (10251,
	10337,
	10338);
INSERT INTO R_OIR
	VALUES (10251,
	10337,
	10338,
	0);
INSERT INTO R_PART
	VALUES (10236,
	10337,
	10339,
	0,
	1,
	'was executing when halted');
INSERT INTO O_RTIDA
	VALUES (10340,
	10236,
	0,
	10337,
	10339);
INSERT INTO R_RTO
	VALUES (10236,
	10337,
	10339,
	0);
INSERT INTO R_OIR
	VALUES (10236,
	10337,
	10339,
	0);
INSERT INTO R_SIMP
	VALUES (10341);
INSERT INTO R_REL
	VALUES (10341,
	692,
	'',
	10191);
INSERT INTO R_FORM
	VALUES (10251,
	10341,
	10342,
	0,
	1,
	'');
INSERT INTO R_RGO
	VALUES (10251,
	10341,
	10342);
INSERT INTO R_OIR
	VALUES (10251,
	10341,
	10342,
	0);
INSERT INTO R_PART
	VALUES (10243,
	10341,
	10343,
	0,
	1,
	'was executing when halted');
INSERT INTO O_RTIDA
	VALUES (10344,
	10243,
	0,
	10341,
	10343);
INSERT INTO R_RTO
	VALUES (10243,
	10341,
	10343,
	0);
INSERT INTO R_OIR
	VALUES (10243,
	10341,
	10343,
	0);
INSERT INTO R_SIMP
	VALUES (10345);
INSERT INTO R_REL
	VALUES (10345,
	650,
	'Persistent:false
R612/R650 and R601/R666 are similar but are separate to allow parsing to be
decoupled from Verifier/Export.  As parsing occurs R612/R650 are used, however 
R601/R666 are populated only when one of the following four conditions happens:
1) Verifier is launched
2) OAL is saved after being edited
3) Model export is performed
4) During model import when the parse on import option is selected
This allows a user to make a change to the OAL while running a verifier session, 
but not have verifier "see" the change until the change is explicitly saved by
the user.',
	10191);
INSERT INTO R_FORM
	VALUES (10227,
	10345,
	10346,
	0,
	1,
	'is outer parse level of');
INSERT INTO R_RGO
	VALUES (10227,
	10345,
	10346);
INSERT INTO R_OIR
	VALUES (10227,
	10345,
	10346,
	0);
INSERT INTO R_PART
	VALUES (35,
	10345,
	10347,
	0,
	1,
	'has parsed outer');
INSERT INTO O_RTIDA
	VALUES (163,
	35,
	0,
	10345,
	10347);
INSERT INTO R_RTO
	VALUES (35,
	10345,
	10347,
	0);
INSERT INTO R_OIR
	VALUES (35,
	10345,
	10347,
	0);
INSERT INTO R_SIMP
	VALUES (10348);
INSERT INTO R_REL
	VALUES (10348,
	612,
	'Persistent:false
R612/R650 and R601/R666 are similar but are separate to allow parsing to be
decoupled from Verifier/Export.  As parsing occurs R612/R650 are used, however 
R601/R666 are populated only when one of the following four conditions happens:
1) Verifier is launched
2) OAL is saved after being edited
3) Model export is performed
4) During model import when the parse on import option is selected
This allows a user to make a change to the OAL while running a verifier session, 
but not have verifier "see" the change until the change is explicitly saved by
the user.',
	10191);
INSERT INTO R_PART
	VALUES (10227,
	10348,
	10349,
	0,
	0,
	'is parsed from');
INSERT INTO O_RTIDA
	VALUES (10285,
	10227,
	0,
	10348,
	10349);
INSERT INTO R_RTO
	VALUES (10227,
	10348,
	10349,
	0);
INSERT INTO R_OIR
	VALUES (10227,
	10348,
	10349,
	0);
INSERT INTO R_FORM
	VALUES (35,
	10348,
	10350,
	1,
	1,
	'has parsed');
INSERT INTO R_RGO
	VALUES (35,
	10348,
	10350);
INSERT INTO R_OIR
	VALUES (35,
	10348,
	10350,
	0);
INSERT INTO R_SIMP
	VALUES (10351);
INSERT INTO R_REL
	VALUES (10351,
	684,
	'',
	10191);
INSERT INTO R_PART
	VALUES (1485,
	10351,
	10352,
	0,
	0,
	'specifies processing for');
INSERT INTO O_RTIDA
	VALUES (1641,
	1485,
	0,
	10351,
	10352);
INSERT INTO R_RTO
	VALUES (1485,
	10351,
	10352,
	0);
INSERT INTO R_OIR
	VALUES (1485,
	10351,
	10352,
	10221);
INSERT INTO R_FORM
	VALUES (10330,
	10351,
	10353,
	0,
	1,
	'');
INSERT INTO R_RGO
	VALUES (10330,
	10351,
	10353);
INSERT INTO R_OIR
	VALUES (10330,
	10351,
	10353,
	0);
INSERT INTO R_SIMP
	VALUES (10354);
INSERT INTO R_REL
	VALUES (10354,
	685,
	'',
	10191);
INSERT INTO R_PART
	VALUES (3308,
	10354,
	10355,
	0,
	0,
	'specifies processing for');
INSERT INTO O_RTIDA
	VALUES (3337,
	3308,
	0,
	10354,
	10355);
INSERT INTO R_RTO
	VALUES (3308,
	10354,
	10355,
	0);
INSERT INTO R_OIR
	VALUES (3308,
	10354,
	10355,
	10220);
INSERT INTO R_FORM
	VALUES (10328,
	10354,
	10356,
	0,
	1,
	'');
INSERT INTO R_RGO
	VALUES (10328,
	10354,
	10356);
INSERT INTO R_OIR
	VALUES (10328,
	10354,
	10356,
	0);
INSERT INTO R_SIMP
	VALUES (10357);
INSERT INTO R_REL
	VALUES (10357,
	686,
	'',
	10191);
INSERT INTO R_PART
	VALUES (1483,
	10357,
	10358,
	0,
	0,
	'specifies processing for');
INSERT INTO O_RTIDA
	VALUES (1637,
	1483,
	0,
	10357,
	10358);
INSERT INTO R_RTO
	VALUES (1483,
	10357,
	10358,
	0);
INSERT INTO R_OIR
	VALUES (1483,
	10357,
	10358,
	10219);
INSERT INTO R_FORM
	VALUES (10326,
	10357,
	10359,
	0,
	1,
	'');
INSERT INTO R_RGO
	VALUES (10326,
	10357,
	10359);
INSERT INTO R_OIR
	VALUES (10326,
	10357,
	10359,
	0);
INSERT INTO R_SIMP
	VALUES (10360);
INSERT INTO R_REL
	VALUES (10360,
	687,
	'',
	10191);
INSERT INTO R_PART
	VALUES (3306,
	10360,
	10361,
	0,
	0,
	'specifies processing for');
INSERT INTO O_RTIDA
	VALUES (3334,
	3306,
	0,
	10360,
	10361);
INSERT INTO R_RTO
	VALUES (3306,
	10360,
	10361,
	0);
INSERT INTO R_OIR
	VALUES (3306,
	10360,
	10361,
	10218);
INSERT INTO R_FORM
	VALUES (10324,
	10360,
	10362,
	0,
	1,
	'');
INSERT INTO R_RGO
	VALUES (10324,
	10360,
	10362);
INSERT INTO R_OIR
	VALUES (10324,
	10360,
	10362,
	0);
INSERT INTO R_ASSOC
	VALUES (10363);
INSERT INTO R_REL
	VALUES (10363,
	694,
	'',
	10191);
INSERT INTO R_AONE
	VALUES (709,
	10363,
	10364,
	0,
	1,
	'is declared in');
INSERT INTO O_RTIDA
	VALUES (762,
	709,
	0,
	10363,
	10364);
INSERT INTO R_RTO
	VALUES (709,
	10363,
	10364,
	0);
INSERT INTO R_OIR
	VALUES (709,
	10363,
	10364,
	10224);
INSERT INTO R_AOTH
	VALUES (10227,
	10363,
	10365,
	1,
	1,
	'has declared');
INSERT INTO O_RTIDA
	VALUES (10285,
	10227,
	0,
	10363,
	10365);
INSERT INTO R_RTO
	VALUES (10227,
	10363,
	10365,
	0);
INSERT INTO R_OIR
	VALUES (10227,
	10363,
	10365,
	0);
INSERT INTO R_ASSR
	VALUES (10366,
	10363,
	10367,
	0);
INSERT INTO R_RGO
	VALUES (10366,
	10363,
	10367);
INSERT INTO R_OIR
	VALUES (10366,
	10363,
	10367,
	0);
INSERT INTO R_SIMP
	VALUES (10368);
INSERT INTO R_REL
	VALUES (10368,
	688,
	'',
	10191);
INSERT INTO R_FORM
	VALUES (10332,
	10368,
	10369,
	0,
	1,
	'');
INSERT INTO R_RGO
	VALUES (10332,
	10368,
	10369);
INSERT INTO R_OIR
	VALUES (10332,
	10368,
	10369,
	0);
INSERT INTO R_PART
	VALUES (1559,
	10368,
	10370,
	0,
	0,
	'specifies processing for');
INSERT INTO O_RTIDA
	VALUES (1561,
	1559,
	0,
	10368,
	10370);
INSERT INTO O_RTIDA
	VALUES (1562,
	1559,
	0,
	10368,
	10370);
INSERT INTO R_RTO
	VALUES (1559,
	10368,
	10370,
	0);
INSERT INTO R_OIR
	VALUES (1559,
	10368,
	10370,
	10197);
INSERT INTO R_ASSOC
	VALUES (10371);
INSERT INTO R_REL
	VALUES (10371,
	640,
	'',
	10191);
INSERT INTO R_AONE
	VALUES (10227,
	10371,
	10372,
	1,
	1,
	'has declared');
INSERT INTO O_RTIDA
	VALUES (10285,
	10227,
	0,
	10371,
	10372);
INSERT INTO R_RTO
	VALUES (10227,
	10371,
	10372,
	0);
INSERT INTO R_OIR
	VALUES (10227,
	10371,
	10372,
	0);
INSERT INTO R_AOTH
	VALUES (26,
	10371,
	10373,
	0,
	1,
	'is declared in');
INSERT INTO O_RTIDA
	VALUES (25,
	26,
	0,
	10371,
	10373);
INSERT INTO R_RTO
	VALUES (26,
	10371,
	10373,
	0);
INSERT INTO R_OIR
	VALUES (26,
	10371,
	10373,
	10225);
INSERT INTO R_ASSR
	VALUES (10374,
	10371,
	10375,
	0);
INSERT INTO R_RGO
	VALUES (10374,
	10371,
	10375);
INSERT INTO R_OIR
	VALUES (10374,
	10371,
	10375,
	0);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10239,
	'While Stmt',
	619,
	'ACT_WHL',
	'This class represents a while statement in a block of action language.',
	10191);
INSERT INTO O_TFR
	VALUES (10376,
	10239,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.
',
	19,
	1,
	'select one blk related by self->ACT_BLK[R608];
if ( not_empty blk )
  unrelate self from blk across R608;
  blk.dispose();
end if;

select one val related by self->V_VAL[R626];
if ( not_empty val )
  unrelate self from val across R626;
  val.dispose();
end if;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (10377,
	10239,
	'execute',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	10376);
INSERT INTO O_TPARM
	VALUES (10378,
	10377,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (10239,
	686,
	0,
	685,
	2386,
	10258,
	2388,
	10379,
	10380,
	0,
	0,
	'',
	'Statement',
	'Statement_ID',
	'R603');
INSERT INTO O_RATTR
	VALUES (10379,
	10239,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (10379,
	10239,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10239,
	70,
	0,
	72,
	10271,
	10272,
	10273,
	10381,
	10382,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R626.''continue result''');
INSERT INTO O_RATTR
	VALUES (10381,
	10239,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (10381,
	10239,
	10379,
	'Value_ID',
	'

',
	'',
	'Value_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10239,
	35,
	0,
	163,
	10238,
	10240,
	10241,
	10383,
	10384,
	0,
	0,
	'',
	'Block',
	'Block_ID',
	'R608.''controls''');
INSERT INTO O_RATTR
	VALUES (10383,
	10239,
	163,
	35,
	1,
	'Block_ID');
INSERT INTO O_ATTR
	VALUES (10383,
	10239,
	10381,
	'Block_ID',
	'',
	'',
	'Block_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10239);
INSERT INTO O_OIDA
	VALUES (10379,
	10239,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	10239);
INSERT INTO O_ID
	VALUES (2,
	10239);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10332,
	'Transition Action Body',
	643,
	'ACT_TAB',
	'',
	10191);
INSERT INTO O_TFR
	VALUES (10385,
	10332,
	'dispose',
	'',
	19,
	1,
	'// Transition Action Body.dispose()
select one act related by self->SM_ACT[R688];
if ( not_empty act )
  unrelate self from act across R688;
end if;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (10386,
	10332,
	'getContainingComponentId',
	'',
	296,
	1,
	'select one stateMachine related by self->SM_ACT[R688]->SM_SM[R515];
return stateMachine.getContainingComponentId();',
	1,
	'',
	10385);
INSERT INTO O_TFR
	VALUES (10387,
	10332,
	'getContainerId',
	'',
	296,
	1,
	'// Transition Action Body.getContainerId()
select one stateMachine related by self->SM_ACT[R688]->SM_SM[R515];
return stateMachine.getContainerId();',
	1,
	'',
	10386);
INSERT INTO O_TFR
	VALUES (10388,
	10332,
	'getPath',
	'',
	322,
	1,
	' select one action related by self->SM_ACT[R688];
select one transition related by action->SM_AH[R514]->SM_TAH[R513]->SM_TXN[R530];
actionPath ="";
transitionName =transition.get_name();
stateMachineType ="";
if (not_empty action)
  select one modelClass related by action->SM_SM[R515]->SM_ISM[R517]->O_OBJ[R518];
    stateMachineType="Instance Based State Machine";
    if(empty modelClass)
      select one modelClass related by action->SM_SM[R515]->SM_ASM[R517]->O_OBJ[R519];
      stateMachineType="Class Based State Machine";
    end if;
  
  modelClassName = modelClass.Name; 
   select one pe_pe related by modelClass->PE_PE[R8001];
     if(not_empty pe_pe )
     //Is In Generics
      select one pkg related by pe_pe->EP_PKG[R8000];
      actionPath= pkg.getPath(path:modelClassName+"::"+stateMachineType+"::"+transitionName);
     else
      //In specialized 
      select one subSystem related by modelClass ->S_SS[R2];
      actionPath = subSystem.getPath(path:modelClassName+"::"+stateMachineType+"::"+transitionName);    
     end if;
end if;
return actionPath;',
	1,
	'',
	10387);
INSERT INTO O_REF
	VALUES (10332,
	10227,
	0,
	10285,
	10317,
	10333,
	10318,
	10389,
	10390,
	0,
	0,
	'',
	'Body',
	'Action_ID',
	'R698');
INSERT INTO O_RATTR
	VALUES (10389,
	10332,
	10285,
	10227,
	1,
	'Action_ID');
INSERT INTO O_ATTR
	VALUES (10389,
	10332,
	0,
	'Action_ID',
	'',
	'',
	'Action_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10332,
	1559,
	0,
	1561,
	10368,
	10369,
	10370,
	10391,
	10392,
	0,
	0,
	'',
	'Action',
	'SM_ID',
	'R688');
INSERT INTO O_RATTR
	VALUES (10391,
	10332,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (10391,
	10332,
	10389,
	'SM_ID',
	'',
	'',
	'SM_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10332,
	1559,
	0,
	1562,
	10368,
	10369,
	10370,
	10393,
	10394,
	0,
	0,
	'',
	'Action',
	'Act_ID',
	'R688');
INSERT INTO O_RATTR
	VALUES (10393,
	10332,
	1562,
	1559,
	1,
	'Act_ID');
INSERT INTO O_ATTR
	VALUES (10393,
	10332,
	10391,
	'Act_ID',
	'',
	'',
	'Act_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10332);
INSERT INTO O_OIDA
	VALUES (10389,
	10332,
	0,
	'Action_ID');
INSERT INTO O_ID
	VALUES (1,
	10332);
INSERT INTO O_ID
	VALUES (2,
	10332);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (686,
	'Statement',
	602,
	'ACT_SMT',
	'This class represents an action language statement within a block.',
	10191);
INSERT INTO O_TFR
	VALUES (10395,
	686,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	10396);
INSERT INTO O_TFR
	VALUES (10397,
	686,
	'execute',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	10395);
INSERT INTO O_TPARM
	VALUES (10398,
	10397,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10396,
	686,
	'checkBreakpoint',
	'',
	316,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return false;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (10399,
	10396,
	'stack_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10400,
	686,
	'stepIn',
	'',
	316,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return false;',
	1,
	'',
	10401);
INSERT INTO O_TFR
	VALUES (10401,
	686,
	'setupNextStatement',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	10402);
INSERT INTO O_TPARM
	VALUES (10403,
	10401,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10402,
	686,
	'popUpToBlock',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	10397);
INSERT INTO O_TPARM
	VALUES (10404,
	10402,
	'block_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (10405,
	10402,
	'stack_frame_id',
	296,
	0,
	'',
	10404,
	'');
INSERT INTO O_NBATTR
	VALUES (685,
	686);
INSERT INTO O_BATTR
	VALUES (685,
	686);
INSERT INTO O_ATTR
	VALUES (685,
	686,
	0,
	'Statement_ID',
	'',
	'',
	'Statement_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_REF
	VALUES (686,
	35,
	0,
	163,
	10254,
	10255,
	10256,
	10233,
	10406,
	0,
	0,
	'',
	'Block',
	'Block_ID',
	'R602.''contains''');
INSERT INTO O_REF
	VALUES (686,
	686,
	1,
	10233,
	10230,
	10231,
	10232,
	10233,
	10407,
	10406,
	0,
	'',
	'Statement',
	'Block_ID',
	'R661.''succeeds''');
INSERT INTO O_RATTR
	VALUES (10233,
	686,
	163,
	35,
	1,
	'Block_ID');
INSERT INTO O_ATTR
	VALUES (10233,
	686,
	685,
	'Block_ID',
	'',
	'',
	'Block_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (686,
	686,
	1,
	685,
	10230,
	10231,
	10232,
	10408,
	10409,
	0,
	0,
	'',
	'Statement',
	'Statement_ID',
	'R661.''succeeds''');
INSERT INTO O_RATTR
	VALUES (10408,
	686,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (10408,
	686,
	10233,
	'Previous_Statement_ID',
	'',
	'Previous_',
	'Statement_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10410,
	686);
INSERT INTO O_BATTR
	VALUES (10410,
	686);
INSERT INTO O_ATTR
	VALUES (10410,
	686,
	10408,
	'LineNumber',
	'The line in the activity at which this statement resides.  For multi-line
statements, this is the line that the statement starts at.  It has
a default value of -1, indicating that the location is not known.
                        
Not_participating_value: -1',
	'',
	'LineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10411,
	686);
INSERT INTO O_BATTR
	VALUES (10411,
	686);
INSERT INTO O_ATTR
	VALUES (10411,
	686,
	10410,
	'StartPosition',
	'The column in the activity at which this statement starts. It has
a default value of -1, indicating that the location is not known.
                        
Not_participating_value: -1',
	'',
	'StartPosition',
	0,
	298,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (10412,
	686,
	'select one body related by self->ACT_BLK[R602]->ACT_ACT[R601];
result = "Unknown Activity";
if (not_empty body)
  result = body.Label;
end if;
self.Label = result + " line: " + GD::int_to_string(value:self.LineNumber);',
	1);
INSERT INTO O_BATTR
	VALUES (10412,
	686);
INSERT INTO O_ATTR
	VALUES (10412,
	686,
	10411,
	'Label',
	'',
	'',
	'Label',
	0,
	322,
	'',
	'');
INSERT INTO O_ID
	VALUES (1,
	686);
INSERT INTO O_OIDA
	VALUES (685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_OIDA
	VALUES (10233,
	686,
	1,
	'Block_ID');
INSERT INTO O_ID
	VALUES (0,
	686);
INSERT INTO O_OIDA
	VALUES (685,
	686,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (2,
	686);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10299,
	'State Action Body',
	632,
	'ACT_SAB',
	'This class represents the action language containing body of a State Action.',
	10191);
INSERT INTO O_TFR
	VALUES (10413,
	10299,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'// State Action Body.dispose()
select one act related by self->SM_ACT[R691];
if ( not_empty act )
  unrelate self from act across R691;
end if;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (10414,
	10299,
	'getContainingComponentId',
	'',
	296,
	1,
	'select one stateMachine related by self->SM_ACT[R691]->SM_SM[R515];
return stateMachine.getContainingComponentId();',
	1,
	'',
	10413);
INSERT INTO O_TFR
	VALUES (10415,
	10299,
	'getContainerId',
	'',
	296,
	1,
	'// State Action Body.getContainerId()
select one stateMachine related by self->SM_ACT[R691]->SM_SM[R515];
return stateMachine.getContainerId();',
	1,
	'',
	10414);
INSERT INTO O_TFR
	VALUES (10416,
	10299,
	'getPath',
	'',
	322,
	1,
	' select one action related by self->SM_ACT[R691];
 select one state related by action->SM_AH[R514]->SM_MOAH[R513]->SM_STATE[R511];
actionPath ="";
stateName =state.Name;
stateMachineType ="";
if (not_empty action)
  select one modelClass related by action->SM_SM[R515]->SM_ISM[R517]->O_OBJ[R518];
    stateMachineType="Instance Based State Machine";
    if(empty modelClass)
      select one modelClass related by action->SM_SM[R515]->SM_ASM[R517]->O_OBJ[R519];
      stateMachineType="Class Based State Machine";
    end if;
  
  modelClassName = modelClass.Name; 
   select one pe_pe related by modelClass->PE_PE[R8001];
     if(not_empty pe_pe )
     //Is In Generics
      select one pkg related by pe_pe->EP_PKG[R8000];
      actionPath= pkg.getPath(path:modelClassName+"::"+stateMachineType+"::"+stateName);
     else
      //In specialized 
      select one subSystem related by modelClass ->S_SS[R2];
      actionPath = subSystem.getPath(path:modelClassName+"::"+stateMachineType+"::"+stateName);    
     end if;
end if;
return actionPath;',
	1,
	'',
	10415);
INSERT INTO O_REF
	VALUES (10299,
	10227,
	0,
	10285,
	10317,
	10319,
	10318,
	10417,
	10418,
	0,
	0,
	'',
	'Body',
	'Action_ID',
	'R698');
INSERT INTO O_RATTR
	VALUES (10417,
	10299,
	10285,
	10227,
	1,
	'Action_ID');
INSERT INTO O_ATTR
	VALUES (10417,
	10299,
	0,
	'Action_ID',
	'',
	'',
	'Action_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10299,
	1559,
	0,
	1561,
	10297,
	10300,
	10298,
	10419,
	10420,
	0,
	0,
	'',
	'Action',
	'SM_ID',
	'R691');
INSERT INTO O_RATTR
	VALUES (10419,
	10299,
	564,
	565,
	1,
	'SM_ID');
INSERT INTO O_ATTR
	VALUES (10419,
	10299,
	10417,
	'SM_ID',
	'',
	'',
	'SM_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10299,
	1559,
	0,
	1562,
	10297,
	10300,
	10298,
	10421,
	10422,
	0,
	0,
	'',
	'Action',
	'Act_ID',
	'R691');
INSERT INTO O_RATTR
	VALUES (10421,
	10299,
	1562,
	1559,
	1,
	'Act_ID');
INSERT INTO O_ATTR
	VALUES (10421,
	10299,
	10419,
	'Act_ID',
	'',
	'',
	'Act_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10299);
INSERT INTO O_OIDA
	VALUES (10417,
	10299,
	0,
	'Action_ID');
INSERT INTO O_ID
	VALUES (1,
	10299);
INSERT INTO O_ID
	VALUES (2,
	10299);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10330,
	'Required Signal Body',
	640,
	'ACT_RSB',
	'',
	10191);
INSERT INTO O_TFR
	VALUES (10423,
	10330,
	'dispose',
	'',
	19,
	1,
	'select one act related by self->SPR_RS[R684];
if ( not_empty act )
  unrelate self from act across R684;
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (10424,
	10330,
	'getContainingComponentId',
	'',
	296,
	1,
	'select one requiredSig related by self->SPR_RS[R684];
return requiredSig.getComponentId();',
	1,
	'',
	10423);
INSERT INTO O_TFR
	VALUES (10425,
	10330,
	'getContainerId',
	'',
	296,
	1,
	'// Required Signal Body.getContainerId()
select one requiredSig related by self->SPR_RS[R684];
return requiredSig.getComponentId();',
	1,
	'',
	10424);
INSERT INTO O_TFR
	VALUES (10426,
	10330,
	'getPath',
	'',
	322,
	1,
	'select one requiredSig related by self->SPR_RS[R684];
requiredSigPath ="";
requiredSigName ="";
if (not_empty requiredSig)
  requiredSigName = requiredSig.Name; 
   select one comp related by requiredSig ->SPR_REP[R4502]->C_R[R4500]->C_IR[R4009]->C_PO[R4016]->C_C[R4010];
      requiredSigPath= comp.getPath(includeSelf:true,path:requiredSigName);
end if;
return requiredSigPath;',
	1,
	'',
	10425);
INSERT INTO O_REF
	VALUES (10330,
	10227,
	0,
	10285,
	10317,
	10331,
	10318,
	10427,
	10428,
	0,
	0,
	'',
	'Body',
	'Action_ID',
	'R698');
INSERT INTO O_RATTR
	VALUES (10427,
	10330,
	10285,
	10227,
	1,
	'Action_ID');
INSERT INTO O_ATTR
	VALUES (10427,
	10330,
	0,
	'Action_ID',
	'',
	'',
	'Action_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10330,
	1485,
	0,
	1641,
	10351,
	10353,
	10352,
	10429,
	10430,
	0,
	0,
	'',
	'Required Signal',
	'Id',
	'R684');
INSERT INTO O_RATTR
	VALUES (10429,
	10330,
	267,
	63,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (10429,
	10330,
	10427,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10330);
INSERT INTO O_OIDA
	VALUES (10427,
	10330,
	0,
	'Action_ID');
INSERT INTO O_ID
	VALUES (1,
	10330);
INSERT INTO O_ID
	VALUES (2,
	10330);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10328,
	'Required Operation Body',
	639,
	'ACT_ROB',
	'',
	10191);
INSERT INTO O_TFR
	VALUES (10431,
	10328,
	'dispose',
	'',
	19,
	1,
	'select one act related by self->SPR_RO[R685];
if ( not_empty act )
  unrelate self from act across R685;
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (10432,
	10328,
	'getContainingComponentId',
	'',
	296,
	1,
	'select one requiredOp related by self->SPR_RO[R685];
return requiredOp.getComponentId();',
	1,
	'',
	10431);
INSERT INTO O_TFR
	VALUES (10433,
	10328,
	'getContainerId',
	'',
	296,
	1,
	'// Required Operation Body.getContainerId()
select one requiredOp related by self->SPR_RO[R685];
return requiredOp.getComponentId();',
	1,
	'',
	10432);
INSERT INTO O_TFR
	VALUES (10434,
	10328,
	'getPath',
	'',
	322,
	1,
	'select one requiredOp related by self->SPR_RO[R685];
requiredOpPath ="";
requiredOpName ="";
if (not_empty requiredOp)
  requiredOpName = requiredOp.Name; 
   select one comp related by requiredOp ->SPR_REP[R4502]->C_R[R4500]->C_IR[R4009]->C_PO[R4016]->C_C[R4010];
     requiredOpPath= comp.getPath(includeSelf:true,path:requiredOpName);
end if;
return requiredOpPath;',
	1,
	'',
	10433);
INSERT INTO O_REF
	VALUES (10328,
	10227,
	0,
	10285,
	10317,
	10329,
	10318,
	10435,
	10436,
	0,
	0,
	'',
	'Body',
	'Action_ID',
	'R698');
INSERT INTO O_RATTR
	VALUES (10435,
	10328,
	10285,
	10227,
	1,
	'Action_ID');
INSERT INTO O_ATTR
	VALUES (10435,
	10328,
	0,
	'Action_ID',
	'',
	'',
	'Action_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10328,
	3308,
	0,
	3337,
	10354,
	10356,
	10355,
	10437,
	10438,
	0,
	0,
	'',
	'Required Operation',
	'Id',
	'R685');
INSERT INTO O_RATTR
	VALUES (10437,
	10328,
	267,
	63,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (10437,
	10328,
	10435,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10328);
INSERT INTO O_OIDA
	VALUES (10435,
	10328,
	0,
	'Action_ID');
INSERT INTO O_ID
	VALUES (1,
	10328);
INSERT INTO O_ID
	VALUES (2,
	10328);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10326,
	'Provided Signal Body',
	638,
	'ACT_PSB',
	'',
	10191);
INSERT INTO O_TFR
	VALUES (10439,
	10326,
	'dispose',
	'',
	19,
	1,
	'select one act related by self->SPR_PS[R686];
if ( not_empty act )
  unrelate self from act across R686;
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (10440,
	10326,
	'getContainingComponentId',
	'',
	296,
	1,
	'select one providedSig related by self->SPR_PS[R686];
return providedSig.getComponentId();',
	1,
	'',
	10439);
INSERT INTO O_TFR
	VALUES (10441,
	10326,
	'getContainerId',
	'',
	296,
	1,
	'// Provided Signal Body.getContainerId()
select one providedSig related by self->SPR_PS[R686];
return providedSig.getComponentId();',
	1,
	'',
	10440);
INSERT INTO O_TFR
	VALUES (10442,
	10326,
	'getPath',
	'',
	322,
	1,
	'select one providedSig related by self->SPR_PS[R686];
providedSigPath ="";
providedSigName ="";
if (not_empty providedSig)
  providedSigName = providedSig.Name; 
   select one comp related by providedSig ->SPR_PEP[R4503]->C_P[R4501]->C_IR[R4009]->C_PO[R4016]->C_C[R4010];
     providedSigPath= comp.getPath(includeSelf:true,path:providedSigName);
end if;
return providedSigPath;',
	1,
	'',
	10441);
INSERT INTO O_REF
	VALUES (10326,
	10227,
	0,
	10285,
	10317,
	10327,
	10318,
	10443,
	10444,
	0,
	0,
	'',
	'Body',
	'Action_ID',
	'R698');
INSERT INTO O_RATTR
	VALUES (10443,
	10326,
	10285,
	10227,
	1,
	'Action_ID');
INSERT INTO O_ATTR
	VALUES (10443,
	10326,
	0,
	'Action_ID',
	'',
	'',
	'Action_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10326,
	1483,
	0,
	1637,
	10357,
	10359,
	10358,
	10445,
	10446,
	0,
	0,
	'',
	'Provided Signal',
	'Id',
	'R686');
INSERT INTO O_RATTR
	VALUES (10445,
	10326,
	263,
	61,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (10445,
	10326,
	10443,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10326);
INSERT INTO O_OIDA
	VALUES (10443,
	10326,
	0,
	'Action_ID');
INSERT INTO O_ID
	VALUES (1,
	10326);
INSERT INTO O_ID
	VALUES (2,
	10326);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10324,
	'Provided Operation Body',
	637,
	'ACT_POB',
	'',
	10191);
INSERT INTO O_TFR
	VALUES (10447,
	10324,
	'dispose',
	'',
	19,
	1,
	'select one act related by self->SPR_PO[R687];
if ( not_empty act )
  unrelate self from act across R687;
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (10448,
	10324,
	'getContainingComponentId',
	'',
	296,
	1,
	'select one providedOp related by self->SPR_PO[R687];
return providedOp.getComponentId();',
	1,
	'',
	10447);
INSERT INTO O_TFR
	VALUES (10449,
	10324,
	'getContainerId',
	'',
	296,
	1,
	'// Provided Operation Body.getContainerId()
select one providedOp related by self->SPR_PO[R687];
return providedOp.getComponentId();',
	1,
	'',
	10448);
INSERT INTO O_TFR
	VALUES (10450,
	10324,
	'getPath',
	'',
	322,
	1,
	'select one providedOp related by self->SPR_PO[R687];
providedOpPath ="";
providedOpName ="";
if (not_empty providedOp)
  providedOpName = providedOp.Name; 
   select one comp related by providedOp ->SPR_PEP[R4503]->C_P[R4501]->C_IR[R4009]->C_PO[R4016]->C_C[R4010];
    providedOpPath= comp.getPath(includeSelf:true,path:providedOpName);
     
end if;
return providedOpPath;',
	1,
	'',
	10449);
INSERT INTO O_REF
	VALUES (10324,
	10227,
	0,
	10285,
	10317,
	10325,
	10318,
	10451,
	10452,
	0,
	0,
	'',
	'Body',
	'Action_ID',
	'R698');
INSERT INTO O_RATTR
	VALUES (10451,
	10324,
	10285,
	10227,
	1,
	'Action_ID');
INSERT INTO O_ATTR
	VALUES (10451,
	10324,
	0,
	'Action_ID',
	'',
	'',
	'Action_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10324,
	3306,
	0,
	3334,
	10360,
	10362,
	10361,
	10453,
	10454,
	0,
	0,
	'',
	'Provided Operation',
	'Id',
	'R687');
INSERT INTO O_RATTR
	VALUES (10453,
	10324,
	263,
	61,
	1,
	'Id');
INSERT INTO O_ATTR
	VALUES (10453,
	10324,
	10451,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10324);
INSERT INTO O_OIDA
	VALUES (10451,
	10324,
	0,
	'Action_ID');
INSERT INTO O_ID
	VALUES (1,
	10324);
INSERT INTO O_ID
	VALUES (2,
	10324);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10311,
	'Operation Body',
	635,
	'ACT_OPB',
	'This class represents the action language containing body of an Operation.',
	10191);
INSERT INTO O_TFR
	VALUES (10455,
	10311,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'  select one opb related by self->O_TFR[R696];
  if ( not_empty opb )
    unrelate self from opb across R696;
  end if;
  delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (10456,
	10311,
	'getContainingComponentId',
	'',
	296,
	1,
	'select one op related by self->O_TFR[R696];
return op.getContainingComponentId();',
	1,
	'',
	10455);
INSERT INTO O_TFR
	VALUES (10457,
	10311,
	'getContainerId',
	'',
	296,
	1,
	'// Operation Body.getContainerId()
select one op related by self->O_TFR[R696];
return op.getContainerId();',
	1,
	'',
	10456);
INSERT INTO O_TFR
	VALUES (10458,
	10311,
	'getPath',
	'',
	322,
	1,
	'select one operation related by self->O_TFR[R696];
opPath ="";
opName="";
if (not_empty operation	)
  opName = operation.Name; 
   select one pe_pe related by operation-> O_OBJ[R115]->PE_PE[R8001];
     if(not_empty pe_pe )
     //Is In Generics
      select one pkg related by pe_pe->EP_PKG[R8000];
      opPath= pkg.getPath(path:opName);
     else
      //In specialized 
      select one subSystem related by operation-> O_OBJ[R115]->S_SS[R2];
      opPath = subSystem.getPath(path:opName);    
     end if;
end if;
return opPath;',
	1,
	'',
	10457);
INSERT INTO O_REF
	VALUES (10311,
	10227,
	0,
	10285,
	10317,
	10322,
	10318,
	10459,
	10460,
	0,
	0,
	'',
	'Body',
	'Action_ID',
	'R698');
INSERT INTO O_RATTR
	VALUES (10459,
	10311,
	10285,
	10227,
	1,
	'Action_ID');
INSERT INTO O_ATTR
	VALUES (10459,
	10311,
	0,
	'Action_ID',
	'',
	'',
	'Action_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10311,
	43,
	0,
	201,
	10309,
	10312,
	10310,
	10461,
	10462,
	0,
	0,
	'',
	'Operation',
	'Tfr_ID',
	'R696');
INSERT INTO O_RATTR
	VALUES (10461,
	10311,
	201,
	43,
	1,
	'Tfr_ID');
INSERT INTO O_ATTR
	VALUES (10461,
	10311,
	10459,
	'Tfr_ID',
	'',
	'',
	'Tfr_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10311);
INSERT INTO O_OIDA
	VALUES (10459,
	10311,
	0,
	'Action_ID');
INSERT INTO O_ID
	VALUES (1,
	10311);
INSERT INTO O_ID
	VALUES (2,
	10311);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10251,
	'If Stmt',
	617,
	'ACT_IF',
	'The class represents an if statement in a block of action language.',
	10191);
INSERT INTO O_TFR
	VALUES (10463,
	10251,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'select one blk related by self->ACT_BLK[R607];
if ( not_empty blk )
  unrelate self from blk across R607;
  blk.dispose();
end if;
select one els related by self->ACT_E[R683];
if (not_empty els)
  unrelate self from els across R683;
end if;
select one stmt related by self->ACT_SMT[R603];
if (not_empty stmt)
  unrelate self from stmt across R603;
end if;
select many elfs related by self->ACT_EL[R682];
for each elf in elfs
  unrelate self from elf across R682;
end for;
select one val related by self->V_VAL[R625];
if ( not_empty val )
  unrelate self from val across R625;
  val.dispose();
end if;

select one exec_elif_stmt related by self->ACT_EL[R690];
if(not_empty exec_elif_stmt)
  unrelate self from exec_elif_stmt across R690; 
end if;  
      
select one exec_else_stmt related by self->ACT_E[R692];
if(not_empty exec_else_stmt)
  unrelate self from exec_else_stmt across R692; 
end if;  
   
delete object instance self;

',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (10464,
	10251,
	'execute',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	10463);
INSERT INTO O_TPARM
	VALUES (10465,
	10464,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (10251,
	686,
	0,
	685,
	2386,
	10259,
	2388,
	10292,
	10466,
	0,
	0,
	'',
	'Statement',
	'Statement_ID',
	'R603');
INSERT INTO O_RATTR
	VALUES (10292,
	10251,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (10292,
	10251,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10251,
	35,
	0,
	163,
	10250,
	10252,
	10253,
	10467,
	10468,
	0,
	0,
	'',
	'Block',
	'Block_ID',
	'R607.''controls''');
INSERT INTO O_RATTR
	VALUES (10467,
	10251,
	163,
	35,
	1,
	'Block_ID');
INSERT INTO O_ATTR
	VALUES (10467,
	10251,
	10292,
	'Block_ID',
	'',
	'',
	'Block_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10251,
	70,
	0,
	72,
	10274,
	10275,
	10276,
	10469,
	10470,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R625.''test result''');
INSERT INTO O_RATTR
	VALUES (10469,
	10251,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (10469,
	10251,
	10467,
	'Value_ID',
	'

',
	'',
	'Value_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10251,
	10236,
	0,
	10340,
	10337,
	10338,
	10339,
	10471,
	10472,
	0,
	0,
	'',
	'ElseIf Stmt',
	'Statement_ID',
	'R690.''was executing when halted''');
INSERT INTO O_RATTR
	VALUES (10471,
	10251,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (10471,
	10251,
	10469,
	'Elif_Statement_ID',
	'',
	'Elif_',
	'Statement_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10251,
	10243,
	0,
	10344,
	10341,
	10342,
	10343,
	10473,
	10474,
	0,
	0,
	'',
	'Else Stmt',
	'Statement_ID',
	'R692.''was executing when halted''');
INSERT INTO O_RATTR
	VALUES (10473,
	10251,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (10473,
	10251,
	10471,
	'Else_Statement_ID',
	'',
	'Else_',
	'Statement_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10251);
INSERT INTO O_OIDA
	VALUES (10292,
	10251,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	10251);
INSERT INTO O_ID
	VALUES (2,
	10251);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10307,
	'Function Body',
	634,
	'ACT_FNB',
	'This class represents the action language containing body of a Function.',
	10191);
INSERT INTO O_TFR
	VALUES (10475,
	10307,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'  select one fnb related by self->S_SYNC[R695];
  if ( not_empty fnb )
    unrelate self from fnb across R695;
  end if;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (10476,
	10307,
	'getContainingComponentId',
	'',
	296,
	1,
	'select one function related by self->S_SYNC[R695];
return function.getContainingComponentId();',
	1,
	'',
	10475);
INSERT INTO O_TFR
	VALUES (10477,
	10307,
	'getContainerId',
	'',
	296,
	1,
	'// Function Body.getContainerId()
select one function related by self->S_SYNC[R695];
return function.getContainerId();',
	1,
	'',
	10476);
INSERT INTO O_TFR
	VALUES (10478,
	10307,
	'getPath',
	'',
	322,
	1,
	'select one function related by self->S_SYNC[R695];
fnPath ="";
fnName="";
if (not_empty function)
  fnName = function.Name; 
   select one pe_pe related by function ->PE_PE[R8001];
     if(not_empty pe_pe )
     //Is In Generics
      select one pkg related by pe_pe->EP_PKG[R8000];
      fnPath= pkg.getPath(path:fnName);
     else
      //In specialized 
      select one fnPkg related by function->S_FPK[R31];
      fnPath = fnPkg.getPath()+"::"+ fnName;    
     end if;
end if;
return fnPath;',
	1,
	'',
	10477);
INSERT INTO O_REF
	VALUES (10307,
	10227,
	0,
	10285,
	10317,
	10321,
	10318,
	10479,
	10480,
	0,
	0,
	'',
	'Body',
	'Action_ID',
	'R698');
INSERT INTO O_RATTR
	VALUES (10479,
	10307,
	10285,
	10227,
	1,
	'Action_ID');
INSERT INTO O_ATTR
	VALUES (10479,
	10307,
	0,
	'Action_ID',
	'',
	'',
	'Action_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10307,
	8,
	0,
	11,
	10305,
	10308,
	10306,
	10481,
	10482,
	0,
	0,
	'',
	'Function',
	'Sync_ID',
	'R695');
INSERT INTO O_RATTR
	VALUES (10481,
	10307,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (10481,
	10307,
	10479,
	'Sync_ID',
	'',
	'',
	'Sync_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10307);
INSERT INTO O_OIDA
	VALUES (10479,
	10307,
	0,
	'Action_ID');
INSERT INTO O_ID
	VALUES (1,
	10307);
INSERT INTO O_ID
	VALUES (2,
	10307);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10247,
	'For Stmt',
	606,
	'ACT_FOR',
	'The class represents a for statement in a block of action language.',
	10191);
INSERT INTO O_TFR
	VALUES (10483,
	10247,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'select one obj related by self->O_OBJ[R670];
if ( not_empty obj )
  unrelate self from obj across R670;
end if;

select one iter related by self->V_VAR[R614];
if ( not_empty iter )
  unrelate self from iter across R614;
end if;

select one iter_set related by self->V_VAR[R652];
if ( not_empty iter_set )
  unrelate self from iter_set across R652;
end if;

select one blk related by self->ACT_BLK[R605];
if ( not_empty blk )
  unrelate self from blk across R605;
  blk.dispose();
end if;
delete object instance self;

',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (10484,
	10247,
	'execute',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	10483);
INSERT INTO O_TPARM
	VALUES (10485,
	10484,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10486,
	10247,
	'getLocalLoopVarID',
	'',
	296,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return GD::NULL_UNIQUE_ID();',
	1,
	'',
	10484);
INSERT INTO O_TPARM
	VALUES (10487,
	10486,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (10247,
	686,
	0,
	685,
	2386,
	10257,
	2388,
	10488,
	10489,
	0,
	0,
	'',
	'Statement',
	'Statement_ID',
	'R603');
INSERT INTO O_RATTR
	VALUES (10488,
	10247,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (10488,
	10247,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10247,
	35,
	0,
	163,
	10246,
	10248,
	10249,
	10490,
	10491,
	0,
	0,
	'',
	'Block',
	'Block_ID',
	'R605.''controls''');
INSERT INTO O_RATTR
	VALUES (10490,
	10247,
	163,
	35,
	1,
	'Block_ID');
INSERT INTO O_ATTR
	VALUES (10490,
	10247,
	10488,
	'Block_ID',
	'',
	'',
	'Block_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10492,
	10247);
INSERT INTO O_BATTR
	VALUES (10492,
	10247);
INSERT INTO O_ATTR
	VALUES (10492,
	10247,
	10490,
	'is_implicit',
	'Full Name: Is Implicit
Specifies whether the loop instance handle found is being used for the first time in this scope or not.',
	'',
	'is_implicit',
	0,
	316,
	'',
	'');
INSERT INTO O_REF
	VALUES (10247,
	129,
	0,
	131,
	10268,
	10269,
	10270,
	10493,
	10494,
	0,
	0,
	'',
	'Variable',
	'Var_ID',
	'R614.''loop''');
INSERT INTO O_RATTR
	VALUES (10493,
	10247,
	131,
	129,
	1,
	'Var_ID');
INSERT INTO O_ATTR
	VALUES (10493,
	10247,
	10492,
	'Loop_Var_ID',
	'

',
	'Loop_',
	'Var_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10247,
	129,
	0,
	131,
	10287,
	10288,
	10289,
	10495,
	10496,
	0,
	0,
	'',
	'Variable',
	'Var_ID',
	'R652.''set''');
INSERT INTO O_RATTR
	VALUES (10495,
	10247,
	131,
	129,
	1,
	'Var_ID');
INSERT INTO O_ATTR
	VALUES (10495,
	10247,
	10493,
	'Set_Var_ID',
	'

',
	'Set_',
	'Var_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10247,
	30,
	0,
	150,
	10280,
	10281,
	10282,
	10497,
	10498,
	0,
	0,
	'',
	'Model Class',
	'Obj_ID',
	'R670.''iterates a set of''');
INSERT INTO O_RATTR
	VALUES (10497,
	10247,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (10497,
	10247,
	10495,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10247);
INSERT INTO O_OIDA
	VALUES (10488,
	10247,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	10247);
INSERT INTO O_ID
	VALUES (2,
	10247);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10236,
	'ElseIf Stmt',
	622,
	'ACT_EL',
	'The class represents an else if statement in a block of action language.',
	10191);
INSERT INTO O_TFR
	VALUES (10499,
	10236,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.
',
	19,
	1,
	'select one val related by self->V_VAL[R659];
if ( not_empty val )
  unrelate self from val across R659;
  val.dispose();
end if;

select one blk related by self->ACT_BLK[R658];
if ( not_empty blk )
  unrelate self from blk across R658;
  blk.dispose();
end if;
delete object instance self;

',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (10236,
	686,
	0,
	685,
	2386,
	10260,
	2388,
	10340,
	10500,
	0,
	0,
	'',
	'Statement',
	'Statement_ID',
	'R603');
INSERT INTO O_RATTR
	VALUES (10340,
	10236,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (10340,
	10236,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10236,
	35,
	0,
	163,
	10234,
	10237,
	10235,
	10501,
	10502,
	0,
	0,
	'',
	'Block',
	'Block_ID',
	'R658');
INSERT INTO O_RATTR
	VALUES (10501,
	10236,
	163,
	35,
	1,
	'Block_ID');
INSERT INTO O_ATTR
	VALUES (10501,
	10236,
	10340,
	'Block_ID',
	'',
	'',
	'Block_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10236,
	70,
	0,
	72,
	10277,
	10278,
	10279,
	10503,
	10504,
	0,
	0,
	'',
	'Value',
	'Value_ID',
	'R659');
INSERT INTO O_RATTR
	VALUES (10503,
	10236,
	72,
	70,
	1,
	'Value_ID');
INSERT INTO O_ATTR
	VALUES (10503,
	10236,
	10501,
	'Value_ID',
	'

',
	'',
	'Value_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10236,
	10251,
	0,
	10292,
	10290,
	10293,
	10291,
	10505,
	10506,
	0,
	0,
	'',
	'If Stmt',
	'Statement_ID',
	'R682');
INSERT INTO O_RATTR
	VALUES (10505,
	10236,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (10505,
	10236,
	10503,
	'If_Statement_ID',
	'

',
	'If_',
	'Statement_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10236);
INSERT INTO O_OIDA
	VALUES (10340,
	10236,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	10236);
INSERT INTO O_ID
	VALUES (2,
	10236);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10243,
	'Else Stmt',
	610,
	'ACT_E',
	'The class represents an else statement in a block of action language.',
	10191);
INSERT INTO O_TFR
	VALUES (10507,
	10243,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.
',
	19,
	1,
	'select one blk related by self->ACT_BLK[R606];
if ( not_empty blk )
  unrelate self from blk across R606;
  blk.dispose();
end if;
select one ifstmt related by self->ACT_IF[R683];
if (not_empty ifstmt)
  unrelate self from ifstmt across R683;
end if;
select one stmt related by self->ACT_SMT[R603];
if (not_empty stmt)
 unrelate self from stmt across R603;
end if;
delete object instance self;

',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (10243,
	686,
	0,
	685,
	2386,
	10261,
	2388,
	10344,
	10508,
	0,
	0,
	'',
	'Statement',
	'Statement_ID',
	'R603');
INSERT INTO O_RATTR
	VALUES (10344,
	10243,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (10344,
	10243,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10243,
	35,
	0,
	163,
	10242,
	10244,
	10245,
	10509,
	10510,
	0,
	0,
	'',
	'Block',
	'Block_ID',
	'R606');
INSERT INTO O_RATTR
	VALUES (10509,
	10243,
	163,
	35,
	1,
	'Block_ID');
INSERT INTO O_ATTR
	VALUES (10509,
	10243,
	10344,
	'Block_ID',
	'',
	'',
	'Block_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10243,
	10251,
	0,
	10292,
	10294,
	10296,
	10295,
	10511,
	10512,
	0,
	0,
	'',
	'If Stmt',
	'Statement_ID',
	'R683');
INSERT INTO O_RATTR
	VALUES (10511,
	10243,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (10511,
	10243,
	10509,
	'If_Statement_ID',
	'

',
	'If_',
	'Statement_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10243);
INSERT INTO O_OIDA
	VALUES (10344,
	10243,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	10243);
INSERT INTO O_ID
	VALUES (2,
	10243);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10303,
	'Derived Attribute Body',
	633,
	'ACT_DAB',
	'This class represents the action language containing body of a derived attribute.',
	10191);
INSERT INTO O_TFR
	VALUES (10513,
	10303,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'  select one dab related by self->O_DBATTR[R693];
  if ( not_empty dab )
    unrelate self from dab across R693;
  end if;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (10514,
	10303,
	'getContainingComponentId',
	'',
	296,
	1,
	'select one clazz related by self->O_DBATTR[R693]->O_BATTR[R107]->O_ATTR[R106]
                                                                  ->O_OBJ[R102];
return clazz.getContainingComponentId();',
	1,
	'',
	10513);
INSERT INTO O_TFR
	VALUES (10515,
	10303,
	'getContainerId',
	'',
	296,
	1,
	'// Derived Attribute Body.getContainerId()
select one clazz related by self->O_DBATTR[R693]->O_BATTR[R107]->O_ATTR[R106]
                                                                  ->O_OBJ[R102];
return clazz.getContainerId();',
	1,
	'',
	10514);
INSERT INTO O_TFR
	VALUES (10516,
	10303,
	'getPath',
	'',
	322,
	1,
	'select one attribute related by self->O_DBATTR[R693];
attrPath ="";
attrName="";
if (not_empty attribute	)
  select one attr related by attribute->O_BATTR[R107]->O_ATTR[R106];
  attrName = attr.Name; 
   select one pe_pe related by attr-> O_OBJ[R102]->PE_PE[R8001];
     if(not_empty pe_pe )
     //Is In Generics
      select one pkg related by pe_pe->EP_PKG[R8000];
      attrPath= pkg.getPath(path:attrName);
     else
      //In specialized 
      select one subSystem related by attr-> O_OBJ[R102]->S_SS[R2];
      attrPath = subSystem.getPath(path:attrName);    
     end if;
end if;
return attrPath;',
	1,
	'',
	10515);
INSERT INTO O_REF
	VALUES (10303,
	10227,
	0,
	10285,
	10317,
	10320,
	10318,
	10517,
	10518,
	0,
	0,
	'',
	'Body',
	'Action_ID',
	'R698');
INSERT INTO O_RATTR
	VALUES (10517,
	10303,
	10285,
	10227,
	1,
	'Action_ID');
INSERT INTO O_ATTR
	VALUES (10517,
	10303,
	0,
	'Action_ID',
	'',
	'',
	'Action_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10303,
	1023,
	0,
	1366,
	10301,
	10304,
	10302,
	10519,
	10520,
	0,
	0,
	'',
	'Derived Base Attribute',
	'Attr_ID',
	'R693');
INSERT INTO O_RATTR
	VALUES (10519,
	10303,
	168,
	37,
	1,
	'Attr_ID');
INSERT INTO O_ATTR
	VALUES (10519,
	10303,
	10521,
	'Attr_ID',
	'',
	'',
	'Attr_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10522,
	10303);
INSERT INTO O_BATTR
	VALUES (10522,
	10303);
INSERT INTO O_ATTR
	VALUES (10522,
	10303,
	10519,
	'AttributeWritten',
	'This attribute is used by the parser to indicate that the
derived attribute value has been written to by the activity associated
with the attribute.
---------------------------------------------------------------------
Bridge:ALS
',
	'',
	'AttributeWritten',
	0,
	316,
	'',
	'');
INSERT INTO O_REF
	VALUES (10303,
	1023,
	0,
	1369,
	10301,
	10304,
	10302,
	10521,
	10523,
	0,
	0,
	'',
	'Derived Base Attribute',
	'Obj_ID',
	'R693');
INSERT INTO O_RATTR
	VALUES (10521,
	10303,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (10521,
	10303,
	10517,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10303);
INSERT INTO O_OIDA
	VALUES (10517,
	10303,
	0,
	'Action_ID');
INSERT INTO O_ID
	VALUES (1,
	10303);
INSERT INTO O_ID
	VALUES (2,
	10303);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10262,
	'Control',
	628,
	'ACT_CTL',
	'This class generates a control statement within a block.',
	10191);
INSERT INTO O_TFR
	VALUES (10524,
	10262,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'// do nothing
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (10525,
	10262,
	'execute',
	'',
	19,
	1,
	'// Control Statement.execute

// Do nothing.

// This statement is required to cause Verifier to suspend, but doing it here
// stops on the _next_ statement, not the current one. This particularly ugly
// because control stop is frequently the last statement in an action, so the
// halt occurs outside the OAL that caused it. Hence, the implementation of
// this behavior is found in Statement.checkBreakpoint where we have control
// (in Stack.execute, the caller) over whether we execute the statement or not.',
	1,
	'',
	10524);
INSERT INTO O_TPARM
	VALUES (10526,
	10525,
	'stack_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (10262,
	686,
	0,
	685,
	2386,
	10263,
	2388,
	10527,
	10528,
	0,
	0,
	'',
	'Statement',
	'Statement_ID',
	'R603');
INSERT INTO O_RATTR
	VALUES (10527,
	10262,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (10527,
	10262,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10262);
INSERT INTO O_OIDA
	VALUES (10527,
	10262,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	10262);
INSERT INTO O_ID
	VALUES (2,
	10262);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10266,
	'Continue',
	630,
	'ACT_CON',
	'This class generates a continue statement within a block.',
	10191);
INSERT INTO O_TFR
	VALUES (10529,
	10266,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'// do nothing
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (10530,
	10266,
	'execute',
	'This operation will cause all blocks to stop executing until the originating for each or while loop is found.',
	19,
	1,
	'// Body:Continue.execute()

// WARNING: This function assumes that break and continue statements can only
//          exist within a for each or while loop. If a break or continue
//          statement exists somewhere else, an infinite loop will occur.

// Find the potentially nested block that is controlled by a for each or a
// while loop

found_loop_block = FALSE;
select one containing_block related by self->ACT_SMT[R603]->ACT_BLK[R602];

while (found_loop_block == FALSE)

  // Tell each block of OAL to stop executing up to the originating for each
  // or while loop containing_block.exitBlock();  

  // Test if break was called within a for loop
  select one for_statement related by containing_block->ACT_FOR[R605];
  if (not_empty for_statement)
    select one containing_block related by for_statement->
                                                   ACT_SMT[R603]->ACT_BLK[R602];
    found_loop_block = TRUE;  
  else
    // See if break was called within a while loop
    select one while_statement related by containing_block->ACT_WHL[R608];
    if (not_empty while_statement)
      select one containing_block related by while_statement->
                                                   ACT_SMT[R603]->ACT_BLK[R602];
      found_loop_block = TRUE;
    else 
  
      // This block isn''t the source of the while or for loop.
      //  Find a nested control structure block.
      select one if_statement related by containing_block->ACT_IF[R607];
      select one elif_statement related by containing_block->ACT_EL[R658];
      select one else_statement related by containing_block->ACT_E[R606];
    
      if (not_empty if_statement)
        select one containing_block related by if_statement->
                                                   ACT_SMT[R603]->ACT_BLK[R602];
      elif (not_empty elif_statement)
        select one containing_block related by elif_statement->
                                                   ACT_SMT[R603]->ACT_BLK[R602];
      elif (not_empty else_statement)
        select one containing_block related by else_statement->
                                                   ACT_SMT[R603]->ACT_BLK[R602];
      end if;
    end if;
  end if;
end while;

// Abandon all processing in all blocks below the loop block
select one statement related by self->ACT_SMT[R603];
statement.popUpToBlock(block_id:containing_block.Block_ID,
                                           stack_frame_id:param.stack_frame_id);
',
	1,
	'',
	10529);
INSERT INTO O_TPARM
	VALUES (10531,
	10530,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (10266,
	686,
	0,
	685,
	2386,
	10267,
	2388,
	10532,
	10533,
	0,
	0,
	'',
	'Statement',
	'Statement_ID',
	'R603');
INSERT INTO O_RATTR
	VALUES (10532,
	10266,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (10532,
	10266,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10266);
INSERT INTO O_OIDA
	VALUES (10532,
	10266,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	10266);
INSERT INTO O_ID
	VALUES (2,
	10266);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10315,
	'Bridge Body',
	636,
	'ACT_BRB',
	'This class represents the action language containing body of a Bridge.',
	10191);
INSERT INTO O_TFR
	VALUES (10534,
	10315,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'  select one brb related by self->S_BRG[R697];
  if ( not_empty brb )
    unrelate self from brb across R697;
  end if;
  delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (10535,
	10315,
	'getContainingComponentId',
	'',
	296,
	1,
	'select one brg related by self->S_BRG[R697];
return brg.getContainingComponentId();',
	1,
	'',
	10534);
INSERT INTO O_TFR
	VALUES (10536,
	10315,
	'getContainerId',
	'',
	296,
	1,
	'// Bridge Body.getContainerId()
select one brg related by self->S_BRG[R697];
return brg.getContainerId();',
	1,
	'',
	10535);
INSERT INTO O_TFR
	VALUES (10537,
	10315,
	'getPath',
	'',
	322,
	1,
	'select one brdg related by self->S_BRG[R697];
brdgPath =""; 
brdgName="";
if (not_empty brdg)
  brdgName = brdg.Name; 
   select one pe_pe related by brdg ->S_EE[R19]->PE_PE[R8001];
     if(not_empty pe_pe )
     //Is In Generics
      select one pkg related by pe_pe->EP_PKG[R8000];
      brdgPath= pkg.getPath(path:brdgName);
     else
      //In specialized 
      select one eePkg related by brdg->S_EE[R19]->S_EEPK[R33];
      brdgPath = eePkg.getPath()+"::"+ brdgName;    
     end if;
end if;
return brdgPath;',
	1,
	'',
	10536);
INSERT INTO O_REF
	VALUES (10315,
	10227,
	0,
	10285,
	10317,
	10323,
	10318,
	10538,
	10539,
	0,
	0,
	'',
	'Body',
	'Action_ID',
	'R698');
INSERT INTO O_RATTR
	VALUES (10538,
	10315,
	10285,
	10227,
	1,
	'Action_ID');
INSERT INTO O_ATTR
	VALUES (10538,
	10315,
	0,
	'Action_ID',
	'',
	'',
	'Action_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10315,
	6,
	0,
	16,
	10313,
	10316,
	10314,
	10540,
	10541,
	0,
	0,
	'',
	'Bridge',
	'Brg_ID',
	'R697');
INSERT INTO O_RATTR
	VALUES (10540,
	10315,
	16,
	6,
	1,
	'Brg_ID');
INSERT INTO O_ATTR
	VALUES (10540,
	10315,
	10538,
	'Brg_ID',
	'',
	'',
	'Brg_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10315);
INSERT INTO O_OIDA
	VALUES (10538,
	10315,
	0,
	'Action_ID');
INSERT INTO O_ID
	VALUES (1,
	10315);
INSERT INTO O_ID
	VALUES (2,
	10315);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10264,
	'Break',
	629,
	'ACT_BRK',
	'This class generates a break statement within a block.',
	10191);
INSERT INTO O_TFR
	VALUES (10542,
	10264,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.
',
	19,
	1,
	'// do nothing
delete object instance self;

',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (10543,
	10264,
	'execute',
	'// WARNING: This function assumes that break and continue statements can only exist within a for each or while loop.
//          If a break or continue statement exists somewhere else, an infinite loop will occur.
',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	10542);
INSERT INTO O_TPARM
	VALUES (10544,
	10543,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (10264,
	686,
	0,
	685,
	2386,
	10265,
	2388,
	10545,
	10546,
	0,
	0,
	'',
	'Statement',
	'Statement_ID',
	'R603');
INSERT INTO O_RATTR
	VALUES (10545,
	10264,
	685,
	686,
	1,
	'Statement_ID');
INSERT INTO O_ATTR
	VALUES (10545,
	10264,
	0,
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10264);
INSERT INTO O_OIDA
	VALUES (10545,
	10264,
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	10264);
INSERT INTO O_ID
	VALUES (2,
	10264);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10374,
	'Body in Element',
	644,
	'ACT_BIE',
	'Convenience class to allow a Body instance to quickly locate its container.
------------------------
Persistent:false',
	10191);
INSERT INTO O_REF
	VALUES (10374,
	10227,
	0,
	10285,
	10371,
	10375,
	10372,
	10547,
	10548,
	0,
	0,
	'',
	'Body',
	'Action_ID',
	'R640');
INSERT INTO O_RATTR
	VALUES (10547,
	10374,
	10285,
	10227,
	1,
	'Action_ID');
INSERT INTO O_ATTR
	VALUES (10547,
	10374,
	10549,
	'Action_ID',
	'',
	'',
	'Action_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10374,
	26,
	0,
	25,
	10371,
	10375,
	10373,
	10549,
	10550,
	0,
	0,
	'',
	'Packageable Element',
	'Element_ID',
	'R640');
INSERT INTO O_RATTR
	VALUES (10549,
	10374,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (10549,
	10374,
	0,
	'Element_ID',
	'',
	'',
	'Element_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10374);
INSERT INTO O_OIDA
	VALUES (10547,
	10374,
	0,
	'Action_ID');
INSERT INTO O_OIDA
	VALUES (10549,
	10374,
	0,
	'Element_ID');
INSERT INTO O_ID
	VALUES (1,
	10374);
INSERT INTO O_ID
	VALUES (2,
	10374);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10366,
	'Body in Component',
	642,
	'ACT_BIC',
	'Convenience class to allow a Body instance to quickly locate its component.
------------------------
Persistent:false',
	10191);
INSERT INTO O_REF
	VALUES (10366,
	10227,
	0,
	10285,
	10363,
	10367,
	10365,
	10551,
	10552,
	0,
	0,
	'',
	'Body',
	'Action_ID',
	'R694');
INSERT INTO O_RATTR
	VALUES (10551,
	10366,
	10285,
	10227,
	1,
	'Action_ID');
INSERT INTO O_ATTR
	VALUES (10551,
	10366,
	10553,
	'Action_ID',
	'',
	'',
	'Action_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10366,
	709,
	0,
	762,
	10363,
	10367,
	10364,
	10553,
	10554,
	0,
	0,
	'',
	'Component',
	'Id',
	'R694');
INSERT INTO O_RATTR
	VALUES (10553,
	10366,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (10553,
	10366,
	0,
	'Component_Id',
	'',
	'Component_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10366);
INSERT INTO O_OIDA
	VALUES (10551,
	10366,
	0,
	'Action_ID');
INSERT INTO O_OIDA
	VALUES (10553,
	10366,
	0,
	'Component_Id');
INSERT INTO O_ID
	VALUES (1,
	10366);
INSERT INTO O_ID
	VALUES (2,
	10366);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10227,
	'Body',
	601,
	'ACT_ACT',
	'This class represents the action, whether it be a state action, operation or function body etc.

An Action consists of a number of statements scoped into one or more nested Blocks.',
	10191);
INSERT INTO O_TFR
	VALUES (10555,
	10227,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	19,
	1,
	'self.clear_blocks();      // parsed blocks
self.clear_live_blocks(); // executable blocks

select one sab related by self->ACT_SAB[R698];
if ( not_empty sab )	
  unrelate self from sab across R698;
  sab.dispose();
end if;

select one tab related by self->ACT_TAB[R698];
if not_empty tab
  unrelate self from tab across R698;
  tab.dispose();
end if;

select one dab related by self->ACT_DAB[R698];
if ( not_empty dab )	
  unrelate self from dab across R698;
  dab.dispose();
end if;

select one fnb related by self->ACT_FNB[R698];
if ( not_empty fnb )	
  unrelate self from fnb across R698;
  fnb.dispose();
end if;

select one opb related by self->ACT_OPB[R698];
if ( not_empty opb )	
  unrelate self from opb across R698;
  opb.dispose();
end if;

select one psb related by self->ACT_PSB[R698];
if(not_empty psb)
  unrelate self from psb across R698;
  psb.dispose();
end if;

select one pob related by self->ACT_POB[R698];
if(not_empty pob)
  unrelate self from pob across R698;
  pob.dispose();
end if;

select one rsb related by self->ACT_RSB[R698];
if(not_empty rsb)
  unrelate self from rsb across R698;
  rsb.dispose();
end if;

select one rob related by self->ACT_ROB[R698];
if(not_empty rob)
  unrelate self from rob across R698;
  rob.dispose();
end if;

select one brb related by self->ACT_BRB[R698];
if ( not_empty brb )	
  unrelate self from brb across R698;
  brb.dispose();
end if;

select one blk related by self->ACT_BLK[R699];
if ( not_empty blk )
  unrelate self from blk across R699;
end if;

select one comp related by self->ACT_BIC[R694]->C_C[R694];
if not_empty comp
  select one bic related by self->ACT_BIC[R694];
  unrelate self from comp across R694 using bic;
  delete object instance bic;
end if;

select one pe related by self->ACT_BIE[R640]->PE_PE[R640];
if not_empty pe
  select one bie related by self->ACT_BIE[R640];
  unrelate self from pe across R640 using bie;
  delete object instance bie;
end if;
delete object instance self;
',
	1,
	'',
	10556);
INSERT INTO O_TFR
	VALUES (10557,
	10227,
	'entered_loop',
	'This operation is called during parsing each time a loop (for or while) is entered.
-----------------------------------------------------------------------------------
Bridge:ALS
',
	19,
	1,
	'self.LoopLevel = self.LoopLevel + 1;
',
	1,
	'',
	10555);
INSERT INTO O_TFR
	VALUES (10558,
	10227,
	'exitted_loop',
	'This operation is called during parsing each time a loop (for or while) is exitted.
-----------------------------------------------------------------------------------
Bridge:ALS',
	19,
	1,
	'self.LoopLevel = self.LoopLevel - 1;
',
	1,
	'',
	10557);
INSERT INTO O_TFR
	VALUES (10559,
	10227,
	'in_loop',
	'This operation is called during parsing to determine if the current statement is inside of a loop.
-----------------------------------------------------------------------------------
Bridge:ALS',
	316,
	1,
	'return self.LoopLevel > 0;
',
	1,
	'',
	10560);
INSERT INTO O_TFR
	VALUES (10561,
	10227,
	'self_is_valid',
	'This operation returns true if the variable ''self'' can be referenced in this body.
-----------------------------------------------------------------------------------
Bridge:ALS',
	316,
	1,
	'select one op related by self->ACT_OPB[R698]->O_TFR[R696];
if not_empty op
  if op.Instance_Based == Scope::Instance
    return true;
  end if;
else
  select one sm_act related by self->ACT_SAB[R698]->SM_ACT[R691];
  if empty sm_act
    select one sm_act related by self->ACT_TAB[R698]->SM_ACT[R688];
  end if;
  if not_empty sm_act
    select one ism related by sm_act->SM_SM[R515]->SM_ISM[R517];
    if not_empty ism
      return true;
    end if;
  else
    select one dab related by self->ACT_DAB[R698]->O_DBATTR[R693];
    if not_empty dab
      return true;
    end if;
  end if;
end if;

return false;',
	1,
	'',
	10562);
INSERT INTO O_TFR
	VALUES (10563,
	10227,
	'clear_blocks',
	'This operation removes all Block instances related to this instance.',
	19,
	1,
	'self.LoopLevel = 0;
select one first_block related by self->ACT_BLK[R650];
if ( not_empty first_block )
   unrelate self from first_block across R650;
end if;

select many block_set related by self->ACT_BLK[R612];
for each block in block_set
  unrelate self from block across R612;
  block.dispose();
end for;',
	1,
	'',
	10564);
INSERT INTO O_TFR
	VALUES (10562,
	10227,
	'return_is_required',
	'',
	316,
	1,
	'select one fnb related by self->ACT_FNB[R698];
if ( not_empty fnb )	
  select one sync related by fnb->S_SYNC[R695];
  select one dt related by sync->S_DT[R25];
  if ( dt.Name != "void" )
    return true;
  end if;
else
  select one opb related by self->ACT_OPB[R698];
  if ( not_empty opb )	
    select one op related by opb->O_TFR[R696];
    select one dt related by op->S_DT[R116];
    if ( dt.Name != "void" )
      return true;
    end if;
  else
    select one brb related by self->ACT_BRB[R698];
    if ( not_empty brb )	
      select one brg related by brb->S_BRG[R697];
      select one dt related by brg->S_DT[R20];
      if ( dt.Name != "void" )
        return true;
      end if;
    else
      select one rqOpB related by self->ACT_ROB[R698];
      if not_empty rqOpB
        select one dt related by rqOpB->SPR_RO[R685]->SPR_REP[R4502]->
                                          C_EP[R4500]->C_IO[R4004]->S_DT[R4008];
        if ( dt.Name != "void" )
          return true;
        end if;
      else
        select one prOpB related by self->ACT_POB[R698];
        if not_empty prOpB
          select one dt related by prOpB->SPR_PO[R687]->SPR_PEP[R4503]->
                                          C_EP[R4501]->C_IO[R4004]->S_DT[R4008];
          if ( dt.Name != "void" )
            return true;
          end if;
        end if;
      end if;
    end if;
  end if;
end if;
return false;
',
	1,
	'',
	10565);
INSERT INTO O_TFR
	VALUES (10566,
	10227,
	'createStackFrame',
	'',
	296,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return GD::NULL_UNIQUE_ID(); ',
	1,
	'',
	10567);
INSERT INTO O_TPARM
	VALUES (10568,
	10566,
	'stack_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (10569,
	10566,
	'enqueue',
	316,
	0,
	'',
	10568,
	'');
INSERT INTO O_TPARM
	VALUES (10570,
	10566,
	'invoking_stack_frame_or_component_id',
	296,
	0,
	'',
	10569,
	'');
INSERT INTO O_TFR
	VALUES (10571,
	10227,
	'deleteStackFrame',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	10572);
INSERT INTO O_TPARM
	VALUES (10573,
	10571,
	'stack_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10574,
	10227,
	'createStackFrameForBridge',
	'Called to create an initial stack frame for execution of a funtion wired to a bridge in another model.',
	296,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return GD::NULL_UNIQUE_ID(); ',
	1,
	'',
	10566);
INSERT INTO O_TPARM
	VALUES (10575,
	10574,
	'stack_frame_id_caller',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10556,
	10227,
	'deleteStackFrameForBridge',
	'Called to delete an initial stack frame used for execution of a funtion wired to a bridge in another model.',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	10571);
INSERT INTO O_TPARM
	VALUES (10576,
	10556,
	'stack_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10572,
	10227,
	'deleteStackForBridge',
	'Called to delete a temporary stack used for execution of a funtion wired to a bridge in another model.',
	19,
	1,
	'',
	1,
	'',
	10577);
INSERT INTO O_TPARM
	VALUES (10578,
	10572,
	'stack_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10565,
	10227,
	'initialize',
	'',
	19,
	1,
	'// Body.initialize()
// First destroy all the old blocks
select one block related by self->ACT_BLK[R666];
if (not_empty block)
  unrelate self from block across R666;
end if;
select many blocks related by self->ACT_BLK[R601];
for each block in blocks
  unrelate self from block across R601;
  block.dispose();
end for;
// Now move new blocks from parse associations
// verifier associations ready for execution
select one block related by self->ACT_BLK[R650];
if (not_empty block)
  unrelate self from block across R650;
  relate self to block across R666;
end if;
select many blocks related by self->ACT_BLK[R612];
for each block in blocks
  unrelate self from block across R612;
  relate self to block across R601;
  block.initialize();
end for;',
	1,
	'',
	10559);
INSERT INTO O_TFR
	VALUES (10579,
	10227,
	'clear_live_blocks',
	'',
	19,
	1,
	'self.LoopLevel = 0;
select one first_block related by self->ACT_BLK[R666];
if ( not_empty first_block )
   unrelate self from first_block across R666;
end if;

select many block_set related by self->ACT_BLK[R601];
for each block in block_set
  unrelate self from block across R601;
  block.dispose();
end for;',
	1,
	'',
	10563);
INSERT INTO O_TFR
	VALUES (10564,
	10227,
	'associateWithOwningComponent',
	'',
	19,
	1,
	'// associateWithOwningComponent()
select one component related by self->ACT_BIC[R694]->C_C[R694];
if empty component
  // The component for a body will not change once,
  // established. So compute it only once
  id = self.getContainingComponentId();
  // the body will live in the same model-root as the component,
  // therefore it is safe to use a from instances selection
  select any component from instances of C_C where (selected.Id == id);
  if not_empty component
    create object instance bic of ACT_BIC;
    relate self to component across R694 using bic;
  end if;
end if;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (10567,
	10227,
	'createStackForSignal',
	'',
	296,
	1,
	'return GD::NULL_UNIQUE_ID();',
	1,
	'',
	10580);
INSERT INTO O_TPARM
	VALUES (10581,
	10567,
	'execution_engine_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10577,
	10227,
	'createStackFrameForMessage',
	'',
	296,
	1,
	'// Body:Body.createStackFrameForMessage
frame_id = self.createStackFrame(stack_id:param.stack_id, enqueue: false,
                     invoking_stack_frame_or_component_id:GD::NULL_UNIQUE_ID());
self.startStackFrameForMessage(stackframe_id:frame_id);
return frame_id;',
	1,
	'',
	10574);
INSERT INTO O_TPARM
	VALUES (10582,
	10577,
	'stack_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10583,
	10227,
	'createStackAndFrameForSignal',
	'',
	296,
	1,
	'// create a stack and frame for signal
// execution
stack_id = self.createStackForSignal(
    execution_engine_id:param.execution_engine_id);
frame_id = self.createStackFrameForMessage(stack_id:stack_id);
return stack_id;',
	1,
	'',
	10579);
INSERT INTO O_TPARM
	VALUES (10584,
	10583,
	'execution_engine_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10560,
	10227,
	'getContainingComponentId',
	'',
	296,
	1,
	'select one rsb related by self->ACT_RSB[R698];
select one rob related by self->ACT_ROB[R698];
select one psb related by self->ACT_PSB[R698];
select one pob related by self->ACT_POB[R698];
select one tab related by self->ACT_TAB[R698];
select one sab related by self->ACT_SAB[R698];
select one dab related by self->ACT_DAB[R698];
select one fnb related by self->ACT_FNB[R698];
select one opb related by self->ACT_OPB[R698];
select one brb related by self->ACT_BRB[R698];
if(not_empty rsb)
  return rsb.getContainingComponentId();
elif(not_empty rob)
  return rob.getContainingComponentId();
elif(not_empty psb)
  return psb.getContainingComponentId();
elif(not_empty pob)
  return pob.getContainingComponentId();
elif(not_empty tab)
  return tab.getContainingComponentId();
elif(not_empty sab)
  return sab.getContainingComponentId();
elif(not_empty dab)
  return dab.getContainingComponentId();
elif(not_empty fnb)
  return fnb.getContainingComponentId();
elif(not_empty opb)
  return opb.getContainingComponentId();
elif(not_empty brb)
  return brb.getContainingComponentId();
end if;
return GD::NULL_UNIQUE_ID();',
	1,
	'',
	10558);
INSERT INTO O_TFR
	VALUES (10580,
	10227,
	'createStackForBridge',
	'Called to create a temporary stack for execution of a funtion wired to a bridge in another model.',
	296,
	1,
	'// Body:Body.createStackForBridge 

return GD::NULL_UNIQUE_ID();',
	1,
	'',
	10583);
INSERT INTO O_TFR
	VALUES (10585,
	10227,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'// just return this instance as an Object
return this;',
	0,
	'',
	10561);
INSERT INTO O_TFR
	VALUES (10586,
	10227,
	'startStackFrameForMessage',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation
',
	1,
	'',
	10585);
INSERT INTO O_TPARM
	VALUES (10587,
	10586,
	'stackframe_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10588,
	10227,
	'associateWithContainer',
	'',
	316,
	1,
	'// Body.associateWithContainer()
select one container related by self->ACT_BIE[R640]->PE_PE[R640];
if empty container
  // The component for a body will not change once,
  // established. So compute it only once
  id = self.getContainerId();
  // the body will live in the same model-root as the component,
  // therefore it is safe to use a from instances selection
  select any container from instances of PE_PE where (selected.Element_ID == id);
  if not_empty container
    create object instance bie of ACT_BIE;
    relate self to container across R640 using bie;
  else
    return false;
  end if;
end if;
return true;',
	1,
	'',
	10586);
INSERT INTO O_TFR
	VALUES (10589,
	10227,
	'getContainerId',
	'',
	296,
	1,
	'// Body.getContainerId()
select one rsb related by self->ACT_RSB[R698];
select one rob related by self->ACT_ROB[R698];
select one psb related by self->ACT_PSB[R698];
select one pob related by self->ACT_POB[R698];
select one tab related by self->ACT_TAB[R698];
select one sab related by self->ACT_SAB[R698];
select one dab related by self->ACT_DAB[R698];
select one fnb related by self->ACT_FNB[R698];
select one opb related by self->ACT_OPB[R698];
select one brb related by self->ACT_BRB[R698];
if(not_empty rsb)
  return rsb.getContainerId();
elif(not_empty rob)
  return rob.getContainerId();
elif(not_empty psb)
  return psb.getContainerId();
elif(not_empty pob)
  return pob.getContainerId();
elif(not_empty tab)
  return tab.getContainerId();
elif(not_empty sab)
  return sab.getContainerId();
elif(not_empty dab)
  return dab.getContainerId();
elif(not_empty fnb)
  return fnb.getContainerId();
elif(not_empty opb)
  return opb.getContainerId();
elif(not_empty brb)
  return brb.getContainerId();
end if;
return GD::NULL_UNIQUE_ID();',
	1,
	'',
	10588);
INSERT INTO O_TFR
	VALUES (10590,
	10227,
	'getPath',
	'',
	322,
	1,
	'//Route to the proper getPath() method
resultPath="<Path is not available in getPath()>";

select one functionBody related by self->ACT_FNB[R698]; 
select one stateActionBody related by self->ACT_SAB[R698];
select one derivedAttributeBody related by self->ACT_DAB[R698];
select one operationBody  related by self->ACT_OPB[R698];
select one bridgeBody related by self->ACT_BRB[R698];
select one providedOperationBody related by self-> ACT_POB[R698];
select one providedSignalBody related by self->ACT_PSB[R698];
select one requiredOperationBody related by self->ACT_ROB[R698];
select one requiredSignalBody related by self-> ACT_RSB[R698];
select one transitionActionBody related by self->ACT_TAB[R698]; 

if (not_empty functionBody)
resultPath = functionBody.getPath();

elif (not_empty stateActionBody )
resultPath = stateActionBody.getPath();

elif (not_empty derivedAttributeBody )
resultPath = derivedAttributeBody.getPath();

elif (not_empty operationBody )
resultPath = operationBody.getPath();

elif (not_empty bridgeBody)
resultPath = bridgeBody.getPath();

elif (not_empty providedOperationBody)
resultPath = providedOperationBody.getPath();

elif (not_empty providedSignalBody )
resultPath = providedSignalBody.getPath();

elif (not_empty requiredOperationBody )
resultPath = requiredOperationBody.getPath();

elif (not_empty requiredSignalBody)
resultPath =requiredSignalBody.getPath();

elif (not_empty transitionActionBody )
resultPath =  transitionActionBody.getPath();

end if;


return resultPath;',
	1,
	'',
	10589);
INSERT INTO O_TFR
	VALUES (10591,
	10227,
	'isInitialized',
	'',
	316,
	1,
	'select one outerblock related by self->ACT_BLK[R666];
if (not_empty outerblock)
  return true;
end if;
select any block related by self->ACT_BLK[R601];
if (not_empty block)
  return true;
end if;
return false;

',
	1,
	'',
	10590);
INSERT INTO O_NBATTR
	VALUES (10285,
	10227);
INSERT INTO O_BATTR
	VALUES (10285,
	10227);
INSERT INTO O_ATTR
	VALUES (10285,
	10227,
	0,
	'Action_ID',
	'',
	'',
	'Action_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10592,
	10227);
INSERT INTO O_BATTR
	VALUES (10592,
	10227);
INSERT INTO O_ATTR
	VALUES (10592,
	10227,
	10285,
	'Type',
	'This is the user-readable description of the body subtype. It it used for displaying error messages to the user. Possible values:  "function", "class operation", "operation", "bridge", "state", "class state", "derived attribute", "provided signal", "required signal", "provided operation", "required operation".',
	'',
	'Type',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10593,
	10227);
INSERT INTO O_BATTR
	VALUES (10593,
	10227);
INSERT INTO O_ATTR
	VALUES (10593,
	10227,
	10592,
	'LoopLevel',
	'While parsing an action, this attribute contains the depth of nested loops in the body.
---------------------------------------------------------------------
Bridge:ALS',
	'',
	'LoopLevel',
	0,
	298,
	'',
	'');
INSERT INTO O_REF
	VALUES (10227,
	35,
	0,
	163,
	10226,
	10228,
	10229,
	10594,
	10595,
	0,
	0,
	'',
	'Block',
	'Block_ID',
	'R666.''has committed outer''');
INSERT INTO O_RATTR
	VALUES (10594,
	10227,
	163,
	35,
	1,
	'Block_ID');
INSERT INTO O_ATTR
	VALUES (10594,
	10227,
	10593,
	'Block_ID',
	'',
	'',
	'Block_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10227,
	35,
	0,
	163,
	10334,
	10336,
	10335,
	10596,
	10597,
	0,
	0,
	'',
	'Block',
	'Block_ID',
	'R699.''has current scope''');
INSERT INTO O_RATTR
	VALUES (10596,
	10227,
	163,
	35,
	0,
	'Block_ID');
INSERT INTO O_ATTR
	VALUES (10596,
	10227,
	10594,
	'CurrentScope_ID',
	'',
	'',
	'CurrentScope_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10598,
	10227);
INSERT INTO O_BATTR
	VALUES (10598,
	10227);
INSERT INTO O_ATTR
	VALUES (10598,
	10227,
	10596,
	'return_value',
	'For bodies of OAL that return a value, this attribute will be set by the return statement.',
	'',
	'return_value',
	0,
	317,
	'',
	'');
INSERT INTO O_DBATTR
	VALUES (10599,
	10227,
	'select one sab related by self->ACT_SAB[R698];
select one tab related by self->ACT_TAB[R698];
select one dab related by self->ACT_DAB[R698];
select one fnb related by self->ACT_FNB[R698];
select one opb related by self->ACT_OPB[R698];
select one brb related by self->ACT_BRB[R698];
select one psb related by self->ACT_PSB[R698];
select one pob related by self->ACT_POB[R698];
select one rsb related by self->ACT_RSB[R698];
select one rob related by self->ACT_ROB[R698];
if (not_empty sab)
  select one state related by sab->SM_ACT[R691]->SM_AH[R514]->SM_MOAH[R513]->SM_STATE[R511];
  select one clazz related by state->SM_SM[R501]->SM_ISM[R517]->O_OBJ[R518];
  if (empty clazz)
    select one clazz related by state->SM_SM[R501]->SM_ASM[R517]->O_OBJ[R519];
  end if;
  self.Label = clazz.Name + "::" + state.Name;
elif not_empty tab
  select one txn related by tab->SM_ACT[R688]->SM_AH[R514]->
                                                     SM_TAH[R513]->SM_TXN[R530];
  if (not_empty txn)
    self.Label = txn.get_name();
  else
    self.Label = "Internal error getting transition name";
  end if;
elif (not_empty dab)
  select one attr related by dab->O_DBATTR[R693]->O_BATTR[R107]->O_ATTR[R106];
  select one clazz related by attr->O_OBJ[R102];
  self.Label = clazz.Name + "::" + attr.Name;
elif (not_empty fnb)
  select one fn related by fnb->S_SYNC[R695];
  self.Label = fn.Name;
elif (not_empty opb)
  select one op related by opb->O_TFR[R696];
  select one clazz related by op->O_OBJ[R115];
  self.Label = clazz.Name + "::" + op.Name;
elif (not_empty brb)
  select one brg related by brb->S_BRG[R697];
  select one ee related by brg->S_EE[R19];
  self.Label = ee.Name + "::" + brg.Name;
elif(not_empty psb)
  select one proSig related by psb->SPR_PS[R686];
  select one irRef related by proSig->SPR_PEP[R4503]->C_P[R4501]->C_IR[R4009];
  select one port related by irRef->C_PO[R4016];
  self.Label = port.Name + "::" + irRef.interfaceName() + "::" + proSig.Name;
elif(not_empty pob)
  select one proOp related by pob->SPR_PO[R687];
  select one irRef related by proOp->SPR_PEP[R4503]->C_P[R4501]->C_IR[R4009];
  select one port related by irRef->C_PO[R4016];
  self.Label = port.Name + "::" + irRef.interfaceName() + "::" + proOp.Name;
elif(not_empty rsb)
  select one reqSig related by rsb->SPR_RS[R684];
  select one irRef related by reqSig->SPR_REP[R4502]->C_R[R4500]->C_IR[R4009];
  select one port related by irRef->C_PO[R4016];
  self.Label = port.Name + "::" + irRef.interfaceName() + "::" + reqSig.Name;
elif(not_empty rob)
  select one reqOp related by rob->SPR_RO[R685];
  select one irRef related by reqOp->SPR_REP[R4502]->C_R[R4500]->C_IR[R4009];
  select one port related by irRef->C_PO[R4016];
  self.Label = port.Name + "::" + irRef.interfaceName() + "::" + reqOp.Name;
else
  self.Label = "Error: Unknown Action type.";
end if;',
	1);
INSERT INTO O_BATTR
	VALUES (10599,
	10227);
INSERT INTO O_ATTR
	VALUES (10599,
	10227,
	10598,
	'Label',
	'',
	'',
	'Label',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (10227,
	35,
	0,
	163,
	10345,
	10346,
	10347,
	10600,
	10601,
	0,
	0,
	'',
	'Block',
	'Block_ID',
	'R650.''has parsed outer''');
INSERT INTO O_RATTR
	VALUES (10600,
	10227,
	163,
	35,
	1,
	'Block_ID');
INSERT INTO O_ATTR
	VALUES (10600,
	10227,
	10599,
	'Parsed_Block_ID',
	'',
	'Parsed_',
	'Block_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10602,
	10227);
INSERT INTO O_BATTR
	VALUES (10602,
	10227);
INSERT INTO O_ATTR
	VALUES (10602,
	10227,
	10600,
	'ReturnFound',
	'Persistent:false',
	'',
	'ReturnFound',
	0,
	316,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10227);
INSERT INTO O_OIDA
	VALUES (10285,
	10227,
	0,
	'Action_ID');
INSERT INTO O_ID
	VALUES (1,
	10227);
INSERT INTO O_ID
	VALUES (2,
	10227);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (35,
	'Block',
	600,
	'ACT_BLK',
	'This class represents a block of action language within an action. Each block contains a number of statements.

',
	10191);
INSERT INTO O_TFR
	VALUES (10603,
	35,
	'clearCurrentScope',
	'This operation finds the instance of Block that is the current scope 
for the Body instance, and unrelates it.  It then clears all blocks for the
Body instance.
This operation is used for resetting the block data after the parser has an
unrecoverable token error.
---------------------------------------------------------------------
Bridge:ALS',
	19,
	0,
	'select any act from instances of ACT_ACT where ( selected.Action_ID == param.currentContext);
if(not_empty act)
  select one blk related by act->ACT_BLK[R699];
  if ( not_empty blk )
    unrelate blk from act across R699;
  end if;
  act.clear_blocks();
end if;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (10604,
	10603,
	'currentContext',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10605,
	35,
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.
',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation',
	1,
	'',
	10603);
INSERT INTO O_TFR
	VALUES (10606,
	35,
	'newLocalReference',
	'',
	296,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return GD::NULL_UNIQUE_ID(); ',
	1,
	'',
	10607);
INSERT INTO O_TPARM
	VALUES (10608,
	10606,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10609,
	35,
	'newLocalValue',
	'',
	296,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return GD::NULL_UNIQUE_ID(); ',
	1,
	'',
	10610);
INSERT INTO O_TPARM
	VALUES (10611,
	10609,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10610,
	35,
	'newLocalSelectedReference',
	'',
	296,
	1,
	'// Mentor Graphics Verifier-specific Implementation
return GD::NULL_UNIQUE_ID(); ',
	1,
	'',
	10606);
INSERT INTO O_TPARM
	VALUES (10612,
	10610,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10607,
	35,
	'isOuter',
	'',
	316,
	1,
	'// Block.isOuter
select one body related by self->ACT_ACT[R666];
return not_empty body;',
	1,
	'',
	10613);
INSERT INTO O_TFR
	VALUES (10613,
	35,
	'initialize',
	'',
	19,
	1,
	'// Block.initialize()
select many statements related by self->ACT_SMT[R602];
select any prevStmt from instances of ACT_SMT where (selected.Statement_ID == GD::NULL_UNIQUE_ID());
for each statement in statements
  select one elseStmt related by statement->ACT_E[R603];
  select one elifStmt related by statement->ACT_EL[R603];
  if (empty elseStmt and empty elifStmt)
    if (not_empty prevStmt)
      relate prevStmt to statement across R661.''succeeds'';
    end if;
    prevStmt = statement;
  end if;
end for;',
	1,
	'',
	10605);
INSERT INTO O_TFR
	VALUES (10614,
	35,
	'popUpBlock',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation',
	1,
	'',
	10609);
INSERT INTO O_TPARM
	VALUES (10615,
	10614,
	'stack_frame_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10616,
	35,
	'exitAsynchronousActivity',
	'',
	19,
	1,
	'// Mentor Graphics Verifier-specific Implementation',
	1,
	'',
	10614);
INSERT INTO O_TPARM
	VALUES (10617,
	10616,
	'stack_ID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (10618,
	10616,
	'body_ID',
	296,
	0,
	'',
	10617,
	'');
INSERT INTO O_NBATTR
	VALUES (163,
	35);
INSERT INTO O_BATTR
	VALUES (163,
	35);
INSERT INTO O_ATTR
	VALUES (163,
	35,
	0,
	'Block_ID',
	'',
	'',
	'Block_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_REF
	VALUES (35,
	10227,
	0,
	10285,
	10283,
	10286,
	10284,
	10619,
	10620,
	0,
	0,
	'',
	'Body',
	'Action_ID',
	'R601.''is committed from''');
INSERT INTO O_RATTR
	VALUES (10619,
	35,
	10285,
	10227,
	1,
	'Action_ID');
INSERT INTO O_ATTR
	VALUES (10619,
	35,
	10621,
	'Action_ID',
	'',
	'',
	'Action_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10622,
	35);
INSERT INTO O_BATTR
	VALUES (10622,
	35);
INSERT INTO O_ATTR
	VALUES (10622,
	35,
	163,
	'WhereSpecOK',
	'This attribute is used during parsing to flag if the where specification that was last parsed had any errors or not.
---------------------------------------------------------------------
Bridge:ALS',
	'',
	'WhereSpecOK',
	0,
	316,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10623,
	35);
INSERT INTO O_BATTR
	VALUES (10623,
	35);
INSERT INTO O_ATTR
	VALUES (10623,
	35,
	10622,
	'InWhereSpec',
	'This attribute is used during parsing to flag if the parser is currently parsing a where specification.
---------------------------------------------------------------------
Bridge:ALS',
	'',
	'InWhereSpec',
	0,
	316,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10624,
	35);
INSERT INTO O_BATTR
	VALUES (10624,
	35);
INSERT INTO O_ATTR
	VALUES (10624,
	35,
	10623,
	'SelectedFound',
	'This attribute is used during parsing to flag if the parser found the keyword ''selected'' in a where specification.
---------------------------------------------------------------------
Bridge:ALS',
	'',
	'SelectedFound',
	0,
	316,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10625,
	35);
INSERT INTO O_BATTR
	VALUES (10625,
	35);
INSERT INTO O_ATTR
	VALUES (10625,
	35,
	10624,
	'TempBuffer',
	'This attribute is used by the parser to save textual infomation 
for later use by the parser.  The current uses of this attribute are
by the functions:  obj_or_ee_keyletters_validate, and phrase_validate.
---------------------------------------------------------------------
Bridge:ALS

',
	'',
	'TempBuffer',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10626,
	35);
INSERT INTO O_BATTR
	VALUES (10626,
	35);
INSERT INTO O_ATTR
	VALUES (10626,
	35,
	10625,
	'SupData1',
	'This attribute is used by the parser to save textual infomation 
for later use by the parser.  It is used cache the name of the first parameter in an event parameter list.
---------------------------------------------------------------------
Bridge:ALS


',
	'',
	'SupData1',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10627,
	35);
INSERT INTO O_BATTR
	VALUES (10627,
	35);
INSERT INTO O_ATTR
	VALUES (10627,
	35,
	10626,
	'SupData2',
	'This attribute is used by the parser to save textual infomation 
for later use by the parser.  It is used cache the name of the second and subsequent parameters in an event parameter list.
---------------------------------------------------------------------
Bridge:ALS
',
	'',
	'SupData2',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10628,
	35);
INSERT INTO O_BATTR
	VALUES (10628,
	35);
INSERT INTO O_ATTR
	VALUES (10628,
	35,
	10627,
	'CurrentLine',
	'This is a temporary value used to save the line number of the statement
currently being parsed.',
	'',
	'CurrentLine',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10629,
	35);
INSERT INTO O_BATTR
	VALUES (10629,
	35);
INSERT INTO O_ATTR
	VALUES (10629,
	35,
	10628,
	'CurrentCol',
	'This is a temporary value used to save the starting column of the statement
currently being parsed.',
	'',
	'CurrentCol',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10630,
	35);
INSERT INTO O_BATTR
	VALUES (10630,
	35);
INSERT INTO O_ATTR
	VALUES (10630,
	35,
	10629,
	'currentKeyLettersLineNumber',
	'Holds the line number (within the activity text as a whole) of the last 
key-letters token parsed in this block.
',
	'',
	'currentKeyLettersLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10631,
	35);
INSERT INTO O_BATTR
	VALUES (10631,
	35);
INSERT INTO O_ATTR
	VALUES (10631,
	35,
	10630,
	'currentKeyLettersColumn',
	'Holds the column (within the activity text as a whole) of the last 
key-letters token parsed in this block.
',
	'',
	'currentKeyLettersColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10632,
	35);
INSERT INTO O_BATTR
	VALUES (10632,
	35);
INSERT INTO O_ATTR
	VALUES (10632,
	35,
	10631,
	'currentParameterAssignmentNameLineNumber',
	'',
	'',
	'currentParameterAssignmentNameLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10633,
	35);
INSERT INTO O_BATTR
	VALUES (10633,
	35);
INSERT INTO O_ATTR
	VALUES (10633,
	35,
	10632,
	'currentParameterAssignmentNameColumn',
	'',
	'',
	'currentParameterAssignmentNameColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10634,
	35);
INSERT INTO O_BATTR
	VALUES (10634,
	35);
INSERT INTO O_ATTR
	VALUES (10634,
	35,
	10633,
	'currentAssociationNumberLineNumber',
	'',
	'',
	'currentAssociationNumberLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10635,
	35);
INSERT INTO O_BATTR
	VALUES (10635,
	35);
INSERT INTO O_ATTR
	VALUES (10635,
	35,
	10634,
	'currentAssociationNumberColumn',
	'',
	'',
	'currentAssociationNumberColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10636,
	35);
INSERT INTO O_BATTR
	VALUES (10636,
	35);
INSERT INTO O_ATTR
	VALUES (10636,
	35,
	10635,
	'currentAssociationPhraseLineNumber',
	'',
	'',
	'currentAssociationPhraseLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10637,
	35);
INSERT INTO O_BATTR
	VALUES (10637,
	35);
INSERT INTO O_ATTR
	VALUES (10637,
	35,
	10636,
	'currentAssociationPhraseColumn',
	'',
	'',
	'currentAssociationPhraseColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10638,
	35);
INSERT INTO O_BATTR
	VALUES (10638,
	35);
INSERT INTO O_ATTR
	VALUES (10638,
	35,
	10637,
	'currentDataTypeNameLineNumber',
	'',
	'',
	'currentDataTypeNameLineNumber',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10639,
	35);
INSERT INTO O_BATTR
	VALUES (10639,
	35);
INSERT INTO O_ATTR
	VALUES (10639,
	35,
	10638,
	'currentDataTypeNameColumn',
	'',
	'',
	'currentDataTypeNameColumn',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10621,
	35);
INSERT INTO O_BATTR
	VALUES (10621,
	35);
INSERT INTO O_ATTR
	VALUES (10621,
	35,
	10639,
	'blockInStackFrameCreated',
	'',
	'',
	'blockInStackFrameCreated',
	0,
	316,
	'',
	'');
INSERT INTO O_REF
	VALUES (35,
	10227,
	0,
	10285,
	10348,
	10350,
	10349,
	10640,
	10641,
	0,
	0,
	'',
	'Body',
	'Action_ID',
	'R612.''is parsed from''');
INSERT INTO O_RATTR
	VALUES (10640,
	35,
	10285,
	10227,
	1,
	'Action_ID');
INSERT INTO O_ATTR
	VALUES (10640,
	35,
	10619,
	'Parsed_Action_ID',
	'',
	'Parsed_',
	'Action_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	35);
INSERT INTO O_OIDA
	VALUES (163,
	35,
	0,
	'Block_ID');
INSERT INTO O_ID
	VALUES (1,
	35);
INSERT INTO O_ID
	VALUES (2,
	35);
-- BP 7.1 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (10642,
	'Association',
	'A association (R_REL) captures an association between things in the real world. A association is stated in terms of the formal classs (O_OBJ) that model the real world entities participating in the association. There can be any number of associations between the same two classs and any class can participate in any number of associations with other classs.',
	'R',
	201,
	1,
	10643);
INSERT INTO S_SID
	VALUES (1,
	10642);
INSERT INTO O_IOBJ
	VALUES (10644,
	30,
	5,
	10642,
	'Model Class',
	'O_OBJ');
INSERT INTO O_IOBJ
	VALUES (10645,
	1050,
	5,
	10642,
	'Imported Class',
	'O_IOBJ');
INSERT INTO R_ASSOC
	VALUES (10646);
INSERT INTO R_REL
	VALUES (10646,
	201,
	'CrossComponent:true',
	10642);
INSERT INTO R_AONE
	VALUES (2322,
	10646,
	10647,
	1,
	1,
	'has instance associations abstracted');
INSERT INTO O_RTIDA
	VALUES (2368,
	2322,
	0,
	10646,
	10647);
INSERT INTO R_RTO
	VALUES (2322,
	10646,
	10647,
	0);
INSERT INTO R_OIR
	VALUES (2322,
	10646,
	10647,
	0);
INSERT INTO R_ASSR
	VALUES (1109,
	10646,
	10648,
	1);
INSERT INTO R_RGO
	VALUES (1109,
	10646,
	10648);
INSERT INTO R_OIR
	VALUES (1109,
	10646,
	10648,
	0);
INSERT INTO R_AOTH
	VALUES (30,
	10646,
	10649,
	1,
	0,
	'abstracts association between instances of');
INSERT INTO O_RTIDA
	VALUES (150,
	30,
	0,
	10646,
	10649);
INSERT INTO R_RTO
	VALUES (30,
	10646,
	10649,
	0);
INSERT INTO R_OIR
	VALUES (30,
	10646,
	10649,
	10644);
INSERT INTO R_SUBSUP
	VALUES (10650);
INSERT INTO R_REL
	VALUES (10650,
	206,
	'',
	10642);
INSERT INTO R_SUPER
	VALUES (2322,
	10650,
	10651);
INSERT INTO O_RTIDA
	VALUES (2368,
	2322,
	0,
	10650,
	10651);
INSERT INTO R_RTO
	VALUES (2322,
	10650,
	10651,
	0);
INSERT INTO R_OIR
	VALUES (2322,
	10650,
	10651,
	0);
INSERT INTO R_SUB
	VALUES (10652,
	10650,
	10653);
INSERT INTO R_RGO
	VALUES (10652,
	10650,
	10653);
INSERT INTO R_OIR
	VALUES (10652,
	10650,
	10653,
	0);
INSERT INTO R_SUB
	VALUES (10654,
	10650,
	10655);
INSERT INTO R_RGO
	VALUES (10654,
	10650,
	10655);
INSERT INTO R_OIR
	VALUES (10654,
	10650,
	10655,
	0);
INSERT INTO R_SUB
	VALUES (10656,
	10650,
	10657);
INSERT INTO R_RGO
	VALUES (10656,
	10650,
	10657);
INSERT INTO R_OIR
	VALUES (10656,
	10650,
	10657,
	0);
INSERT INTO R_SUB
	VALUES (10658,
	10650,
	10659);
INSERT INTO R_RGO
	VALUES (10658,
	10650,
	10659);
INSERT INTO R_OIR
	VALUES (10658,
	10650,
	10659,
	0);
INSERT INTO R_SIMP
	VALUES (10660);
INSERT INTO R_REL
	VALUES (10660,
	207,
	'A formalized Simple Association is related to one instance of Class As Simple Participant.
A un-formalized Simple Association is related to two instances of Class As Simple Participant.
',
	10642);
INSERT INTO R_FORM
	VALUES (10661,
	10660,
	10662,
	1,
	0,
	'relates');
INSERT INTO R_RGO
	VALUES (10661,
	10660,
	10662);
INSERT INTO R_OIR
	VALUES (10661,
	10660,
	10662,
	0);
INSERT INTO R_PART
	VALUES (10652,
	10660,
	10663,
	0,
	0,
	'is related to formalizer via');
INSERT INTO O_RTIDA
	VALUES (10664,
	10652,
	0,
	10660,
	10663);
INSERT INTO R_RTO
	VALUES (10652,
	10660,
	10663,
	0);
INSERT INTO R_OIR
	VALUES (10652,
	10660,
	10663,
	0);
INSERT INTO R_SIMP
	VALUES (10665);
INSERT INTO R_REL
	VALUES (10665,
	208,
	'The conditionality towards R_FORM accounts for unformalized simple associations in the analysis models. In BridgePoint V3.x, and unformalized simple association results in two instances of the Class As Simple Participant (R_PART), and zero instances of Class As Simple Formalizer. Archetypes should check the cardinality of R_FORM (verifying it is one) before navigating to R_PART.',
	10642);
INSERT INTO R_FORM
	VALUES (10666,
	10665,
	10667,
	0,
	1,
	'relates');
INSERT INTO R_RGO
	VALUES (10666,
	10665,
	10667);
INSERT INTO R_OIR
	VALUES (10666,
	10665,
	10667,
	0);
INSERT INTO R_PART
	VALUES (10652,
	10665,
	10668,
	0,
	0,
	'is related to participant via');
INSERT INTO O_RTIDA
	VALUES (10664,
	10652,
	0,
	10665,
	10668);
INSERT INTO R_RTO
	VALUES (10652,
	10665,
	10668,
	0);
INSERT INTO R_OIR
	VALUES (10652,
	10665,
	10668,
	0);
INSERT INTO R_SIMP
	VALUES (10669);
INSERT INTO R_REL
	VALUES (10669,
	209,
	'',
	10642);
INSERT INTO R_FORM
	VALUES (10670,
	10669,
	10671,
	0,
	0,
	'relates');
INSERT INTO R_RGO
	VALUES (10670,
	10669,
	10671);
INSERT INTO R_OIR
	VALUES (10670,
	10669,
	10671,
	0);
INSERT INTO R_PART
	VALUES (10656,
	10669,
	10672,
	0,
	0,
	'is related to other side via');
INSERT INTO O_RTIDA
	VALUES (10673,
	10656,
	0,
	10669,
	10672);
INSERT INTO R_RTO
	VALUES (10656,
	10669,
	10672,
	0);
INSERT INTO R_OIR
	VALUES (10656,
	10669,
	10672,
	0);
INSERT INTO R_SIMP
	VALUES (10674);
INSERT INTO R_REL
	VALUES (10674,
	210,
	'',
	10642);
INSERT INTO R_FORM
	VALUES (10675,
	10674,
	10676,
	0,
	0,
	'relates');
INSERT INTO R_RGO
	VALUES (10675,
	10674,
	10676);
INSERT INTO R_OIR
	VALUES (10675,
	10674,
	10676,
	0);
INSERT INTO R_PART
	VALUES (10656,
	10674,
	10677,
	0,
	0,
	'is related to one side via');
INSERT INTO O_RTIDA
	VALUES (10673,
	10656,
	0,
	10674,
	10677);
INSERT INTO R_RTO
	VALUES (10656,
	10674,
	10677,
	0);
INSERT INTO R_OIR
	VALUES (10656,
	10674,
	10677,
	0);
INSERT INTO R_SIMP
	VALUES (10678);
INSERT INTO R_REL
	VALUES (10678,
	211,
	'',
	10642);
INSERT INTO R_FORM
	VALUES (10679,
	10678,
	10680,
	0,
	0,
	'uses a formalizer');
INSERT INTO R_RGO
	VALUES (10679,
	10678,
	10680);
INSERT INTO R_OIR
	VALUES (10679,
	10678,
	10680,
	0);
INSERT INTO R_PART
	VALUES (10656,
	10678,
	10681,
	0,
	0,
	'formalizes association between associated classes');
INSERT INTO O_RTIDA
	VALUES (10673,
	10656,
	0,
	10678,
	10681);
INSERT INTO R_RTO
	VALUES (10656,
	10678,
	10681,
	0);
INSERT INTO R_OIR
	VALUES (10656,
	10678,
	10681,
	0);
INSERT INTO R_SIMP
	VALUES (10682);
INSERT INTO R_REL
	VALUES (10682,
	212,
	'',
	10642);
INSERT INTO R_FORM
	VALUES (10683,
	10682,
	10684,
	0,
	0,
	'relates');
INSERT INTO R_RGO
	VALUES (10683,
	10682,
	10684);
INSERT INTO R_OIR
	VALUES (10683,
	10682,
	10684,
	0);
INSERT INTO R_PART
	VALUES (10658,
	10682,
	10685,
	0,
	0,
	'is related to subtypes via');
INSERT INTO O_RTIDA
	VALUES (10686,
	10658,
	0,
	10682,
	10685);
INSERT INTO R_RTO
	VALUES (10658,
	10682,
	10685,
	0);
INSERT INTO R_OIR
	VALUES (10658,
	10682,
	10685,
	0);
INSERT INTO R_SIMP
	VALUES (10687);
INSERT INTO R_REL
	VALUES (10687,
	213,
	'The conditionality towards Class As Subtype (R_SUB) represents that an analysis model may contain a supertype class that does not yet have any subtype classes entered on the OIM.',
	10642);
INSERT INTO R_FORM
	VALUES (10688,
	10687,
	10689,
	1,
	1,
	'relates');
INSERT INTO R_RGO
	VALUES (10688,
	10687,
	10689);
INSERT INTO R_OIR
	VALUES (10688,
	10687,
	10689,
	0);
INSERT INTO R_PART
	VALUES (10658,
	10687,
	10690,
	0,
	0,
	'is related to supertype via');
INSERT INTO O_RTIDA
	VALUES (10686,
	10658,
	0,
	10687,
	10690);
INSERT INTO R_RTO
	VALUES (10658,
	10687,
	10690,
	0);
INSERT INTO R_OIR
	VALUES (10658,
	10687,
	10690,
	0);
INSERT INTO R_SIMP
	VALUES (10691);
INSERT INTO R_REL
	VALUES (10691,
	214,
	'',
	10642);
INSERT INTO R_FORM
	VALUES (10692,
	10691,
	10693,
	0,
	0,
	'relates');
INSERT INTO R_RGO
	VALUES (10692,
	10691,
	10693);
INSERT INTO R_OIR
	VALUES (10692,
	10691,
	10693,
	0);
INSERT INTO R_PART
	VALUES (10654,
	10691,
	10694,
	0,
	0,
	'is related to other type via');
INSERT INTO O_RTIDA
	VALUES (10695,
	10654,
	0,
	10691,
	10694);
INSERT INTO R_RTO
	VALUES (10654,
	10691,
	10694,
	0);
INSERT INTO R_OIR
	VALUES (10654,
	10691,
	10694,
	0);
INSERT INTO R_SIMP
	VALUES (10696);
INSERT INTO R_REL
	VALUES (10696,
	215,
	'',
	10642);
INSERT INTO R_FORM
	VALUES (10697,
	10696,
	10698,
	0,
	0,
	'relates');
INSERT INTO R_RGO
	VALUES (10697,
	10696,
	10698);
INSERT INTO R_OIR
	VALUES (10697,
	10696,
	10698,
	0);
INSERT INTO R_PART
	VALUES (10654,
	10696,
	10699,
	0,
	0,
	'is related to one side via');
INSERT INTO O_RTIDA
	VALUES (10695,
	10654,
	0,
	10696,
	10699);
INSERT INTO R_RTO
	VALUES (10654,
	10696,
	10699,
	0);
INSERT INTO R_OIR
	VALUES (10654,
	10696,
	10699,
	0);
INSERT INTO R_SUBSUP
	VALUES (10700);
INSERT INTO R_REL
	VALUES (10700,
	203,
	'',
	10642);
INSERT INTO R_SUPER
	VALUES (1109,
	10700,
	10701);
INSERT INTO O_RTIDA
	VALUES (1108,
	1109,
	0,
	10700,
	10701);
INSERT INTO O_RTIDA
	VALUES (10702,
	1109,
	0,
	10700,
	10701);
INSERT INTO O_RTIDA
	VALUES (10703,
	1109,
	0,
	10700,
	10701);
INSERT INTO R_RTO
	VALUES (1109,
	10700,
	10701,
	0);
INSERT INTO R_OIR
	VALUES (1109,
	10700,
	10701,
	0);
INSERT INTO R_SUB
	VALUES (983,
	10700,
	10704);
INSERT INTO R_RGO
	VALUES (983,
	10700,
	10704);
INSERT INTO R_OIR
	VALUES (983,
	10700,
	10704,
	0);
INSERT INTO R_SUB
	VALUES (985,
	10700,
	10705);
INSERT INTO R_RGO
	VALUES (985,
	10700,
	10705);
INSERT INTO R_OIR
	VALUES (985,
	10700,
	10705,
	0);
INSERT INTO R_SUB
	VALUES (10692,
	10700,
	10706);
INSERT INTO R_RGO
	VALUES (10692,
	10700,
	10706);
INSERT INTO R_OIR
	VALUES (10692,
	10700,
	10706,
	0);
INSERT INTO R_SUB
	VALUES (10697,
	10700,
	10707);
INSERT INTO R_RGO
	VALUES (10697,
	10700,
	10707);
INSERT INTO R_OIR
	VALUES (10697,
	10700,
	10707,
	0);
INSERT INTO R_SUBSUP
	VALUES (10708);
INSERT INTO R_REL
	VALUES (10708,
	205,
	'',
	10642);
INSERT INTO R_SUPER
	VALUES (985,
	10708,
	10709);
INSERT INTO O_RTIDA
	VALUES (1069,
	985,
	0,
	10708,
	10709);
INSERT INTO O_RTIDA
	VALUES (1070,
	985,
	0,
	10708,
	10709);
INSERT INTO O_RTIDA
	VALUES (1071,
	985,
	0,
	10708,
	10709);
INSERT INTO R_RTO
	VALUES (985,
	10708,
	10709,
	0);
INSERT INTO R_OIR
	VALUES (985,
	10708,
	10709,
	0);
INSERT INTO R_SUB
	VALUES (10688,
	10708,
	10710);
INSERT INTO R_RGO
	VALUES (10688,
	10708,
	10710);
INSERT INTO R_OIR
	VALUES (10688,
	10708,
	10710,
	0);
INSERT INTO R_SUB
	VALUES (10666,
	10708,
	10711);
INSERT INTO R_RGO
	VALUES (10666,
	10708,
	10711);
INSERT INTO R_OIR
	VALUES (10666,
	10708,
	10711,
	0);
INSERT INTO R_SUB
	VALUES (10679,
	10708,
	10712);
INSERT INTO R_RGO
	VALUES (10679,
	10708,
	10712);
INSERT INTO R_OIR
	VALUES (10679,
	10708,
	10712,
	0);
INSERT INTO R_SUBSUP
	VALUES (10713);
INSERT INTO R_REL
	VALUES (10713,
	204,
	'',
	10642);
INSERT INTO R_SUPER
	VALUES (983,
	10713,
	10714);
INSERT INTO O_RTIDA
	VALUES (1055,
	983,
	0,
	10713,
	10714);
INSERT INTO O_RTIDA
	VALUES (1056,
	983,
	0,
	10713,
	10714);
INSERT INTO O_RTIDA
	VALUES (1057,
	983,
	0,
	10713,
	10714);
INSERT INTO R_RTO
	VALUES (983,
	10713,
	10714,
	0);
INSERT INTO R_OIR
	VALUES (983,
	10713,
	10714,
	0);
INSERT INTO R_SUB
	VALUES (10683,
	10713,
	10715);
INSERT INTO R_RGO
	VALUES (10683,
	10713,
	10715);
INSERT INTO R_OIR
	VALUES (10683,
	10713,
	10715,
	0);
INSERT INTO R_SUB
	VALUES (10661,
	10713,
	10716);
INSERT INTO R_RGO
	VALUES (10661,
	10713,
	10716);
INSERT INTO R_OIR
	VALUES (10661,
	10713,
	10716,
	0);
INSERT INTO R_SUB
	VALUES (10670,
	10713,
	10717);
INSERT INTO R_RGO
	VALUES (10670,
	10713,
	10717);
INSERT INTO R_OIR
	VALUES (10670,
	10713,
	10717,
	0);
INSERT INTO R_SUB
	VALUES (10675,
	10713,
	10718);
INSERT INTO R_RGO
	VALUES (10675,
	10713,
	10718);
INSERT INTO R_OIR
	VALUES (10675,
	10713,
	10718,
	0);
INSERT INTO R_SIMP
	VALUES (10719);
INSERT INTO R_REL
	VALUES (10719,
	202,
	'CrossComponent:true',
	10642);
INSERT INTO R_FORM
	VALUES (1109,
	10719,
	10720,
	1,
	1,
	'is used for spanning associations as');
INSERT INTO R_RGO
	VALUES (1109,
	10719,
	10720);
INSERT INTO R_OIR
	VALUES (1109,
	10719,
	10720,
	0);
INSERT INTO R_PART
	VALUES (1050,
	10719,
	10721,
	0,
	1,
	'may be represented by');
INSERT INTO O_RTIDA
	VALUES (1360,
	1050,
	0,
	10719,
	10721);
INSERT INTO R_RTO
	VALUES (1050,
	10719,
	10721,
	0);
INSERT INTO R_OIR
	VALUES (1050,
	10719,
	10721,
	10645);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10658,
	'Subtype Supertype Association',
	212,
	'R_SUBSUP',
	'A supertype/subtype association (R_SUBSUP) is an  between two classes, a supertype (R_SUPER) and a subtype (R_SUB).   The class that holds the referential attributes for  the association is know as the referring class in the association (R_RGO) and the class that participates in the association and carries the identifying attributes used to formalize the association is the referred to class  (R_RTO).  Supertype/Subtype associations are always formalized in the subtype (R_SUB).',
	10642);
INSERT INTO O_TFR
	VALUES (10722,
	10658,
	'dispose',
	'The dispose operation for the R_SUPSUB class.',
	19,
	1,
	'select one assoc related by self->R_REL[R206];
unrelate self from assoc across R206;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (10723,
	10658,
	'isFormalized',
	'',
	316,
	1,
	'select one rto related by self->R_SUPER[R212]->R_RTO[R204];
select any rtida related by rto->O_RTIDA[R110];
return not_empty rtida;
',
	1,
	'',
	10724);
INSERT INTO O_TFR
	VALUES (10724,
	10658,
	'formalize',
	'',
	19,
	1,
	'if ( self.isFormalized() )
  self.unformalize();
end if;

select one sup_rto related by self->R_SUPER[R212]->R_RTO[R204];
select one sup_obj related by sup_rto->R_OIR[R203]->O_OBJ[R201];
select any oid related by sup_obj->O_ID[R104] where selected.Oid_ID == param.id;
relate oid to sup_rto across R109;

select many oida_set related by oid->O_OIDA[R105];
select many sub_rgo_set related by self->R_SUB[R213]->R_RGO[R205];
// always create the O_RTIDA instances even if the
// association doesn''t have any subclasses defined at the moment
for each oida in oida_set 
  create object instance rtida of O_RTIDA;
  relate oida to sup_rto across R110 using rtida;
end for;
for each sub_rgo in sub_rgo_set
  select one sub_obj related by sub_rgo->R_OIR[R203]->O_OBJ[R201];
  unused_oid = sub_obj.findUnusedIdentifier();
  for each oida in oida_set 
    newAttr_id = oida.addReference(rel_id: self.Rel_ID,
        rto_obj_id: sup_rto.Obj_ID, rto_oir_id: sup_rto.OIR_ID, 
        rgo_obj_id: sub_rgo.Obj_ID, rgo_oir_id: sub_rgo.OIR_ID,
        id: unused_oid);
  end for;
end for;
',
	1,
	'',
	10722);
INSERT INTO O_TPARM
	VALUES (10725,
	10724,
	'id',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10726,
	10658,
	'unformalize',
	'',
	19,
	1,
	'
select one sup_rto related by self->R_SUPER[R212]->R_RTO[R204];
select one sup_oir related by sup_rto->R_OIR[R203];

sup_rto.unformalize();

// have to relate again due to propagation of previous unrelates
relate sup_oir to sup_rto across R203;

',
	1,
	'',
	10723);
INSERT INTO O_REF
	VALUES (10658,
	2322,
	0,
	2368,
	10650,
	10659,
	10651,
	10686,
	10727,
	0,
	0,
	'',
	'Association',
	'Rel_ID',
	'R206');
INSERT INTO O_RATTR
	VALUES (10686,
	10658,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (10686,
	10658,
	0,
	'Rel_ID',
	'',
	'',
	'Rel_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10658);
INSERT INTO O_OIDA
	VALUES (10686,
	10658,
	0,
	'Rel_ID');
INSERT INTO O_ID
	VALUES (1,
	10658);
INSERT INTO O_ID
	VALUES (2,
	10658);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10652,
	'Simple Association',
	205,
	'R_SIMP',
	'A simple association (R_SIMP) is an association between two classs which are formalized with referential attributes in one of the classes.  The class that holds the referential attributes for  the association is know as the referring class in the association (R_RGO) and is the formalizer of the association (R_FORM).  The class that participates in the association and carries the identifying attributes used to formalize the association is the referred to class  (R_RTO) and is a participant in the association (R_PART).',
	10642);
INSERT INTO O_TFR
	VALUES (10728,
	10652,
	'get_connector_text',
	'First determines whether the association has been formalized (there
is one R_PART and one R_FORM instance if the association is formalized,
two R_PART instances if not). Then it obtains the phrases by calling
the operations of the same name in the associated R_PART/R_FORM
instances.
-----------------------------------------------------------------------------------
Bridge:GD
',
	322,
	1,
	'result = "";
select one rel related by self->R_REL[R206];
isReflexive = false;
if ( not_empty rel )
  isReflexive = rel.is_reflexive();
end if;

select many part_set related by self->R_PART[R207];
if ( cardinality part_set > 1 )
  // un-formalized
  if (isReflexive)
    select any part1 related by self->R_PART[R207];
    if (param.at == End::Start OR param.at == End::Start_Fixed)
      if (not_empty part1)
        result = part1.get_connector_text(at:param.at);
      end if;
    elif (param.at == End::End OR param.at == End::End_Fixed)
      select any part2 related by self->R_PART[R207] 
        where selected.OIR_ID != part1.OIR_ID;
      if (not_empty part2)
        result = part2.get_connector_text(at:param.at);
      end if;
    end if;
  else
    select any part related by self->R_PART[R207] where (selected.Obj_ID == param.Obj_ID);
    if (not_empty part)
      result = part.get_connector_text(at:param.at);
    end if;
  end if;
else
  if (isReflexive)
    if (param.at == End::Start OR param.at == End::Start_Fixed)
      select any part related by self->R_PART[R207];
      if (not_empty part)
        result = part.get_connector_text(at:param.at);
      end if;
    elif (param.at == End::End OR param.at == End::End_Fixed)
      select one form related by self->R_FORM[R208];
      if (not_empty form)
        result = form.get_connector_text(at:param.at);
      end if;
    end if;
  else
    select any part related by self->R_PART[R207] where (selected.Obj_ID == param.Obj_ID);
    if (not_empty part)
      result = part.get_connector_text(at:param.at);
    else
      select one form related by self->R_FORM[R208] where (selected.Obj_ID == param.Obj_ID);
      if (not_empty form)
        result = form.get_connector_text(at:param.at);
      end if;
    end if;
  end if;
end if;
return result;
',
	1,
	'',
	10729);
INSERT INTO O_TPARM
	VALUES (10730,
	10728,
	'Obj_ID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (10731,
	10728,
	'at',
	880,
	0,
	'',
	10730,
	'');
INSERT INTO O_TFR
	VALUES (10732,
	10652,
	'dispose',
	'The dispose operation for the R_SIMP class.',
	19,
	1,
	'select one assoc related by self->R_REL[R206];
unrelate self from assoc across R206;
select many parts related by self->R_PART[R207];
for each part in parts
  unrelate self from part across R207;
end for;
select one form related by self->R_FORM[R208];
if(not_empty form)
  unrelate self from form across R208;
end if;
delete object instance self;',
	1,
	'',
	10733);
INSERT INTO O_TFR
	VALUES (10734,
	10652,
	'migrateToLinked',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// create the class as link
create object instance assr of R_ASSR;

// Unformalize self if it is formalized
if (self.isFormalized())
  self.unformalize();
end if;
select one toAssoc related by self->R_REL[R206];
select any fromClass related by self->R_REL[R206]->S_SS[R4]->S_DOM[R1]->S_SS[R1]->O_OBJ[R2] where (selected.Obj_ID == param.using);
if (empty fromClass)
   // see if this is in a package (isInGenericPackage)
   select any fromClass related by self->R_REL[R206]->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405]->EP_PKG[R1405]->PE_PE[R8000]->O_OBJ[R8001]  where (selected.Obj_ID == param.using);
end if;
// migrate the simple association to a linked association
create object instance assoc of R_ASSOC;
unrelate self from toAssoc across R206;
relate assoc to toAssoc across R206;
//
select many parts related by self->R_PART[R207];
if (cardinality parts == 1)
  // this association is formalized 
  // migrate from participant to oneside
  select any part related by self->R_PART[R207];
  select one rto related by part->R_RTO[R204];
  unrelate part from rto across R204;
  unrelate self from part across R207;
  create object instance aone of R_AONE;
  aone.Mult = part.Mult;
  aone.Cond = part.Cond;
  aone.Txt_Phrs = part.Txt_Phrs;
  relate rto to aone across R204;
  delete object instance part;
  // link the one side to the new linked association
  relate aone to assoc across R209;
  // migrate from formalizer to otherside
  select one form related by self->R_FORM[R208];
  select one rgo related by form->R_RGO[R205];
  unrelate form from rgo across R205;
  unrelate self from form across R208;
  select one oir related by rgo->R_OIR[R203];
  unrelate oir from rgo across R203;
  rgo.dispose();
  create object instance othRto of R_RTO;
  relate oir to othRto across R203;
  create object instance aoth of R_AOTH;
  aoth.Mult = form.Mult;
  aoth.Cond = form.Cond;
  aoth.Txt_Phrs = form.Txt_Phrs;
  delete object instance form;
  relate othRto to aoth across R204;
  // link the other side to the new linked association
  relate aoth to assoc across R210;
  select one refClass related by oir->O_OBJ[R201];
else
  // this association is unformalized
  doingOneSide = true;
  for each part in parts
    if (doingOneSide)
      // migrate from participant to oneside
      select one rto related by part->R_RTO[R204];
      unrelate part from rto across R204;
      unrelate self from part across R207;
      create object instance aone of R_AONE;
      aone.Mult = part.Mult;
      aone.Cond = part.Cond;
      aone.Txt_Phrs = part.Txt_Phrs;
      delete object instance part;
      relate rto to aone across R204;
      // link the one side to the new linked association
      relate aone to assoc across R209;
      doingOneSide = false;
    else
      // migrate from participant to otherside
      select one rto related by part->R_RTO[R204];
      unrelate part from rto across R204;
      unrelate self from part across R207;
      create object instance aoth of R_AOTH;
      aoth.Mult = part.Mult;
      aoth.Cond = part.Cond;
      aoth.Txt_Phrs = part.Txt_Phrs;
      delete object instance part;
      relate rto to aoth across R204;
      // link the other side to the new linked association
      relate aoth to assoc across R210;
    end if;
  end for;
end if;
// link the fromClass to the association
create object instance oir of R_OIR;
relate fromClass to toAssoc across R201 using oir;
// create the referring class in association
create object instance rgo of R_RGO;
relate rgo to oir across R203;
relate rgo to assr across R205;
// link it with the linked association
relate assr to assoc across R211;
if ( param.imported_id != GD::NULL_UNIQUE_ID() )
  // link class is an imported class
  select any imp_class related by fromClass->O_IOBJ[R101] 
        where selected.IObj_ID == param.imported_id;
  relate imp_class to oir across R202;
end if;
delete object instance self;
',
	1,
	'',
	10735);
INSERT INTO O_TPARM
	VALUES (10736,
	10734,
	'using',
	296,
	0,
	'',
	10737,
	'');
INSERT INTO O_TPARM
	VALUES (10737,
	10734,
	'imported_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10735,
	10652,
	'isFormalized',
	'',
	316,
	1,
	'select one form related by self->R_FORM[R208];
if ( not_empty form )
  select any rto related by self->R_PART[R207]->R_RTO[R204];
  select any rtida related by rto->O_RTIDA[R110];
  if ( empty rtida )
    select one assoc related by self->R_REL[R206];
    rel_num = GD::int_to_string(value: assoc.Numb );
    USER::logError(msg: "Association R"+rel_num+" has inconsistent formalization data",path:"");
  end if;
  return true;
end if;
return false;
',
	1,
	'',
	10728);
INSERT INTO O_TFR
	VALUES (10729,
	10652,
	'formalize',
	'',
	19,
	1,
	'if ( self.isFormalized() )
  self.unformalize();
end if;

select any part related by self->R_PART[R207]
  where selected.OIR_ID == param.part_oir_id;

// migrate participant to Class As Simple Formalizer
// select using OIR_ID so that we get a different instance in the reflexive case
select any form_part related by self->R_PART[R207]
  where selected.OIR_ID != part.OIR_ID;
form_part.migrateToFormalizer();
select one form related by self->R_FORM[R208];

select one part_rto related by part->R_RTO[R204];
select one part_obj related by part_rto->R_OIR[R203]->O_OBJ[R201];
select any oid related by part_obj->O_ID[R104] where selected.Oid_ID == param.id_id;
relate oid to part_rto across R109;

select many oida_set related by oid->O_OIDA[R105];

select one form_rgo related by form->R_RGO[R205];
select one form_obj related by form_rgo->R_OIR[R203]->O_OBJ[R201];
for each oida in oida_set
    newAttr_id = oida.addReference(rel_id: self.Rel_ID,
        rto_obj_id: part_rto.Obj_ID, rto_oir_id: part_rto.OIR_ID, 
        rgo_obj_id: form_rgo.Obj_ID, rgo_oir_id: form_rgo.OIR_ID,
        id: -1);
end for;
',
	1,
	'',
	10732);
INSERT INTO O_TPARM
	VALUES (10738,
	10729,
	'part_oir_id',
	296,
	0,
	'',
	10739,
	'');
INSERT INTO O_TPARM
	VALUES (10739,
	10729,
	'id_id',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10740,
	10652,
	'unformalize',
	'',
	19,
	1,
	'select any part_rto related by self->R_PART[R207]->R_RTO[R204];  // there is only one

part_rto.unformalize();

// migrate formalizer back to Class As Simple Participant
select one form related by self->R_FORM[R208];
form.migrateToParticipant();


',
	1,
	'',
	10734);
INSERT INTO O_TFR
	VALUES (10733,
	10652,
	'canParticipate',
	'',
	316,
	1,
	'select any part related by self->R_PART[R207]
    where selected.Obj_ID == param.id;
if ( not_empty part )
  select any oida related by part->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201]->O_ID[R104]->O_OIDA[R105];
  // participant has to have an id with attributes and cardinality of one (value zero)
  return not_empty oida and part.Mult == 0;
end if;
return false;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (10741,
	10733,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (10652,
	2322,
	0,
	2368,
	10650,
	10653,
	10651,
	10664,
	10742,
	0,
	0,
	'',
	'Association',
	'Rel_ID',
	'R206');
INSERT INTO O_RATTR
	VALUES (10664,
	10652,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (10664,
	10652,
	0,
	'Rel_ID',
	'',
	'',
	'Rel_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10652);
INSERT INTO O_OIDA
	VALUES (10664,
	10652,
	0,
	'Rel_ID');
INSERT INTO O_ID
	VALUES (1,
	10652);
INSERT INTO O_ID
	VALUES (2,
	10652);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (985,
	'Referring Class In Assoc',
	204,
	'R_RGO',
	'A referring Class In Association is a class which contains referential attributes which refer to identifying attributes across the association.',
	10642);
INSERT INTO O_TFR
	VALUES (10743,
	985,
	'dispose',
	'The O_RGO dispose function. ',
	19,
	1,
	'// Association Subsystem
select one link related by self->R_ASSR[R205];
select one sub related by self->R_SUB[R205];
select one form related by self->R_FORM[R205];
if (not_empty link)
 link.dispose();
elif (not_empty sub)
  sub.dispose();
elif (not_empty form)
  form.dispose();
end if;
select one cia related by self->R_OIR[R203];
if ( not_empty cia )
  unrelate self from cia across R203;
end if;
//
// Subsystem Subsystem
self.clearReferences();
//
// Finally delete self
delete object instance self;',
	1,
	'',
	10744);
INSERT INTO O_TFR
	VALUES (10744,
	985,
	'clearReferences',
	'Called by the O_RGO dispose function.
Clears the associated O_REFs.',
	19,
	1,
	'select many refs related by self->O_REF[R111];
for each ref in refs
  ref.migrateRefAttrOrDispose();
end for;
',
	1,
	'',
	0);
INSERT INTO O_REF
	VALUES (985,
	1109,
	0,
	1108,
	10700,
	10705,
	10701,
	1069,
	10745,
	0,
	0,
	'',
	'Class In Association',
	'OIR_ID',
	'R203');
INSERT INTO O_RATTR
	VALUES (1069,
	985,
	1108,
	1109,
	1,
	'OIR_ID');
INSERT INTO O_ATTR
	VALUES (1069,
	985,
	1071,
	'OIR_ID',
	'',
	'',
	'OIR_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (985,
	1109,
	0,
	10702,
	10700,
	10705,
	10701,
	1070,
	10746,
	0,
	0,
	'',
	'Class In Association',
	'Obj_ID',
	'R203');
INSERT INTO O_RATTR
	VALUES (1070,
	985,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (1070,
	985,
	0,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (985,
	1109,
	0,
	10703,
	10700,
	10705,
	10701,
	1071,
	10747,
	0,
	0,
	'',
	'Class In Association',
	'Rel_ID',
	'R203');
INSERT INTO O_RATTR
	VALUES (1071,
	985,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (1071,
	985,
	1070,
	'Rel_ID',
	'',
	'',
	'Rel_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	985);
INSERT INTO O_OIDA
	VALUES (1069,
	985,
	0,
	'OIR_ID');
INSERT INTO O_OIDA
	VALUES (1070,
	985,
	0,
	'Obj_ID');
INSERT INTO O_OIDA
	VALUES (1071,
	985,
	0,
	'Rel_ID');
INSERT INTO O_ID
	VALUES (1,
	985);
INSERT INTO O_ID
	VALUES (2,
	985);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (983,
	'Referred To Class in Assoc',
	203,
	'R_RTO',
	'A Referred To Class In Association is a class which contains identifying attributes which are referred to across the association.',
	10642);
INSERT INTO O_TFR
	VALUES (10748,
	983,
	'dispose',
	'The dispose function for the O_RTO class.',
	19,
	1,
	'// Association Subsystem
select one zuper related by self->R_SUPER[R204];
select one one related by self->R_AONE[R204];
select one other related by self->R_AOTH[R204];
select one part related by self->R_PART[R204];
if (not_empty zuper)
  zuper.dispose();
elif (not_empty one)
  one.dispose();
elif (not_empty other)
  other.dispose();
elif (not_empty part)
  part.dispose();
end if;
select one cia related by self->R_OIR[R203];
if ( not_empty cia )
  unrelate self from cia across R203;
end if;
//
// Subsystem Subsystem
select one oid related by self->O_ID[R109];
if (not_empty oid)
  unrelate self from oid across R109;
end if;
select many rtidas related by self->O_RTIDA[R110];
for each rtida in rtidas
  rtida.dispose();
end for;
//
// Finally delete self
delete object instance self;
',
	1,
	'',
	10749);
INSERT INTO O_TFR
	VALUES (10750,
	983,
	'unformalize',
	'',
	19,
	1,
	'select many rtida_set related by self->O_RTIDA[R110];
for each rtida in rtida_set
  select many ref_set related by rtida->O_REF[R111];
  for each ref in ref_set
    ref.migrateRefAttrOrDispose();  
  end for;
  select one oida related by rtida->O_OIDA[R110];
  unrelate oida from self across R110 using rtida;
  delete object instance rtida;
end for;

select one oid related by self->O_ID[R109];
unrelate oid from self across R109;
',
	1,
	'',
	10748);
INSERT INTO O_TFR
	VALUES (10749,
	983,
	'addAttributeToIdentifier',
	'',
	19,
	1,
	'select any oida related by self->O_ID[R109]->O_OIDA[R105] 
     where selected.Attr_ID == param.attr_id;
if ( not_empty oida )
  select many rgo_set related by self->R_OIR[R203]->R_REL[R201]->R_OIR[R201]->R_RGO[R203]
    where ( selected.OIR_ID != self.OIR_ID and selected.Rel_ID == self.Rel_ID );
  for each rgo in rgo_set
    select any ref_attr_id related by rgo->O_REF[R111]->O_RATTR[R108]->O_ATTR[R106]->O_OIDA[R105];
    id_id = -1;
    if ( not_empty ref_attr_id )
      select one assoc related by rgo->R_OIR[R203]->R_REL[R201]->R_ASSOC[R206];
      select one subsup related by rgo->R_OIR[R203]->R_REL[R201]->R_SUBSUP[R206];
      if not_empty assoc or not_empty subsup
        // these associations require the referentials be part of the
        // identifier.
         id_id = ref_attr_id.Oid_ID;
      end if;
    end if;
    newAttr_id = oida.addReference(rel_id: self.Rel_ID,
        rto_obj_id: self.Obj_ID, rto_oir_id: self.OIR_ID, 
        rgo_obj_id: rgo.Obj_ID, rgo_oir_id: rgo.OIR_ID,
        id: id_id);
    if ( id_id != -1 )
      // we''ve updated the id for the rgo
      // check if we need to update any referentials referring
      // to the rgo''s identifier
      select many rto_set related by ref_attr_id->O_ID[R105]->R_RTO[R109];
      for each rto in rto_set
        rto.addAttributeToIdentifier(attr_id: newAttr_id);
      end for;
    end if;
  end for;
end if;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (10751,
	10749,
	'attr_id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_REF
	VALUES (983,
	1109,
	0,
	1108,
	10700,
	10704,
	10701,
	1055,
	10752,
	0,
	0,
	'',
	'Class In Association',
	'OIR_ID',
	'R203');
INSERT INTO O_RATTR
	VALUES (1055,
	983,
	1108,
	1109,
	1,
	'OIR_ID');
INSERT INTO O_ATTR
	VALUES (1055,
	983,
	1057,
	'OIR_ID',
	'',
	'',
	'OIR_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (983,
	1039,
	0,
	1041,
	1064,
	1065,
	1066,
	1054,
	10753,
	0,
	0,
	'',
	'Class Identifier',
	'Oid_ID',
	'R109');
INSERT INTO O_RATTR
	VALUES (1054,
	983,
	1041,
	1039,
	1,
	'Oid_ID');
INSERT INTO O_ATTR
	VALUES (1054,
	983,
	1055,
	'Oid_ID',
	'Not_participating_value: -1
',
	'',
	'Oid_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (983,
	1109,
	0,
	10702,
	10700,
	10704,
	10701,
	1056,
	10754,
	0,
	0,
	'',
	'Class In Association',
	'Obj_ID',
	'R203');
INSERT INTO O_REF
	VALUES (983,
	1039,
	0,
	1042,
	1064,
	1065,
	1066,
	1056,
	10755,
	10754,
	0,
	'',
	'Class Identifier',
	'Obj_ID',
	'R109');
INSERT INTO O_RATTR
	VALUES (1056,
	983,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (1056,
	983,
	0,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (983,
	1109,
	0,
	10703,
	10700,
	10704,
	10701,
	1057,
	10756,
	0,
	0,
	'',
	'Class In Association',
	'Rel_ID',
	'R203');
INSERT INTO O_RATTR
	VALUES (1057,
	983,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (1057,
	983,
	1056,
	'Rel_ID',
	'',
	'',
	'Rel_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	983);
INSERT INTO O_OIDA
	VALUES (1055,
	983,
	0,
	'OIR_ID');
INSERT INTO O_OIDA
	VALUES (1056,
	983,
	0,
	'Obj_ID');
INSERT INTO O_OIDA
	VALUES (1057,
	983,
	0,
	'Rel_ID');
INSERT INTO O_ID
	VALUES (1,
	983);
INSERT INTO O_OIDA
	VALUES (1054,
	983,
	1,
	'Oid_ID');
INSERT INTO O_OIDA
	VALUES (1055,
	983,
	1,
	'OIR_ID');
INSERT INTO O_OIDA
	VALUES (1056,
	983,
	1,
	'Obj_ID');
INSERT INTO O_OIDA
	VALUES (1057,
	983,
	1,
	'Rel_ID');
INSERT INTO O_ID
	VALUES (2,
	983);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10656,
	'Linked Association',
	208,
	'R_ASSOC',
	'A linked association (R_ASSOC) is an association between two classes (R_AONE and R_AOTH)  which is formalized in an associative class (R_ASSR).  The class that holds the referential attributes for  the association is known as the referring class in the association (R_RGO) and the class that participates in the association and carries the identifying attributes used to formalize the association is the referred to class  (R_RTO).  Linked associations require formalization of the association in a class called the associator (R_ASSR).',
	10642);
INSERT INTO O_TFR
	VALUES (10757,
	10656,
	'get_connector_text',
	'Obtains the phrases by calling the operations of the same name in the
associated R_AONE/R_AOTH/R_ASSOC instances.
-----------------------------------------------------------------------------------
Bridge:GD',
	322,
	1,
	'result = "";
select one rel related by self->R_REL[R206];
isReflexive = false;
if ( not_empty rel )
  isReflexive = rel.is_reflexive();
end if;
if (isReflexive)
  if (param.at == End::Start OR param.at == End::Start_Fixed)
    select one aone related by self->R_AONE[R209];
    if (not_empty aone)
      result = aone.get_connector_text(at:param.at);
    end if;
  elif (param.at == End::End OR param.at == End::End_Fixed)
    select one aoth related by self->R_AOTH[R210];
    if (not_empty aoth)
      result = aoth.get_connector_text(at:param.at);
    end if;
  end if;
else
  select one oneside related by self->R_AONE[R209] where (selected.Obj_ID == param.Obj_ID);
  if (not_empty oneside)
    result = oneside.get_connector_text(at:param.at);
  else
    select one other related by self->R_AOTH[R210] where (selected.Obj_ID == param.Obj_ID);
    if (not_empty other)
      result = other.get_connector_text(at:param.at);
    end if;
  end if;
end if;
// class as link is handled directly by the instance, so no need to delegate here . . . 
return result;',
	1,
	'',
	10758);
INSERT INTO O_TPARM
	VALUES (10759,
	10757,
	'Obj_ID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (10760,
	10757,
	'at',
	880,
	0,
	'',
	10759,
	'');
INSERT INTO O_TFR
	VALUES (10761,
	10656,
	'migrateToSimple',
	'Migrate associative association to a simple, unformalized one.
',
	19,
	1,
	'// Unformalize self if it is formalized
if (self.isFormalized())
  self.unformalize();
end if;
//
// Unlink from the Supertype, create a new Simple Assoc and relate that
//  to the Supertype
select one origAssoc related by self->R_REL[R206];
unrelate self from origAssoc across R206;
create object instance simple of R_SIMP;
relate origAssoc to simple across R206;
//
// Select the aone,  create a new rpart, copy the attrs to the
// new rpart, relate the rpart to the new simple.
select one aone related by self->R_AONE[R209];
create object instance rpart1 of R_PART;
rpart1.Mult = aone.Mult;
rpart1.Cond = aone.Cond;
rpart1.Txt_Phrs = aone.Txt_Phrs;
relate simple to rpart1 across R207;
// Disconnect aone from the rto and connect the rto to rpart1
select one rto related by aone->R_RTO[R204];
unrelate aone from rto across R204;
relate rpart1 to rto across R204;
unrelate self from aone across R209;
delete object instance aone;
//
//Select the aoth, create a second new rpart, copy the attrs to the new
//rpart, relate the rpart to the new simple.
select one aoth related by self->R_AOTH[R210];
create object instance rpart2 of R_PART;
rpart2.Mult = aoth.Mult;
rpart2.Cond = aoth.Cond;
rpart2.Txt_Phrs = aoth.Txt_Phrs;
relate simple to rpart2 across R207;
// Disconnect aoth from the rto annd connect the rto to rpart2
select one rto related by aoth->R_RTO[R204];
unrelate aoth from rto across R204;
relate rpart2 to rto across R204;
unrelate self from aoth across R210;
delete object instance aoth;
//
// select the assr, unrelate from this (to prevent its dispose from
// calling this function), and delete
select one assr related by self->R_ASSR[R211];
unrelate self from assr across R211;
select one assr_oir related by assr->R_RGO[R205]->R_OIR[R203];
assr_oir.dispose();
//
// Finally, delete self
delete object instance self;',
	1,
	'',
	10762);
INSERT INTO O_TFR
	VALUES (10763,
	10656,
	'dispose',
	'The dispose operation for the R_ASSOC class.',
	19,
	1,
	'select one assoc related by self->R_REL[R206];
unrelate self from assoc across R206;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (10762,
	10656,
	'isFormalized',
	'',
	316,
	1,
	'select one rto1 related by self->R_AONE[R209]->R_RTO[R204];
select any rtida1 related by rto1->O_RTIDA[R110];
select one rto2 related by self->R_AOTH[R210]->R_RTO[R204];
select any rtida2 related by rto2->O_RTIDA[R110];
return not_empty rtida1 and not_empty rtida2;
',
	1,
	'',
	10757);
INSERT INTO O_TFR
	VALUES (10758,
	10656,
	'formalize',
	'',
	19,
	1,
	'if ( self.isFormalized() )
  self.unformalize();
end if;

select one aone_rto related by self->R_AONE[R209]->R_RTO[R204];
select one aone_obj related by aone_rto->R_OIR[R203]->O_OBJ[R201];
select any aone_oid related by aone_obj->O_ID[R104] where selected.Oid_ID == param.one_id;
relate aone_oid to aone_rto across R109;

select one aoth_rto related by self->R_AOTH[R210]->R_RTO[R204];
select one aoth_obj related by aoth_rto->R_OIR[R203]->O_OBJ[R201];
select any aoth_oid related by aoth_obj->O_ID[R104] where selected.Oid_ID == param.oth_id;
relate aoth_oid to aoth_rto across R109;

select one assr_rgo related by self->R_ASSR[R211]->R_RGO[R205];
select one assr_obj related by assr_rgo->R_OIR[R203]->O_OBJ[R201];
unused_oid = assr_obj.findUnusedIdentifier();

select many aone_oida_set related by aone_oid->O_OIDA[R105];
for each oida in aone_oida_set
    newAttr_id = oida.addReference(rel_id: self.Rel_ID,
        rto_obj_id: aone_rto.Obj_ID, rto_oir_id: aone_rto.OIR_ID, 
        rgo_obj_id: assr_rgo.Obj_ID, rgo_oir_id: assr_rgo.OIR_ID,
        id: unused_oid);
end for;

select many aoth_oida_set related by aoth_oid->O_OIDA[R105];
for each oida in aoth_oida_set
    newAttr_id = oida.addReference(rel_id: self.Rel_ID,
        rto_obj_id: aoth_rto.Obj_ID, rto_oir_id: aoth_rto.OIR_ID, 
        rgo_obj_id: assr_rgo.Obj_ID, rgo_oir_id: assr_rgo.OIR_ID,
        id: unused_oid);
end for;
',
	1,
	'',
	10763);
INSERT INTO O_TPARM
	VALUES (10764,
	10758,
	'one_id',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (10765,
	10758,
	'oth_id',
	298,
	0,
	'',
	10764,
	'');
INSERT INTO O_TFR
	VALUES (10766,
	10656,
	'unformalize',
	'',
	19,
	1,
	'
select one aone_rto related by self->R_AONE[R209]->R_RTO[R204];
select one aone_oir related by aone_rto->R_OIR[R203];
select one aoth_rto related by self->R_AOTH[R210]->R_RTO[R204];
select one aoth_oir related by aoth_rto->R_OIR[R203];

aone_rto.unformalize();
aoth_rto.unformalize();

// have to relate again due to propagation of previous unrelates
relate aone_oir to aone_rto across R203;
relate aoth_oir to aoth_rto across R203;


',
	1,
	'',
	10761);
INSERT INTO O_REF
	VALUES (10656,
	2322,
	0,
	2368,
	10650,
	10657,
	10651,
	10673,
	10767,
	0,
	0,
	'',
	'Association',
	'Rel_ID',
	'R206');
INSERT INTO O_RATTR
	VALUES (10673,
	10656,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (10673,
	10656,
	0,
	'Rel_ID',
	'',
	'',
	'Rel_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10656);
INSERT INTO O_OIDA
	VALUES (10673,
	10656,
	0,
	'Rel_ID');
INSERT INTO O_ID
	VALUES (1,
	10656);
INSERT INTO O_ID
	VALUES (2,
	10656);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10654,
	'Derived Association',
	215,
	'R_COMP',
	'A compositional association (R_COMP) is an association between two classes R_CONE, on one side of the association, and R_COTH, on the other.  A compositional association is one  that is formalized by a query along other associations in a loop (R_COMP.Rel_Chn).',
	10642);
INSERT INTO O_TFR
	VALUES (10768,
	10654,
	'get_connector_text',
	'Obtains the phrases by calling the operations of the same name in the
associated R_CONE/R_COTH instances.
-----------------------------------------------------------------------------------
Bridge:GD
',
	322,
	1,
	'result = "";
select one rel related by self->R_REL[R206];
isReflexive = false;
if ( not_empty rel )
  isReflexive = rel.is_reflexive();
end if;
if (isReflexive)
  if (param.at == End::Start OR param.at == End::Start_Fixed)
    select one cone related by self->R_CONE[R214];
    if (not_empty cone)
      result = cone.get_connector_text(at:param.at);
    end if;
  elif (param.at == End::End OR param.at == End::End_Fixed)
    select one coth related by self->R_COTH[R215];
    if (not_empty coth)
      result = coth.get_connector_text(at:param.at);
    end if;
  end if;
else
  select one cone related by self->R_CONE[R214] where (selected.Obj_ID == param.Obj_ID);
  if (not_empty cone)
    result = cone.get_connector_text(at:param.at);
  else
    select one coth related by self->R_COTH[R215] where (selected.Obj_ID == param.Obj_ID);
    if (not_empty coth)
      result = coth.get_connector_text(at:param.at);
    end if;
  end if;
end if;
return result;
',
	1,
	'',
	10769);
INSERT INTO O_TPARM
	VALUES (10770,
	10768,
	'Obj_ID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (10771,
	10768,
	'at',
	880,
	0,
	'',
	10770,
	'');
INSERT INTO O_TFR
	VALUES (10769,
	10654,
	'dispose',
	'The dispose operation for the R_COMP class.',
	19,
	1,
	'select one assoc related by self->R_REL[R206];
unrelate self from assoc across R206;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (10772,
	10654,
	'get_name',
	'',
	322,
	1,
	'select one rel related by self->R_REL[R206];
return rel.get_name();
',
	1,
	'',
	10768);
INSERT INTO O_NBATTR
	VALUES (10773,
	10654);
INSERT INTO O_BATTR
	VALUES (10773,
	10654);
INSERT INTO O_ATTR
	VALUES (10773,
	10654,
	10695,
	'Rel_Chn',
	'Full Name: Association Chain
Description: Composed association chain as it appears in the model.
',
	'',
	'Rel_Chn',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (10654,
	2322,
	0,
	2368,
	10650,
	10655,
	10651,
	10695,
	10774,
	0,
	0,
	'',
	'Association',
	'Rel_ID',
	'R206');
INSERT INTO O_RATTR
	VALUES (10695,
	10654,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (10695,
	10654,
	0,
	'Rel_ID',
	'',
	'',
	'Rel_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10654);
INSERT INTO O_OIDA
	VALUES (10695,
	10654,
	0,
	'Rel_ID');
INSERT INTO O_ID
	VALUES (1,
	10654);
INSERT INTO O_ID
	VALUES (2,
	10654);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (1109,
	'Class In Association',
	202,
	'R_OIR',
	'A Class In Association captures the role which a class plays in participating in an association.',
	10642);
INSERT INTO O_TFR
	VALUES (10775,
	1109,
	'get_text_phrase',
	'Returns the association phrase at the end of the association this class is attached to.

',
	322,
	1,
	'select one part related by self->R_RTO[R203]->R_PART[R204];
if ( not_empty part )
  return part.Txt_Phrs;
end if;

select one form related by self->R_RGO[R203]->R_FORM[R205];
if ( not_empty form )
  return form.Txt_Phrs;
end if;

select one aone related by self->R_RTO[R203]->R_AONE[R204];
if ( not_empty aone )
  return aone.Txt_Phrs;
end if;

select one aoth related by self->R_RTO[R203]->R_AOTH[R204];
if ( not_empty aoth )
  return aoth.Txt_Phrs;
end if;

select one cone related by self->R_CONE[R203];
if ( not_empty cone )
  return cone.Txt_Phrs;
end if;

select one coth related by self->R_COTH[R203];
if ( not_empty coth )
  return coth.Txt_Phrs;
end if;

return "";

',
	1,
	'',
	10776);
INSERT INTO O_TFR
	VALUES (10776,
	1109,
	'get_multiplicity',
	'Returns the multiplicity at the end of the association this class is attached to.

',
	2434,
	1,
	'select one part related by self->R_RTO[R203]->R_PART[R204];
if ( not_empty part )
  if (  part.Mult == 0 ) return Multiplicity::One; else return Multiplicity::Many; end if;
end if;

select one form related by self->R_RGO[R203]->R_FORM[R205];
if ( not_empty form )
  if (  form.Mult == 0 ) return Multiplicity::One; else return Multiplicity::Many; end if;
end if;

select one aone related by self->R_RTO[R203]->R_AONE[R204];
if ( not_empty aone )
  if (  aone.Mult == 0 ) return Multiplicity::One; else return Multiplicity::Many; end if;
end if;

select one aoth related by self->R_RTO[R203]->R_AOTH[R204];
if ( not_empty aoth )
  if (  aoth.Mult == 0 ) return Multiplicity::One; else return Multiplicity::Many; end if;
end if;

select one assr related by self->R_RGO[R203]->R_ASSR[R205];
if ( not_empty assr )
  if (  assr.Mult == 0 ) return Multiplicity::One; else return Multiplicity::Many; end if;
end if;

select one cone related by self->R_CONE[R203];
if ( not_empty cone )
  if (  cone.Mult == 0 ) return Multiplicity::One; else return Multiplicity::Many; end if;
end if;

select one coth related by self->R_COTH[R203];
if ( not_empty coth )
  if (  coth.Mult == 0 ) return Multiplicity::One; else return Multiplicity::Many; end if;
end if;

return Multiplicity::Unknown;

',
	1,
	'',
	10777);
INSERT INTO O_TFR
	VALUES (10777,
	1109,
	'dispose',
	'The dispose operation for this class.
Select the related subtype and call it''s dispose operation.
Then delete self.',
	19,
	1,
	'// Association Subsystem
select one rgo related by self->R_RGO[R203];
select one rto related by self->R_RTO[R203];
select one cone related by self->R_CONE[R203];
select one coth related by self->R_COTH[R203];
if (not_empty rgo)
  rgo.dispose();
elif (not_empty rto)
  rto.dispose();
elif (not_empty cone)
  cone.dispose();
elif (not_empty coth)
  coth.dispose();
end if;
select one iobj related by self->O_IOBJ[R202];
if ( not_empty iobj )
  unrelate self from iobj across R202;
end if;
//
// Finally delete self
select one obj related by self->O_OBJ[R201];
select one rel related by self->R_REL[R201];
unrelate obj from rel across R201 using self;
select many oirs related by rel->R_OIR[R201];
if (not_empty rel and cardinality oirs == 0)
  // if this is the last class in the association . . .
  rel.dispose();
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_NBATTR
	VALUES (1108,
	1109);
INSERT INTO O_BATTR
	VALUES (1108,
	1109);
INSERT INTO O_ATTR
	VALUES (1108,
	1109,
	10703,
	'OIR_ID',
	'Full Name: Class In Association Identifier',
	'',
	'OIR_ID',
	0,
	296,
	'',
	'');
INSERT INTO O_REF
	VALUES (1109,
	30,
	0,
	150,
	10646,
	10648,
	10649,
	10702,
	10778,
	0,
	0,
	'',
	'Model Class',
	'Obj_ID',
	'R201');
INSERT INTO O_RATTR
	VALUES (10702,
	1109,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (10702,
	1109,
	0,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1109,
	1050,
	0,
	1360,
	10719,
	10720,
	10721,
	10779,
	10780,
	0,
	0,
	'',
	'Imported Class',
	'IObj_ID',
	'R202');
INSERT INTO O_RATTR
	VALUES (10779,
	1109,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (10779,
	1109,
	1108,
	'IObj_ID',
	'',
	'',
	'IObj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (1109,
	2322,
	0,
	2368,
	10646,
	10648,
	10647,
	10703,
	10781,
	0,
	0,
	'',
	'Association',
	'Rel_ID',
	'R201');
INSERT INTO O_RATTR
	VALUES (10703,
	1109,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (10703,
	1109,
	10702,
	'Rel_ID',
	'',
	'',
	'Rel_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	1109);
INSERT INTO O_OIDA
	VALUES (1108,
	1109,
	0,
	'OIR_ID');
INSERT INTO O_OIDA
	VALUES (10702,
	1109,
	0,
	'Obj_ID');
INSERT INTO O_OIDA
	VALUES (10703,
	1109,
	0,
	'Rel_ID');
INSERT INTO O_ID
	VALUES (1,
	1109);
INSERT INTO O_ID
	VALUES (2,
	1109);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10683,
	'Class As Supertype',
	213,
	'R_SUPER',
	'This class represents a class playing a supertype role in a supertype/subtype association.',
	10642);
INSERT INTO O_TFR
	VALUES (10782,
	10683,
	'get_connector_text',
	'Returns ''Disjoint, Complete'' for the start, and the Association number
for the end (note this differs from every other Association where the
''R'' number is the middle phrase).
-----------------------------------------------------------------------------------
Bridge:GD
',
	322,
	1,
	'result = "";
if (param.at == End::Start)
  result = "";
elif (param.at == End::End)
  select one rel related by self->R_SUBSUP[R212]->R_REL[R206];
  if ( not_empty rel )
    // Generalizations have the R number on the end . . . 
    result = "R" + GD::int_to_string(value:rel.Numb);
  else
    result = "R???";
  end if;
end if;
return result;',
	1,
	'',
	10783);
INSERT INTO O_TPARM
	VALUES (10784,
	10782,
	'at',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10783,
	10683,
	'dispose',
	'The dispose operation for the R_SUPER class.',
	19,
	1,
	'select one rsubsup related by self->R_SUBSUP[R212];
unrelate self from rsubsup across R212;
select one rto related by self->R_RTO[R204];
unrelate self from rto across R204;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (10785,
	10683,
	'get_name',
	'',
	322,
	1,
	'select one obj related by self->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201];
return obj.Name;
',
	1,
	'',
	10782);
INSERT INTO O_REF
	VALUES (10683,
	983,
	0,
	1055,
	10713,
	10715,
	10714,
	10786,
	10787,
	0,
	0,
	'',
	'Referred To Class in Assoc',
	'OIR_ID',
	'R204');
INSERT INTO O_RATTR
	VALUES (10786,
	10683,
	1108,
	1109,
	1,
	'OIR_ID');
INSERT INTO O_ATTR
	VALUES (10786,
	10683,
	10788,
	'OIR_ID',
	'',
	'',
	'OIR_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10683,
	983,
	0,
	1056,
	10713,
	10715,
	10714,
	10789,
	10790,
	0,
	0,
	'',
	'Referred To Class in Assoc',
	'Obj_ID',
	'R204');
INSERT INTO O_RATTR
	VALUES (10789,
	10683,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (10789,
	10683,
	0,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10683,
	10658,
	0,
	10686,
	10682,
	10684,
	10685,
	10788,
	10791,
	0,
	0,
	'',
	'Subtype Supertype Association',
	'Rel_ID',
	'R212');
INSERT INTO O_REF
	VALUES (10683,
	983,
	0,
	1057,
	10713,
	10715,
	10714,
	10788,
	10792,
	10791,
	0,
	'',
	'Referred To Class in Assoc',
	'Rel_ID',
	'R204');
INSERT INTO O_RATTR
	VALUES (10788,
	10683,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (10788,
	10683,
	10789,
	'Rel_ID',
	'',
	'',
	'Rel_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10683);
INSERT INTO O_OIDA
	VALUES (10786,
	10683,
	0,
	'OIR_ID');
INSERT INTO O_OIDA
	VALUES (10789,
	10683,
	0,
	'Obj_ID');
INSERT INTO O_OIDA
	VALUES (10788,
	10683,
	0,
	'Rel_ID');
INSERT INTO O_ID
	VALUES (1,
	10683);
INSERT INTO O_ID
	VALUES (2,
	10683);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10688,
	'Class As Subtype',
	214,
	'R_SUB',
	'This class represents a class playing a subtype role in a supertype/subtype association.',
	10642);
INSERT INTO O_TFR
	VALUES (10793,
	10688,
	'dispose',
	'The dispose operation for the R_SUB class.',
	19,
	1,
	'select one rsubsup related by self->R_SUBSUP[R213];
select one subtypeClass related by self->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201];
// delete any non-local events that were received
// through this subtype
select one supertypeClass related by rsubsup->R_SUPER[R212]->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201];
unrelate self from rsubsup across R213;
subtypeClass.disposeLowerNonLocalEvents(disposeSelfEvents:true, originalId:subtypeClass.Obj_ID, polyId:GD::NULL_UNIQUE_ID(), originalSupertypeId:supertypeClass.Obj_ID);
select one rgo related by self->R_RGO[R205];
select one cia related by rgo->R_OIR[R203];
if(not_empty cia)
  unrelate self from rgo across R205;
  cia.dispose();
end if;
delete object instance self;
',
	1,
	'',
	10794);
INSERT INTO O_TFR
	VALUES (10795,
	10688,
	'get_style',
	'A subtype line is always solid
-------------------------------------------------------
Bridge: GD',
	784,
	1,
	'return Style::Solid;',
	1,
	'',
	10796);
INSERT INTO O_TPARM
	VALUES (10797,
	10795,
	'at',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10796,
	10688,
	'get_ooa_id',
	'The GD needs this value to set up the connector ooa_id.
----------------------------------------------------
Bridge:GD',
	296,
	1,
	'return self.OIR_ID;',
	1,
	'',
	10798);
INSERT INTO O_TFR
	VALUES (10799,
	10688,
	'get_connector_text',
	'Subtype lines have no adorning text.
-----------------------------------------------
Bridge:GD',
	322,
	1,
	'return "";',
	1,
	'',
	10793);
INSERT INTO O_TPARM
	VALUES (10800,
	10799,
	'OOA_ID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (10801,
	10799,
	'OOA_TypeIsImportedClass',
	316,
	0,
	'',
	10800,
	'');
INSERT INTO O_TPARM
	VALUES (10802,
	10799,
	'at',
	880,
	0,
	'',
	10801,
	'');
INSERT INTO O_TPARM
	VALUES (10803,
	10799,
	'parent_ID',
	296,
	0,
	'',
	10802,
	'');
INSERT INTO O_TFR
	VALUES (10798,
	10688,
	'get_name',
	'Returns the name of the class which is being subtyped.',
	322,
	1,
	'select one obj related by self->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201];
return obj.Name;
',
	1,
	'',
	10799);
INSERT INTO O_TFR
	VALUES (10794,
	10688,
	'actionFilter',
	'Bridge: UI
	',
	316,
	1,
	'select one rel related by self->R_SUBSUP[R213]->R_REL[R206];
return rel.actionFilter(name: param.name, value: param.value );
',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (10804,
	10794,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (10805,
	10794,
	'value',
	322,
	0,
	'',
	10804,
	'');
INSERT INTO O_REF
	VALUES (10688,
	985,
	0,
	1069,
	10708,
	10710,
	10709,
	10806,
	10807,
	0,
	0,
	'',
	'Referring Class In Assoc',
	'OIR_ID',
	'R205');
INSERT INTO O_RATTR
	VALUES (10806,
	10688,
	1108,
	1109,
	1,
	'OIR_ID');
INSERT INTO O_ATTR
	VALUES (10806,
	10688,
	10808,
	'OIR_ID',
	'',
	'',
	'OIR_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10688,
	985,
	0,
	1070,
	10708,
	10710,
	10709,
	10809,
	10810,
	0,
	0,
	'',
	'Referring Class In Assoc',
	'Obj_ID',
	'R205');
INSERT INTO O_RATTR
	VALUES (10809,
	10688,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (10809,
	10688,
	0,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10688,
	10658,
	0,
	10686,
	10687,
	10689,
	10690,
	10808,
	10811,
	0,
	0,
	'',
	'Subtype Supertype Association',
	'Rel_ID',
	'R213');
INSERT INTO O_REF
	VALUES (10688,
	985,
	0,
	1071,
	10708,
	10710,
	10709,
	10808,
	10812,
	10811,
	0,
	'',
	'Referring Class In Assoc',
	'Rel_ID',
	'R205');
INSERT INTO O_RATTR
	VALUES (10808,
	10688,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (10808,
	10688,
	10809,
	'Rel_ID',
	'',
	'',
	'Rel_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10688);
INSERT INTO O_OIDA
	VALUES (10806,
	10688,
	0,
	'OIR_ID');
INSERT INTO O_OIDA
	VALUES (10809,
	10688,
	0,
	'Obj_ID');
INSERT INTO O_OIDA
	VALUES (10808,
	10688,
	0,
	'Rel_ID');
INSERT INTO O_ID
	VALUES (1,
	10688);
INSERT INTO O_ID
	VALUES (2,
	10688);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10661,
	'Class As Simple Participant',
	206,
	'R_PART',
	'A Class As Simple Participant is the referred to class in a simple association.',
	10642);
INSERT INTO O_TFR
	VALUES (10813,
	10661,
	'get_connector_text',
	'If the end type is fixed, examines the values of ''Cond'' and ''Mult'' and
returns the appropriate value from  ''1'', ''0..1'', ''1..*'' or ''*''. Otherwise
it returns the value of the ''Txt_Phrs'' attribute.
-----------------------------------------------------------------------------------
Bridge:GD
',
	322,
	1,
	'result = "";
if (param.at == End::Start OR param.at == End::End)
  result = self.Txt_Phrs;
elif (param.at == End::Start_Fixed OR param.at == End::End_Fixed)
  result = R_REL::get_cardinality_text(Mult:self.Mult, Cond:self.Cond);
end if;
return result;',
	1,
	'',
	10814);
INSERT INTO O_TPARM
	VALUES (10815,
	10813,
	'at',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10814,
	10661,
	'dispose',
	'The dispose operation of the R_PART class.
',
	19,
	1,
	'select one rsimp related by self->R_SIMP[R207];
unrelate self from rsimp across R207;
select one rto related by self->R_RTO[R204];
unrelate self from rto across R204;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (10816,
	10661,
	'get_name',
	'',
	322,
	1,
	'select one obj related by self->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201];
return obj.Name;
',
	1,
	'',
	10813);
INSERT INTO O_TFR
	VALUES (10817,
	10661,
	'migrateToFormalizer',
	'',
	19,
	1,
	'
create object instance rgo of R_RGO;
create object instance form of R_FORM;

form.Mult = self.Mult;
form.Cond = self.Cond;
form.Txt_Phrs = self.Txt_Phrs;

select one rto related by self->R_RTO[R204];
select one oir related by rto->R_OIR[R203];
select one simp related by self->R_SIMP[R207];

relate oir to rgo across R203;
relate rgo to form across R205;
relate form to simp across R208;

// and dispose self from supertype
rto.dispose();
',
	1,
	'',
	10818);
INSERT INTO O_TFR
	VALUES (10818,
	10661,
	'manyMultAllowed',
	'',
	316,
	1,
	'select one form related by self->R_SIMP[R207]->R_FORM[R208];
// if empty form, then rel is unformalized, and many multiplicity is allowed
return empty form;
',
	1,
	'',
	10816);
INSERT INTO O_TFR
	VALUES (10819,
	10661,
	'mergeDispose',
	'',
	19,
	1,
	'/**
   *  We must dispose of the Simple Association instance here
   */
select one simp related by self->R_SIMP[R207];
if(not_empty simp)
  unrelate self from simp across R207;
  simp.dispose();
end if;
select one rsimp related by self->R_SIMP[R207];
unrelate self from rsimp across R207;
select one rto related by self->R_RTO[R204];
select one cia related by rto->R_OIR[R203];
if(not_empty rto)
  unrelate self from rto across R204;
  if(not_empty cia)
    cia.dispose();
  end if;
end if;
delete object instance self;
',
	1,
	'',
	10817);
INSERT INTO O_REF
	VALUES (10661,
	983,
	0,
	1055,
	10713,
	10716,
	10714,
	10820,
	10821,
	0,
	0,
	'',
	'Referred To Class in Assoc',
	'OIR_ID',
	'R204');
INSERT INTO O_RATTR
	VALUES (10820,
	10661,
	1108,
	1109,
	1,
	'OIR_ID');
INSERT INTO O_ATTR
	VALUES (10820,
	10661,
	10822,
	'OIR_ID',
	'',
	'',
	'OIR_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10823,
	10661);
INSERT INTO O_BATTR
	VALUES (10823,
	10661);
INSERT INTO O_ATTR
	VALUES (10823,
	10661,
	10820,
	'Mult',
	'Full Name: Multiplicity
Description: Multiplicity at the participant end of the association
Data Domain: 0 = one, 1 = many
enum0: One
enum1: Many
',
	'',
	'Mult',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10824,
	10661);
INSERT INTO O_BATTR
	VALUES (10824,
	10661);
INSERT INTO O_ATTR
	VALUES (10824,
	10661,
	10823,
	'Cond',
	'Full Name: Conditionality
Description: Conditionality at the participant end of the association
Data Domain: 0 = unconditional, 1 = conditional
enum0: Unconditional
enum1: Conditional
',
	'',
	'Cond',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10825,
	10661);
INSERT INTO O_BATTR
	VALUES (10825,
	10661);
INSERT INTO O_ATTR
	VALUES (10825,
	10661,
	10824,
	'Txt_Phrs',
	'Full Name: Text Phrase
Description: Text phrase at the participant end of the association
',
	'',
	'Txt_Phrs',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (10661,
	983,
	0,
	1056,
	10713,
	10716,
	10714,
	10826,
	10827,
	0,
	0,
	'',
	'Referred To Class in Assoc',
	'Obj_ID',
	'R204');
INSERT INTO O_RATTR
	VALUES (10826,
	10661,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (10826,
	10661,
	0,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10661,
	10652,
	0,
	10664,
	10660,
	10662,
	10663,
	10822,
	10828,
	0,
	0,
	'',
	'Simple Association',
	'Rel_ID',
	'R207');
INSERT INTO O_REF
	VALUES (10661,
	983,
	0,
	1057,
	10713,
	10716,
	10714,
	10822,
	10829,
	10828,
	0,
	'',
	'Referred To Class in Assoc',
	'Rel_ID',
	'R204');
INSERT INTO O_RATTR
	VALUES (10822,
	10661,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (10822,
	10661,
	10826,
	'Rel_ID',
	'',
	'',
	'Rel_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10661);
INSERT INTO O_OIDA
	VALUES (10820,
	10661,
	0,
	'OIR_ID');
INSERT INTO O_OIDA
	VALUES (10826,
	10661,
	0,
	'Obj_ID');
INSERT INTO O_OIDA
	VALUES (10822,
	10661,
	0,
	'Rel_ID');
INSERT INTO O_ID
	VALUES (1,
	10661);
INSERT INTO O_ID
	VALUES (2,
	10661);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10666,
	'Class As Simple Formalizer',
	207,
	'R_FORM',
	'A Class As Simple Formalizer is the referring class in a simple association.',
	10642);
INSERT INTO O_TFR
	VALUES (10830,
	10666,
	'get_connector_text',
	'If the end type is fixed, examines the values of ''Cond'' and ''Mult'' and
returns the appropriate value from  ''1'', ''0..1'', ''1..*'' or ''*''. Otherwise
it returns the value of the ''Txt_Phrs'' attribute.
-----------------------------------------------------------------------------------
Bridge:GD',
	322,
	1,
	'result = "";
if (param.at == End::Start OR param.at == End::End)
  result = self.Txt_Phrs;
elif (param.at == End::Start_Fixed OR param.at == End::End_Fixed)
  result = R_REL::get_cardinality_text(Mult:self.Mult, Cond:self.Cond);
end if;
return result;',
	1,
	'',
	10831);
INSERT INTO O_TPARM
	VALUES (10832,
	10830,
	'at',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10831,
	10666,
	'dispose',
	'The dispose function for the R_FORM class.',
	19,
	1,
	'select one rsimp related by self->R_SIMP[R208];
unrelate self from rsimp across R208;
select one rto related by self->R_RGO[R205];
unrelate self from rto across R205;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (10833,
	10666,
	'get_name',
	'',
	322,
	1,
	'select one obj related by self->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201];
return obj.Name;
',
	1,
	'',
	10830);
INSERT INTO O_TFR
	VALUES (10834,
	10666,
	'migrateToParticipant',
	'',
	19,
	1,
	'
create object instance rto of R_RTO;
create object instance part of R_PART;

part.Mult = self.Mult;
part.Cond = self.Cond;
part.Txt_Phrs = self.Txt_Phrs;

select one rgo related by self->R_RGO[R205];
select one oir related by rgo->R_OIR[R203];
select one simp related by self->R_SIMP[R208];

relate oir to rto across R203;
relate rto to part across R204;
relate part to simp across R207;

// and dispose self from supertype
rgo.dispose();
',
	1,
	'',
	10835);
INSERT INTO O_TFR
	VALUES (10835,
	10666,
	'manyMultAllowed',
	'',
	316,
	1,
	'select any part related by self->R_SIMP[R208]->R_PART[R207];
return part.Mult == 0;
',
	1,
	'',
	10833);
INSERT INTO O_TFR
	VALUES (10836,
	10666,
	'mergeDispose',
	'',
	19,
	1,
	'select one rsimp related by self->R_SIMP[R208];
unrelate self from rsimp across R208;
select one rgo related by self->R_RGO[R205];
select one cia related by rgo->R_OIR[R203];
if(not_empty rgo)
  unrelate self from rgo across R205;
  if(not_empty cia)
    cia.dispose();
  end if;
end if;
// possibly being unformalized, unrelate from O_ID
select any rto related by rsimp->R_PART[R207]->R_RTO[R204];
if(not_empty rto)
  select one oid related by rto->O_ID[R109];
  if(not_empty oid)
    unrelate rto from oid across R109;
  end if;
end if;
delete object instance self;
',
	1,
	'',
	10834);
INSERT INTO O_REF
	VALUES (10666,
	985,
	0,
	1069,
	10708,
	10711,
	10709,
	10837,
	10838,
	0,
	0,
	'',
	'Referring Class In Assoc',
	'OIR_ID',
	'R205');
INSERT INTO O_RATTR
	VALUES (10837,
	10666,
	1108,
	1109,
	1,
	'OIR_ID');
INSERT INTO O_ATTR
	VALUES (10837,
	10666,
	10839,
	'OIR_ID',
	'',
	'',
	'OIR_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10840,
	10666);
INSERT INTO O_BATTR
	VALUES (10840,
	10666);
INSERT INTO O_ATTR
	VALUES (10840,
	10666,
	10837,
	'Mult',
	'Full Name: Multiplicity
Description: Multiplicity at the formalizing end of the association
Data Domain: 0 = one, 1 = many
enum0: One
enum1: Many
',
	'',
	'Mult',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10841,
	10666);
INSERT INTO O_BATTR
	VALUES (10841,
	10666);
INSERT INTO O_ATTR
	VALUES (10841,
	10666,
	10840,
	'Cond',
	'Full Name: Conditionality
Description: Conditionality at the formalizing end of the association
Data Domain: 0 = unconditional, 1 = conditional
enum0: Unconditional
enum1: Conditional
',
	'',
	'Cond',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10842,
	10666);
INSERT INTO O_BATTR
	VALUES (10842,
	10666);
INSERT INTO O_ATTR
	VALUES (10842,
	10666,
	10841,
	'Txt_Phrs',
	'Full Name: Text Phrase
Description: Text phrase at the formalizing end of the association
',
	'',
	'Txt_Phrs',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (10666,
	985,
	0,
	1070,
	10708,
	10711,
	10709,
	10843,
	10844,
	0,
	0,
	'',
	'Referring Class In Assoc',
	'Obj_ID',
	'R205');
INSERT INTO O_RATTR
	VALUES (10843,
	10666,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (10843,
	10666,
	0,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10666,
	10652,
	0,
	10664,
	10665,
	10667,
	10668,
	10839,
	10845,
	0,
	0,
	'',
	'Simple Association',
	'Rel_ID',
	'R208');
INSERT INTO O_REF
	VALUES (10666,
	985,
	0,
	1071,
	10708,
	10711,
	10709,
	10839,
	10846,
	10845,
	0,
	'',
	'Referring Class In Assoc',
	'Rel_ID',
	'R205');
INSERT INTO O_RATTR
	VALUES (10839,
	10666,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (10839,
	10666,
	10843,
	'Rel_ID',
	'',
	'',
	'Rel_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10666);
INSERT INTO O_OIDA
	VALUES (10837,
	10666,
	0,
	'OIR_ID');
INSERT INTO O_OIDA
	VALUES (10843,
	10666,
	0,
	'Obj_ID');
INSERT INTO O_OIDA
	VALUES (10839,
	10666,
	0,
	'Rel_ID');
INSERT INTO O_ID
	VALUES (1,
	10666);
INSERT INTO O_ID
	VALUES (2,
	10666);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10679,
	'Class As Link',
	211,
	'R_ASSR',
	'The Associator is the class that formalizes the linked association between two classes.',
	10642);
INSERT INTO O_TFR
	VALUES (10847,
	10679,
	'get_connector_text',
	'Returns either ''{*}'' or the empty string depending on the value of ''Mult''.
-----------------------------------------------------------------------------------
Bridge:GD',
	322,
	1,
	'result = "";
if (param.at == End::End_Fixed)
  if (self.Mult == 1)
    result = "{*}";
  end if;
end if;
return result;',
	1,
	'',
	10848);
INSERT INTO O_TPARM
	VALUES (10849,
	10847,
	'OOA_ID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (10850,
	10847,
	'OOA_TypeIsImportedClass',
	316,
	0,
	'',
	10849,
	'');
INSERT INTO O_TPARM
	VALUES (10851,
	10847,
	'at',
	880,
	0,
	'',
	10850,
	'');
INSERT INTO O_TPARM
	VALUES (10852,
	10847,
	'parent_ID',
	296,
	0,
	'',
	10851,
	'');
INSERT INTO O_TFR
	VALUES (10848,
	10679,
	'dispose',
	'The dispose operation for the R_ASSR class.  It calls R_ASSOC.migrateToSimple.  Associative associations are not removed completely, they are converted to simple, unformalized. ',
	19,
	1,
	'select one rassoc related by self->R_ASSOC[R211];
if (not_empty rassoc)
  rassoc.migrateToSimple();
  unrelate self from rassoc across R211;
end if;
select one rgo related by self->R_RGO[R205];
unrelate self from rgo across R205;
delete object instance self;
',
	1,
	'',
	10853);
INSERT INTO O_TFR
	VALUES (10854,
	10679,
	'get_ooa_id',
	'Return Rel_ID so that GD can set up connector ooa_id.
-----------------------------------------------------------------------------------
Bridge:GD',
	296,
	1,
	'return self.Rel_ID;',
	1,
	'',
	10855);
INSERT INTO O_TFR
	VALUES (10856,
	10679,
	'get_style',
	'A link line style is always a broken line.
-----------------------------------------------------------------------------------
Bridge:GD',
	784,
	1,
	'return Style::Broken;',
	1,
	'',
	10854);
INSERT INTO O_TPARM
	VALUES (10857,
	10856,
	'at',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10855,
	10679,
	'get_name',
	'',
	322,
	1,
	'select one obj related by self->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201];
return obj.Name;
',
	1,
	'',
	10847);
INSERT INTO O_TFR
	VALUES (10858,
	10679,
	'manyMultAllowed',
	'',
	316,
	1,
	'return true;
',
	1,
	'',
	10856);
INSERT INTO O_TFR
	VALUES (10853,
	10679,
	'actionFilter',
	'Bridge: UI
	',
	316,
	1,
	'select one rel related by self->R_ASSOC[R211]->R_REL[R206];
if (not_empty rel)
    return rel.actionFilter(name: param.name, value: param.value);
else
    return false;
end if;
',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (10859,
	10853,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (10860,
	10853,
	'value',
	322,
	0,
	'',
	10859,
	'');
INSERT INTO O_TFR
	VALUES (10861,
	10679,
	'mergeDispose',
	'',
	19,
	1,
	'// need to delete the Linked Assoc instance
select one link related by self->R_ASSOC[R211];
if(not_empty link)
  unrelate self from link across R211;
  link.dispose();
end if;
select one rgo related by self->R_RGO[R205];
select one cia related by rgo->R_OIR[R203];
if(not_empty rgo)
  unrelate self from rgo across R205;
  if(not_empty cia)
    cia.dispose();
  end if;
end if;
delete object instance self;
',
	1,
	'',
	10858);
INSERT INTO O_REF
	VALUES (10679,
	985,
	0,
	1069,
	10708,
	10712,
	10709,
	10862,
	10863,
	0,
	0,
	'',
	'Referring Class In Assoc',
	'OIR_ID',
	'R205');
INSERT INTO O_RATTR
	VALUES (10862,
	10679,
	1108,
	1109,
	1,
	'OIR_ID');
INSERT INTO O_ATTR
	VALUES (10862,
	10679,
	10864,
	'OIR_ID',
	'',
	'',
	'OIR_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10865,
	10679);
INSERT INTO O_BATTR
	VALUES (10865,
	10679);
INSERT INTO O_ATTR
	VALUES (10865,
	10679,
	10862,
	'Mult',
	'Full Name: Multiplicity
Description: Multiplicity of the associator.  Indicates how many instances of the associator may exist for each instance of the association between the two related classes.
Data Domain: 0 = one, 1 = many
enum0: One
enum1: Many
',
	'',
	'Mult',
	0,
	298,
	'',
	'');
INSERT INTO O_REF
	VALUES (10679,
	985,
	0,
	1070,
	10708,
	10712,
	10709,
	10866,
	10867,
	0,
	0,
	'',
	'Referring Class In Assoc',
	'Obj_ID',
	'R205');
INSERT INTO O_RATTR
	VALUES (10866,
	10679,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (10866,
	10679,
	0,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10679,
	10656,
	0,
	10673,
	10678,
	10680,
	10681,
	10864,
	10868,
	0,
	0,
	'',
	'Linked Association',
	'Rel_ID',
	'R211');
INSERT INTO O_REF
	VALUES (10679,
	985,
	0,
	1071,
	10708,
	10712,
	10709,
	10864,
	10869,
	10868,
	0,
	'',
	'Referring Class In Assoc',
	'Rel_ID',
	'R205');
INSERT INTO O_RATTR
	VALUES (10864,
	10679,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (10864,
	10679,
	10866,
	'Rel_ID',
	'',
	'',
	'Rel_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10679);
INSERT INTO O_OIDA
	VALUES (10862,
	10679,
	0,
	'OIR_ID');
INSERT INTO O_OIDA
	VALUES (10866,
	10679,
	0,
	'Obj_ID');
INSERT INTO O_OIDA
	VALUES (10864,
	10679,
	0,
	'Rel_ID');
INSERT INTO O_ID
	VALUES (1,
	10679);
INSERT INTO O_ID
	VALUES (2,
	10679);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10697,
	'Class As Derived Other Side',
	217,
	'R_COTH',
	'In a compositional association, this is one of the two classes in the association.   This class is the one at the other end of the association from R_CONE.',
	10642);
INSERT INTO O_TFR
	VALUES (10870,
	10697,
	'get_connector_text',
	'If the end type is fixed, examines the values of ''Cond'' and ''Mult'' and
returns the appropriate value from  ''1'', ''0..1'', ''1..*'' or ''*''. Otherwise
it returns the value of the ''Txt_Phrs'' attribute.
-----------------------------------------------------------------------------------
Bridge:GD
',
	322,
	1,
	'result = "";
if (param.at == End::Start OR param.at == End::End)
  result = self.Txt_Phrs;
elif (param.at == End::Start_Fixed OR param.at == End::End_Fixed)
  result = R_REL::get_cardinality_text(Mult:self.Mult, Cond:self.Cond);
end if;
return result;',
	1,
	'',
	10871);
INSERT INTO O_TPARM
	VALUES (10872,
	10870,
	'at',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10871,
	10697,
	'dispose',
	'The dispose operation for the R_COTH class.',
	19,
	1,
	'select one rcomp related by self->R_COMP[R215];
unrelate self from rcomp across R215;
select one oir related by self->R_OIR[R203];
unrelate self from oir across R203;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (10873,
	10697,
	'get_name',
	'',
	322,
	1,
	'select one object related by self->R_OIR[R203]->O_OBJ[R201];
return object.Name;
',
	1,
	'',
	10870);
INSERT INTO O_TFR
	VALUES (10874,
	10697,
	'manyMultAllowed',
	'',
	316,
	1,
	'select one cone related by self->R_COMP[R215]->R_CONE[R214];
return cone.Mult == 0;',
	1,
	'',
	10873);
INSERT INTO O_REF
	VALUES (10697,
	1109,
	0,
	1108,
	10700,
	10707,
	10701,
	10875,
	10876,
	0,
	0,
	'',
	'Class In Association',
	'OIR_ID',
	'R203');
INSERT INTO O_RATTR
	VALUES (10875,
	10697,
	1108,
	1109,
	1,
	'OIR_ID');
INSERT INTO O_ATTR
	VALUES (10875,
	10697,
	10877,
	'OIR_ID',
	'',
	'',
	'OIR_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10878,
	10697);
INSERT INTO O_BATTR
	VALUES (10878,
	10697);
INSERT INTO O_ATTR
	VALUES (10878,
	10697,
	10875,
	'Mult',
	'Full Name: Multiplicity
Description: Multiplicity at the other side of the compositional association.  This attribute is derived from the multiplicities of the classes on the far end of each association in the chain when navigating the loop as specified in R_COMP.Rel_Chn from this class (R_COTH)  to the other participating in the association (R_CONE).  It is one when all multiplicities at the far ends in the loop are one, else it is many.
Data Domain: 0 = one, 1 = many
enum0: One
enum1: Many
',
	'',
	'Mult',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10879,
	10697);
INSERT INTO O_BATTR
	VALUES (10879,
	10697);
INSERT INTO O_ATTR
	VALUES (10879,
	10697,
	10878,
	'Cond',
	'Full Name: Conditionality
Description: Conditionality at the other side of the compositional association.  This attribute is derived from the conditionalities of the classes on the far end of each association in the chain when navigating the loop as specified in R_COMP.Rel_Chn from this class (R_COTH)  to the other participating in the association (R_CONE).  It is one when all conditionalities at the far ends in the loop are one, else it is many.
Data Domain: 0 = one, 1 = many
enum0: Unconditional
enum1: Conditional
',
	'',
	'Cond',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10880,
	10697);
INSERT INTO O_BATTR
	VALUES (10880,
	10697);
INSERT INTO O_ATTR
	VALUES (10880,
	10697,
	10879,
	'Txt_Phrs',
	'Full Name: Text Phrase
',
	'',
	'Txt_Phrs',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (10697,
	1109,
	0,
	10702,
	10700,
	10707,
	10701,
	10881,
	10882,
	0,
	0,
	'',
	'Class In Association',
	'Obj_ID',
	'R203');
INSERT INTO O_RATTR
	VALUES (10881,
	10697,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (10881,
	10697,
	0,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10697,
	10654,
	0,
	10695,
	10696,
	10698,
	10699,
	10877,
	10883,
	0,
	0,
	'',
	'Derived Association',
	'Rel_ID',
	'R215');
INSERT INTO O_REF
	VALUES (10697,
	1109,
	0,
	10703,
	10700,
	10707,
	10701,
	10877,
	10884,
	10883,
	0,
	'',
	'Class In Association',
	'Rel_ID',
	'R203');
INSERT INTO O_RATTR
	VALUES (10877,
	10697,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (10877,
	10697,
	10881,
	'Rel_ID',
	'',
	'',
	'Rel_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10697);
INSERT INTO O_OIDA
	VALUES (10875,
	10697,
	0,
	'OIR_ID');
INSERT INTO O_OIDA
	VALUES (10881,
	10697,
	0,
	'Obj_ID');
INSERT INTO O_OIDA
	VALUES (10877,
	10697,
	0,
	'Rel_ID');
INSERT INTO O_ID
	VALUES (1,
	10697);
INSERT INTO O_ID
	VALUES (2,
	10697);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10692,
	'Class As Derived One Side',
	216,
	'R_CONE',
	'In a compositional association, this is one of the two classes in the association.   This class is the one at the other end of the association from R_COTH.',
	10642);
INSERT INTO O_TFR
	VALUES (10885,
	10692,
	'get_connector_text',
	'If the end type is fixed, examines the values of ''Cond'' and ''Mult'' and
returns the appropriate value from  ''1'', ''0..1'', ''1..*'' or ''*''. Otherwise
it returns the value of the ''Txt_Phrs'' attribute.
-----------------------------------------------------------------------------------
Bridge:GD',
	322,
	1,
	'result = "";
if (param.at == End::Start OR param.at == End::End)
  result = self.Txt_Phrs;
elif (param.at == End::Start_Fixed OR param.at == End::End_Fixed)
  result = R_REL::get_cardinality_text(Mult:self.Mult, Cond:self.Cond);
end if;
return result;',
	1,
	'',
	10886);
INSERT INTO O_TPARM
	VALUES (10887,
	10885,
	'at',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10886,
	10692,
	'dispose',
	'The dispose operation for the R_CONE class.',
	19,
	1,
	'select one rcomp related by self->R_COMP[R214];
unrelate self from rcomp across R214;
select one oir related by self->R_OIR[R203];
unrelate self from oir across R203;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (10888,
	10692,
	'get_name',
	'',
	322,
	1,
	'select one object related by self->R_OIR[R203]->O_OBJ[R201];
return object.Name;
',
	1,
	'',
	10885);
INSERT INTO O_TFR
	VALUES (10889,
	10692,
	'manyMultAllowed',
	'',
	316,
	1,
	'select one coth related by self->R_COMP[R214]->R_COTH[R215];
return coth.Mult == 0;',
	1,
	'',
	10888);
INSERT INTO O_REF
	VALUES (10692,
	1109,
	0,
	1108,
	10700,
	10706,
	10701,
	10890,
	10891,
	0,
	0,
	'',
	'Class In Association',
	'OIR_ID',
	'R203');
INSERT INTO O_RATTR
	VALUES (10890,
	10692,
	1108,
	1109,
	1,
	'OIR_ID');
INSERT INTO O_ATTR
	VALUES (10890,
	10692,
	10892,
	'OIR_ID',
	'',
	'',
	'OIR_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10893,
	10692);
INSERT INTO O_BATTR
	VALUES (10893,
	10692);
INSERT INTO O_ATTR
	VALUES (10893,
	10692,
	10890,
	'Mult',
	'Full Name: Multiplicity
Description: Multiplicity at one side of the compositional association.  This attribute is derived from the multiplicities of the classes on the far end of each association in the chain when navigating the loop as specified in R_COMP.Rel_Chn from this class (R_CONE)  to the other participating in the association (R_COTH).  It is one when all multiplicities at the far ends in the loop are one, else it is many.
Data Domain: 0 = one, 1 = many
enum0: One
enum1: Many
',
	'',
	'Mult',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10894,
	10692);
INSERT INTO O_BATTR
	VALUES (10894,
	10692);
INSERT INTO O_ATTR
	VALUES (10894,
	10692,
	10893,
	'Cond',
	'Full Name: Conditionality
Description: Conditionality at one side of the compositional association.  This attribute is derived from the conditionalities of the classes on the far end of each association in the chain when navigating the loop as specified in R_COMP.Rel_Chn from this class (R_CONE)  to the other participating in the association (R_COTH).  It is one when all conditionalities at the far ends in the loop are one, else it is many.
Data Domain: 0 = one, 1 = many
enum0: Unconditional
enum1: Conditional
',
	'',
	'Cond',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10895,
	10692);
INSERT INTO O_BATTR
	VALUES (10895,
	10692);
INSERT INTO O_ATTR
	VALUES (10895,
	10692,
	10894,
	'Txt_Phrs',
	'Full Name: Text Phrase
',
	'',
	'Txt_Phrs',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (10692,
	1109,
	0,
	10702,
	10700,
	10706,
	10701,
	10896,
	10897,
	0,
	0,
	'',
	'Class In Association',
	'Obj_ID',
	'R203');
INSERT INTO O_RATTR
	VALUES (10896,
	10692,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (10896,
	10692,
	0,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10692,
	10654,
	0,
	10695,
	10691,
	10693,
	10694,
	10892,
	10898,
	0,
	0,
	'',
	'Derived Association',
	'Rel_ID',
	'R214');
INSERT INTO O_REF
	VALUES (10692,
	1109,
	0,
	10703,
	10700,
	10706,
	10701,
	10892,
	10899,
	10898,
	0,
	'',
	'Class In Association',
	'Rel_ID',
	'R203');
INSERT INTO O_RATTR
	VALUES (10892,
	10692,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (10892,
	10692,
	10896,
	'Rel_ID',
	'',
	'',
	'Rel_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10692);
INSERT INTO O_OIDA
	VALUES (10890,
	10692,
	0,
	'OIR_ID');
INSERT INTO O_OIDA
	VALUES (10896,
	10692,
	0,
	'Obj_ID');
INSERT INTO O_OIDA
	VALUES (10892,
	10692,
	0,
	'Rel_ID');
INSERT INTO O_ID
	VALUES (1,
	10692);
INSERT INTO O_ID
	VALUES (2,
	10692);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10675,
	'Class As Associated Other Side',
	210,
	'R_AOTH',
	'In an linked association, this is one of the two classes in the association.  This class is the one at the other end of the association from R_AONE.',
	10642);
INSERT INTO O_TFR
	VALUES (10900,
	10675,
	'get_connector_text',
	'If the end type is fixed, examines the values of ''Cond'' and ''Mult'' and
returns the appropriate value from  ''1'', ''0..1'', ''1..*'' or ''*''. Otherwise
it returns the value of the ''Txt_Phrs'' attribute.
-----------------------------------------------------------------------------------
Bridge:GD',
	322,
	1,
	'result = "";
if (param.at == End::Start OR param.at == End::End)
  result = self.Txt_Phrs;
elif (param.at == End::Start_Fixed OR param.at == End::End_Fixed)
  result = R_REL::get_cardinality_text(Mult:self.Mult, Cond:self.Cond);
end if;
return result;',
	1,
	'',
	10901);
INSERT INTO O_TPARM
	VALUES (10902,
	10900,
	'at',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10901,
	10675,
	'dispose',
	'The dispose operation for the R_AOTH class.
',
	19,
	1,
	'select one rassoc related by self->R_ASSOC[R210];
unrelate self from rassoc across R210;
select one rto related by self->R_RTO[R204];
unrelate self from rto across R204;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (10903,
	10675,
	'get_name',
	'',
	322,
	1,
	'select one obj related by self->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201];
return obj.Name;
',
	1,
	'',
	10900);
INSERT INTO O_TFR
	VALUES (10904,
	10675,
	'manyMultAllowed',
	'',
	316,
	1,
	'return true;
',
	1,
	'',
	10903);
INSERT INTO O_REF
	VALUES (10675,
	983,
	0,
	1055,
	10713,
	10718,
	10714,
	10905,
	10906,
	0,
	0,
	'',
	'Referred To Class in Assoc',
	'OIR_ID',
	'R204');
INSERT INTO O_RATTR
	VALUES (10905,
	10675,
	1108,
	1109,
	1,
	'OIR_ID');
INSERT INTO O_ATTR
	VALUES (10905,
	10675,
	10907,
	'OIR_ID',
	'',
	'',
	'OIR_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10908,
	10675);
INSERT INTO O_BATTR
	VALUES (10908,
	10675);
INSERT INTO O_ATTR
	VALUES (10908,
	10675,
	10905,
	'Mult',
	'Full Name: Multiplicity
Description: Multiplicity at one end of the linked association. 
Data Domain: 0 = one, 1 = many
enum0: One
enum1: Many
',
	'',
	'Mult',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10909,
	10675);
INSERT INTO O_BATTR
	VALUES (10909,
	10675);
INSERT INTO O_ATTR
	VALUES (10909,
	10675,
	10908,
	'Cond',
	'Full Name: Conditionality
Description: Conditionality at one end of the linked association
Data Domain: 0 = unconditional, 1 = conditional
enum0: Unconditional
enum1: Conditional
',
	'',
	'Cond',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10910,
	10675);
INSERT INTO O_BATTR
	VALUES (10910,
	10675);
INSERT INTO O_ATTR
	VALUES (10910,
	10675,
	10909,
	'Txt_Phrs',
	'Full Name: Text Phrase
Description: Text phrase at one end of the linked association
',
	'',
	'Txt_Phrs',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (10675,
	983,
	0,
	1056,
	10713,
	10718,
	10714,
	10911,
	10912,
	0,
	0,
	'',
	'Referred To Class in Assoc',
	'Obj_ID',
	'R204');
INSERT INTO O_RATTR
	VALUES (10911,
	10675,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (10911,
	10675,
	0,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10675,
	10656,
	0,
	10673,
	10674,
	10676,
	10677,
	10907,
	10913,
	0,
	0,
	'',
	'Linked Association',
	'Rel_ID',
	'R210');
INSERT INTO O_REF
	VALUES (10675,
	983,
	0,
	1057,
	10713,
	10718,
	10714,
	10907,
	10914,
	10913,
	0,
	'',
	'Referred To Class in Assoc',
	'Rel_ID',
	'R204');
INSERT INTO O_RATTR
	VALUES (10907,
	10675,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (10907,
	10675,
	10911,
	'Rel_ID',
	'',
	'',
	'Rel_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10675);
INSERT INTO O_OIDA
	VALUES (10905,
	10675,
	0,
	'OIR_ID');
INSERT INTO O_OIDA
	VALUES (10911,
	10675,
	0,
	'Obj_ID');
INSERT INTO O_OIDA
	VALUES (10907,
	10675,
	0,
	'Rel_ID');
INSERT INTO O_ID
	VALUES (1,
	10675);
INSERT INTO O_ID
	VALUES (2,
	10675);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10670,
	'Class As Associated One Side',
	209,
	'R_AONE',
	'In an linked association, this is one of the two classes in the association.   This class is the one at the other end of the association from R_AOTH.',
	10642);
INSERT INTO O_TFR
	VALUES (10915,
	10670,
	'get_connector_text',
	'If the end type is fixed, examines the values of ''Cond'' and ''Mult'' and
returns the appropriate value from  ''1'', ''0..1'', ''1..*'' or ''*''. Otherwise
it returns the value of the ''Txt_Phrs'' attribute.
-----------------------------------------------------------------------------------
Bridge:GD',
	322,
	1,
	'result = "";
if (param.at == End::Start OR param.at == End::End)
  result = self.Txt_Phrs;
elif (param.at == End::Start_Fixed OR param.at == End::End_Fixed)
  result = R_REL::get_cardinality_text(Mult:self.Mult, Cond:self.Cond);
end if;
return result;',
	1,
	'',
	10916);
INSERT INTO O_TPARM
	VALUES (10917,
	10915,
	'at',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10916,
	10670,
	'dispose',
	'The dispose operation for the R_AONE class.',
	19,
	1,
	'select one rassoc related by self->R_ASSOC[R209];
unrelate self from rassoc across R209;
select one rto related by self->R_RTO[R204];
unrelate self from rto across R204;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (10918,
	10670,
	'get_name',
	'',
	322,
	1,
	'select one obj related by self->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201];
return obj.Name;
',
	1,
	'',
	10915);
INSERT INTO O_TFR
	VALUES (10919,
	10670,
	'manyMultAllowed',
	'',
	316,
	1,
	'return true;
',
	1,
	'',
	10918);
INSERT INTO O_REF
	VALUES (10670,
	983,
	0,
	1055,
	10713,
	10717,
	10714,
	10920,
	10921,
	0,
	0,
	'',
	'Referred To Class in Assoc',
	'OIR_ID',
	'R204');
INSERT INTO O_RATTR
	VALUES (10920,
	10670,
	1108,
	1109,
	1,
	'OIR_ID');
INSERT INTO O_ATTR
	VALUES (10920,
	10670,
	10922,
	'OIR_ID',
	'',
	'',
	'OIR_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10923,
	10670);
INSERT INTO O_BATTR
	VALUES (10923,
	10670);
INSERT INTO O_ATTR
	VALUES (10923,
	10670,
	10920,
	'Mult',
	'Full Name: Multiplicity
Description: Multiplicity at one end of the linked association
Data Domain: 0 = one, 1 = many
enum0: One
enum1: Many
',
	'',
	'Mult',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10924,
	10670);
INSERT INTO O_BATTR
	VALUES (10924,
	10670);
INSERT INTO O_ATTR
	VALUES (10924,
	10670,
	10923,
	'Cond',
	'Full Name: Conditionality
Description: Conditionality at one end of the linked association
Data Domain: 0 = unconditional, 1 = conditional
enum0: Unconditional
enum1: Conditional
',
	'',
	'Cond',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10925,
	10670);
INSERT INTO O_BATTR
	VALUES (10925,
	10670);
INSERT INTO O_ATTR
	VALUES (10925,
	10670,
	10924,
	'Txt_Phrs',
	'Full Name: Text Phrase
Description: Text phrase at one end of the linked association
',
	'',
	'Txt_Phrs',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (10670,
	983,
	0,
	1056,
	10713,
	10717,
	10714,
	10926,
	10927,
	0,
	0,
	'',
	'Referred To Class in Assoc',
	'Obj_ID',
	'R204');
INSERT INTO O_RATTR
	VALUES (10926,
	10670,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (10926,
	10670,
	0,
	'Obj_ID',
	'',
	'',
	'Obj_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (10670,
	10656,
	0,
	10673,
	10669,
	10671,
	10672,
	10922,
	10928,
	0,
	0,
	'',
	'Linked Association',
	'Rel_ID',
	'R209');
INSERT INTO O_REF
	VALUES (10670,
	983,
	0,
	1057,
	10713,
	10717,
	10714,
	10922,
	10929,
	10928,
	0,
	'',
	'Referred To Class in Assoc',
	'Rel_ID',
	'R204');
INSERT INTO O_RATTR
	VALUES (10922,
	10670,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (10922,
	10670,
	10926,
	'Rel_ID',
	'',
	'',
	'Rel_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10670);
INSERT INTO O_OIDA
	VALUES (10920,
	10670,
	0,
	'OIR_ID');
INSERT INTO O_OIDA
	VALUES (10926,
	10670,
	0,
	'Obj_ID');
INSERT INTO O_OIDA
	VALUES (10922,
	10670,
	0,
	'Rel_ID');
INSERT INTO O_ID
	VALUES (1,
	10670);
INSERT INTO O_ID
	VALUES (2,
	10670);
-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2322,
	'Association',
	201,
	'R_REL',
	'An Association captures an association that exists between things in the real world. An Association is stated in terms of the formal Classs that participates in the association.',
	10642);
INSERT INTO O_TFR
	VALUES (10930,
	2322,
	'is_reflexive',
	'Returns true if this is a reflexive association, false otherwise.
Only Simple and Associative associations can be reflexive.
',
	316,
	1,
	'select one srel related by self->R_SIMP[R206];
if ( not_empty srel )
  select many part_set related by srel->R_PART[R207];
  if ( cardinality part_set > 1 )
    select any part1 related by srel->R_PART[R207];
    select any part2 related by srel->R_PART[R207] 
      where selected.OIR_ID != part1.OIR_ID;
    if ( part1.Obj_ID == part2.Obj_ID )
      return true;
    end if;
  else
    select any part related by srel->R_PART[R207];
    select one form related by srel->R_FORM[R208];
    if ( not_empty form )
      if ( part.Obj_ID == form.Obj_ID )
        return true;
      end if;
    end if;
  end if;
else
  select one arel related by self->R_ASSOC[R206];
  if ( not_empty arel )
    select one aone related by arel->R_AONE[R209];
    select one aoth related by arel->R_AOTH[R210];
    if ( aone.Obj_ID == aoth.Obj_ID )
      return true;
    end if;
  end if;
end if;
return false;

',
	1,
	'',
	10931);
INSERT INTO O_TFR
	VALUES (10932,
	2322,
	'get_connector_text',
	'Gets the text adornments for the Association. This function returns the
text phrase or cardinality string for the start or end of the Association,
or the Association number for the middle of the Association depending
on the value of ''at:End_type''.
-----------------------------------------------------------------------------------
Bridge:GD
',
	322,
	1,
	'result = "";
Obj_ID = param.OOA_ID;
if (param.OOA_TypeIsImportedClass)
  select any impClass from instances of O_IOBJ where (selected.IObj_ID == Obj_ID);
  if (not_empty impClass)
    select one modelClass related by impClass->O_OBJ[R101];
    Obj_ID = modelClass.Obj_ID;
  end if;
end if;
select one superType related by self->R_SUBSUP[R206]->R_SUPER[R212];
if (param.at == End::Middle AND empty superType)
  result = "R" + GD::int_to_string(value:self.Numb);
else
  select one simp related by self->R_SIMP[R206];
  if (not_empty simp)
      result = simp.get_connector_text(Obj_ID:Obj_ID, at:param.at);
  end if;
  select one assoc related by self->R_ASSOC[R206];
  if (not_empty assoc)
      result = assoc.get_connector_text(Obj_ID:Obj_ID, at:param.at);
  end if;
  // super tyupe already selected above
  if (not_empty superType)
    result = superType.get_connector_text(at:param.at);
  end if;
  select one comp related by self->R_COMP[R206];
  if (not_empty comp)
    result = comp.get_connector_text(Obj_ID:Obj_ID, at:param.at);
  end if;
end if;
return result;',
	1,
	'',
	10933);
INSERT INTO O_TPARM
	VALUES (10934,
	10932,
	'OOA_ID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (10935,
	10932,
	'OOA_TypeIsImportedClass',
	316,
	0,
	'',
	10934,
	'');
INSERT INTO O_TPARM
	VALUES (10936,
	10932,
	'at',
	880,
	0,
	'',
	10935,
	'');
INSERT INTO O_TPARM
	VALUES (10937,
	10932,
	'parent_ID',
	296,
	0,
	'',
	10936,
	'');
INSERT INTO O_TFR
	VALUES (10933,
	2322,
	'get_cardinality_text',
	'Gets the text for the cardinality adornments. The values of ''Mult''
and ''Cond'' are used to determine if the text string is to be ''1'',
''0..1'', ''1..*'' or ''*''.
-----------------------------------------------------------------------------------
Bridge:GD
',
	322,
	0,
	'if (param.Cond == 0)
  if (param.Mult == 0)
    return "1";
  else
    return "1..*";
  end if;
else
  if (param.Mult == 0)
    return "0..1";
  else
    return "*";
  end if;
end if;
',
	1,
	'',
	10938);
INSERT INTO O_TPARM
	VALUES (10939,
	10933,
	'Mult',
	298,
	0,
	'',
	10940,
	'');
INSERT INTO O_TPARM
	VALUES (10940,
	10933,
	'Cond',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10941,
	2322,
	'get_style',
	'In all cases except supertype (which has a Triangle on it''s end), an
Association has no special line end style.
-----------------------------------------------------------------------------------
Bridge:GD',
	784,
	1,
	'if (param.at == End::Start)
  select one subsup related by self->R_SUBSUP[R206];
  if (not_empty subsup)
    return Style::Triangle;
  else
    return Style::None;
  end if;
end if;
return Style::None;',
	1,
	'',
	10942);
INSERT INTO O_TPARM
	VALUES (10943,
	10941,
	'at',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (10944,
	2322,
	'get_name',
	'Creates a string containing a descriptive name for the instance.',
	322,
	1,
	'return "R" + GD::int_to_string( value: self.Numb );
',
	1,
	'',
	10932);
INSERT INTO O_TFR
	VALUES (10938,
	2322,
	'dispose',
	'The dispose operation for the R_REL class.',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// Association Subsystem
if self.isFormalized()
  self.unformalize();
end if;
// Remove RGOs first, for example to migrate associative to simple associations.
select many rgo_oirs related by self->R_OIR[R201]->R_RGO[R203]->R_OIR[R203];
select many rto_oirs related by self->R_OIR[R201]->R_RTO[R203]->R_OIR[R203];
for each rgo_oir in rgo_oirs
   rgo_oir.dispose();
end for;
for each rto_oir in rto_oirs
     rto_oir.dispose();
  end for;;
select one simp related by self->R_SIMP[R206];
select one assoc related by self->R_ASSOC[R206];
select one subsup related by self->R_SUBSUP[R206];
select one comp related by self->R_COMP[R206];
if (not_empty simp)
   simp.dispose();
elif (not_empty assoc)
   assoc.dispose();
elif (not_empty subsup)
   subsup.dispose();
elif (not_empty comp)
   comp.dispose();
end if;
//
// Relate and Unrelate Subsystem
select many rels related by self->ACT_REL[R653];
for each rel in rels
  unrelate self from rel across R653;
end for;
select many rus related by self->ACT_RU[R654];
for each ru in rus
  unrelate self from ru across R654;
end for;
select many unrs related by self->ACT_UNR[R655];
for each unr in unrs
  unrelate self from unr across R655;
end for;
select many urus related by self->ACT_URU[R656];
for each uru in urus
  unrelate self from uru across R656;
end for;
//
// Selection subsystem
select many lnks related by self->ACT_LNK[R681];
for each lnk in lnks
  unrelate self from lnk across R681;
end for;
//
// Domain subsystem
select one ss related by self->S_SS[R4];
if ( not_empty ss )
  unrelate self from ss across R4;
end if;
//
// Instance Subsystem
select many iils related by self->I_LIP[R2959];
for each iil in iils
  unrelate self from iil across R2959;
  iil.dispose();
end for;
//
select many ilinks related by self->I_LNK[R2904];
for each ilink in ilinks
  unrelate self from ilink across R2904;
  ilink.dispose();
end for;
// if this association is used to formalize
// any communication links unformalize them
select many links related by self->COMM_LNK[R1128];
for each link in links
  link.unformalize();
end for;
//
select one pe related by self->PE_PE[R8001];
if (not_empty pe)
  unrelate self from pe across R8001;
  pe.dispose();
end if;
//
// Finally, delete self
delete object instance self;',
	1,
	'',
	10945);
INSERT INTO O_TFR
	VALUES (10946,
	2322,
	'initialize',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// this association''s default number is either one or
// the starting value in the number range of its owning subsystem
// if the range is not zero
select one packageableElem related by self->PE_PE[R8001];  
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
isInGenericPackage = not_empty package or not_empty component;
if (isInGenericPackage)
  if (empty package)
    rootCompIdInPkg = component.getRootComponentId();
    select any rootComponent from instances of C_C where (selected.Id == rootCompIdInPkg);
    select one package related by rootComponent->PE_PE[R8001]->EP_PKG[R8000];
  end if;
  if ( package.Num_Rng == 0 )
    self.Numb = 1;
  else
    self.Numb = package.Num_Rng;
  end if;
  // for each assocation associated with this association''s
  // owning subsystem
  select many assocs related by package->PE_PE[R8000]->R_REL[R8001];
  for each assoc in assocs
    // if this association equals self, skip it
    if (assoc.Rel_ID == self.Rel_ID) continue; end if;
  
    // if this other association''s number is 
    // greater than this association''s number
    if (assoc.Numb >= self.Numb)
      // have this association''s number be just greater 
      // than this other association''s number
      self.Numb = assoc.Numb + 1;
    end if;
  end for;
else
  select one ss related by self->S_SS[R4];
  if ( ss.Num_Rng == 0 )
    self.Numb = 1;
  else
    self.Numb = ss.Num_Rng;
  end if;
  
  // for each assocation associated with this association''s
  // owning subsystem
  select many assocs related by ss->R_REL[R4];
  for each assoc in assocs
    // if this association equals self, skip it
    if (assoc.Rel_ID == self.Rel_ID) continue; end if;
  
    // if this other association''s number is 
    // greater than this association''s number
    if (assoc.Numb >= self.Numb)
      // have this association''s number be just greater 
      // than this other association''s number
      self.Numb = assoc.Numb + 1;
    end if;
  end for;
end if;',
	1,
	'',
	10941);
INSERT INTO O_TFR
	VALUES (10942,
	2322,
	'get_ooa_id',
	'Return the rel id to that the GD can set_up the connector ooa_id.
-----------------------------------------------------------------------------------
Bridge:GD',
	296,
	1,
	'return self.Rel_ID;',
	1,
	'',
	10944);
INSERT INTO O_TFR
	VALUES (10945,
	2322,
	'actionFilter',
	'Bridge: UI
',
	316,
	1,
	'if (param.name == "type" )
  if (param.value =="unform simp" )
    if ( not self.isFormalized() )
      select one simp related by self->R_SIMP[R206];
      if ( not_empty simp )
        select many part_set related by simp->R_PART[R207];
        num_many_mult = 0;
        one_mult_has_id = false;
        for each part in part_set
          if ( part.Mult == 1 )
            num_many_mult = num_many_mult + 1;
          else
            select any oida related by part->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201]->O_ID[R104]->O_OIDA[R105];
            if ( not_empty oida )
              one_mult_has_id = true;
            end if;
          end if;
        end for;
        // we can only formalize simple relationships if 
        // there is at most one participant with a many multiplicity
        return one_mult_has_id and num_many_mult < 2;
      end if;
    end if;
  elif (param.value == "unform assoc" )
    if ( not self.isFormalized() )
      select one assoc related by self->R_ASSOC[R206];
      if not_empty assoc
        select one aone related by assoc->R_AONE[R209];
        select one aoth related by assoc->R_AOTH[R210];
        select any aone_oida related by aone->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201]->O_ID[R104]->O_OIDA[R105];
        select any aoth_oida related by aoth->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201]->O_ID[R104]->O_OIDA[R105];
        return not_empty aone_oida and not_empty aoth_oida;
      end if;
    end if;
  elif (param.value == "unform subsup" )
    if ( not self.isFormalized() )
      select one subsup related by self->R_SUBSUP[R206];
      if not_empty subsup
        select one sup related by subsup->R_SUPER[R212];
        select any sup_oida related by sup->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201]->O_ID[R104]->O_OIDA[R105];
        return not_empty sup_oida;
      end if;
    end if;
  end if;
elif (param.name == "formalized" )
  if (param.value =="true" )
    return self.isFormalized();
  end if; 
end if;
return false;
',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (10947,
	10945,
	'name',
	322,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (10948,
	10945,
	'value',
	322,
	0,
	'',
	10947,
	'');
INSERT INTO O_TFR
	VALUES (10931,
	2322,
	'isFormalized',
	'',
	316,
	1,
	'select one simp related by self->R_SIMP[R206];
if ( not_empty simp )
  return simp.isFormalized();
else 
  select one assoc related by self->R_ASSOC[R206];
  if ( not_empty assoc )
    return assoc.isFormalized();
  else
    select one subsup related by self->R_SUBSUP[R206];
    if ( not_empty subsup )
      return subsup.isFormalized();
    end if;
  end if;
end if;
return false;',
	1,
	'',
	10946);
INSERT INTO O_TFR
	VALUES (10949,
	2322,
	'unformalize',
	'',
	19,
	1,
	'select one simp related by self->R_SIMP[R206];
if ( not_empty simp )
  simp.unformalize();
else 
  select one assoc related by self->R_ASSOC[R206];
  if ( not_empty assoc )
    assoc.unformalize();
  else
    select one subsup related by self->R_SUBSUP[R206];
    if ( not_empty subsup )
      subsup.unformalize();
    end if;
  end if;
end if;
',
	1,
	'',
	10930);
INSERT INTO O_TFR
	VALUES (10950,
	2322,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'// just return this instance as an Object
return this;',
	0,
	'',
	10949);
INSERT INTO O_TFR
	VALUES (10951,
	2322,
	'checkIntegrity',
	'',
	19,
	1,
	'/**
 *  Create integrity issues if there are any other associations in this package
 *  with the same association number
 */
select many associations related by self->PE_PE[R8001]->EP_PKG[R8000]
                                                   ->PE_PE[R8000]->R_REL[R8001];
select one system related by self->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405];
sys_id = GD::NULL_UNIQUE_ID();
if(not_empty system)
  sys_id = system.Sys_ID;
end if;
for each association in associations
  if(association != self and association.Numb == self.Numb)
    MI_IM::createIssue(sys_id:sys_id, description:
                      "Found another association in the same package with a " +
                                                             "matching number.",
         severity:Severity::Error, name:self.get_name(), path:self.getPath(),
                              id:self.Rel_ID, element:self.convertToInstance());
  end if;
end for;',
	1,
	'',
	10950);
INSERT INTO O_TFR
	VALUES (10952,
	2322,
	'getPath',
	'',
	322,
	1,
	'select one package related by self->PE_PE[R8001]->EP_PKG[R8000];
return package.getPath(path:"") + "::" + self.get_name();',
	1,
	'',
	10951);
INSERT INTO O_NBATTR
	VALUES (10953,
	2322);
INSERT INTO O_BATTR
	VALUES (10953,
	2322);
INSERT INTO O_ATTR
	VALUES (10953,
	2322,
	2368,
	'Numb',
	'Full Name: Association Number
min_value: 0
max_value: 9999
',
	'',
	'Numb',
	0,
	298,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (10954,
	2322);
INSERT INTO O_BATTR
	VALUES (10954,
	2322);
INSERT INTO O_ATTR
	VALUES (10954,
	2322,
	10953,
	'Descrip',
	'Full Name: Association Description',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (2322,
	701,
	0,
	717,
	7293,
	7295,
	7294,
	10955,
	10956,
	0,
	0,
	'',
	'Subsystem',
	'SS_ID',
	'R4');
INSERT INTO O_RATTR
	VALUES (10955,
	2322,
	717,
	701,
	1,
	'SS_ID');
INSERT INTO O_ATTR
	VALUES (10955,
	2322,
	10954,
	'SS_ID',
	'',
	'',
	'SS_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2322,
	26,
	0,
	25,
	868,
	2838,
	870,
	2368,
	10957,
	0,
	0,
	'',
	'Packageable Element',
	'Element_ID',
	'R8001');
INSERT INTO O_RATTR
	VALUES (2368,
	2322,
	25,
	26,
	0,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (2368,
	2322,
	0,
	'Rel_ID',
	'Full Name: Association Identifier',
	'',
	'Rel_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2322);
INSERT INTO O_OIDA
	VALUES (2368,
	2322,
	0,
	'Rel_ID');
INSERT INTO O_ID
	VALUES (1,
	2322);
INSERT INTO O_ID
	VALUES (2,
	2322);
-- BP 7.1 content: Subsystem syschar: 3 persistence-version: 7.1.6

INSERT INTO S_SS
	VALUES (10958,
	'Activity',
	'// This is used by schema_gen to ignore this subsystem (for publication)
TRANSLATE_FOR_EXTERNAL_USE:FALSE',
	'A',
	1100,
	1,
	0);
INSERT INTO S_SID
	VALUES (1,
	10958);
INSERT INTO O_IOBJ
	VALUES (10959,
	699,
	0,
	10958,
	'Domain',
	'S_DOM');
INSERT INTO O_IOBJ
	VALUES (10960,
	701,
	0,
	10958,
	'Subsystem',
	'S_SS');
INSERT INTO O_IOBJ
	VALUES (10961,
	705,
	0,
	10958,
	'System Model',
	'S_SYS');
INSERT INTO O_IOBJ
	VALUES (10962,
	709,
	0,
	10958,
	'Component',
	'C_C');
INSERT INTO O_IOBJ
	VALUES (10963,
	707,
	0,
	10958,
	'Component Package',
	'CP_CP');
INSERT INTO R_SIMP
	VALUES (10964);
INSERT INTO R_REL
	VALUES (10964,
	1100,
	'',
	10958);
INSERT INTO R_PART
	VALUES (699,
	10964,
	10965,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (712,
	699,
	0,
	10964,
	10965);
INSERT INTO R_RTO
	VALUES (699,
	10964,
	10965,
	0);
INSERT INTO R_OIR
	VALUES (699,
	10964,
	10965,
	10959);
INSERT INTO R_FORM
	VALUES (6798,
	10964,
	10966,
	1,
	1,
	'contains');
INSERT INTO R_RGO
	VALUES (6798,
	10964,
	10966);
INSERT INTO R_OIR
	VALUES (6798,
	10964,
	10966,
	0);
INSERT INTO R_SIMP
	VALUES (10967);
INSERT INTO R_REL
	VALUES (10967,
	1108,
	'',
	10958);
INSERT INTO R_PART
	VALUES (701,
	10967,
	10968,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (717,
	701,
	0,
	10967,
	10968);
INSERT INTO R_RTO
	VALUES (701,
	10967,
	10968,
	0);
INSERT INTO R_OIR
	VALUES (701,
	10967,
	10968,
	10960);
INSERT INTO R_FORM
	VALUES (6798,
	10967,
	10969,
	1,
	1,
	'contains');
INSERT INTO R_RGO
	VALUES (6798,
	10967,
	10969);
INSERT INTO R_OIR
	VALUES (6798,
	10967,
	10969,
	0);
INSERT INTO R_SIMP
	VALUES (10970);
INSERT INTO R_REL
	VALUES (10970,
	1109,
	'',
	10958);
INSERT INTO R_PART
	VALUES (6798,
	10970,
	10971,
	0,
	0,
	'');
INSERT INTO O_RTIDA
	VALUES (10972,
	6798,
	0,
	10970,
	10971);
INSERT INTO R_RTO
	VALUES (6798,
	10970,
	10971,
	0);
INSERT INTO R_OIR
	VALUES (6798,
	10970,
	10971,
	0);
INSERT INTO R_FORM
	VALUES (10973,
	10970,
	10974,
	0,
	1,
	'is parent via');
INSERT INTO R_RGO
	VALUES (10973,
	10970,
	10974);
INSERT INTO R_OIR
	VALUES (10973,
	10970,
	10974,
	0);
INSERT INTO R_SIMP
	VALUES (10975);
INSERT INTO R_REL
	VALUES (10975,
	1110,
	'',
	10958);
INSERT INTO R_FORM
	VALUES (6798,
	10975,
	10976,
	1,
	1,
	'has children');
INSERT INTO R_RGO
	VALUES (6798,
	10975,
	10976);
INSERT INTO R_OIR
	VALUES (6798,
	10975,
	10976,
	0);
INSERT INTO R_PART
	VALUES (10973,
	10975,
	10977,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (10978,
	10973,
	0,
	10975,
	10977);
INSERT INTO R_RTO
	VALUES (10973,
	10975,
	10977,
	0);
INSERT INTO R_OIR
	VALUES (10973,
	10975,
	10977,
	0);
INSERT INTO R_SIMP
	VALUES (10979);
INSERT INTO R_REL
	VALUES (10979,
	1111,
	'',
	10958);
INSERT INTO R_PART
	VALUES (6798,
	10979,
	10980,
	0,
	0,
	'');
INSERT INTO O_RTIDA
	VALUES (10972,
	6798,
	0,
	10979,
	10980);
INSERT INTO R_RTO
	VALUES (6798,
	10979,
	10980,
	0);
INSERT INTO R_OIR
	VALUES (6798,
	10979,
	10980,
	0);
INSERT INTO R_FORM
	VALUES (2812,
	10979,
	10981,
	1,
	1,
	'group');
INSERT INTO R_RGO
	VALUES (2812,
	10979,
	10981);
INSERT INTO R_OIR
	VALUES (2812,
	10979,
	10981,
	0);
INSERT INTO R_SIMP
	VALUES (10982);
INSERT INTO R_REL
	VALUES (10982,
	1102,
	'',
	10958);
INSERT INTO R_PART
	VALUES (6798,
	10982,
	10983,
	0,
	0,
	'');
INSERT INTO O_RTIDA
	VALUES (10972,
	6798,
	0,
	10982,
	10983);
INSERT INTO R_RTO
	VALUES (6798,
	10982,
	10983,
	0);
INSERT INTO R_OIR
	VALUES (6798,
	10982,
	10983,
	0);
INSERT INTO R_FORM
	VALUES (2814,
	10982,
	10984,
	1,
	1,
	'contained edge');
INSERT INTO R_RGO
	VALUES (2814,
	10982,
	10984);
INSERT INTO R_OIR
	VALUES (2814,
	10982,
	10984,
	0);
INSERT INTO R_SIMP
	VALUES (10985);
INSERT INTO R_REL
	VALUES (10985,
	1101,
	'',
	10958);
INSERT INTO R_PART
	VALUES (6798,
	10985,
	10986,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (10972,
	6798,
	0,
	10985,
	10986);
INSERT INTO R_RTO
	VALUES (6798,
	10985,
	10986,
	0);
INSERT INTO R_OIR
	VALUES (6798,
	10985,
	10986,
	0);
INSERT INTO R_FORM
	VALUES (2803,
	10985,
	10987,
	1,
	1,
	'contained node');
INSERT INTO R_RGO
	VALUES (2803,
	10985,
	10987);
INSERT INTO R_OIR
	VALUES (2803,
	10985,
	10987,
	0);
INSERT INTO R_SIMP
	VALUES (10988);
INSERT INTO R_REL
	VALUES (10988,
	1103,
	'',
	10958);
INSERT INTO R_PART
	VALUES (2803,
	10988,
	10989,
	0,
	0,
	'target');
INSERT INTO O_RTIDA
	VALUES (10990,
	2803,
	0,
	10988,
	10989);
INSERT INTO R_RTO
	VALUES (2803,
	10988,
	10989,
	0);
INSERT INTO R_OIR
	VALUES (2803,
	10988,
	10989,
	0);
INSERT INTO R_FORM
	VALUES (2814,
	10988,
	10991,
	1,
	1,
	'incoming');
INSERT INTO R_RGO
	VALUES (2814,
	10988,
	10991);
INSERT INTO R_OIR
	VALUES (2814,
	10988,
	10991,
	0);
INSERT INTO R_SIMP
	VALUES (10992);
INSERT INTO R_REL
	VALUES (10992,
	1104,
	'',
	10958);
INSERT INTO R_PART
	VALUES (2803,
	10992,
	10993,
	0,
	0,
	'source');
INSERT INTO O_RTIDA
	VALUES (10990,
	2803,
	0,
	10992,
	10993);
INSERT INTO R_RTO
	VALUES (2803,
	10992,
	10993,
	0);
INSERT INTO R_OIR
	VALUES (2803,
	10992,
	10993,
	0);
INSERT INTO R_FORM
	VALUES (2814,
	10992,
	10994,
	1,
	1,
	'outgoing');
INSERT INTO R_RGO
	VALUES (2814,
	10992,
	10994);
INSERT INTO R_OIR
	VALUES (2814,
	10992,
	10994,
	0);
INSERT INTO R_SUBSUP
	VALUES (10995);
INSERT INTO R_REL
	VALUES (10995,
	1105,
	'',
	10958);
INSERT INTO R_SUPER
	VALUES (2803,
	10995,
	10996);
INSERT INTO O_RTIDA
	VALUES (10990,
	2803,
	0,
	10995,
	10996);
INSERT INTO R_RTO
	VALUES (2803,
	10995,
	10996,
	0);
INSERT INTO R_OIR
	VALUES (2803,
	10995,
	10996,
	0);
INSERT INTO R_SUB
	VALUES (10997,
	10995,
	10998);
INSERT INTO R_RGO
	VALUES (10997,
	10995,
	10998);
INSERT INTO R_OIR
	VALUES (10997,
	10995,
	10998,
	0);
INSERT INTO R_SUB
	VALUES (10999,
	10995,
	11000);
INSERT INTO R_RGO
	VALUES (10999,
	10995,
	11000);
INSERT INTO R_OIR
	VALUES (10999,
	10995,
	11000,
	0);
INSERT INTO R_SUB
	VALUES (11001,
	10995,
	11002);
INSERT INTO R_RGO
	VALUES (11001,
	10995,
	11002);
INSERT INTO R_OIR
	VALUES (11001,
	10995,
	11002,
	0);
INSERT INTO R_SUBSUP
	VALUES (11003);
INSERT INTO R_REL
	VALUES (11003,
	1107,
	'',
	10958);
INSERT INTO R_SUPER
	VALUES (10997,
	11003,
	11004);
INSERT INTO O_RTIDA
	VALUES (11005,
	10997,
	0,
	11003,
	11004);
INSERT INTO R_RTO
	VALUES (10997,
	11003,
	11004,
	0);
INSERT INTO R_OIR
	VALUES (10997,
	11003,
	11004,
	0);
INSERT INTO R_SUB
	VALUES (11006,
	11003,
	11007);
INSERT INTO R_RGO
	VALUES (11006,
	11003,
	11007);
INSERT INTO R_OIR
	VALUES (11006,
	11003,
	11007,
	0);
INSERT INTO R_SUB
	VALUES (11008,
	11003,
	11009);
INSERT INTO R_RGO
	VALUES (11008,
	11003,
	11009);
INSERT INTO R_OIR
	VALUES (11008,
	11003,
	11009,
	0);
INSERT INTO R_SUB
	VALUES (11010,
	11003,
	11011);
INSERT INTO R_RGO
	VALUES (11010,
	11003,
	11011);
INSERT INTO R_OIR
	VALUES (11010,
	11003,
	11011,
	0);
INSERT INTO R_SUBSUP
	VALUES (11012);
INSERT INTO R_REL
	VALUES (11012,
	1106,
	'',
	10958);
INSERT INTO R_SUPER
	VALUES (11001,
	11012,
	11013);
INSERT INTO O_RTIDA
	VALUES (11014,
	11001,
	0,
	11012,
	11013);
INSERT INTO R_RTO
	VALUES (11001,
	11012,
	11013,
	0);
INSERT INTO R_OIR
	VALUES (11001,
	11012,
	11013,
	0);
INSERT INTO R_SUB
	VALUES (11015,
	11012,
	11016);
INSERT INTO R_RGO
	VALUES (11015,
	11012,
	11016);
INSERT INTO R_OIR
	VALUES (11015,
	11012,
	11016,
	0);
INSERT INTO R_SUB
	VALUES (11017,
	11012,
	11018);
INSERT INTO R_RGO
	VALUES (11017,
	11012,
	11018);
INSERT INTO R_OIR
	VALUES (11017,
	11012,
	11018,
	0);
INSERT INTO R_SUB
	VALUES (11019,
	11012,
	11020);
INSERT INTO R_RGO
	VALUES (11019,
	11012,
	11020);
INSERT INTO R_OIR
	VALUES (11019,
	11012,
	11020,
	0);
INSERT INTO R_SUB
	VALUES (11021,
	11012,
	11022);
INSERT INTO R_RGO
	VALUES (11021,
	11012,
	11022);
INSERT INTO R_OIR
	VALUES (11021,
	11012,
	11022,
	0);
INSERT INTO R_SUB
	VALUES (11023,
	11012,
	11024);
INSERT INTO R_RGO
	VALUES (11023,
	11012,
	11024);
INSERT INTO R_OIR
	VALUES (11023,
	11012,
	11024,
	0);
INSERT INTO R_SUBSUP
	VALUES (11025);
INSERT INTO R_REL
	VALUES (11025,
	1112,
	'',
	10958);
INSERT INTO R_SUPER
	VALUES (11006,
	11025,
	11026);
INSERT INTO O_RTIDA
	VALUES (11027,
	11006,
	0,
	11025,
	11026);
INSERT INTO R_RTO
	VALUES (11006,
	11025,
	11026,
	0);
INSERT INTO R_OIR
	VALUES (11006,
	11025,
	11026,
	0);
INSERT INTO R_SUB
	VALUES (11028,
	11025,
	11029);
INSERT INTO R_RGO
	VALUES (11028,
	11025,
	11029);
INSERT INTO R_OIR
	VALUES (11028,
	11025,
	11029,
	0);
INSERT INTO R_SUB
	VALUES (11030,
	11025,
	11031);
INSERT INTO R_RGO
	VALUES (11030,
	11025,
	11031);
INSERT INTO R_OIR
	VALUES (11030,
	11025,
	11031,
	0);
INSERT INTO R_SIMP
	VALUES (11032);
INSERT INTO R_REL
	VALUES (11032,
	1113,
	'',
	10958);
INSERT INTO R_PART
	VALUES (705,
	11032,
	11033,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (754,
	705,
	0,
	11032,
	11033);
INSERT INTO R_RTO
	VALUES (705,
	11032,
	11033,
	0);
INSERT INTO R_OIR
	VALUES (705,
	11032,
	11033,
	10961);
INSERT INTO R_FORM
	VALUES (6798,
	11032,
	11034,
	1,
	1,
	'contains');
INSERT INTO R_RGO
	VALUES (6798,
	11032,
	11034);
INSERT INTO R_OIR
	VALUES (6798,
	11032,
	11034,
	0);
INSERT INTO R_SIMP
	VALUES (11035);
INSERT INTO R_REL
	VALUES (11035,
	1114,
	'',
	10958);
INSERT INTO R_PART
	VALUES (707,
	11035,
	11036,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (758,
	707,
	0,
	11035,
	11036);
INSERT INTO R_RTO
	VALUES (707,
	11035,
	11036,
	0);
INSERT INTO R_OIR
	VALUES (707,
	11035,
	11036,
	10963);
INSERT INTO R_FORM
	VALUES (6798,
	11035,
	11037,
	1,
	1,
	'contains');
INSERT INTO R_RGO
	VALUES (6798,
	11035,
	11037);
INSERT INTO R_OIR
	VALUES (6798,
	11035,
	11037,
	0);
INSERT INTO R_SIMP
	VALUES (11038);
INSERT INTO R_REL
	VALUES (11038,
	1115,
	'',
	10958);
INSERT INTO R_PART
	VALUES (709,
	11038,
	11039,
	0,
	1,
	'');
INSERT INTO O_RTIDA
	VALUES (762,
	709,
	0,
	11038,
	11039);
INSERT INTO R_RTO
	VALUES (709,
	11038,
	11039,
	0);
INSERT INTO R_OIR
	VALUES (709,
	11038,
	11039,
	10962);
INSERT INTO R_FORM
	VALUES (6798,
	11038,
	11040,
	1,
	1,
	'contains');
INSERT INTO R_RGO
	VALUES (6798,
	11038,
	11040);
INSERT INTO R_OIR
	VALUES (6798,
	11038,
	11040,
	0);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (11010,
	'Send Signal',
	1114,
	'A_SS',
	'',
	10958);
INSERT INTO O_TFR
	VALUES (11041,
	11010,
	'dispose',
	'',
	19,
	1,
	'select one parent related by self->A_ACT[R1107];
if ( not_empty parent )
  parent.dispose();
  return;
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (11042,
	11010,
	'incomingEdgeAllowed',
	'',
	316,
	1,
	'select one node related by self->A_ACT[R1107]->A_N[R1105];
return node.numIncomingEdges() == 0;',
	1,
	'',
	11043);
INSERT INTO O_TFR
	VALUES (11044,
	11010,
	'outgoingEdgeAllowed',
	'',
	316,
	1,
	'select one node related by self->A_ACT[R1107]->A_N[R1105];
return node.numOutgoingEdges() == 0;',
	1,
	'',
	11045);
INSERT INTO O_TFR
	VALUES (11046,
	11010,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Id;',
	1,
	'',
	11047);
INSERT INTO O_TFR
	VALUES (11048,
	11010,
	'get_style',
	'',
	784,
	1,
	'return Style::ConvexPentagon;',
	1,
	'',
	11046);
INSERT INTO O_TFR
	VALUES (11043,
	11010,
	'get_text_style',
	'',
	784,
	1,
	'return Style::None;',
	1,
	'',
	11048);
INSERT INTO O_TPARM
	VALUES (11049,
	11043,
	'comp_num',
	298,
	0,
	'',
	11050,
	'');
INSERT INTO O_TPARM
	VALUES (11051,
	11043,
	'ent_num',
	298,
	0,
	'',
	11049,
	'');
INSERT INTO O_TPARM
	VALUES (11050,
	11043,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11052,
	11010,
	'get_compartments',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	11053);
INSERT INTO O_TFR
	VALUES (11047,
	11010,
	'get_entries',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	11052);
INSERT INTO O_TPARM
	VALUES (11054,
	11047,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11053,
	11010,
	'get_compartment_text',
	'',
	322,
	1,
	'result = "";
if (param.at == Justification::Center)
  result = self.Name;
end if;
return result;',
	1,
	'',
	11041);
INSERT INTO O_TPARM
	VALUES (11055,
	11053,
	'comp_num',
	298,
	0,
	'',
	11056,
	'');
INSERT INTO O_TPARM
	VALUES (11057,
	11053,
	'ent_num',
	298,
	0,
	'',
	11055,
	'');
INSERT INTO O_TPARM
	VALUES (11056,
	11053,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11045,
	11010,
	'initialize',
	'',
	19,
	1,
	'name = "Unnamed Send Signal";
success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:false);    
if ( success!="") 
 self.Name=success;
else 
 self.dispose();
end if;   ',
	1,
	'',
	11042);
INSERT INTO O_TFR
	VALUES (11058,
	11010,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'return this;',
	0,
	'',
	11044);
INSERT INTO O_NBATTR
	VALUES (11059,
	11010);
INSERT INTO O_BATTR
	VALUES (11059,
	11010);
INSERT INTO O_ATTR
	VALUES (11059,
	11010,
	11060,
	'Name',
	'Full Name: Signal Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (11061,
	11010);
INSERT INTO O_BATTR
	VALUES (11061,
	11010);
INSERT INTO O_ATTR
	VALUES (11061,
	11010,
	11059,
	'Descrip',
	'Full Name: Signal Description',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (11010,
	10997,
	0,
	11005,
	11003,
	11011,
	11004,
	11060,
	11062,
	0,
	0,
	'',
	'Action Node',
	'Id',
	'R1107');
INSERT INTO O_RATTR
	VALUES (11060,
	11010,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (11060,
	11010,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	11010);
INSERT INTO O_OIDA
	VALUES (11060,
	11010,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	11010);
INSERT INTO O_ID
	VALUES (2,
	11010);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10999,
	'Object Node',
	1104,
	'A_OBJ',
	'',
	10958);
INSERT INTO O_TFR
	VALUES (11063,
	10999,
	'dispose',
	'',
	19,
	1,
	'select one parent related by self->A_N[R1105];
if ( not_empty parent )
  parent.dispose();
  return;
end if;

delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (11064,
	10999,
	'incomingEdgeAllowed',
	'',
	316,
	1,
	'return true;',
	1,
	'',
	11065);
INSERT INTO O_TFR
	VALUES (11066,
	10999,
	'outgoingEdgeAllowed',
	'',
	316,
	1,
	'return true;',
	1,
	'',
	11067);
INSERT INTO O_TFR
	VALUES (11067,
	10999,
	'initialize',
	'',
	19,
	1,
	'name = "Unnamed Object";
success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:false);    
if ( success!="") 
 self.Name=success;
else 
 self.dispose();
end if;   ',
	1,
	'',
	11064);
INSERT INTO O_TFR
	VALUES (11068,
	10999,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Id;
',
	1,
	'',
	11069);
INSERT INTO O_TFR
	VALUES (11070,
	10999,
	'get_style',
	'',
	784,
	1,
	'return Style::Box;',
	1,
	'',
	11068);
INSERT INTO O_TFR
	VALUES (11065,
	10999,
	'get_text_style',
	'',
	784,
	1,
	'return Style::None;',
	1,
	'',
	11070);
INSERT INTO O_TPARM
	VALUES (11071,
	11065,
	'comp_num',
	298,
	0,
	'',
	11072,
	'');
INSERT INTO O_TPARM
	VALUES (11073,
	11065,
	'ent_num',
	298,
	0,
	'',
	11071,
	'');
INSERT INTO O_TPARM
	VALUES (11072,
	11065,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11074,
	10999,
	'get_compartments',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	11075);
INSERT INTO O_TFR
	VALUES (11069,
	10999,
	'get_entries',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	11074);
INSERT INTO O_TPARM
	VALUES (11076,
	11069,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11075,
	10999,
	'get_compartment_text',
	'',
	322,
	1,
	'result = "";
if (param.at == Justification::Center)
  result = self.Name;
end if;
return result;',
	1,
	'',
	11063);
INSERT INTO O_TPARM
	VALUES (11077,
	11075,
	'comp_num',
	298,
	0,
	'',
	11078,
	'');
INSERT INTO O_TPARM
	VALUES (11079,
	11075,
	'ent_num',
	298,
	0,
	'',
	11077,
	'');
INSERT INTO O_TPARM
	VALUES (11078,
	11075,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11080,
	10999,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'return this;',
	0,
	'',
	11066);
INSERT INTO O_NBATTR
	VALUES (11081,
	10999);
INSERT INTO O_BATTR
	VALUES (11081,
	10999);
INSERT INTO O_ATTR
	VALUES (11081,
	10999,
	11082,
	'Name',
	'Full Name: Object Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (11083,
	10999);
INSERT INTO O_BATTR
	VALUES (11083,
	10999);
INSERT INTO O_ATTR
	VALUES (11083,
	10999,
	11081,
	'Descrip',
	'Full Name: Object Node Description',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (10999,
	2803,
	0,
	10990,
	10995,
	11000,
	10996,
	11082,
	11084,
	0,
	0,
	'',
	'Activity Node',
	'Id',
	'R1105');
INSERT INTO O_RATTR
	VALUES (11082,
	10999,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (11082,
	10999,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10999);
INSERT INTO O_OIDA
	VALUES (11082,
	10999,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	10999);
INSERT INTO O_ID
	VALUES (2,
	10999);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (11019,
	'Initial Node',
	1106,
	'A_INI',
	'',
	10958);
INSERT INTO O_TFR
	VALUES (11085,
	11019,
	'dispose',
	'',
	19,
	1,
	'select one parent related by self->A_CTL[R1106];
if ( not_empty parent )
  parent.dispose();
  return;
end if;
delete object instance self;

',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (11086,
	11019,
	'get_style',
	'',
	784,
	1,
	'return Style::FilledCircle;',
	1,
	'',
	11087);
INSERT INTO O_TFR
	VALUES (11088,
	11019,
	'get_text_style',
	'',
	784,
	1,
	'return Style::None;',
	1,
	'',
	11086);
INSERT INTO O_TPARM
	VALUES (11089,
	11088,
	'comp_num',
	298,
	0,
	'',
	11090,
	'');
INSERT INTO O_TPARM
	VALUES (11091,
	11088,
	'ent_num',
	298,
	0,
	'',
	11089,
	'');
INSERT INTO O_TPARM
	VALUES (11090,
	11088,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11092,
	11019,
	'get_compartments',
	'',
	298,
	1,
	'return 0;',
	1,
	'',
	11093);
INSERT INTO O_TFR
	VALUES (11094,
	11019,
	'get_entries',
	'',
	298,
	1,
	'return 0;',
	1,
	'',
	11092);
INSERT INTO O_TPARM
	VALUES (11095,
	11094,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11093,
	11019,
	'get_compartment_text',
	'',
	322,
	1,
	'return "";',
	1,
	'',
	11085);
INSERT INTO O_TPARM
	VALUES (11096,
	11093,
	'comp_num',
	298,
	0,
	'',
	11097,
	'');
INSERT INTO O_TPARM
	VALUES (11098,
	11093,
	'ent_num',
	298,
	0,
	'',
	11096,
	'');
INSERT INTO O_TPARM
	VALUES (11097,
	11093,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11087,
	11019,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Id;
',
	1,
	'',
	11099);
INSERT INTO O_TFR
	VALUES (11099,
	11019,
	'get_name',
	'',
	322,
	1,
	'return "";',
	1,
	'',
	11094);
INSERT INTO O_TFR
	VALUES (11100,
	11019,
	'incomingEdgeAllowed',
	'',
	316,
	1,
	'return false;',
	1,
	'',
	11088);
INSERT INTO O_TFR
	VALUES (11101,
	11019,
	'outgoingEdgeAllowed',
	'',
	316,
	1,
	'select one node related by self->A_CTL[R1106]->A_N[R1105];
return node.numOutgoingEdges() == 0;',
	1,
	'',
	11100);
INSERT INTO O_NBATTR
	VALUES (11102,
	11019);
INSERT INTO O_BATTR
	VALUES (11102,
	11019);
INSERT INTO O_ATTR
	VALUES (11102,
	11019,
	11103,
	'Descrip',
	'Full Name: Initial Node Description',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (11019,
	11001,
	0,
	11014,
	11012,
	11020,
	11013,
	11103,
	11104,
	0,
	0,
	'',
	'Control Node',
	'Id',
	'R1106');
INSERT INTO O_RATTR
	VALUES (11103,
	11019,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (11103,
	11019,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	11019);
INSERT INTO O_OIDA
	VALUES (11103,
	11019,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	11019);
INSERT INTO O_ID
	VALUES (2,
	11019);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (11023,
	'Fork Join Node',
	1110,
	'A_FJ',
	'',
	10958);
INSERT INTO O_TFR
	VALUES (11105,
	11023,
	'dispose',
	'',
	19,
	1,
	'select one parent related by self->A_CTL[R1106];
if ( not_empty parent )
  parent.dispose();
  return;
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (11106,
	11023,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Id;',
	1,
	'',
	11107);
INSERT INTO O_TFR
	VALUES (11108,
	11023,
	'get_style',
	'',
	784,
	1,
	'return Style::None;',
	1,
	'',
	11106);
INSERT INTO O_TPARM
	VALUES (11109,
	11108,
	'at',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11110,
	11023,
	'get_connector_text',
	'',
	322,
	1,
	'result = "";
if (param.at == End::End)
  result = self.GuardCondition;
end if;
return result;',
	1,
	'',
	11105);
INSERT INTO O_TPARM
	VALUES (11111,
	11110,
	'OOA_ID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (11112,
	11110,
	'OOA_TypeIsImportedClass',
	316,
	0,
	'',
	11111,
	'');
INSERT INTO O_TPARM
	VALUES (11113,
	11110,
	'at',
	880,
	0,
	'',
	11112,
	'');
INSERT INTO O_TPARM
	VALUES (11114,
	11110,
	'parent_ID',
	296,
	0,
	'',
	11113,
	'');
INSERT INTO O_TFR
	VALUES (11107,
	11023,
	'get_name',
	'',
	322,
	1,
	'return self.GuardCondition;',
	1,
	'',
	11110);
INSERT INTO O_TFR
	VALUES (11115,
	11023,
	'incomingEdgeAllowed',
	'',
	316,
	1,
	'return true;',
	1,
	'',
	11108);
INSERT INTO O_TFR
	VALUES (11116,
	11023,
	'outgoingEdgeAllowed',
	'',
	316,
	1,
	'return true;',
	1,
	'',
	11115);
INSERT INTO O_NBATTR
	VALUES (11117,
	11023);
INSERT INTO O_BATTR
	VALUES (11117,
	11023);
INSERT INTO O_ATTR
	VALUES (11117,
	11023,
	11118,
	'Descrip',
	'Full Name: Fork Join Description',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (11119,
	11023);
INSERT INTO O_BATTR
	VALUES (11119,
	11023);
INSERT INTO O_ATTR
	VALUES (11119,
	11023,
	11117,
	'GuardCondition',
	'Full Name: Guard Condition',
	'',
	'GuardCondition',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (11023,
	11001,
	0,
	11014,
	11012,
	11024,
	11013,
	11118,
	11120,
	0,
	0,
	'',
	'Control Node',
	'Id',
	'R1106');
INSERT INTO O_RATTR
	VALUES (11118,
	11023,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (11118,
	11023,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	11023);
INSERT INTO O_OIDA
	VALUES (11118,
	11023,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	11023);
INSERT INTO O_ID
	VALUES (2,
	11023);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (11015,
	'Flow Final Node',
	1108,
	'A_FF',
	'',
	10958);
INSERT INTO O_TFR
	VALUES (11121,
	11015,
	'dispose',
	'',
	19,
	1,
	'select one parent related by self->A_CTL[R1106];
if ( not_empty parent )
  parent.dispose();
  return;
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (11122,
	11015,
	'get_name',
	'',
	322,
	1,
	'return "";',
	1,
	'',
	11123);
INSERT INTO O_TFR
	VALUES (11124,
	11015,
	'incomingEdgeAllowed',
	'',
	316,
	1,
	'return true;',
	1,
	'',
	11125);
INSERT INTO O_TFR
	VALUES (11126,
	11015,
	'outgoingEdgeAllowed',
	'',
	316,
	1,
	'return false;',
	1,
	'',
	11124);
INSERT INTO O_TFR
	VALUES (11127,
	11015,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Id;',
	1,
	'',
	11122);
INSERT INTO O_TFR
	VALUES (11128,
	11015,
	'get_style',
	'',
	784,
	1,
	'return Style::CircleCross;',
	1,
	'',
	11127);
INSERT INTO O_TFR
	VALUES (11125,
	11015,
	'get_text_style',
	'',
	784,
	1,
	'return Style::None;',
	1,
	'',
	11128);
INSERT INTO O_TPARM
	VALUES (11129,
	11125,
	'comp_num',
	298,
	0,
	'',
	11130,
	'');
INSERT INTO O_TPARM
	VALUES (11131,
	11125,
	'ent_num',
	298,
	0,
	'',
	11129,
	'');
INSERT INTO O_TPARM
	VALUES (11130,
	11125,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11132,
	11015,
	'get_compartments',
	'',
	298,
	1,
	'return 0;',
	1,
	'',
	11133);
INSERT INTO O_TFR
	VALUES (11123,
	11015,
	'get_entries',
	'',
	298,
	1,
	'return 0;',
	1,
	'',
	11132);
INSERT INTO O_TPARM
	VALUES (11134,
	11123,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11133,
	11015,
	'get_compartment_text',
	'',
	322,
	1,
	'return "";',
	1,
	'',
	11121);
INSERT INTO O_TPARM
	VALUES (11135,
	11133,
	'comp_num',
	298,
	0,
	'',
	11136,
	'');
INSERT INTO O_TPARM
	VALUES (11137,
	11133,
	'ent_num',
	298,
	0,
	'',
	11135,
	'');
INSERT INTO O_TPARM
	VALUES (11136,
	11133,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_NBATTR
	VALUES (11138,
	11015);
INSERT INTO O_BATTR
	VALUES (11138,
	11015);
INSERT INTO O_ATTR
	VALUES (11138,
	11015,
	11139,
	'Descrip',
	'Full Name: Final Flow Description',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (11015,
	11001,
	0,
	11014,
	11012,
	11016,
	11013,
	11139,
	11140,
	0,
	0,
	'',
	'Control Node',
	'Id',
	'R1106');
INSERT INTO O_RATTR
	VALUES (11139,
	11015,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (11139,
	11015,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	11015);
INSERT INTO O_OIDA
	VALUES (11139,
	11015,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	11015);
INSERT INTO O_ID
	VALUES (2,
	11015);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (11021,
	'Decision Merge Node',
	1109,
	'A_DM',
	'',
	10958);
INSERT INTO O_TFR
	VALUES (11141,
	11021,
	'dispose',
	'',
	19,
	1,
	'select one parent related by self->A_CTL[R1106];
if ( not_empty parent )
  parent.dispose();
  return;
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (11142,
	11021,
	'get_name',
	'',
	322,
	1,
	'return self.Name;',
	1,
	'',
	11143);
INSERT INTO O_TFR
	VALUES (11144,
	11021,
	'incomingEdgeAllowed',
	'',
	316,
	1,
	'return true;',
	1,
	'',
	11145);
INSERT INTO O_TFR
	VALUES (11146,
	11021,
	'outgoingEdgeAllowed',
	'',
	316,
	1,
	'return true;',
	1,
	'',
	11147);
INSERT INTO O_TFR
	VALUES (11148,
	11021,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Id;',
	1,
	'',
	11142);
INSERT INTO O_TFR
	VALUES (11149,
	11021,
	'get_style',
	'',
	784,
	1,
	'return Style::Diamond;',
	1,
	'',
	11148);
INSERT INTO O_TFR
	VALUES (11145,
	11021,
	'get_text_style',
	'',
	784,
	1,
	'return Style::None;',
	1,
	'',
	11149);
INSERT INTO O_TPARM
	VALUES (11150,
	11145,
	'comp_num',
	298,
	0,
	'',
	11151,
	'');
INSERT INTO O_TPARM
	VALUES (11152,
	11145,
	'ent_num',
	298,
	0,
	'',
	11150,
	'');
INSERT INTO O_TPARM
	VALUES (11151,
	11145,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11153,
	11021,
	'get_compartments',
	'',
	298,
	1,
	'return 0;',
	1,
	'',
	11154);
INSERT INTO O_TFR
	VALUES (11143,
	11021,
	'get_entries',
	'',
	298,
	1,
	'return 0;',
	1,
	'',
	11153);
INSERT INTO O_TPARM
	VALUES (11155,
	11143,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11154,
	11021,
	'get_compartment_text',
	'',
	322,
	1,
	'result = "";
if (param.at == Justification::Floating)
  if ( self.Name != "" )
    result = self.Name;
  end if;
end if;
return result;',
	1,
	'',
	11141);
INSERT INTO O_TPARM
	VALUES (11156,
	11154,
	'comp_num',
	298,
	0,
	'',
	11157,
	'');
INSERT INTO O_TPARM
	VALUES (11158,
	11154,
	'ent_num',
	298,
	0,
	'',
	11156,
	'');
INSERT INTO O_TPARM
	VALUES (11157,
	11154,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11147,
	11021,
	'initialize',
	'',
	19,
	1,
	'// do nothing, as the DecisionInput should be initialized to the empty string
// make it explicit
self.Name = "";',
	1,
	'',
	11144);
INSERT INTO O_NBATTR
	VALUES (11159,
	11021);
INSERT INTO O_BATTR
	VALUES (11159,
	11021);
INSERT INTO O_ATTR
	VALUES (11159,
	11021,
	11160,
	'Name',
	'Full Name: Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (11161,
	11021);
INSERT INTO O_BATTR
	VALUES (11161,
	11021);
INSERT INTO O_ATTR
	VALUES (11161,
	11021,
	11159,
	'Descrip',
	'Full Name: Decision Merge Description',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (11021,
	11001,
	0,
	11014,
	11012,
	11022,
	11013,
	11160,
	11162,
	0,
	0,
	'',
	'Control Node',
	'Id',
	'R1106');
INSERT INTO O_RATTR
	VALUES (11160,
	11021,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (11160,
	11021,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	11021);
INSERT INTO O_OIDA
	VALUES (11160,
	11021,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	11021);
INSERT INTO O_ID
	VALUES (2,
	11021);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (11001,
	'Control Node',
	1105,
	'A_CTL',
	'',
	10958);
INSERT INTO O_TFR
	VALUES (11163,
	11001,
	'dispose',
	'',
	19,
	1,
	'select one parent related by self->A_N[R1105];
if ( not_empty parent )
  parent.dispose();
  return;
end if;

select one ini related by self->A_INI[R1106];
if ( not_empty ini )
  unrelate self from ini across R1106;
  ini.dispose();
end if;
select one af related by self->A_AF[R1106];
if ( not_empty af )
  unrelate self from af across R1106;
  af.dispose();
end if;
select one ff related by self->A_FF[R1106];
if ( not_empty ff )
  unrelate self from ff across R1106;
  ff.dispose();
end if;
select one d related by self->A_DM[R1106];
if ( not_empty d )
  unrelate self from d across R1106;
  d.dispose();
end if;
select one fj related by self->A_FJ[R1106];
if ( not_empty fj )
  unrelate self from fj across R1106;
  fj.dispose();
end if;

delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (11164,
	11001,
	'incomingEdgeAllowed',
	'',
	316,
	1,
	'select one ini related by self->A_INI[R1106];
if ( not_empty ini )
  return ini.incomingEdgeAllowed();
else
  select one af related by self->A_AF[R1106];
  if ( not_empty af )
    return af.incomingEdgeAllowed();
  else
    select one ff related by self->A_FF[R1106];
    if ( not_empty ff )
      return ff.incomingEdgeAllowed();
    else
      select one d related by self->A_DM[R1106];
      if ( not_empty d )
        return d.incomingEdgeAllowed();
      else
        select one fj related by self->A_FJ[R1106];
        if ( not_empty fj )
          return fj.incomingEdgeAllowed();
        end if;
      end if;
    end if;
  end if;
end if;
return false;',
	1,
	'',
	11163);
INSERT INTO O_TFR
	VALUES (11165,
	11001,
	'outgoingEdgeAllowed',
	'',
	316,
	1,
	'select one ini related by self->A_INI[R1106];
if ( not_empty ini )
  return ini.outgoingEdgeAllowed();
else
  select one af related by self->A_AF[R1106];
  if ( not_empty af )
    return af.outgoingEdgeAllowed();
  else
    select one ff related by self->A_FF[R1106];
    if ( not_empty ff )
      return ff.outgoingEdgeAllowed();
    else
      select one d related by self->A_DM[R1106];
      if ( not_empty d )
        return d.outgoingEdgeAllowed();
      else
        select one fj related by self->A_FJ[R1106];
        if ( not_empty fj )
          return fj.outgoingEdgeAllowed();
        end if;
      end if;
    end if;
  end if;
end if;
return false;',
	1,
	'',
	11164);
INSERT INTO O_REF
	VALUES (11001,
	2803,
	0,
	10990,
	10995,
	11002,
	10996,
	11014,
	11166,
	0,
	0,
	'',
	'Activity Node',
	'Id',
	'R1105');
INSERT INTO O_RATTR
	VALUES (11014,
	11001,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (11014,
	11001,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	11001);
INSERT INTO O_OIDA
	VALUES (11014,
	11001,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	11001);
INSERT INTO O_ID
	VALUES (2,
	11001);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2812,
	'Activity Partition',
	1301,
	'A_AP',
	'',
	10958);
INSERT INTO O_TFR
	VALUES (11167,
	2812,
	'dispose',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one parent related by self->A_A[R1111];
if not empty parent
  unrelate self from parent across R1111;
end if;
select one pe related by self->PE_PE[R8001];
if (not_empty pe)
  unrelate self from pe across R8001;
  pe.dispose();
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (11168,
	2812,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Id;',
	1,
	'',
	11169);
INSERT INTO O_TFR
	VALUES (11170,
	2812,
	'get_style',
	'',
	784,
	1,
	'return Style::None;',
	1,
	'',
	11168);
INSERT INTO O_TPARM
	VALUES (11171,
	11170,
	'at',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11169,
	2812,
	'get_connector_text',
	'',
	322,
	1,
	'result = "";
if (param.at == End::Middle)
  result = self.Name;
end if;
return result;',
	1,
	'',
	11167);
INSERT INTO O_TPARM
	VALUES (11172,
	11169,
	'OOA_ID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (11173,
	11169,
	'OOA_TypeIsImportedClass',
	316,
	0,
	'',
	11172,
	'');
INSERT INTO O_TPARM
	VALUES (11174,
	11169,
	'at',
	880,
	0,
	'',
	11173,
	'');
INSERT INTO O_TPARM
	VALUES (11175,
	11169,
	'parent_ID',
	296,
	0,
	'',
	11174,
	'');
INSERT INTO O_NBATTR
	VALUES (11176,
	2812);
INSERT INTO O_BATTR
	VALUES (11176,
	2812);
INSERT INTO O_ATTR
	VALUES (11176,
	2812,
	11177,
	'Name',
	'Full Name: Partition Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (11178,
	2812);
INSERT INTO O_BATTR
	VALUES (11178,
	2812);
INSERT INTO O_ATTR
	VALUES (11178,
	2812,
	11176,
	'Descrip',
	'Full Name: Partition Description',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (2812,
	6798,
	0,
	10972,
	10979,
	10981,
	10980,
	11177,
	11179,
	0,
	0,
	'',
	'Activity',
	'Package_ID',
	'R1111');
INSERT INTO O_RATTR
	VALUES (11177,
	2812,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (11177,
	2812,
	11180,
	'Package_ID',
	'',
	'',
	'Package_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2812,
	26,
	0,
	25,
	868,
	2835,
	870,
	11180,
	11181,
	0,
	0,
	'',
	'Packageable Element',
	'Element_ID',
	'R8001');
INSERT INTO O_RATTR
	VALUES (11180,
	2812,
	25,
	26,
	0,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (11180,
	2812,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2812);
INSERT INTO O_OIDA
	VALUES (11180,
	2812,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	2812);
INSERT INTO O_ID
	VALUES (2,
	2812);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2803,
	'Activity Node',
	1101,
	'A_N',
	'',
	10958);
INSERT INTO O_TFR
	VALUES (11182,
	2803,
	'dispose',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one parent related by self->A_A[R1101];
if ( not_empty parent )
  unrelate self from parent across R1101;
end if;

select one act related by self->A_ACT[R1105];
if ( not_empty act )
  unrelate self from act across R1105;
  act.dispose();
end if;
select one obj related by self->A_OBJ[R1105];
if ( not_empty obj )
  unrelate self from obj across R1105;
  obj.dispose();
end if;
select one ctl related by self->A_CTL[R1105];
if ( not_empty ctl )
  unrelate self from ctl across R1105;
  ctl.dispose();
end if;

select many inEdges related by self->A_E[R1103];
for each inEdge in inEdges
  inEdge.dispose();
end for;

select many outEdges related by self->A_E[R1104];
for each outEdge in outEdges
  outEdge.dispose();
end for;
select one pe related by self->PE_PE[R8001];
if (not_empty pe)
  unrelate self from pe across R8001;
  pe.dispose();
end if;
delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (11183,
	2803,
	'incomingEdgeAllowed',
	'',
	316,
	1,
	'select one act related by self->A_ACT[R1105];
if ( not_empty act )
  return act.incomingEdgeAllowed();
else
  select one obj related by self->A_OBJ[R1105];
  if ( not_empty obj )
    return obj.incomingEdgeAllowed();
  else
    select one ctl related by self->A_CTL[R1105];
    if ( not_empty ctl )
      return ctl.incomingEdgeAllowed();
    end if;
  end if;
end if;
return false;',
	1,
	'',
	11182);
INSERT INTO O_TFR
	VALUES (11184,
	2803,
	'outgoingEdgeAllowed',
	'',
	316,
	1,
	'select one act related by self->A_ACT[R1105];
if ( not_empty act )
  return act.outgoingEdgeAllowed();
else
  select one obj related by self->A_OBJ[R1105];
  if ( not_empty obj )
    return obj.outgoingEdgeAllowed();
  else
    select one ctl related by self->A_CTL[R1105];
    if ( not_empty ctl )
      return ctl.outgoingEdgeAllowed();
    end if;
  end if;
end if;
return false;',
	1,
	'',
	11185);
INSERT INTO O_TFR
	VALUES (11186,
	2803,
	'numIncomingEdges',
	'',
	298,
	1,
	'select many inEdges related by self->A_E[R1103];
return cardinality inEdges;',
	1,
	'',
	11183);
INSERT INTO O_TFR
	VALUES (11185,
	2803,
	'numOutgoingEdges',
	'',
	298,
	1,
	'select many outEdges related by self->A_E[R1104];
return cardinality outEdges;',
	1,
	'',
	11186);
INSERT INTO O_REF
	VALUES (2803,
	6798,
	0,
	10972,
	10985,
	10987,
	10986,
	11187,
	11188,
	0,
	0,
	'',
	'Activity',
	'Package_ID',
	'R1101');
INSERT INTO O_RATTR
	VALUES (11187,
	2803,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (11187,
	2803,
	10990,
	'Package_ID',
	'',
	'',
	'Package_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2803,
	26,
	0,
	25,
	868,
	2829,
	870,
	10990,
	11189,
	0,
	0,
	'',
	'Packageable Element',
	'Element_ID',
	'R8001');
INSERT INTO O_RATTR
	VALUES (10990,
	2803,
	25,
	26,
	0,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (10990,
	2803,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2803);
INSERT INTO O_OIDA
	VALUES (10990,
	2803,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	2803);
INSERT INTO O_ID
	VALUES (2,
	2803);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10973,
	'Activity In Activity',
	1115,
	'A_AIA',
	'',
	10958);
INSERT INTO O_REF
	VALUES (10973,
	6798,
	0,
	10972,
	10970,
	10974,
	10971,
	10978,
	11190,
	0,
	0,
	'',
	'Activity',
	'Package_ID',
	'R1109');
INSERT INTO O_RATTR
	VALUES (10978,
	10973,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (10978,
	10973,
	0,
	'Package_ID',
	'',
	'',
	'Package_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10973);
INSERT INTO O_OIDA
	VALUES (10978,
	10973,
	0,
	'Package_ID');
INSERT INTO O_ID
	VALUES (1,
	10973);
INSERT INTO O_ID
	VALUES (2,
	10973);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (11017,
	'Activity Final Node',
	1107,
	'A_AF',
	'',
	10958);
INSERT INTO O_TFR
	VALUES (11191,
	11017,
	'dispose',
	'',
	19,
	1,
	'select one parent related by self->A_CTL[R1106];
if ( not_empty parent )
  parent.dispose();
  return;
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (11192,
	11017,
	'get_name',
	'',
	322,
	1,
	'return "";',
	1,
	'',
	11193);
INSERT INTO O_TFR
	VALUES (11194,
	11017,
	'incomingEdgeAllowed',
	'',
	316,
	1,
	'return true;',
	1,
	'',
	11195);
INSERT INTO O_TFR
	VALUES (11196,
	11017,
	'outgoingEdgeAllowed',
	'',
	316,
	1,
	'return false;',
	1,
	'',
	11194);
INSERT INTO O_TFR
	VALUES (11197,
	11017,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Id;',
	1,
	'',
	11192);
INSERT INTO O_TFR
	VALUES (11198,
	11017,
	'get_style',
	'',
	784,
	1,
	'return Style::BullsEye;',
	1,
	'',
	11197);
INSERT INTO O_TFR
	VALUES (11195,
	11017,
	'get_text_style',
	'',
	784,
	1,
	'return Style::None;',
	1,
	'',
	11198);
INSERT INTO O_TPARM
	VALUES (11199,
	11195,
	'comp_num',
	298,
	0,
	'',
	11200,
	'');
INSERT INTO O_TPARM
	VALUES (11201,
	11195,
	'ent_num',
	298,
	0,
	'',
	11199,
	'');
INSERT INTO O_TPARM
	VALUES (11200,
	11195,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11202,
	11017,
	'get_compartments',
	'',
	298,
	1,
	'return 0;',
	1,
	'',
	11203);
INSERT INTO O_TFR
	VALUES (11193,
	11017,
	'get_entries',
	'',
	298,
	1,
	'return 0;',
	1,
	'',
	11202);
INSERT INTO O_TPARM
	VALUES (11204,
	11193,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11203,
	11017,
	'get_compartment_text',
	'',
	322,
	1,
	'return "";',
	1,
	'',
	11191);
INSERT INTO O_TPARM
	VALUES (11205,
	11203,
	'comp_num',
	298,
	0,
	'',
	11206,
	'');
INSERT INTO O_TPARM
	VALUES (11207,
	11203,
	'ent_num',
	298,
	0,
	'',
	11205,
	'');
INSERT INTO O_TPARM
	VALUES (11206,
	11203,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_NBATTR
	VALUES (11208,
	11017);
INSERT INTO O_BATTR
	VALUES (11208,
	11017);
INSERT INTO O_ATTR
	VALUES (11208,
	11017,
	11209,
	'Descrip',
	'Full Name: Final Activity Description',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (11017,
	11001,
	0,
	11014,
	11012,
	11018,
	11013,
	11209,
	11210,
	0,
	0,
	'',
	'Control Node',
	'Id',
	'R1106');
INSERT INTO O_RATTR
	VALUES (11209,
	11017,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (11209,
	11017,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	11017);
INSERT INTO O_OIDA
	VALUES (11209,
	11017,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	11017);
INSERT INTO O_ID
	VALUES (2,
	11017);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (2814,
	'Activity Edge',
	1102,
	'A_E',
	'',
	10958);
INSERT INTO O_TFR
	VALUES (11211,
	2814,
	'dispose',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one parent related by self->A_A[R1102];
if ( not_empty parent )
  unrelate self from parent across R1102;
end if;

select one source related by self->A_N[R1104];
if ( not_empty source )
  unrelate self from source across R1104;
end if;
select one target related by self->A_N[R1103];
if ( not_empty target )
  unrelate self from target across R1103;
end if;
select one pe related by self->PE_PE[R8001];
if (not_empty pe)
  unrelate self from pe across R8001;
  pe.dispose();
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (11212,
	2814,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Id;',
	1,
	'',
	11213);
INSERT INTO O_TFR
	VALUES (11214,
	2814,
	'get_style',
	'',
	784,
	1,
	'if (param.at == End::End)
  return Style::OpenArrow;
else
  return Style::None;
end if;',
	1,
	'',
	11212);
INSERT INTO O_TPARM
	VALUES (11215,
	11214,
	'at',
	880,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11216,
	2814,
	'get_connector_text',
	'',
	322,
	1,
	'result = "";
if (param.at == End::Middle)
  if ( self.Guard != "" )
    result = "[" + self.Guard + "]";
  end if;
end if;
return result;',
	1,
	'',
	11211);
INSERT INTO O_TPARM
	VALUES (11217,
	11216,
	'OOA_ID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (11218,
	11216,
	'OOA_TypeIsImportedClass',
	316,
	0,
	'',
	11217,
	'');
INSERT INTO O_TPARM
	VALUES (11219,
	11216,
	'at',
	880,
	0,
	'',
	11218,
	'');
INSERT INTO O_TPARM
	VALUES (11220,
	11216,
	'parent_ID',
	296,
	0,
	'',
	11219,
	'');
INSERT INTO O_TFR
	VALUES (11213,
	2814,
	'get_name',
	'',
	322,
	1,
	'return self.Guard;',
	1,
	'',
	11216);
INSERT INTO O_NBATTR
	VALUES (11221,
	2814);
INSERT INTO O_BATTR
	VALUES (11221,
	2814);
INSERT INTO O_ATTR
	VALUES (11221,
	2814,
	11222,
	'Guard',
	'Full Name: Guard Condition',
	'',
	'Guard',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (11223,
	2814);
INSERT INTO O_BATTR
	VALUES (11223,
	2814);
INSERT INTO O_ATTR
	VALUES (11223,
	2814,
	11221,
	'Descrip',
	'Full Name: Edge Description',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (2814,
	6798,
	0,
	10972,
	10982,
	10984,
	10983,
	11222,
	11224,
	0,
	0,
	'',
	'Activity',
	'Package_ID',
	'R1102');
INSERT INTO O_RATTR
	VALUES (11222,
	2814,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (11222,
	2814,
	11225,
	'Package_ID',
	'',
	'',
	'Package_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2814,
	2803,
	0,
	10990,
	10988,
	10991,
	10989,
	11226,
	11227,
	0,
	0,
	'',
	'Activity Node',
	'Id',
	'R1103');
INSERT INTO O_RATTR
	VALUES (11226,
	2814,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (11226,
	2814,
	11223,
	'TargetId',
	'',
	'Target',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2814,
	2803,
	0,
	10990,
	10992,
	10994,
	10993,
	11228,
	11229,
	0,
	0,
	'',
	'Activity Node',
	'Id',
	'R1104');
INSERT INTO O_RATTR
	VALUES (11228,
	2814,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (11228,
	2814,
	11226,
	'SourceId',
	'',
	'Source',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (2814,
	26,
	0,
	25,
	868,
	2836,
	870,
	11225,
	11230,
	0,
	0,
	'',
	'Packageable Element',
	'Element_ID',
	'R8001');
INSERT INTO O_RATTR
	VALUES (11225,
	2814,
	25,
	26,
	0,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (11225,
	2814,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	2814);
INSERT INTO O_OIDA
	VALUES (11225,
	2814,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	2814);
INSERT INTO O_ID
	VALUES (2,
	2814);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (11008,
	'Activity Diagram Action',
	1111,
	'A_GA',
	'',
	10958);
INSERT INTO O_TFR
	VALUES (11231,
	11008,
	'incomingEdgeAllowed',
	'',
	316,
	1,
	'select any edge related by self->A_ACT[R1107]->A_N[R1105]->A_E[R1103];
return empty edge;',
	1,
	'',
	11232);
INSERT INTO O_TFR
	VALUES (11233,
	11008,
	'outgoingEdgeAllowed',
	'',
	316,
	1,
	'select any edge related by self->A_ACT[R1107]->A_N[R1105]->A_E[R1104];
return empty edge;',
	1,
	'',
	11234);
INSERT INTO O_TFR
	VALUES (11235,
	11008,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Id;',
	1,
	'',
	11236);
INSERT INTO O_TFR
	VALUES (11237,
	11008,
	'get_style',
	'',
	784,
	1,
	'return Style::RoundBox;',
	1,
	'',
	11235);
INSERT INTO O_TFR
	VALUES (11232,
	11008,
	'get_text_style',
	'',
	784,
	1,
	'return Style::None;',
	1,
	'',
	11237);
INSERT INTO O_TPARM
	VALUES (11238,
	11232,
	'comp_num',
	298,
	0,
	'',
	11239,
	'');
INSERT INTO O_TPARM
	VALUES (11240,
	11232,
	'ent_num',
	298,
	0,
	'',
	11238,
	'');
INSERT INTO O_TPARM
	VALUES (11239,
	11232,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11241,
	11008,
	'get_compartments',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	11242);
INSERT INTO O_TFR
	VALUES (11236,
	11008,
	'get_entries',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	11241);
INSERT INTO O_TPARM
	VALUES (11243,
	11236,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11242,
	11008,
	'get_compartment_text',
	'',
	322,
	1,
	'result = "";
if (param.at == Justification::Center)
  result = self.Name;
end if;
return result;',
	1,
	'',
	11244);
INSERT INTO O_TPARM
	VALUES (11245,
	11242,
	'comp_num',
	298,
	0,
	'',
	11246,
	'');
INSERT INTO O_TPARM
	VALUES (11247,
	11242,
	'ent_num',
	298,
	0,
	'',
	11245,
	'');
INSERT INTO O_TPARM
	VALUES (11246,
	11242,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11234,
	11008,
	'initialize',
	'',
	19,
	1,
	'name = "Unnamed Action";
success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:false);    
if ( success!="") 
 self.Name=success;
else 
 self.dispose();
end if;   ',
	1,
	'',
	11231);
INSERT INTO O_TFR
	VALUES (11244,
	11008,
	'dispose',
	'',
	19,
	1,
	'select one parent related by self->A_ACT[R1107];
if ( not_empty parent )
  parent.dispose();
  return;
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (11248,
	11008,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'return this;',
	0,
	'',
	11233);
INSERT INTO O_NBATTR
	VALUES (11249,
	11008);
INSERT INTO O_BATTR
	VALUES (11249,
	11008);
INSERT INTO O_ATTR
	VALUES (11249,
	11008,
	11250,
	'Name',
	'Full Name: Action Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (11251,
	11008);
INSERT INTO O_BATTR
	VALUES (11251,
	11008);
INSERT INTO O_ATTR
	VALUES (11251,
	11008,
	11249,
	'Descrip',
	'Full Name: Action Description',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (11008,
	10997,
	0,
	11005,
	11003,
	11009,
	11004,
	11250,
	11252,
	0,
	0,
	'',
	'Action Node',
	'Id',
	'R1107');
INSERT INTO O_RATTR
	VALUES (11250,
	11008,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (11250,
	11008,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	11008);
INSERT INTO O_OIDA
	VALUES (11250,
	11008,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	11008);
INSERT INTO O_ID
	VALUES (2,
	11008);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (6798,
	'Activity',
	1100,
	'A_A',
	'',
	10958);
INSERT INTO O_TFR
	VALUES (11253,
	6798,
	'initialize',
	'',
	19,
	1,
	'self.Name = ::getUniqueInitialName( 
    instance: self.convertToInstance(), 
    candidateName: "Unnamed Activity" );',
	1,
	'',
	11254);
INSERT INTO O_TFR
	VALUES (11255,
	6798,
	'dispose',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one dom related by self->S_DOM[R1100];
if ( not_empty dom )
  unrelate self from dom across R1100;
end if;

select one system related by self->S_SYS[R1113];
if(not_empty system)
  unrelate self from system across R1113;
end if;

select one compPackage related by self->CP_CP[R1114];
if(not_empty compPackage)
  unrelate self from compPackage across R1114;
end if;

select one comp related by self->C_C[R1115];
if(not_empty comp)
  unrelate self from comp across R1115;
end if;

select one ss related by self->S_SS[R1108];
if ( not_empty ss )
  unrelate self from ss across R1108;
end if;

select many nodes related by self->A_N[R1101];
for each node in nodes 
  unrelate self from node across R1101;
  node.dispose();
end for;

select many edges related by self->A_E[R1102];
for each edge in edges 
  unrelate self from edge across R1102;
  edge.dispose();
end for;

select many partitions related by self->A_AP[R1111];
for each partition in partitions 
  unrelate self from partition across R1111;
  partition.dispose();
end for;

// delete child activities
select one aia related by self->A_AIA[R1109];
if not_empty aia
  select many acts related by aia->A_A[R1110];
  for each act in acts
    unrelate aia from act across R1110;
    act.dispose();
  end for;
  unrelate self from aia across R1109;
  delete object instance aia;
end if;

// unrelate from parent
select one aia related by self->A_AIA[R1110];
if not_empty aia
  unrelate aia from self across R1110;
  // are there any other children?
  select any other_child related by aia->A_A[R1110];
  if ( empty other_child )
    // there are no other children
    select one parent related by aia->A_A[R1109];
    unrelate parent from aia across R1109;
    delete object instance aia;
  end if;
end if;

select one specPkg related by self->EP_SPKG[R1402];




if(not_empty specPkg)
  unrelate self from specPkg across R1402;
  specPkg.dispose();
end if;
delete object instance self;',
	1,
	'',
	11256);
INSERT INTO O_TFR
	VALUES (11257,
	6798,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Package_ID;',
	1,
	'',
	11258);
INSERT INTO O_TFR
	VALUES (11259,
	6798,
	'get_style',
	'',
	784,
	1,
	'return Style::Folder;',
	1,
	'',
	11257);
INSERT INTO O_TFR
	VALUES (11254,
	6798,
	'get_text_style',
	'',
	784,
	1,
	'return Style::None;',
	1,
	'',
	11259);
INSERT INTO O_TPARM
	VALUES (11260,
	11254,
	'comp_num',
	298,
	0,
	'',
	11261,
	'');
INSERT INTO O_TPARM
	VALUES (11262,
	11254,
	'ent_num',
	298,
	0,
	'',
	11260,
	'');
INSERT INTO O_TPARM
	VALUES (11261,
	11254,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11263,
	6798,
	'get_compartments',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	11264);
INSERT INTO O_TFR
	VALUES (11258,
	6798,
	'get_entries',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	11263);
INSERT INTO O_TPARM
	VALUES (11265,
	11258,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11264,
	6798,
	'get_compartment_text',
	'',
	322,
	1,
	'result = "";
if (param.at == Justification::Center_in_X)
  result = "activity";
elif (param.at == Justification::Center)
  result = self.Name;
end if;
return result;',
	1,
	'',
	11255);
INSERT INTO O_TPARM
	VALUES (11266,
	11264,
	'comp_num',
	298,
	0,
	'',
	11267,
	'');
INSERT INTO O_TPARM
	VALUES (11268,
	11264,
	'ent_num',
	298,
	0,
	'',
	11266,
	'');
INSERT INTO O_TPARM
	VALUES (11267,
	11264,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11269,
	6798,
	'newForkJoin',
	'',
	316,
	1,
	'if(param.from == GD::NULL_UNIQUE_ID()) and (param.to == GD::NULL_UNIQUE_ID())
  create object instance node of A_N;
  create object instance ctl of A_CTL;
  create object instance fj of A_FJ;

  relate node to self across R1101;
  relate node to ctl across R1105;
  relate ctl to fj across R1106;
  
  return true;
end if;
return false;
',
	1,
	'',
	11270);
INSERT INTO O_TPARM
	VALUES (11271,
	11269,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (11272,
	11269,
	'to',
	296,
	0,
	'',
	11273,
	'');
INSERT INTO O_TPARM
	VALUES (11273,
	11269,
	'fromTypeIsImportedClass',
	316,
	0,
	'',
	11271,
	'');
INSERT INTO O_TPARM
	VALUES (11274,
	11269,
	'toTypeIsImportedClass',
	316,
	0,
	'',
	11272,
	'');
INSERT INTO O_TFR
	VALUES (11275,
	6798,
	'newInitialNode',
	'',
	19,
	1,
	'create object instance node of A_N;
create object instance ctl of A_CTL;
create object instance ini of A_INI;

relate node to self across R1101;
relate node to ctl across R1105;
relate ctl to ini across R1106;
',
	1,
	'',
	11276);
INSERT INTO O_TFR
	VALUES (11277,
	6798,
	'newActivityFinalNode',
	'',
	19,
	1,
	'create object instance node of A_N;
create object instance ctl of A_CTL;
create object instance af of A_AF;

relate node to self across R1101;
relate node to ctl across R1105;
relate ctl to af across R1106;
',
	1,
	'',
	11278);
INSERT INTO O_TFR
	VALUES (11270,
	6798,
	'newFlowFinalNode',
	'',
	19,
	1,
	'create object instance node of A_N;
create object instance ctl of A_CTL;
create object instance ff of A_FF;

relate node to self across R1101;
relate node to ctl across R1105;
relate ctl to ff across R1106;',
	1,
	'',
	11279);
INSERT INTO O_TFR
	VALUES (11279,
	6798,
	'newDecisionMergeNode',
	'',
	19,
	1,
	'create object instance node of A_N;
create object instance ctl of A_CTL;
create object instance d of A_DM;

relate node to self across R1101;
relate node to ctl across R1105;
relate ctl to d across R1106;

d.initialize();
',
	1,
	'',
	11280);
INSERT INTO O_TFR
	VALUES (11278,
	6798,
	'newActivityEdge',
	'',
	316,
	1,
	'if ( param.from == param.to )
  return false;
end if;
select any fromNode related by self->A_N[R1101] where (selected.Id == param.from);
select any toNode related by self->A_N[R1101] where (selected.Id == param.to);
if (not_empty fromNode and not_empty toNode)
  if ( fromNode.outgoingEdgeAllowed() and toNode.incomingEdgeAllowed() )
    create object instance edge of A_E;
    relate edge to self across R1102;
    relate edge to fromNode across R1104;
    relate edge to toNode across R1103;
    return true;
  end if;
end if;
return false;',
	1,
	'',
	11281);
INSERT INTO O_TPARM
	VALUES (11282,
	11278,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (11283,
	11278,
	'to',
	296,
	0,
	'',
	11284,
	'');
INSERT INTO O_TPARM
	VALUES (11284,
	11278,
	'fromTypeIsImportedClass',
	316,
	0,
	'',
	11282,
	'');
INSERT INTO O_TPARM
	VALUES (11285,
	11278,
	'toTypeIsImportedClass',
	316,
	0,
	'',
	11283,
	'');
INSERT INTO O_TFR
	VALUES (11276,
	6798,
	'newGenericAction',
	'',
	19,
	1,
	'create object instance node of A_N;
create object instance act of A_ACT;
create object instance ga of A_GA;

relate node to self across R1101;
relate node to act across R1105;
relate act to ga across R1107;
ga.initialize();',
	1,
	'',
	11269);
INSERT INTO O_TFR
	VALUES (11286,
	6798,
	'newObjectNode',
	'',
	19,
	1,
	'create object instance node of A_N;
create object instance obj of A_OBJ;

relate node to self across R1101;
relate node to obj across R1105;
obj.initialize();',
	1,
	'',
	11275);
INSERT INTO O_TFR
	VALUES (11287,
	6798,
	'newAcceptEventAction',
	'',
	19,
	1,
	'create object instance node of A_N;
create object instance act of A_ACT;
create object instance ae of A_AE;
create object instance aea of A_AEA;

relate node to self across R1101;
relate node to act across R1105;
relate act to ae across R1107;
relate ae to aea across R1112;
aea.initialize();',
	1,
	'',
	11253);
INSERT INTO O_TFR
	VALUES (11288,
	6798,
	'newSendSignalAction',
	'',
	19,
	1,
	'create object instance node of A_N;
create object instance act of A_ACT;
create object instance ss of A_SS;

relate node to self across R1101;
relate node to act across R1105;
relate act to ss across R1107;
ss.initialize();',
	1,
	'',
	11286);
INSERT INTO O_TFR
	VALUES (11289,
	6798,
	'newAcceptTimeEventAction',
	'',
	19,
	1,
	'create object instance node of A_N;
create object instance act of A_ACT;
create object instance ae of A_AE;
create object instance ate of A_ATE;

relate node to self across R1101;
relate node to act across R1105;
relate act to ae across R1107;
relate ae to ate across R1112;
ate.initialize();',
	1,
	'',
	11287);
INSERT INTO O_TFR
	VALUES (11281,
	6798,
	'newActivity',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one aia related by self->A_AIA[R1109];
if ( empty aia )
  create object instance aia of A_AIA;
  relate self to aia across R1109;
end if;
create object instance a of A_A;
create object instance sp of EP_SPKG;
relate sp to a across R1402;
relate aia to a across R1110;
a.initialize();',
	1,
	'',
	11289);
INSERT INTO O_TFR
	VALUES (11280,
	6798,
	'newActivityPartition',
	'',
	316,
	1,
	'create object instance ap of A_AP;
relate ap to self across R1111;
return true;',
	1,
	'',
	11277);
INSERT INTO O_TPARM
	VALUES (11290,
	11280,
	'from',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TPARM
	VALUES (11291,
	11280,
	'to',
	296,
	0,
	'',
	11292,
	'');
INSERT INTO O_TPARM
	VALUES (11292,
	11280,
	'fromTypeIsImportedClass',
	316,
	0,
	'',
	11290,
	'');
INSERT INTO O_TPARM
	VALUES (11293,
	11280,
	'toTypeIsImportedClass',
	316,
	0,
	'',
	11291,
	'');
INSERT INTO O_TFR
	VALUES (11294,
	6798,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'// just return this instance as an Object
return this;',
	0,
	'',
	11295);
INSERT INTO O_TFR
	VALUES (11296,
	6798,
	'associateWithPackage',
	'',
	19,
	1,
	'// unhook from current parent
self.deassociateFromParent();
// hook up with package
select any package from instances of EP_PKG
                                     where (selected.Package_ID == param.pkgID);
select one specPkg related by self->EP_SPKG[R1402];
relate specPkg to package across R1400;',
	1,
	'',
	11297);
INSERT INTO O_TPARM
	VALUES (11298,
	11296,
	'pkgID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11256,
	6798,
	'deassociateFromParent',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select one system related by self->S_SYS[R1113];
if(not_empty system)
  unrelate self from system across R1113;
end if;
select one domain related by self->S_DOM[R1100];
if(not_empty domain)
  unrelate self from domain across R1100;
end if;
select one subsystem related by self->S_SS[R1108];
if(not_empty subsystem)
  unrelate self from subsystem across R1108;
end if;
select one cp related by self->CP_CP[R1114];
if(not_empty cp)
  unrelate self from cp across R1114;
end if;
select one comp related by self->C_C[R1115];
if(not_empty comp)
  unrelate self from comp across R1115;
end if;
select one specPkg related by self->EP_SPKG[R1402];
select one package related by specPkg->EP_PKG[R1400];
if(not_empty package)
  unrelate specPkg from package across R1400;
end if;
select one aia related by self->A_AIA[R1110];
if(not_empty aia)
  select one activity related by aia->A_A[R1109];
  unrelate aia from self across R1110;
  select many acts related by aia->A_A[R1110];
  if(empty acts)
    unrelate aia from activity across R1109;
    delete object instance aia;
  end if;
end if;',
	1,
	'',
	11294);
INSERT INTO O_TFR
	VALUES (11299,
	6798,
	'pasteActivity',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select any activity from instances of A_A
                                        where (selected.Package_ID == param.id);
if(not_empty activity)
  // guarantee a unique name for the pasted element
  activity.Name = ::getUniqueInitialNameInParent
                                         (instance:activity.convertToInstance(),
     					   name:activity.Name, parent:self.convertToInstance());
  activity.associateWithActivity(actID:self.Package_ID);
end if;',
	1,
	'',
	11288);
INSERT INTO O_TPARM
	VALUES (11300,
	11299,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11301,
	6798,
	'associateWithActivity',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// unhook from current parent
self.deassociateFromParent();
// hook up with activity
select any activity from instances of A_A
                                     where (selected.Package_ID == param.actID);
select one aia related by activity->A_AIA[R1109];
if(empty aia)
  create object instance aia of A_AIA;
  relate aia to activity across R1109;
end if;
relate self to aia across R1110;',
	1,
	'',
	0);
INSERT INTO O_TPARM
	VALUES (11302,
	11301,
	'actID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11303,
	6798,
	'associateWithComponent',
	'',
	19,
	1,
	'// unhook from current parent
self.deassociateFromParent();
// hook up with component
select any component from instances of C_C
                                    where (selected.Id == param.compID);
relate self to component across R1115;',
	1,
	'',
	11301);
INSERT INTO O_TPARM
	VALUES (11304,
	11303,
	'compID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11305,
	6798,
	'associateWithComponentPackage',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// unhook from current parent
self.deassociateFromParent();
// hook up with component package
select any cp from instances of CP_CP where (selected.Package_ID == param.cpID);
relate cp to self across R1114;',
	1,
	'',
	11303);
INSERT INTO O_TPARM
	VALUES (11306,
	11305,
	'cpID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11297,
	6798,
	'associateWithDomain',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// unhook from current parent
self.deassociateFromParent();
// hook up with domain
select any domain from instances of S_DOM
                                         where (selected.Dom_ID == param.domID);
relate domain to self across R1100;',
	1,
	'',
	11305);
INSERT INTO O_TPARM
	VALUES (11307,
	11297,
	'domID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11295,
	6798,
	'associateWithSystem',
	'',
	19,
	1,
	'// unhook from current parent
self.deassociateFromParent();
// hook up with system
select any system from instances of S_SYS
                                         where (selected.Sys_ID == param.sysID);
relate system to self across R1113;',
	1,
	'',
	11308);
INSERT INTO O_TPARM
	VALUES (11309,
	11295,
	'sysID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11308,
	6798,
	'associateWithSubsystem',
	'',
	19,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// unhook from current parent
self.deassociateFromParent();
// hook up with domain
select any ss from instances of S_SS where (selected.SS_ID == param.ssID);
relate ss to self across R1108;',
	1,
	'',
	11296);
INSERT INTO O_TPARM
	VALUES (11310,
	11308,
	'ssID',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11311,
	6798,
	'getActivityCount',
	'',
	298,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
select many activities related by self->A_AIA[R1109]->A_A[R1110];
return cardinality activities;',
	1,
	'',
	11299);
INSERT INTO O_TFR
	VALUES (11312,
	6798,
	'getActivityId',
	'',
	296,
	1,
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
id = GD::NULL_UNIQUE_ID();
select many activities related by self->A_AIA[R1109]->A_A[R1110];
// We''re preincrementing the index
count = -1;
for each activity in activities
  if (not_empty activity)
      count = count+1;
  end if;
  if (count == param.index)
      return activity.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	11311);
INSERT INTO O_TPARM
	VALUES (11313,
	11312,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11314,
	6798,
	'getActionCount',
	'',
	298,
	1,
	'select many actions related by self->A_N[R1101]->A_ACT[R1105];
return cardinality actions;',
	1,
	'',
	11312);
INSERT INTO O_TFR
	VALUES (11315,
	6798,
	'getActionId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many actions related by self->A_N[R1101]->A_ACT[R1105];
// We''re preincrementing the index
count = -1;
for each action in actions
  if (not_empty action)
      count = count+1;
  end if;
  if (count == param.index)
      return action.Id;  
  end if;
end for;
return id;',
	1,
	'',
	11314);
INSERT INTO O_TPARM
	VALUES (11316,
	11315,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11317,
	6798,
	'getObjectNodeCount',
	'',
	298,
	1,
	'select many objectNodes related by self->A_N[R1101]->A_OBJ[R1105];
return cardinality objectNodes;',
	1,
	'',
	11315);
INSERT INTO O_TFR
	VALUES (11318,
	6798,
	'getObjectNodeId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many objectNodes related by self->A_N[R1101]->A_OBJ[R1105];
// We''re preincrementing the index
count = -1;
for each objectNode in objectNodes
  if (not_empty objectNode)
      count = count+1;
  end if;
  if (count == param.index)
      return objectNode.Id;  
  end if;
end for;
return id;',
	1,
	'',
	11317);
INSERT INTO O_TPARM
	VALUES (11319,
	11318,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11320,
	6798,
	'getAcceptEventActionCount',
	'',
	298,
	1,
	'select many acceptEventActions related by self->A_N[R1101]->A_ACT[R1105]->A_AE[R1107]->A_AEA[R1112];
return cardinality acceptEventActions;',
	1,
	'',
	11318);
INSERT INTO O_TFR
	VALUES (11321,
	6798,
	'getAcceptEventActionId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many acceptEventActions related by self->A_N[R1101]->A_ACT[R1105]->A_AE[R1107]->A_AEA[R1112];
// We''re preincrementing the index
count = -1;
for each acceptEventAction in acceptEventActions
  if (not_empty acceptEventAction)
      count = count+1;
  end if;
  if (count == param.index)
      return acceptEventAction.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	11320);
INSERT INTO O_TPARM
	VALUES (11322,
	11321,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11323,
	6798,
	'getSendSignalActionCount',
	'',
	298,
	1,
	'select many sendSignalActions related by self->A_N[R1101]->A_ACT[R1105]->A_SS[R1107];
return cardinality sendSignalActions;',
	1,
	'',
	11321);
INSERT INTO O_TFR
	VALUES (11324,
	6798,
	'getSendSignalActionId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many sendSignalActions related by self->A_N[R1101]->A_ACT[R1105]->A_SS[R1107];
// We''re preincrementing the index
count = -1;
for each sendSignalAction in sendSignalActions
  if (not_empty sendSignalAction)
      count = count+1;
  end if;
  if (count == param.index)
      return sendSignalAction.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	11323);
INSERT INTO O_TPARM
	VALUES (11325,
	11324,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11326,
	6798,
	'getAcceptTimeEventCount',
	'',
	298,
	1,
	'select many acceptTimeEventActions related by self->A_N[R1101]->A_ACT[R1105]->A_AE[R1107]->A_ATE[R1112];
return cardinality acceptTimeEventActions;',
	1,
	'',
	11324);
INSERT INTO O_TFR
	VALUES (11327,
	6798,
	'getAcceptTimeEventId',
	'',
	296,
	1,
	'id = GD::NULL_UNIQUE_ID();
select many acceptTimeEventActions related by self->A_N[R1101]->A_ACT[R1105]->A_AE[R1107]->A_ATE[R1112];
// We''re preincrementing the index
count = -1;
for each acceptTimeEventAction in acceptTimeEventActions
  if (not_empty acceptTimeEventAction)
      count = count+1;
  end if;
  if (count == param.index)
      return acceptTimeEventAction.get_ooa_id();  
  end if;
end for;
return id;',
	1,
	'',
	11326);
INSERT INTO O_TPARM
	VALUES (11328,
	11327,
	'index',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11329,
	6798,
	'pasteInitialNode',
	'',
	19,
	1,
	'select any initNode from instances of A_INI where (selected.Id == param.id);
if(not_empty initNode)
  select one actNode related by initNode->A_CTL[R1106]->A_N[R1105];
  select one existingActivity related by actNode->A_A[R1101];
  if(not_empty existingActivity)
    unrelate actNode from existingActivity across R1101;
  end if;
  relate actNode to self across R1101;
end if;',
	1,
	'',
	11327);
INSERT INTO O_TPARM
	VALUES (11330,
	11329,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11331,
	6798,
	'pasteFlowFinalNode',
	'',
	19,
	1,
	'select any ff from instances of A_FF where (selected.Id == param.id);
if(not_empty ff)
  select one actNode related by ff->A_CTL[R1106]->A_N[R1105];
  select one existingActivity related by actNode->A_A[R1101];
  if(not_empty existingActivity)
    unrelate actNode from existingActivity across R1101;
  end if;
  relate actNode to self across R1101;
end if;',
	1,
	'',
	11329);
INSERT INTO O_TPARM
	VALUES (11332,
	11331,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11333,
	6798,
	'pasteDecisionMergeNode',
	'',
	19,
	1,
	'select any dmNode from instances of A_DM where (selected.Id == param.id);
if(not_empty dmNode)
  select one actNode related by dmNode->A_CTL[R1106]->A_N[R1105];
  select one existingActivity related by actNode->A_A[R1101];
  if(not_empty existingActivity)
    unrelate actNode from existingActivity across R1101;
  end if;
  relate actNode to self across R1101;
end if;',
	1,
	'',
	11331);
INSERT INTO O_TPARM
	VALUES (11334,
	11333,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11335,
	6798,
	'pasteActivityFinalNode',
	'',
	19,
	1,
	'select any fNode from instances of A_AF where (selected.Id == param.id);
if(not_empty fNode)
  select one actNode related by fNode->A_CTL[R1106]->A_N[R1105];
  select one existingActivity related by actNode->A_A[R1101];
  if(not_empty existingActivity)
    unrelate actNode from existingActivity across R1101;
  end if;
  relate actNode to self across R1101;
end if;',
	1,
	'',
	11333);
INSERT INTO O_TPARM
	VALUES (11336,
	11335,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11337,
	6798,
	'pasteObjectNode',
	'',
	19,
	1,
	'select any objNode from instances of A_OBJ where (selected.Id == param.id);
if(not_empty objNode)
  select one actNode related by objNode->A_N[R1105];
  select one existingActivity related by actNode->A_A[R1101];
  if(not_empty existingActivity)
    unrelate actNode from existingActivity across R1101;
  end if;
  relate actNode to self across R1101;
end if;',
	1,
	'',
	11335);
INSERT INTO O_TPARM
	VALUES (11338,
	11337,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11339,
	6798,
	'pasteActivityDiagramAction',
	'',
	19,
	1,
	'select any da from instances of A_GA where (selected.Id == param.id);
if(not_empty da)
  select one actNode related by da->A_ACT[R1107]->A_N[R1105];
  select one existingActivity related by actNode->A_A[R1101];
  if(not_empty existingActivity)
    unrelate actNode from existingActivity across R1101;
  end if;
  relate actNode to self across R1101;
end if;',
	1,
	'',
	11337);
INSERT INTO O_TPARM
	VALUES (11340,
	11339,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11341,
	6798,
	'pasteAcceptTimeEventAction',
	'',
	19,
	1,
	'select any ate from instances of A_ATE where (selected.Id == param.id);
if(not_empty ate)
  select one actNode related by ate->A_AE[R1112]->A_ACT[R1107]->A_N[R1105];
  select one existingActivity related by actNode->A_A[R1101];
  if(not_empty existingActivity)
    unrelate actNode from existingActivity across R1101;
  end if;
  relate actNode to self across R1101;
end if;',
	1,
	'',
	11339);
INSERT INTO O_TPARM
	VALUES (11342,
	11341,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11343,
	6798,
	'pasteAcceptEventAction',
	'',
	19,
	1,
	'select any aea from instances of A_AEA where (selected.Id == param.id);
if(not_empty aea)
  select one actNode related by aea->A_AE[R1112]->A_ACT[R1107]->A_N[R1105];
  select one existingActivity related by actNode->A_A[R1101];
  if(not_empty existingActivity)
    unrelate actNode from existingActivity across R1101;
  end if;
  relate actNode to self across R1101;
end if;',
	1,
	'',
	11341);
INSERT INTO O_TPARM
	VALUES (11344,
	11343,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11345,
	6798,
	'pasteSendSignal',
	'',
	19,
	1,
	'select any ss from instances of A_SS where (selected.Id == param.id);
if(not_empty ss)
  select one actNode related by ss->A_ACT[R1107]->A_N[R1105];
  select one existingActivity related by actNode->A_A[R1101];
  if(not_empty existingActivity)
    unrelate actNode from existingActivity across R1101;
  end if;
  relate actNode to self across R1101;
end if;',
	1,
	'',
	11343);
INSERT INTO O_TPARM
	VALUES (11346,
	11345,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11347,
	6798,
	'pasteActivityPartition',
	'',
	19,
	1,
	'select any partition from instances of A_AP where (selected.Id == param.id);
if(not_empty partition)
  relate partition to self across R1111;
end if;',
	1,
	'',
	11345);
INSERT INTO O_TPARM
	VALUES (11348,
	11347,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11349,
	6798,
	'pasteActivityEdge',
	'',
	19,
	1,
	'select any edge from instances of A_E where (selected.Id == param.id);
if(not_empty edge)
  relate edge to self across R1102;
end if;',
	1,
	'',
	11347);
INSERT INTO O_TPARM
	VALUES (11350,
	11349,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11351,
	6798,
	'pasteForkJoinNode',
	'',
	19,
	1,
	'select any fj from instances of A_FJ where (selected.Id == param.id);
if(not_empty fj)
  select one an related by fj->A_CTL[R1106]->A_N[R1105];
  relate an to self across R1101;
end if;',
	1,
	'',
	11349);
INSERT INTO O_TPARM
	VALUES (11352,
	11351,
	'id',
	296,
	0,
	'',
	0,
	'');
INSERT INTO O_NBATTR
	VALUES (11353,
	6798);
INSERT INTO O_BATTR
	VALUES (11353,
	6798);
INSERT INTO O_ATTR
	VALUES (11353,
	6798,
	10972,
	'Name',
	'Full Name: Activity Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (11354,
	6798);
INSERT INTO O_BATTR
	VALUES (11354,
	6798);
INSERT INTO O_ATTR
	VALUES (11354,
	6798,
	11353,
	'Descrip',
	'Full Name: Activity Description',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (6798,
	699,
	0,
	712,
	10964,
	10966,
	10965,
	11355,
	11356,
	0,
	0,
	'',
	'Domain',
	'Dom_ID',
	'R1100');
INSERT INTO O_RATTR
	VALUES (11355,
	6798,
	712,
	699,
	1,
	'Dom_ID');
INSERT INTO O_ATTR
	VALUES (11355,
	6798,
	11354,
	'Dom_ID',
	'',
	'',
	'Dom_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (6798,
	701,
	0,
	717,
	10967,
	10969,
	10968,
	11357,
	11358,
	0,
	0,
	'',
	'Subsystem',
	'SS_ID',
	'R1108');
INSERT INTO O_RATTR
	VALUES (11357,
	6798,
	717,
	701,
	1,
	'SS_ID');
INSERT INTO O_ATTR
	VALUES (11357,
	6798,
	11355,
	'SS_ID',
	'',
	'',
	'SS_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (6798,
	705,
	0,
	754,
	11032,
	11034,
	11033,
	11359,
	11360,
	0,
	0,
	'',
	'System Model',
	'Sys_ID',
	'R1113');
INSERT INTO O_RATTR
	VALUES (11359,
	6798,
	754,
	705,
	1,
	'Sys_ID');
INSERT INTO O_ATTR
	VALUES (11359,
	6798,
	11361,
	'Sys_ID',
	'',
	'',
	'Sys_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (6798,
	773,
	0,
	772,
	854,
	6806,
	856,
	10972,
	11362,
	0,
	0,
	'',
	'Specification Package',
	'Package_ID',
	'R1402');
INSERT INTO O_RATTR
	VALUES (10972,
	6798,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (10972,
	6798,
	0,
	'Package_ID',
	'',
	'',
	'Package_ID',
	0,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (6798,
	707,
	0,
	758,
	11035,
	11037,
	11036,
	11363,
	11364,
	0,
	0,
	'',
	'Component Package',
	'Package_ID',
	'R1114');
INSERT INTO O_RATTR
	VALUES (11363,
	6798,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (11363,
	6798,
	11359,
	'Component_Package_ID',
	'',
	'Component_',
	'Package_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (6798,
	10973,
	0,
	10978,
	10975,
	10976,
	10977,
	11361,
	11365,
	0,
	0,
	'',
	'Activity In Activity',
	'Package_ID',
	'R1110');
INSERT INTO O_RATTR
	VALUES (11361,
	6798,
	772,
	773,
	1,
	'Package_ID');
INSERT INTO O_ATTR
	VALUES (11361,
	6798,
	11357,
	'Parent_Package_ID',
	'',
	'Parent_',
	'Package_ID',
	1,
	22,
	'',
	'');
INSERT INTO O_REF
	VALUES (6798,
	709,
	0,
	762,
	11038,
	11040,
	11039,
	11366,
	11367,
	0,
	0,
	'',
	'Component',
	'Id',
	'R1115');
INSERT INTO O_RATTR
	VALUES (11366,
	6798,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (11366,
	6798,
	11363,
	'Component_Id',
	'',
	'Component_',
	'Id',
	1,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	6798);
INSERT INTO O_OIDA
	VALUES (10972,
	6798,
	0,
	'Package_ID');
INSERT INTO O_ID
	VALUES (1,
	6798);
INSERT INTO O_ID
	VALUES (2,
	6798);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (10997,
	'Action Node',
	1103,
	'A_ACT',
	'',
	10958);
INSERT INTO O_TFR
	VALUES (11368,
	10997,
	'dispose',
	'',
	19,
	1,
	'select one parent related by self->A_N[R1105];
if ( not_empty parent )
  parent.dispose();
  return;
end if;

select one ga related by self->A_GA[R1107];
if ( not_empty ga )
  unrelate self from ga across R1107;
  ga.dispose();
end if;
select one ae related by self->A_AE[R1107];
if ( not_empty ae )
  unrelate self from ae across R1107;
  ae.dispose();
end if;
select one ss related by self->A_SS[R1107];
if ( not_empty ss )
  unrelate self from ss across R1107;
  ss.dispose();
end if;

delete object instance self;
',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (11369,
	10997,
	'incomingEdgeAllowed',
	'',
	316,
	1,
	'select one ga related by self->A_GA[R1107];
if ( not_empty ga )
  return ga.incomingEdgeAllowed();
else
  select one ae related by self->A_AE[R1107];
  if ( not_empty ae )
    return ae.incomingEdgeAllowed();
  else
    select one ss related by self->A_SS[R1107];
    if ( not_empty ss )
      return ss.incomingEdgeAllowed();
    end if;
  end if;
end if;
return false;',
	1,
	'',
	11368);
INSERT INTO O_TFR
	VALUES (11370,
	10997,
	'outgoingEdgeAllowed',
	'',
	316,
	1,
	'select one ga related by self->A_GA[R1107];
if ( not_empty ga )
  return ga.outgoingEdgeAllowed();
else
  select one ae related by self->A_AE[R1107];
  if ( not_empty ae )
    return ae.outgoingEdgeAllowed();
  else
    select one ss related by self->A_SS[R1107];
    if ( not_empty ss )
      return ss.outgoingEdgeAllowed();
    end if;
  end if;
end if;
return false;',
	1,
	'',
	11369);
INSERT INTO O_REF
	VALUES (10997,
	2803,
	0,
	10990,
	10995,
	10998,
	10996,
	11005,
	11371,
	0,
	0,
	'',
	'Activity Node',
	'Id',
	'R1105');
INSERT INTO O_RATTR
	VALUES (11005,
	10997,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (11005,
	10997,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	10997);
INSERT INTO O_OIDA
	VALUES (11005,
	10997,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	10997);
INSERT INTO O_ID
	VALUES (2,
	10997);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (11028,
	'Accept Time Event Action',
	1302,
	'A_ATE',
	'',
	10958);
INSERT INTO O_TFR
	VALUES (11372,
	11028,
	'dispose',
	'',
	19,
	1,
	'select one ae related by self->A_AE[R1112];
if(not_empty ae)
  ae.dispose();
else
  delete object instance self;
end if;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (11373,
	11028,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Id;',
	1,
	'',
	11374);
INSERT INTO O_TFR
	VALUES (11375,
	11028,
	'get_style',
	'',
	784,
	1,
	'return Style::Hourglass;',
	1,
	'',
	11373);
INSERT INTO O_TFR
	VALUES (11376,
	11028,
	'get_text_style',
	'',
	784,
	1,
	'return Style::None;',
	1,
	'',
	11375);
INSERT INTO O_TPARM
	VALUES (11377,
	11376,
	'comp_num',
	298,
	0,
	'',
	11378,
	'');
INSERT INTO O_TPARM
	VALUES (11379,
	11376,
	'ent_num',
	298,
	0,
	'',
	11377,
	'');
INSERT INTO O_TPARM
	VALUES (11378,
	11376,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11380,
	11028,
	'get_compartments',
	'',
	298,
	1,
	'return 0;',
	1,
	'',
	11381);
INSERT INTO O_TFR
	VALUES (11374,
	11028,
	'get_entries',
	'',
	298,
	1,
	'return 0;',
	1,
	'',
	11380);
INSERT INTO O_TPARM
	VALUES (11382,
	11374,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11381,
	11028,
	'get_compartment_text',
	'',
	322,
	1,
	'if (param.at == Justification::Floating)
  return self.Name;
end if;
return "";',
	1,
	'',
	11372);
INSERT INTO O_TPARM
	VALUES (11383,
	11381,
	'comp_num',
	298,
	0,
	'',
	11384,
	'');
INSERT INTO O_TPARM
	VALUES (11385,
	11381,
	'ent_num',
	298,
	0,
	'',
	11383,
	'');
INSERT INTO O_TPARM
	VALUES (11384,
	11381,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11386,
	11028,
	'initialize',
	'',
	19,
	1,
	'name = "Unnamed Accept Time Event";
success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:false);    
if ( success!="") 
 self.Name=success;
else 
 self.dispose();
end if;   ',
	1,
	'',
	11376);
INSERT INTO O_TFR
	VALUES (11387,
	11028,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'return this;',
	0,
	'',
	11386);
INSERT INTO O_NBATTR
	VALUES (11388,
	11028);
INSERT INTO O_BATTR
	VALUES (11388,
	11028);
INSERT INTO O_ATTR
	VALUES (11388,
	11028,
	11389,
	'Name',
	'Full Name: Accept Time Event Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (11390,
	11028);
INSERT INTO O_BATTR
	VALUES (11390,
	11028);
INSERT INTO O_ATTR
	VALUES (11390,
	11028,
	11388,
	'Descrip',
	'Full Name: Accept Time Event Description',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (11028,
	11006,
	0,
	11027,
	11025,
	11029,
	11026,
	11389,
	11391,
	0,
	0,
	'',
	'Accept Event',
	'Id',
	'R1112');
INSERT INTO O_RATTR
	VALUES (11389,
	11028,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (11389,
	11028,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	11028);
INSERT INTO O_OIDA
	VALUES (11389,
	11028,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	11028);
INSERT INTO O_ID
	VALUES (2,
	11028);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (11030,
	'Accept Event Action',
	1303,
	'A_AEA',
	'',
	10958);
INSERT INTO O_TFR
	VALUES (11392,
	11030,
	'dispose',
	'',
	19,
	1,
	'select one ae related by self->A_AE[R1112];
if(not_empty ae)
  ae.dispose();
else
  delete object instance self;
end if;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (11393,
	11030,
	'get_ooa_id',
	'',
	296,
	1,
	'return self.Id;',
	1,
	'',
	11394);
INSERT INTO O_TFR
	VALUES (11395,
	11030,
	'get_style',
	'',
	784,
	1,
	'return Style::ConcavePentagon;',
	1,
	'',
	11393);
INSERT INTO O_TFR
	VALUES (11396,
	11030,
	'get_text_style',
	'',
	784,
	1,
	'return Style::None;',
	1,
	'',
	11395);
INSERT INTO O_TPARM
	VALUES (11397,
	11396,
	'comp_num',
	298,
	0,
	'',
	11398,
	'');
INSERT INTO O_TPARM
	VALUES (11399,
	11396,
	'ent_num',
	298,
	0,
	'',
	11397,
	'');
INSERT INTO O_TPARM
	VALUES (11398,
	11396,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11400,
	11030,
	'get_compartments',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	11401);
INSERT INTO O_TFR
	VALUES (11394,
	11030,
	'get_entries',
	'',
	298,
	1,
	'return 1;',
	1,
	'',
	11400);
INSERT INTO O_TPARM
	VALUES (11402,
	11394,
	'comp_num',
	298,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11401,
	11030,
	'get_compartment_text',
	'',
	322,
	1,
	'if (param.at == Justification::Center)
  return self.Name;
end if;
return "";',
	1,
	'',
	11392);
INSERT INTO O_TPARM
	VALUES (11403,
	11401,
	'comp_num',
	298,
	0,
	'',
	11404,
	'');
INSERT INTO O_TPARM
	VALUES (11405,
	11401,
	'ent_num',
	298,
	0,
	'',
	11403,
	'');
INSERT INTO O_TPARM
	VALUES (11404,
	11401,
	'at',
	779,
	0,
	'',
	0,
	'');
INSERT INTO O_TFR
	VALUES (11406,
	11030,
	'initialize',
	'',
	19,
	1,
	'name = "Unnamed Accept Event";
success = ::getNewElementName(name:name,instance: self.convertToInstance(),validateName:false);    
if ( success!="") 
 self.Name=success;
else 
 self.dispose();
end if;  ',
	1,
	'',
	11396);
INSERT INTO O_TFR
	VALUES (11407,
	11030,
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	317,
	1,
	'return this;',
	0,
	'',
	11406);
INSERT INTO O_NBATTR
	VALUES (11408,
	11030);
INSERT INTO O_BATTR
	VALUES (11408,
	11030);
INSERT INTO O_ATTR
	VALUES (11408,
	11030,
	11409,
	'Name',
	'Full Name: Accept Event Action Name',
	'',
	'Name',
	0,
	322,
	'',
	'');
INSERT INTO O_NBATTR
	VALUES (11410,
	11030);
INSERT INTO O_BATTR
	VALUES (11410,
	11030);
INSERT INTO O_ATTR
	VALUES (11410,
	11030,
	11408,
	'Descrip',
	'Full Name: Accept Event Action Description',
	'',
	'Descrip',
	0,
	322,
	'',
	'');
INSERT INTO O_REF
	VALUES (11030,
	11006,
	0,
	11027,
	11025,
	11031,
	11026,
	11409,
	11411,
	0,
	0,
	'',
	'Accept Event',
	'Id',
	'R1112');
INSERT INTO O_RATTR
	VALUES (11409,
	11030,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (11409,
	11030,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	11030);
INSERT INTO O_OIDA
	VALUES (11409,
	11030,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	11030);
INSERT INTO O_ID
	VALUES (2,
	11030);
-- BP 7.1 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES (11006,
	'Accept Event',
	1112,
	'A_AE',
	'',
	10958);
INSERT INTO O_TFR
	VALUES (11412,
	11006,
	'dispose',
	'',
	19,
	1,
	'select one parent related by self->A_ACT[R1107];
if ( not_empty parent )
  parent.dispose();
  return;
end if;
select one ate related by self->A_ATE[R1112];
select one aea related by self->A_AEA[R1112];
if(not_empty ate)
  unrelate self from ate across R1112;
  delete object instance ate;
end if;
if(not_empty aea)
  unrelate self from aea across R1112;
  delete object instance aea;
end if;
delete object instance self;',
	1,
	'',
	0);
INSERT INTO O_TFR
	VALUES (11413,
	11006,
	'incomingEdgeAllowed',
	'',
	316,
	1,
	'select one node related by self->A_ACT[R1107]->A_N[R1105];
return node.numIncomingEdges() == 0;',
	1,
	'',
	11412);
INSERT INTO O_TFR
	VALUES (11414,
	11006,
	'outgoingEdgeAllowed',
	'',
	316,
	1,
	'select one node related by self->A_ACT[R1107]->A_N[R1105];
return node.numOutgoingEdges() == 0;',
	1,
	'',
	11413);
INSERT INTO O_REF
	VALUES (11006,
	10997,
	0,
	11005,
	11003,
	11007,
	11004,
	11027,
	11415,
	0,
	0,
	'',
	'Action Node',
	'Id',
	'R1107');
INSERT INTO O_RATTR
	VALUES (11027,
	11006,
	25,
	26,
	1,
	'Element_ID');
INSERT INTO O_ATTR
	VALUES (11027,
	11006,
	0,
	'Id',
	'',
	'',
	'Id',
	0,
	22,
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	11006);
INSERT INTO O_OIDA
	VALUES (11027,
	11006,
	0,
	'Id');
INSERT INTO O_ID
	VALUES (1,
	11006);
INSERT INTO O_ID
	VALUES (2,
	11006);
